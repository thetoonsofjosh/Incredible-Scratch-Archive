'From MIT Squeak 0.9.4 (June 1, 2003) [No updates present.] on 4 January 2004 at 11:02:53 am'!This is a simple ADPCM (adapative delta pulse code modulation) codec. This is a general audio codec that compresses speech, music, or sound effects equally well, and works at any sampling rate (i.e., it contains no frequency-sensitive filters). It compresses 16-bit sample data down to 5, 4, 3, or 2 bits per sample, with lower fidelity and increased noise at the lowest bit rates. Although it does not deliver state-of-the-art compressions, the alorithm is small, simple, and extremely fast, since the encode/decode primitives have been translated into C primitives.This codec will also encode and decode all Flash .swf file compressed sound formats, both mono and stereo. (Note: stereo Flash compression is not yet implemented, but stereo decompression works.)!!ADPCMCodec methodsFor: 'bit streaming' stamp: 'jm 3/28/1999 16:24'!nextBits: n	"Answer the next n bits of my bit stream as an unsigned integer."	| result remaining shift |	self inline: true.	result _ 0.	remaining _ n.	[true] whileTrue: [		shift _ remaining - bitPosition.		result _ result + (currentByte bitShift: shift).		shift > 0			ifTrue: [  "consumed currentByte buffer; fetch next byte"				remaining _ remaining - bitPosition.							currentByte _ (encodedBytes at: (byteIndex _ byteIndex + 1)).				bitPosition _ 8]			ifFalse: [  "still some bits left in currentByte buffer"				bitPosition _ bitPosition - remaining.				"mask out the consumed bits:"				currentByte _ currentByte bitAnd: (255 bitShift: (bitPosition - 8)).				^ result]].! !!ADPCMCodec methodsFor: 'bit streaming' stamp: 'jm 3/28/1999 20:21'!nextBits: n put: anInteger	"Write the next n bits to my bit stream."	| buf bufBits bitsAvailable shift |	self inline: true.	buf _ anInteger.	bufBits _ n.	[true] whileTrue: [		bitsAvailable _ 8 - bitPosition.		shift _ bitsAvailable - bufBits.  "either left or right shift"		"append high bits of buf to end of currentByte:"		currentByte _ currentByte + (buf bitShift: shift).		shift < 0			ifTrue: [  "currentByte buffer filled; output it"				encodedBytes at: (byteIndex _ byteIndex + 1) put: currentByte.				bitPosition _ 0.				currentByte _ 0.				"clear saved high bits of buf:"				buf _ buf bitAnd: (1 bitShift: 0 - shift) - 1.				bufBits _ bufBits - bitsAvailable]			ifFalse: [  "still some bits available in currentByte buffer"				bitPosition _ bitPosition + bufBits.				^ self]].! !!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 12/12/2001 17:57'!bytesPerEncodedFrame	"Answer the number of bytes required to hold one frame of compressed sound data."	"Note: When used as a normal codec, the frame size is always 8 samples which results in (8 * bitsPerSample) / 8 = bitsPerSample bytes."	| bitCount |	frameSizeMask = 0 ifTrue: [^ bitsPerSample].	"Following assumes mono:"	bitCount _ 16 + 6 + ((self samplesPerFrame - 1) * bitsPerSample).	^ (bitCount + 7) // 8! !!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 7/2/1999 13:29'!compressAndDecompress: aSound	"Compress and decompress the given sound. Overridden to use same bits per sample for both compressing and decompressing."	| compressed decoder |	compressed _ self compressSound: aSound.	decoder _ self class new		initializeForBitsPerSample: bitsPerSample		samplesPerFrame: 0.	^ decoder decompressSound: compressed! !!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 3/28/1999 15:37'!decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex	"Decode the given number of monophonic frames starting at the given index in the given ByteArray of compressed sound data and storing the decoded samples into the given SoundBuffer starting at the given destination index. Answer a pair containing the number of bytes of compressed data consumed and the number of decompressed samples produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	encodedBytes _ srcByteArray.	byteIndex _ srcIndex - 1.	bitPosition _ 0.	currentByte _ 0.	samples _ dstSoundBuffer.	sampleIndex _ dstIndex - 1.	self privateDecodeMono: (frameCount * self samplesPerFrame).	^ Array with: (byteIndex - (srcIndex - 1)) with: (sampleIndex - (dstIndex - 1))! !!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 3/28/1999 15:28'!encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	"Encode the given number of frames starting at the given index in the given monophonic SoundBuffer and storing the encoded sound data into the given ByteArray starting at the given destination index. Encode only as many complete frames as will fit into the destination. Answer a pair containing the number of samples consumed and the number of bytes of compressed data produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	samples _ srcSoundBuffer.	sampleIndex _ srcIndex - 1.	encodedBytes _ dstByteArray.	byteIndex _ dstIndex - 1.	bitPosition _ 0.	currentByte _ 0.	self privateEncodeMono: (frameCount * self samplesPerFrame).	^ Array with: frameCount with: (byteIndex - (dstIndex - 1))! !!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 12/14/2001 11:21'!reset	self resetForMono.! !!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 3/28/1999 20:12'!resetForMono	"Reset my encoding and decoding state for mono."	predicted _ 0.	index _ 0.! !!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 3/28/1999 20:12'!resetForStereo	"Reset my encoding and decoding state for stereo."	"keep state as SoundBuffers to allow fast access from primitive"	predicted _ SoundBuffer new: 2.	index _ SoundBuffer new: 2.! !!ADPCMCodec methodsFor: 'codec stuff' stamp: 'jm 3/27/1999 08:34'!samplesPerFrame	"Answer the number of sound samples per compression frame."	frameSizeMask > 0 ifTrue: [^ frameSizeMask + 1].	^ 8  "frame size when there are no running headers"! !!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'jm 3/28/1999 06:26'!decode: aByteArray bitsPerSample: bits	^ self		decode: aByteArray		sampleCount: (aByteArray size * 8) // bits		bitsPerSample: bits		frameSize: 0		stereo: false! !!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'jm 3/28/1999 15:57'!decode: aByteArray sampleCount: count bitsPerSample: bits frameSize: frameSize stereo: stereoFlag	self initializeForBitsPerSample: bits samplesPerFrame: frameSize.	encodedBytes _ aByteArray.	byteIndex _ 0.	bitPosition _ 0.	currentByte _ 0.	stereoFlag		ifTrue: [			self resetForStereo.			samples _ SoundBuffer newMonoSampleCount: count.			rightSamples _ SoundBuffer newMonoSampleCount: count.			sampleIndex _ 0.			self privateDecodeStereo: count.			^ Array with: samples with: rightSamples]		ifFalse: [			samples _ SoundBuffer newMonoSampleCount: count.			sampleIndex _ 0.			self privateDecodeMono: count.			^ samples]! !!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'jm 3/30/1999 08:56'!decodeFlash: aByteArray sampleCount: sampleCount stereo: stereoFlag	| bits |	encodedBytes _ aByteArray.	byteIndex _ 0.	bitPosition _ 0.	currentByte _ 0.	bits _ 2 + (self nextBits: 2).  "bits per sample"	self initializeForBitsPerSample: bits samplesPerFrame: 4096.	stereoFlag		ifTrue: [			self resetForStereo.			samples _ SoundBuffer newMonoSampleCount: sampleCount.			rightSamples _ SoundBuffer newMonoSampleCount: sampleCount.			sampleIndex _ 0.			self privateDecodeStereo: sampleCount.			^ Array with: samples with: rightSamples]		ifFalse: [			samples _ SoundBuffer newMonoSampleCount: sampleCount.			sampleIndex _ 0.			self privateDecodeMono: sampleCount.			^ Array with: samples].! !!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'jm 3/28/1999 08:59'!encode: aSoundBuffer bitsPerSample: bits	^ self		encodeLeft: aSoundBuffer		right: nil		bitsPerSample: bits		frameSize: 0		forFlash: false! !!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'jm 3/28/1999 08:58'!encodeFlashLeft: leftSoundBuffer right: rightSoundBuffer bitsPerSample: bits	^ self		encodeLeft: leftSoundBuffer		right: rightSoundBuffer		bitsPerSample: bits		frameSize: 4096		forFlash: true! !!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'jm 11/21/2001 11:35'!encodeLeft: leftSoundBuffer right: rightSoundBuffer bitsPerSample: bits frameSize: frameSize forFlash: flashFlag	| stereoFlag sampleCount sampleBitCount bitCount |	self initializeForBitsPerSample: bits samplesPerFrame: frameSize.	stereoFlag _ rightSoundBuffer notNil.	sampleCount _ leftSoundBuffer monoSampleCount.	stereoFlag		ifTrue: [sampleBitCount _ 2 * (sampleCount * bitsPerSample)]		ifFalse: [sampleBitCount _ sampleCount * bitsPerSample].	bitCount _ sampleBitCount +		(self headerBitsForSampleCount: sampleCount stereoFlag: stereoFlag).	encodedBytes _ ByteArray new: ((bitCount / 8) ceiling roundUpTo: self bytesPerEncodedFrame).	byteIndex _ 0.	bitPosition _ 0.	currentByte _ 0.	flashFlag ifTrue: [self nextBits: 2 put: bits - 2].	stereoFlag		ifTrue: [			samples _ Array with: leftSoundBuffer with: rightSoundBuffer.			sampleIndex _ Array with: 0 with: 0.			self privateEncodeStereo: sampleCount]		ifFalse: [			samples _ leftSoundBuffer.			sampleIndex _ 0.			self privateEncodeMono: sampleCount].	^ encodedBytes! !!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'jm 3/27/1999 12:14'!headerBitsForSampleCount: sampleCount stereoFlag: stereoFlag	"Answer the number of extra header bits required for the given number of samples. This will be zero if I am not using frame headers."	| frameCount bitsPerHeader |	frameSizeMask = 0 ifTrue: [^ 0].	frameCount _ (sampleCount / self samplesPerFrame) ceiling.	bitsPerHeader _ 16 + 6.	stereoFlag ifTrue: [bitsPerHeader _ 2 * bitsPerHeader].	^ frameCount * bitsPerHeader! !!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'jm 3/28/1999 16:08'!indexForDeltaFrom: thisSample to: nextSample	"Answer the best index to use for the difference between the given samples."	"Details: Scan stepSizeTable for the first entry >= the absolute value of the difference between sample values. Since indexes are zero-based, the index used during decoding will be the one in the following stepSizeTable entry. Since the index field of a Flash frame header is only six bits, the maximum index value is 63."	"Note: Since there does not appear to be any documentation of how Flash acutally computes the indices used in its frame headers, this algorithm was guessed by reverse-engineering the Flash ADPCM decoder."	| diff bestIndex |	self inline: true.	diff _ nextSample - thisSample.	diff < 0 ifTrue: [diff _ 0 - diff].	bestIndex _ 63.	1 to: 62 do: [:j |		bestIndex = 63 ifTrue: [			(stepSizeTable at: j) >= diff ifTrue: [bestIndex _ j]]].	^ bestIndex! !!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'jm 3/28/1999 20:48'!initializeForBitsPerSample: sampleBits samplesPerFrame: frameSize	self resetForMono.	stepSizeTable _ #(7 8 9 10 11 12 13 14 16 17 19 21 23 25 28 31 34 37 41 45 50 55 60 66 73 80 88 97 107 118 130 143 157 173 190 209 230 253 279 307 337 371 408 449 494 544 598 658 724 796 876 963 1060 1166 1282 1411 1552 1707 1878 2066 2272 2499 2749 3024 3327 3660 4026 4428 4871 5358 5894 6484 7132 7845 8630 9493 10442 11487 12635 13899 15289 16818 18500 20350 22385 24623 27086 29794 32767).	indexTable _ nil.	sampleBits = 2 ifTrue: [		indexTable _ #(-1 2)].	sampleBits = 3 ifTrue: [		indexTable _ #(-1 -1 2 4)].	sampleBits = 4 ifTrue: [		indexTable _ #(-1 -1 -1 -1 2 4 6 8)].	sampleBits = 5 ifTrue: [		indexTable _ #(-1 -1 -1 -1 -1 -1 -1 -1 1 2 4 6 8 10 13 16)].	indexTable ifNil: [self error: 'unimplemented bits/sample'].	bitsPerSample _ sampleBits.	deltaSignMask _ 1 bitShift: bitsPerSample - 1.	deltaValueMask _ deltaSignMask - 1.	deltaValueHighBit _ deltaSignMask / 2.	frameSize <= 1		ifTrue: [frameSizeMask _ 0]		ifFalse: [			(frameSize = (1 bitShift: frameSize highBit - 1))				ifFalse: [self error: 'frameSize must be a power of two'].			frameSizeMask _ frameSize - 1].	"keep as SoundBuffer to allow fast access from primitive"	indexTable _ SoundBuffer fromArray: indexTable.	stepSizeTable _ SoundBuffer fromArray: stepSizeTable.! !!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'jm 3/29/1999 07:13'!privateDecodeMono: count	| delta step predictedDelta bit |	<primitive: 550>	self var: #stepSizeTable declareC: 'short int *stepSizeTable'.	self var: #indexTable declareC: 'short int *indexTable'.	self var: #samples declareC: 'short int *samples'.	self var: #encodedBytes declareC: 'unsigned char *encodedBytes'.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1			ifTrue: [  "start of frame; read frame header"				predicted _ self nextBits: 16.				predicted > 32767 ifTrue: [predicted _ predicted - 65536].				index _ self nextBits: 6.				samples at: (sampleIndex _ sampleIndex + 1) put: predicted]			ifFalse: [				delta _ self nextBits: bitsPerSample.				step _ stepSizeTable at: index + 1.				predictedDelta _ 0.				bit _ deltaValueHighBit.				[bit > 0] whileTrue: [					(delta bitAnd: bit) > 0 ifTrue: [predictedDelta _ predictedDelta + step].					step _ step bitShift: -1.					bit _ bit bitShift: -1].				predictedDelta _ predictedDelta + step.				(delta bitAnd: deltaSignMask) > 0					ifTrue: [predicted _ predicted - predictedDelta]					ifFalse: [predicted _ predicted + predictedDelta].				predicted > 32767					ifTrue: [predicted _ 32767]					ifFalse: [predicted < -32768 ifTrue: [predicted _ -32768]].				index _ index + (indexTable at: (delta bitAnd: deltaValueMask) + 1).				index < 0					ifTrue: [index _ 0]					ifFalse: [index > 88 ifTrue: [index _ 88]].				samples at: (sampleIndex _ sampleIndex + 1) put: predicted]].! !!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'jm 3/29/1999 07:13'!privateDecodeStereo: count	| predictedLeft predictedRight indexLeft indexRight deltaLeft deltaRight	 stepLeft stepRight predictedDeltaLeft predictedDeltaRight bit |	<primitive: 551>	self var: #stepSizeTable declareC: 'short int *stepSizeTable'.	self var: #indexTable declareC: 'short int *indexTable'.	self var: #samples declareC: 'short int *samples'.	self var: #encodedBytes declareC: 'unsigned char *encodedBytes'.	self var: #rightSamples declareC: 'short int *rightSamples'.	self var: #predicted declareC: 'short int *predicted'.	self var: #index declareC: 'short int *index'.	"make local copies of decoder state variables"	predictedLeft _ predicted at: 1.	predictedRight _ predicted at: 2.	indexLeft _ index at: 1.	indexRight _ index at: 2.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1			ifTrue: [  "start of frame; read frame header"				predictedLeft _ self nextBits: 16.				indexLeft _ self nextBits: 6.				predictedRight _ self nextBits: 16.				indexRight _ self nextBits: 6.				predictedLeft > 32767 ifTrue: [predictedLeft _ predictedLeft - 65536].				predictedRight > 32767 ifTrue: [predictedRight _ predictedRight - 65536].				samples at: (sampleIndex _ sampleIndex + 1) put: predictedLeft.				rightSamples at: sampleIndex put: predictedRight]			ifFalse: [				deltaLeft _ self nextBits: bitsPerSample.				deltaRight _ self nextBits: bitsPerSample.				stepLeft _ stepSizeTable at: indexLeft + 1.				stepRight _ stepSizeTable at: indexRight + 1.				predictedDeltaLeft _ predictedDeltaRight _ 0.				bit _ deltaValueHighBit.				[bit > 0] whileTrue: [					(deltaLeft bitAnd: bit) > 0 ifTrue: [						predictedDeltaLeft _ predictedDeltaLeft + stepLeft].					(deltaRight bitAnd: bit) > 0 ifTrue: [						predictedDeltaRight _ predictedDeltaRight + stepRight].					stepLeft _ stepLeft bitShift: -1.					stepRight _ stepRight bitShift: -1.					bit _ bit bitShift: -1].				predictedDeltaLeft _ predictedDeltaLeft + stepLeft.				predictedDeltaRight _ predictedDeltaRight + stepRight.				(deltaLeft bitAnd: deltaSignMask) > 0					ifTrue: [predictedLeft _ predictedLeft - predictedDeltaLeft]					ifFalse: [predictedLeft _ predictedLeft + predictedDeltaLeft].				(deltaRight bitAnd: deltaSignMask) > 0					ifTrue: [predictedRight _ predictedRight - predictedDeltaRight]					ifFalse: [predictedRight _ predictedRight + predictedDeltaRight].				predictedLeft > 32767					ifTrue: [predictedLeft _ 32767]					ifFalse: [predictedLeft < -32768 ifTrue: [predictedLeft _ -32768]].				predictedRight > 32767					ifTrue: [predictedRight _ 32767]					ifFalse: [predictedRight < -32768 ifTrue: [predictedRight _ -32768]].				indexLeft _ indexLeft + (indexTable at: (deltaLeft bitAnd: deltaValueMask) + 1).				indexLeft < 0					ifTrue: [indexLeft _ 0]					ifFalse: [indexLeft > 88 ifTrue: [indexLeft _ 88]].				indexRight _ indexRight + (indexTable at: (deltaRight bitAnd: deltaValueMask) + 1).				indexRight < 0					ifTrue: [indexRight _ 0]					ifFalse: [indexRight > 88 ifTrue: [indexRight _ 88]].				samples at: (sampleIndex _ sampleIndex + 1) put: predictedLeft.				rightSamples at: sampleIndex put: predictedRight]].	"save local copies of decoder state variables"	predicted at: 1 put: predictedLeft.	predicted at: 2 put: predictedRight.	index at: 1 put: indexLeft.	index at: 2 put: indexRight.! !!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'jm 3/29/1999 07:13'!privateEncodeMono: count	| step sign diff delta predictedDelta bit p |	<primitive: 552>	self var: #stepSizeTable declareC: 'short int *stepSizeTable'.	self var: #indexTable declareC: 'short int *indexTable'.	self var: #samples declareC: 'short int *samples'.	self var: #encodedBytes declareC: 'unsigned char *encodedBytes'.	step _ stepSizeTable at: 1.	1 to: count do: [:i |		(i bitAnd: frameSizeMask) = 1 ifTrue: [			predicted _ samples at: (sampleIndex _ sampleIndex + 1).			(p _ predicted) < 0 ifTrue: [p _ p + 65536].			self nextBits: 16 put: p.			i < count ifTrue: [				index _ self indexForDeltaFrom: predicted to: (samples at: sampleIndex + 1)].			self nextBits: 6 put: index.		] ifFalse: [			"compute sign and magnitude of difference from the predicted sample"			sign _ 0.			diff _ (samples at: (sampleIndex _ sampleIndex + 1)) - predicted.			diff < 0 ifTrue: [				sign _ deltaSignMask.				diff _ 0 - diff].			"Compute encoded delta and the difference that this will cause in the predicted sample value during decoding. Note that this code approximates:				delta _ (4 * diff) / step.				predictedDelta _ ((delta + 0.5) * step) / 4;			but in the shift step bits are dropped. Thus, even if you have fast mul/div hardware you cannot use it since you would get slightly different bits what than the algorithm defines."			delta _ 0.			predictedDelta _ 0.			bit _ deltaValueHighBit.			[bit > 0] whileTrue: [				diff >= step ifTrue: [					delta _ delta + bit.					predictedDelta _ predictedDelta + step.					diff _ diff - step].				step _ step bitShift: -1.				bit _ bit bitShift: -1].			predictedDelta _ predictedDelta + step.			"compute and clamp new prediction"			sign > 0				ifTrue: [predicted _ predicted - predictedDelta]				ifFalse: [predicted _ predicted + predictedDelta].			predicted > 32767				ifTrue: [predicted _ 32767]				ifFalse: [predicted < -32768 ifTrue: [predicted _ -32768]].			"compute new index and step values"			index _ index + (indexTable at: delta + 1).			index < 0				ifTrue: [index _ 0]				ifFalse: [index > 88 ifTrue: [index _ 88]].			step _ stepSizeTable at: index + 1.			"output encoded, signed delta"			self nextBits: bitsPerSample put: (sign bitOr: delta)]].	bitPosition > 0 ifTrue: [  "flush the last output byte, if necessary"		encodedBytes at: (byteIndex _ byteIndex + 1) put: currentByte].! !!ADPCMCodec methodsFor: 'as yet unclassified' stamp: 'jm 5/29/2003 21:34'!privateEncodeStereo: count	<primitive: 553>	self inline: false.	self notYetImplemented.! !!ADPCMCodec class methodsFor: 'instance creation' stamp: 'jm 3/27/1999 11:15'!new	^ super new		initializeForBitsPerSample: 4		samplesPerFrame: 0.! !!ADPCMCodec class methodsFor: 'instance creation' stamp: 'jm 11/15/2001 16:02'!newBitsPerSample: bitsPerSample	^ super new		initializeForBitsPerSample: bitsPerSample		samplesPerFrame: 0.! !I am a parser for AIFF (audio interchange file format) files. I can read uncompressed 8-bit and 16-bit mono, stereo, or multichannel AIFF files. I read the marker information used by the TransferStation utility to mark the loop points in sounds extracted from commercial sampled-sound CD-ROMs.!!AIFFFileReader methodsFor: 'reading' stamp: 'jm 8/2/1998 16:27'!readFromFile: fileName	"Read the AIFF file of the given name."	"AIFFFileReader new readFromFile: 'test.aiff'"	self readFromFile: fileName		mergeIfStereo: false		skipDataChunk: false.! !!AIFFFileReader methodsFor: 'reading' stamp: 'jm 10/17/2001 17:20'!readFromFile: fileName mergeIfStereo: mergeFlag skipDataChunk: skipDataFlag	"Read the AIFF file of the given name. See comment in readFromStream:mergeIfStereo:skipDataChunk:."	"AIFFFileReader new readFromFile: 'test.aiff' mergeIfStereo: false skipDataChunk: true"	| f |	f _ (FileStream readOnlyFileNamed: fileName) binary.	self readFromStream: f mergeIfStereo: mergeFlag skipDataChunk: skipDataFlag.	f close.! !!AIFFFileReader methodsFor: 'reading'!readFromStream: aBinaryStream mergeIfStereo: mergeFlag skipDataChunk: skipDataFlag	"Read an AIFF file from the given binary stream. If mergeFlag is true and the file contains stereo data, then the left and right channels will be mixed together as the samples are read in. If skipDataFlag is true, then the data chunk to be skipped; this allows the other chunks of a file to be processed in order to extract format information quickly without reading the data."	mergeIfStereo _ mergeFlag.	skipDataChunk _ skipDataFlag.	isLooped _ false.	gain _ 1.0.	self readFrom: aBinaryStream.! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!bitsPerSample	^ bitsPerSample! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:24'!channelCount	^ channelCount! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!channelData	^ channelData! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 10/20/2001 15:07'!channelDataOffset	^ channelDataOffset! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:24'!frameCount	^ frameCount! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!gain	^ gain! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 01:40'!isLooped	^ isLooped! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 20:02'!isStereo	^ channelData size = 2! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:26'!leftSamples	^ channelData at: 1! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:30'!loopEnd	^ markers last last! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:30'!loopLength	^ markers last last - markers first last! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 21:25'!markers	^ markers! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 01:48'!pitch	^ pitch! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 8/2/1998 19:34'!rightSamples	^ channelData at: 2! !!AIFFFileReader methodsFor: 'accessing' stamp: 'jm 7/12/1998 18:25'!samplingRate	^ samplingRate! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 8/17/1998 20:36'!edit	| ed |	ed _ WaveEditor new.	ed data: channelData first.	ed loopEnd: markers last last.	ed loopLength: (markers last last - markers first last) + 1.	ed openInWorld.! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 7/12/1998 01:44'!pitchForKey: midiKey	"Convert my MIDI key number to a pitch and return it."	| indexInOctave octave p |	indexInOctave _ (midiKey \\ 12) + 1.	octave _ (midiKey // 12) + 1.	"Table generator: (0 to: 11) collect: [:i | 16.3516 * (2.0 raisedTo: i asFloat / 12.0)]"	p _ #(16.3516 17.32391 18.35405 19.44544 20.60173 21.82677		  23.12466 24.49972 25.95655 27.50000 29.13524 30.86771) at: indexInOctave.	^ p * (#(0.5 1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0) at: octave)! !!AIFFFileReader methodsFor: 'other' stamp: 'jm 1/14/1999 10:11'!sound	"Answer the sound represented by this AIFFFileReader. This method should be called only after readFrom: has been done."	| snd rightSnd |	snd _ SampledSound		samples: (channelData at: 1)		samplingRate: samplingRate.	self isStereo ifTrue: [		rightSnd _ SampledSound			samples: (channelData at: 2)			samplingRate: samplingRate.		snd _ MixedSound new			add: snd pan: 0;			add: rightSnd pan: 1.0].	^ snd! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 6/29/1998 07:33'!readChunk: chunkType size: chunkSize	"Read a AIFF chunk of the given type. Skip unrecognized chunks. Leave the input stream positioned chunkSize bytes past its position when this method is called."	chunkType = 'COMM' ifTrue: [^ self readCommonChunk: chunkSize].	chunkType = 'SSND' ifTrue: [^ self readSamplesChunk: chunkSize].	chunkType = 'INST' ifTrue: [^ self readInstrumentChunk: chunkSize].	chunkType = 'MARK' ifTrue: [^ self readMarkerChunk: chunkSize].	in skip: chunkSize.  "skip unknown chunks"! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 1/1/2004 18:40'!readCommonChunk: chunkSize	"Read a COMM chunk. All AIFF files have exactly one chunk of this type." 	channelCount _ in uint16.	frameCount _ in uint32.	bitsPerSample _ in uint16.	samplingRate _ self readExtendedFloat.  "10 bytes"	compressionType _ 'NONE'.	fileType = 'AIFF'		ifTrue: [			self assert: [chunkSize >= 18].			in skip: chunkSize - 18]  "skip the reminder of AIFF COMM chunk"		ifFalse: [			self assert: [(fileType = 'AIFC') & (chunkSize >= 22)].			compressionType _ (in next: 4) asString.			(compressionType = 'NONE') | (compressionType = 'ulaw')				 ifFalse: [self error: 'unsupported AIFF file compression format'].			compressionType = 'ulaw' ifTrue: [bitsPerSample _ 8].			in skip: chunkSize - 22]  "skip the reminder of AIFF-C COMM chunk"! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 1/1/2004 18:46'!readExtendedFloat	"Read and answer an Apple extended-precision 80-bit floating point number from the input stream."	"Details: I could not find the specification for this format, so constants were determined empirically based on assumption of 1-bit sign, 15-bit exponent, 64-bit mantissa. This format does not seem to have an implicit one before the mantissa as some float formats do."	| signAndExp mantissa sign exp |	signAndExp _ in uint16.	mantissa _ LargePositiveInteger new: 8.	8 to: 1 by: -1 do: [:i | mantissa digitAt: i put: in next].  "scaled by (2 raisedTo: -64) below"	(signAndExp bitAnd: 16r8000) = 0		ifTrue: [sign _ 1.0]		ifFalse: [sign _ -1.0].	exp _ (signAndExp bitAnd: 16r7FFF) - 16r4000 + 2.  "not sure why +2 is needed..."	^ (sign * mantissa asFloat * (2.0 raisedTo: exp - 64)) roundTo: 0.00000001! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 1/1/2004 18:40'!readFrom: aBinaryStream	"Read AIFF data from the given binary stream."	"Details: An AIFF file consists of a header (FORM chunk) followed by a sequence of tagged data chunks. Each chunk starts with a header consisting of a four-byte tag (a string) and a four byte size. These eight bytes of chunk header are not included in the chunk size. For each chunk, the readChunk:size: method consumes chunkSize bytes of the input stream, parsing recognized chunks or skipping unrecognized ones. If chunkSize is odd, it will be followed by a padding byte. Chunks may occur in any order."	| sz end chunkType chunkSize p |	in _ aBinaryStream.	"read FORM chunk"	(in next: 4) asString = 'FORM' ifFalse: [^ self error: 'not an AIFF file'].	sz _ in uint32.	end _ in position + sz.	fileType _ (in next: 4) asString.	[in atEnd not and: [in position < end]] whileTrue: [		chunkType _ (in next: 4) asString.		chunkSize _ in uint32.		p _ in position.		self readChunk: chunkType size: chunkSize.		(in position = (p + chunkSize))			ifFalse: [self error: 'chunk size mismatch; bad AIFF file?'].		chunkSize odd ifTrue: [in skip: 1]].  "skip padding byte"! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 1/1/2004 18:41'!readInstrumentChunk: chunkSize	| midiKey detune lowNote highNote lowVelocity highVelocity	  sustainMode sustainStartID sustainEndID	  releaseMode releaseStartID releaseEndID |	midiKey _ in next.	detune _ in next.	lowNote _ in next.	highNote _ in next.	lowVelocity _ in next.	highVelocity _ in next.	gain _ in uint16.	sustainMode _ in uint16.	sustainStartID _ in uint16.	sustainEndID _ in uint16.	releaseMode _ in uint16.	releaseStartID _ in uint16.	releaseEndID _ in uint16.	isLooped _ sustainMode = 1.	(isLooped and: [markers notNil]) ifTrue: [		((markers first last > frameCount) or:		 [markers last last > frameCount]) ifTrue: [			"bad loop data; some sample CD files claim to be looped but aren't"			isLooped _ false]].	pitch _ self pitchForKey: midiKey.! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 1/1/2004 18:42'!readMarkerChunk: chunkSize	| markerCount id position labelBytes label |	markerCount _ in uint16.	markers _ Array new: markerCount.	1 to: markerCount do: [:i |		id _ in uint16.		position _ in uint32.		labelBytes _ in next.		label _ (in next: labelBytes) asString.		labelBytes even ifTrue: [in skip: 1].		markers at: i put: (Array with: id with: label with: position)].! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 1/1/2004 18:42'!readSamplesChunk: chunkSize	"Read a SSND chunk. All AIFF files with a non-zero frameCount contain exactly one chunk of this type."	| offset blockSize bytesOfSamples count data |	offset _ in uint32.	blockSize _ in uint32.	((offset ~= 0) or: [blockSize ~= 0])		ifTrue: [^ self error: 'this AIFF reader cannot handle blocked sample chunks'].	bytesOfSamples _ channelCount * frameCount * (bitsPerSample // 8).	bytesOfSamples = (chunkSize - 8)		ifFalse: [self error: 'data bytecount does not match COMM chunk size'].	channelDataOffset _ in position.  "record stream position for start of data"	skipDataChunk ifTrue: [in skip: (chunkSize - 8). ^ self].  "if skipDataChunk, skip sample data"	count _ channelCount * frameCount.	bitsPerSample = 8		ifTrue: [			data _ in next: count.			compressionType = 'ulaw'				ifTrue: [data _ SampledSound uLawDecode: data]				ifFalse: [data _ SampledSound convert8bitSignedTo16Bit: data]]		ifFalse: [			data _ SoundBuffer newMonoSampleCount: count.			in next: ((count + 1) // 2) into: data startingAt: 1.  "size is in 32-bit words"			Smalltalk isBigEndian ifFalse: [data reverseEndiannessStereo: (channelCount = 2)]].	channelCount = 1 ifTrue: [channelData _ Array with: data. ^ self].	((channelCount = 2) & mergeIfStereo) ifTrue: [		channelCount _ 1.		channelData _ Array with: data mergeStereo.		^ self].	self splitChannels: data.  "split into separate channel buffers"! !!AIFFFileReader methodsFor: 'private' stamp: 'jm 12/5/2003 18:28'!splitChannels: data	"Split the given multi-channel (channelCount >= 2) sound buffer into separate buffers."	"allocate channel buffers"	channelData _ (1 to: channelCount) collect: [:i |		SoundBuffer newMonoSampleCount: frameCount].	"split into individual channel buffers"	self assert: [data monoSampleCount = (channelCount * frameCount)].	1 to: data monoSampleCount do: [:i |		channelData at: ((i - 1) \\ channelCount) + 1 put: (data at: i)].! !!AbstractScoreEvent methodsFor: 'accessing' stamp: 'di 6/17/1999 14:28'!adjustTimeBy: delta	time _ time + delta! !!AbstractScoreEvent methodsFor: 'accessing' stamp: 'jm 8/27/1998 16:38'!endTime	"Subclasses should override to return the ending time if the event has some duration."	^ time! !!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!isControlChange	^ false! !!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!isPitchBend	^ false! !!AbstractScoreEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:43'!isProgramChange	^ false! !!AbstractScoreEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port. This default implementation does nothing."! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 3/24/1999 12:03'!loudness: aNumber	"Initialize my volume envelopes and initial volume. Subclasses overriding this method should include a resend to super."	| vol |	vol _ (aNumber asFloat max: 0.0) min: 1.0.	envelopes do: [:e |		(e isKindOf: VolumeEnvelope) ifTrue: [e scale: vol]].	self initialVolume: vol.! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:04'!nameOrNumberToPitch: aStringOrNumber	"Answer the pitch in cycles/second for the given pitch specification. The specification can be either a numeric pitch or pitch name such as 'c4'."	aStringOrNumber isNumber		ifTrue: [^ aStringOrNumber asFloat]		ifFalse: [^ AbstractSound pitchForName: aStringOrNumber]! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/19/1998 08:45'!setPitch: pitchNameOrNumber dur: d loudness: l	"Initialize my envelopes for the given parameters. Subclasses overriding this method should include a resend to super."	| p |	p _ self nameOrNumberToPitch: pitchNameOrNumber.	envelopes do: [:e |		e volume: l.		e centerPitch: p].	self initialVolume: l.	self duration: d.! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/3/1998 17:11'!soundForMidiKey: midiKey dur: d loudness: l	"Answer an initialized sound object (a copy of the receiver) that generates a note for the given MIDI key (in the range 0..127), duration (in seconds), and loudness (in the range 0.0 to 1.0)."	^ self copy		setPitch: (AbstractSound pitchForMIDIKey: midiKey)		dur: d		loudness: l! !!AbstractSound methodsFor: 'initialization' stamp: 'jm 8/3/1998 16:58'!soundForPitch: pitchNameOrNumber dur: d loudness: l	"Answer an initialized sound object (a copy of the receiver) that generates a note of the given pitch, duration, and loudness. Pitch may be a numeric pitch or a string pitch name such as 'c4'. Duration is in seconds and loudness is in the range 0.0 to 1.0."	^ self copy setPitch: pitchNameOrNumber dur: d loudness: l! !!AbstractSound methodsFor: 'accessing' stamp: 'jm 12/16/2001 22:34'!isStereo	"Answer true if this sound has distinct left and right channels. (Every sound plays into a stereo sample buffer, but most sounds, which produce exactly the same samples on both channels, are not stereo.)"	^ false! !!AbstractSound methodsFor: 'sampling rates' stamp: 'jm 12/16/2001 13:14'!originalSamplingRate	"For sampled sounds, answer the sampling rate used to record the stored samples. For other sounds, this is the same as the playback sampling rate."	^ SoundPlayer samplingRate! !!AbstractSound methodsFor: 'copying' stamp: 'di 3/4/1999 21:29'!sounds	"Allows simple sounds to behave as, eg, sequential sounds"	^ Array with: self! !!AbstractSound methodsFor: 'conversion' stamp: 'jm 12/16/2001 13:26'!asSampledSound	"Answer a SampledSound containing my samples. If the receiver is some kind of sampled sound, the resulting SampledSound will have the same original sampling rate as the receiver."	^ SampledSound samples: self samples samplingRate: self originalSamplingRate! !!AbstractSound methodsFor: 'conversion' stamp: 'jm 9/9/2003 17:00'!formPixelsPerSecond: pixPerSec	"Answer a Form that displays this sound graphically. Time is scaled so that one second takes the given number of pixels."	| w f buf samplesPerBucket c x max min baseY v r |	w _ (self duration * pixPerSec) ceiling.	f _ Form extent: (w@32) + 2 depth: 4.	f fillWhite.	f borderWidth: 1.	buf _ self samples.	samplesPerBucket _ self originalSamplingRate // pixPerSec.	c _ Color darkGray.	x _ 1.	max _ min _ 0.	baseY _ 17.	'Computing sound thumbnail...'		displayProgressAt: Sensor cursorPoint		from: 1 to: buf size		during: [:bar |			1 to: buf size do: [:i |				v _ buf at: i.				v > max ifTrue: [max _ v. max = 32767 ifTrue: [c _ Color red]].				v < min ifTrue: [min _ v. min = -32768 ifTrue: [c _ Color red]].				(i \\ samplesPerBucket) = 0 ifTrue: [					bar value: i.					r _ (x@(baseY - (max // 1024))) corner: (x + 1)@(baseY - (min // 1024)).					f fill: r fillColor: c.					x _ x + 1.					c _ Color darkGray.					max _ min _ 0]]].	^ f! !!AbstractSound methodsFor: 'envelopes' stamp: 'jm 8/18/1998 09:57'!removeAllEnvelopes	"Remove all envelopes from my envelopes list."	envelopes _ #().! !!AbstractSound methodsFor: 'volume' stamp: 'jm 8/13/1998 16:37'!loudness	"Answer the current volume setting for this sound."	^ scaledVol asFloat / ScaleFactor asFloat! !!AbstractSound methodsFor: 'volume' stamp: 'jm 8/13/1998 16:28'!volumeEnvelopeScaledTo: scalePoint	"Return a collection of values representing my volume envelope scaled by the given point. The scale point's x component is pixels/second and its y component is the number of pixels for full volume."	self error: 'not yet implemented'.! !!AbstractSound methodsFor: 'playing' stamp: 'ar 12/5/1998 22:20'!isPlaying	"Return true if the receiver is currently playing"	^ SoundPlayer isPlaying: self! !!AbstractSound methodsFor: 'playing' stamp: 'di 5/30/1999 12:46'!millisecondsSinceStart	^ mSecsSinceStart! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/13/1998 15:09'!playAndWaitUntilDone	"Play this sound to the sound ouput port and wait until it has finished playing before returning."	SoundPlayer playSound: self.	[self samplesRemaining > 0] whileTrue.	(Delay forMilliseconds: 2 * SoundPlayer bufferMSecs) wait.  "ensure last buffer has been output"! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/18/1998 10:52'!playChromaticRunFrom: startPitch to: endPitch	"Play a fast chromatic run between the given pitches. Useful for auditioning a sound."	(AbstractSound chromaticRunFrom: startPitch to: endPitch on: self) play.! !!AbstractSound methodsFor: 'playing' stamp: 'jm 8/13/1998 16:17'!playSampleCount: n into: aSoundBuffer startingAt: startIndex	"Mix the next n samples of this sound into the given buffer starting at the given index. Update the receiver's control parameters periodically."	| fullVol samplesBetweenControlUpdates pastEnd i remainingSamples count |	fullVol _ AbstractSound scaleFactor.	samplesBetweenControlUpdates _ self samplingRate // self controlRate.	pastEnd _ startIndex + n.  "index just after the last sample"	i _ startIndex.	[i < pastEnd] whileTrue: [		remainingSamples _ self samplesRemaining.		remainingSamples <= 0 ifTrue: [^ self].		count _ pastEnd - i.		samplesUntilNextControl < count ifTrue: [count _ samplesUntilNextControl].		remainingSamples < count ifTrue: [count _ remainingSamples].		self mixSampleCount: count into: aSoundBuffer startingAt: i leftVol: fullVol rightVol: fullVol.		samplesUntilNextControl _ samplesUntilNextControl - count.		samplesUntilNextControl <= 0 ifTrue: [			self doControl.			samplesUntilNextControl _ samplesBetweenControlUpdates].		i _ i + count].! !!AbstractSound methodsFor: 'playing' stamp: 'jm 7/5/1998 17:53'!playSilently	"Compute the samples of this sound without outputting them. Used for performance analysis."	| bufSize buf |	self reset.	bufSize _ self samplingRate // 10.	buf _ SoundBuffer newStereoSampleCount: bufSize.	[self samplesRemaining > 0] whileTrue: [		buf primFill: 0.		self playSampleCount: bufSize into: buf startingAt: 1].! !!AbstractSound methodsFor: 'playing' stamp: 'jm 12/16/2001 13:22'!samples	"Answer a monophonic sample buffer containing my samples. The left and write channels are merged."	"Warning: This may require a lot of memory!!"	^ (self computeSamplesForSeconds: self duration) mergeStereo! !!AbstractSound methodsFor: 'playing' stamp: 'jm 12/16/2001 13:24'!viewSamples	"Open a WaveEditor on my samples."	WaveEditor openOn: self samples.! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 13:34'!doControl	"Update the control parameters of this sound using its envelopes, if any."	"Note: This is only called at a small fraction of the sampling rate."	| pitchModOrRatioChange |	envelopes size > 0 ifTrue: [		pitchModOrRatioChange _ false.		1 to: envelopes size do: [:i |			((envelopes at: i) updateTargetAt: mSecsSinceStart)				ifTrue: [pitchModOrRatioChange _ true]].		pitchModOrRatioChange ifTrue: [self internalizeModulationAndRatio]].	mSecsSinceStart _ mSecsSinceStart + (1000 // self controlRate).! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 7/6/1998 06:40'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1. The leftVol and rightVol parameters determine the volume of the sound in each channel, where 0 is silence and ScaleFactor is full volume."	self subclassResponsibility.! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 13:45'!reset	"Reset my internal state for a replay. Methods that override this method should do super reset."	mSecsSinceStart _ 0.	samplesUntilNextControl _ 0.	envelopes size > 0 ifTrue: [		1 to: envelopes size do: [:i | (envelopes at: i) reset]].! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:56'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds. This default implementation does nothing."! !!AbstractSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:54'!stopGracefully	"End this note with a graceful decay. If the note has envelopes, determine the decay time from its envelopes."	| decayInMs env |	envelopes isEmpty		ifTrue: [			self adjustVolumeTo: 0 overMSecs: 10.			decayInMs _ 10]		ifFalse: [			env _ envelopes first.			decayInMs _ env attackTime + env decayTime].	self duration: (mSecsSinceStart + decayInMs) / 1000.0.	self stopAfterMSecs: decayInMs.! !!AbstractSound methodsFor: 'composition' stamp: 'jm 2/2/1999 15:53'!asSound	^ self! !!AbstractSound methodsFor: 'file i/o' stamp: 'jm 12/16/2001 21:51'!storeAIFFOnFileNamed: fileName	"Store this sound as a AIFF file of the given name."	| f |	f _ (FileStream fileNamed: fileName) binary.	self storeAIFFSamplesOn: f.	f close.! !!AbstractSound methodsFor: 'file i/o' stamp: 'jm 1/1/2004 18:48'!storeAIFFSamplesOn: aBinaryStream	"Store this sound as a 16-bit AIFF file at the current SoundPlayer sampling rate. Store both channels if self isStereo is true; otherwise, store the left channel only as a mono sound."	| samplesToStore channelCount dataByteCount |	samplesToStore _ (self duration * self samplingRate) ceiling.	channelCount _ self isStereo ifTrue: [2] ifFalse: [1].	dataByteCount _ samplesToStore * channelCount * 2.	"write AIFF file header:"	aBinaryStream nextPutAll: 'FORM' asByteArray.	aBinaryStream int32: ((7 * 4) + 18) + dataByteCount.	aBinaryStream nextPutAll: 'AIFF' asByteArray.	aBinaryStream nextPutAll: 'COMM' asByteArray.	aBinaryStream int32: 18.	aBinaryStream int16: channelCount.	aBinaryStream int32: samplesToStore.	aBinaryStream int16: 16.  "bits/sample"	self storeExtendedFloat: self samplingRate on: aBinaryStream.	aBinaryStream nextPutAll: 'SSND' asByteArray.	aBinaryStream int32: dataByteCount + 8.	aBinaryStream int32: 0.	aBinaryStream int32: 0.	"write data:"	self storeSampleCount: samplesToStore bigEndian: true on: aBinaryStream.! !!AbstractSound methodsFor: 'file i/o' stamp: 'jm 3/13/1999 11:34'!storeExtendedFloat: aNumber on: aBinaryStream	"Store an Apple extended-precision 80-bit floating point number on the given stream."	"Details: I could not find the specification for this format, so constants were determined empirically based on assumption of 1-bit sign, 15-bit exponent, 64-bit mantissa. This format does not seem to have an implicit one before the mantissa as some float formats do."	| n isNeg exp mantissa |	n _ aNumber asFloat.	isNeg _ false.	n < 0.0 ifTrue: [		n _ 0.0 - n.		isNeg _ true].	exp _ (n log: 2.0) ceiling.	mantissa _ (n * (2 raisedTo: 64 - exp)) truncated.	exp _ exp + 16r4000 - 2.  "not sure why the -2 is needed..."	isNeg ifTrue: [exp _ exp bitOr: 16r8000].  "set sign bit"	aBinaryStream nextPut: ((exp bitShift: -8) bitAnd: 16rFF).	aBinaryStream nextPut: (exp bitAnd: 16rFF).	8 to: 1 by: -1 do: [:i | aBinaryStream nextPut: (mantissa digitAt: i)].! !!AbstractSound methodsFor: 'file i/o' stamp: 'jm 12/3/2003 13:09'!storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files). If self isStereo is true, both channels are stored, creating a stereo file. Otherwise, only the left channel is stored, creating a mono file."	| bufSize stereoBuffer reverseBytes remaining out |	self reset.	bufSize _ (2 * self samplingRate rounded) min: samplesToStore.  "two second buffer"	stereoBuffer _ SoundBuffer newStereoSampleCount: bufSize.	reverseBytes _ bigEndianFlag ~= Smalltalk isBigEndian.	'Storing audio...' displayProgressAt: Sensor cursorPoint		from: 0 to: samplesToStore during: [:bar |			remaining _ samplesToStore.			[remaining > 0] whileTrue: [				bar value: samplesToStore - remaining.				stereoBuffer primFill: 0.  "clear the buffer"				self playSampleCount: (bufSize min: remaining) into: stereoBuffer startingAt: 1.				self isStereo					ifTrue: [out _ stereoBuffer]					ifFalse: [out _ stereoBuffer extractLeftChannel].				reverseBytes ifTrue: [out reverseEndiannessStereo: false].				(aBinaryStream isKindOf: StandardFileStream)					ifTrue: [  "optimization for files: write sound buffer directly to file"						aBinaryStream next: (out size // 2) putAll: out startingAt: 1]  "size in words"					ifFalse: [  "for non-file streams:"						1 to: out monoSampleCount do: [:i | aBinaryStream int16: (out at: i)]].				remaining _ remaining - bufSize]].! !!AbstractSound methodsFor: 'file i/o' stamp: 'jm 12/16/2001 21:47'!storeSunAudioOnFileNamed: fileName	"Store this sound as an uncompressed Sun audio file of the given name."	| f |	f _ (FileStream fileNamed: fileName) binary.	self storeSunAudioSamplesOn: f.	f close.! !!AbstractSound methodsFor: 'file i/o' stamp: 'jm 12/16/2001 22:32'!storeSunAudioSamplesOn: aBinaryStream	"Store this sound as a 16-bit Sun audio file at the current SoundPlayer sampling rate. Store both channels if self isStereo is true; otherwise, store the left channel only as a mono sound."	| samplesToStore channelCount dataByteCount |	samplesToStore _ (self duration * self samplingRate) ceiling.	channelCount _ self isStereo ifTrue: [2] ifFalse: [1].	dataByteCount _ samplesToStore * channelCount * 2.	"write Sun audio file header"	channelCount _ self isStereo ifTrue: [2] ifFalse: [1].	aBinaryStream nextPutAll: '.snd' asByteArray.	aBinaryStream uint32: 24.	"header size in bytes"	aBinaryStream uint32: dataByteCount.	aBinaryStream uint32: 3.	"format: 16-bit linear"	aBinaryStream uint32: self samplingRate truncated.	aBinaryStream uint32: channelCount.	"write data:"	self storeSampleCount: samplesToStore bigEndian: true on: aBinaryStream.! !!AbstractSound methodsFor: 'file i/o' stamp: 'jm 12/16/2001 20:03'!storeWAVOnFileNamed: fileName	"Store this sound as a 16-bit Windows WAV file of the given name."	| f |	f _ (FileStream fileNamed: fileName) binary.	self storeWAVSamplesOn: f.	f close.! !!AbstractSound methodsFor: 'file i/o' stamp: 'jm 12/3/2003 15:58'!storeWAVSamplesOn: aBinaryStream	"Store this sound as a 16-bit Windows WAV file at the current SoundPlayer sampling rate. Store both channels if self isStereo is true; otherwise, store the left channel only as a mono sound."	| samplesToStore channelCount dataByteCount samplesPerSec bytesPerSec |	samplesToStore _ (self duration * self samplingRate) ceiling.	channelCount _ self isStereo ifTrue: [2] ifFalse: [1].	dataByteCount _ samplesToStore * channelCount * 2.	samplesPerSec _ self samplingRate rounded.	bytesPerSec _ samplesPerSec * channelCount * 2.	"file header"	aBinaryStream		nextPutAll: 'RIFF' asByteArray;		littleEndianUint32: dataByteCount + 36;	"total length of all chunks"		nextPutAll: 'WAVE' asByteArray.	"format chunk"	aBinaryStream		nextPutAll: 'fmt ' asByteArray;		littleEndianUint32: 16;	"length of this chunk"		littleEndianUint16: 1;		"format tag"		littleEndianUint16: channelCount;		littleEndianUint32: samplesPerSec;		littleEndianUint32: bytesPerSec;		littleEndianUint16: 4;		"alignment"		littleEndianUint16: 16.	"bits per sample"	"data chunk"	aBinaryStream		nextPutAll: 'data' asByteArray;		littleEndianUint32: dataByteCount.  "length of this chunk"	self storeSampleCount: samplesToStore bigEndian: false on: aBinaryStream.! !!AbstractSound class methodsFor: 'class initialization' stamp: 'jm 8/3/1998 16:13'!initialize	"AbstractSound initialize" 	| bottomC |	ScaleFactor _ 2 raisedTo: 15.	FloatScaleFactor _ ScaleFactor asFloat.	MaxScaledValue _ ((2 raisedTo: 31) // ScaleFactor) - 1.  "magnitude of largest scaled value in 32-bits"	"generate pitches for c-1 through c0"	bottomC _ (440.0 / 32) * (2.0 raisedTo: -9.0 / 12.0).	PitchesForBottomOctave _ (0 to: 12) collect: [:i | bottomC * (2.0 raisedTo: i asFloat / 12.0)].	TopOfBottomOctave _ PitchesForBottomOctave last.! !!AbstractSound class methodsFor: 'instance creation' stamp: 'jm 8/3/1998 17:00'!noteSequenceOn: aSound from: anArray	"Build a note sequence (i.e., a SequentialSound) from the given array using the given sound as the instrument. Elements are either (pitch, duration, loudness) triples or (#rest duration) pairs.  Pitches can be given as names or as numbers."	| score pitch |	score _ SequentialSound new.	anArray do: [:el |		el size = 3			ifTrue: [				pitch _ el at: 1.				pitch isNumber ifFalse: [pitch _ self pitchForName: pitch].				score add: (					aSound						soundForPitch: pitch						dur: (el at: 2)						loudness: (el at: 3) / 1000.0)]			ifFalse: [				score add: (RestSound dur: (el at: 2))]].	^ score! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:16'!indexOfBottomOctavePitch: p	"Answer the index of the first pitch in the bottom octave equal to or higher than the given pitch. Assume that the given pitch is below the top pitch of the bottom octave."	1 to: PitchesForBottomOctave size do: [:i |		(PitchesForBottomOctave at: i) >= p ifTrue: [^ i]].	self error: 'implementation error: argument pitch should be below or within the bottom octave'.! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:16'!midiKeyForPitch: pitchNameOrNumber	"Answer the midiKey closest to the given pitch. Pitch may be a numeric pitch or a pitch name string such as 'c4'."	"AbstractSound midiKeyForPitch: 440.0"	| p octave i midiKey |	pitchNameOrNumber isNumber		ifTrue: [p _ pitchNameOrNumber asFloat]		ifFalse: [p _ AbstractSound pitchForName: pitchNameOrNumber].	octave _ -1.	[p >= TopOfBottomOctave] whileTrue: [		octave _ octave + 1.		p _ p / 2.0].	i _ self indexOfBottomOctavePitch: p.	(i > 1) ifTrue: [		(p - (PitchesForBottomOctave at: i - 1)) < ((PitchesForBottomOctave at: i) - p)			ifTrue: [i _ i - 1]].	midiKey _ ((octave * 12) + 11 + i).	midiKey > 127 ifTrue: [midiKey _ 127].	^ midiKey! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 8/3/1998 16:43'!pitchForMIDIKey: midiKey	"Answer the pitch for the given MIDI key."	"(1 to: 127) collect: [:i | AbstractSound pitchForMIDIKey: i]"	| indexInOctave octave |	indexInOctave _ (midiKey \\ 12) + 1.	octave _ (midiKey // 12) + 1.	^ (PitchesForBottomOctave at: indexInOctave) *		(#(1.0 2.0 4.0 8.0 16.0 32.0 64.0 128.0 256.0 512.0 1024.0) at: octave)! !!AbstractSound class methodsFor: 'utilities' stamp: 'jm 7/6/1998 15:47'!pitchTable	"AbstractSound pitchTable"	| out note i |	out _ WriteStream on: (String new: 1000).	i _ 12.	0 to: 8 do: [:octave |		#(c 'c#' d eb e f fs g 'g#' a bf b) do: [:noteName |			note _ noteName, octave printString.			out nextPutAll: note; tab.			out nextPutAll: i printString; tab.			out nextPutAll: (AbstractSound pitchForName: note) printString; cr.			i _ i + 1]].	^ out contents! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 6/30/1998 18:40'!chromaticPitchesFrom: aPitch	| halfStep pitch |	halfStep _ 2.0 raisedTo: (1.0 / 12.0).	pitch _ aPitch isNumber			ifTrue: [aPitch]			ifFalse: [self pitchForName: aPitch].	pitch _ pitch / halfStep.	^ (0 to: 14) collect: [:i | pitch _ pitch * halfStep]! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 8/18/1998 11:32'!chromaticRunFrom: startPitch to: endPitch on: aSound	"Answer a composite sound consisting of a rapid chromatic run between the given pitches on the given sound."	"(AbstractSound chromaticRunFrom: 'c3' to: 'c#5' on: FMSound oboe1) play"	| scale halfStep pEnd p |	scale _ SequentialSound new.	halfStep _ 2.0 raisedTo: (1.0 / 12.0).	endPitch isNumber		ifTrue: [pEnd _ endPitch asFloat]		ifFalse: [pEnd _ AbstractSound pitchForName: endPitch].	startPitch isNumber		ifTrue: [p _ startPitch asFloat]		ifFalse: [p _ AbstractSound pitchForName: startPitch].	[p <= pEnd] whileTrue: [		scale add: (aSound soundForPitch: p dur: 0.2 loudness: 0.5).		p _ p * halfStep].	^ scale! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 8/3/1998 17:00'!majorChordOn: aSound from: aPitch	"FMSound majorChord play"	| score majorScale leadingRest pan note |	majorScale _ self majorPitchesFrom: aPitch.	score _ MixedSound new.	leadingRest _ pan _ 0.	#(1 3 5 8) do: [:noteIndex |		note _ aSound			soundForPitch: (majorScale at: noteIndex)			dur: 2.0 - leadingRest			loudness: 0.3.		score add: (RestSound dur: leadingRest), note pan: pan.		leadingRest _ leadingRest + 0.2.		pan _ pan + 0.3].	^ score! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 7/13/1998 13:09'!majorScaleOn: aSound from: aPitch	"FMSound majorScale play"	^ self noteSequenceOn: aSound		from: ((self majorPitchesFrom: aPitch)			 collect: [:pitch | Array with: pitch with: 0.5 with: 300])! !!AbstractSound class methodsFor: 'examples' stamp: 'jm 1/4/1999 09:26'!majorScaleOn: aSound from: aPitch octaves: octaveCount	"(AbstractSound majorScaleOn: FMSound oboe1 from: #c2 octaves: 5) play"	| startingPitch pitches chromatic |	startingPitch _ aPitch isNumber		ifTrue: [aPitch]		ifFalse: [self pitchForName: aPitch].	pitches _ OrderedCollection new.	0 to: octaveCount - 1 do: [:i |		chromatic _ self chromaticPitchesFrom: startingPitch * (2 raisedTo: i).		#(1 3 5 6 8 10 12) do: [:j | pitches addLast: (chromatic at: j)]].	pitches addLast: startingPitch * (2 raisedTo: octaveCount).	^ self noteSequenceOn: aSound		from: (pitches collect: [:pitch | Array with: pitch with: 0.5 with: 300])! !!AbstractSound class methodsFor: 'examples' stamp: 'di 4/13/1999 13:53'!testFMInteractively	"Experiment with different settings of the FM modulation and multiplier settings interactively by moving the mouse. The top-left corner of the screen is 0 for both parameters. Stop when the mouse is pressed."	"AbstractSound testFMInteractively"	| s mousePt lastVal status mod ratio |	SoundPlayer startPlayerProcessBufferSize: 1100 rate: 11025 stereo: false.	s _ FMSound pitch: 440.0 dur: 200.0 loudness: 0.2.	SoundPlayer playSound: s.	lastVal _ nil.	[Sensor anyButtonPressed] whileFalse: [		mousePt _ Sensor cursorPoint.		mousePt ~= lastVal ifTrue: [			mod _ mousePt x asFloat / 20.0.			ratio _ mousePt y asFloat / 20.0.			s modulation: mod ratio: ratio.			lastVal _ mousePt.			status _'mod: ', mod printString, 'ratio: ', ratio printString.			status displayOn: Display at: 10@10]].	SoundPlayer shutDown.! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/14/1998 13:27'!initSounds	"AbstractSound initSounds"	Sounds _ Dictionary new.	(FMSound class organization listAtCategoryNamed: #instruments)		do: [:sel | Sounds at: sel asString put: (FMSound perform: sel)].! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/14/1998 13:25'!soundNamed: soundName	^ Sounds at: soundName! !!AbstractSound class methodsFor: 'sound library' stamp: 'tk 6/24/1999 11:31'!soundNamed: soundName put: aSound	Sounds at: soundName put: aSound.	Smalltalk at: #ScorePlayerMorph ifPresent: [:playerClass |		playerClass allSubInstancesDo:			[:player | player updateInstrumentsFromLibrary]].! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/19/1998 14:11'!soundNames	^ Sounds keys asSortedCollection asArray! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 8/4/1998 18:26'!sounds	^ Sounds! !!AbstractSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 13:00'!updateFMSounds	"AbstractSound updateFMSounds"	Sounds keys do: [:k |		((Sounds at: k) isKindOf: FMSound) ifTrue: [			Sounds removeKey: k ifAbsent: []]].	(FMSound class organization listAtCategoryNamed: #instruments) do:		[:sel | Sounds at: sel asString put: (FMSound perform: sel)].! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'sge 2/13/2000 05:20'!fileInSoundLibrary	"Prompt the user for a file name and the file in the sound library with that name."	"AbstractSound fileInSoundLibrary"	| fileName |	fileName _ FillInTheBlank request: 'Sound library file name?'.	fileName isEmptyOrNil ifTrue: [^ self].	(fileName endsWith: '.sounds') ifFalse: [fileName _ fileName, '.sounds'].	self fileInSoundLibraryNamed: fileName.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 10/14/2002 18:18'!fileInSoundLibraryNamed: fileName	"File in the sound library with the given file name, and add its contents to the current sound library."	| newSounds |	self flag: 'took out object storage system'.	self error: 'depended on object storage system'.	newSounds associationsDo:		[:assoc | self storeFiledInSound: assoc value named: assoc key].	ScorePlayerMorph allSubInstances do: [:p | p updateInstrumentsFromLibrary].	Smalltalk garbageCollect.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 8/19/1998 12:42'!fileOutSoundLibrary	"File out the current sound library."	"AbstractSound fileOutSoundLibrary"	self fileOutSoundLibrary: Sounds.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 10/14/2002 17:37'!fileOutSoundLibrary: aDictionary	"File out the given dictionary, which is assumed to contain sound and instrument objects keyed by their names."	"Note: This method is separated out so that one can file out edited sound libraries, as well as the system sound library. To make such a collection, you can inspect AbstractSound sounds and remove the items you don't want. Then do: 'AbstractSound fileOutSoundLibrary: self' from the Dictionary inspector."	| fileName |	(aDictionary isKindOf: Dictionary)		ifFalse: [self error: 'arg should be a dictionary of sounds'].	fileName _ FillInTheBlank request: 'Sound library file name?'.	fileName isEmptyOrNil ifTrue: [^ self].	self flag: 'took out object storage system'.	self error: 'depended on object storage system'.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 21:35'!storeFiledInSound: snd named: sndName	"Store the given sound in the sound library. Use the given name if it isn't in use, otherwise ask the user what to do."	| menu choice i |	(Sounds includesKey: sndName) ifFalse: [  "no name clash"		Sounds at: sndName put: snd.		^ self].	(Sounds at: sndName) == UnloadedSnd ifTrue: [		"re-loading a sound that was unloaded to save space"		Sounds at: sndName put: snd.		^ self].	"the given sound name is already used"	menu _ SelectionMenu selections:		#('replace the existing sound' 'rename the new sound' 'skip it').	choice _ menu startUpWithCaption:		'"', sndName, '" has the same name as an existing sound'.	(choice beginsWith: 'replace') ifTrue: [		Sounds at: sndName put: snd.		^ self].	(choice beginsWith: 'rename') ifTrue: [		i _ 2.		[Sounds includesKey: (sndName, ' v', i printString)] whileTrue: [i _ i + 1].		Sounds at: (sndName, ' v', i printString) put: snd].! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 22:18'!unloadSampledTimbres	"This can be done to unload those bulky sampled timbres to shrink the image. The unloaded sounds are replaced by a well-known 'unloaded sound' object to enable the unloaded sounds to be detected when the process is reversed."	"AbstractSound unloadSampledTimbres"	Sounds keys copy do: [:soundName |		(((Sounds at: soundName) isKindOf: SampledInstrument) or:		 [(Sounds at: soundName) isKindOf: LoopedSampledSound]) ifTrue: [			Sounds at: soundName put: self unloadedSound]].	self updateScorePlayers.	Smalltalk garbageCollect.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/11/1998 16:47'!unloadSoundNamed: soundName	(Sounds includesKey: soundName) ifTrue: [		Sounds at: soundName put: self unloadedSound].	self updateScorePlayers.! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'jm 9/12/1998 21:48'!unloadedSound	"Answer a sound to be used as the place-holder for sounds that have been unloaded."	UnloadedSnd ifNil: [UnloadedSnd _ UnloadedSound default copy].	^ UnloadedSnd! !!AbstractSound class methodsFor: 'sound library-file in/out' stamp: 'tk 6/24/1999 07:20'!updateScorePlayers	"Force all ScorePlayers to update their instrument list from the sound library. This may done after loading, unloading, or replacing a sound to make all ScorePlayers feel the change."	ScorePlayer allSubInstances do: [:p | p pause].	SoundPlayer shutDown.	ScorePlayerMorph allInstances do: [:p | p updateInstrumentsFromLibrary].! !!AcceptableCleanTextMorph methodsFor: 'as yet unclassified' stamp: 'di 6/22/1998 21:38'!accept	"Overridden to allow accept of clean text"	| textToAccept ok |	textToAccept _ textMorph asText.	ok _ (setTextSelector == nil) or:		[setTextSelector numArgs = 2			ifTrue: [model perform: setTextSelector with: textToAccept with: self]			ifFalse: [model perform: setTextSelector with: textToAccept]].	ok ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false]! !!AcornFileDirectory methodsFor: 'file name utilities' stamp: 'ar 12/18/1999 00:47'!fullPathFor: path	path isEmpty ifTrue:[^pathName].	((path includes: $$ ) or:[path includes: $:]) ifTrue:[^path].	^pathName, self slash, path! !!AcornFileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/12/1998 22:48'!isActiveDirectoryClass	"Does this class claim to be that properly active subclass of FileDirectory for this platform?	On Acorn, the test is whether systemAttribute 1001 = 'RiscOS' (on newer VMs) or if the primPathNameDelimiter is $. (on older ones), which is what we would like to use for a dirsep if only it would work out. See pathNameDelimiter for more woeful details - then just get on and enjoy Squeak"	| attr |	attr _ Smalltalk getSystemAttribute: 1001.	attr isNil ifFalse:[^attr = 'RiscOS'].	^self primPathNameDelimiter = $.! !!AcornFileDirectory class methodsFor: 'platform specific' stamp: 'TPR 7/20/1999 17:52'!maxFileNameLength	^ 255! !!AcornFileDirectory class methodsFor: 'platform specific' stamp: 'TPR 5/10/1998 21:45'!pathNameDelimiter"Acorn RiscOS uses a dot as the directory separator and has no real concept of filename extensions. We tried to make code handle this, but there are just too many uses of dot as a filename extension - so fake it out by pretending to use a slash. The file prims do conversions instead.Sad, but pragmatic"	^ $/! !Layout my submorphs in a row or column, depending on the setting of orientation. You use rows of columns or columns of rows to create 2-D layouts, but if you need a true table layout AlignmentMorph is not the answer.Centering in the minor dimension (e.g. the vertical placement of morphs in a row) is controlled by the centering setting. Resizing in each dimension in indpendent and can be either "shrinkWrap" (shrink to the smallest possible size that encloses my submorphs), "rigid" (don't change size), or "spaceFill" (grow to fill the available space if I'm in another AlignmentMorph).See my 'accessing' category for other settings.!!AlignmentMorph methodsFor: 'initialization' stamp: 'jm 7/19/2003 15:07'!initialize	super initialize.	borderWidth _ 0.	orientation _ #horizontal.	"#horizontal or #vertical  or #free"	centering _ #topLeft.		"#topLeft, #center, or #bottomRight"	hResizing _ #spaceFill.		"#spaceFill, #shrinkWrap, or #rigid"	vResizing _ #spaceFill.		"#spaceFill, #shrinkWrap, or #rigid"	inset _ 2.					"pixels inset within owner's bounds"	layoutNeeded _ true.	color _ Color r: 0.8 g: 1.0 b: 0.8.! !!AlignmentMorph methodsFor: 'accessing' stamp: 'jm 6/5/2003 17:46'!centering: aSymbol	"Set the minor dimension alignment to #topLeft, #center, or #bottomRight."	(#(topLeft #center #bottomRight) includes: aSymbol)		ifTrue: [centering _ aSymbol].! !!AlignmentMorph methodsFor: 'accessing' stamp: 'jm 6/5/2003 17:45'!hResizing: aSymbol	"Set the horizontal resizing style to #spaceFill, #shrinkWrap, or #rigid."	(#(spaceFill #shrinkWrap #rigid) includes: aSymbol)		ifTrue: [hResizing _ aSymbol].! !!AlignmentMorph methodsFor: 'accessing' stamp: 'jm 6/5/2003 17:42'!orientation: aSymbol	"Set the major layout dimension to #horizontal or #vertical."	#horizontal == aSymbol		ifTrue: [orientation _ #horizontal]		ifFalse: [orientation _ #vertical].! !!AlignmentMorph methodsFor: 'accessing' stamp: 'jm 6/5/2003 17:44'!vResizing: aSymbol	"Set the vertical resizing style to #spaceFill, #shrinkWrap, or #rigid."	(#(spaceFill #shrinkWrap #rigid) includes: aSymbol)		ifTrue: [vResizing _ aSymbol].! !!AlignmentMorph methodsFor: 'dropping/grabbing' stamp: 'jm 6/5/2003 18:35'!acceptDroppingMorph: aMorph event: evt	"Allow the user to add submorphs just by dropping them on this morph."	self privateAddMorph: aMorph atIndex: (self insertionIndexFor: aMorph).	self changed.	self layoutChanged.! !!AlignmentMorph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:47'!rootForGrabOf: aMorph	| root |	self dragNDropEnabled ifFalse: [^ super rootForGrabOf: aMorph].	root _ aMorph.	[root == self] whileFalse:		[root owner = self ifTrue: [^ root].		root _ root owner].	^ super rootForGrabOf: aMorph! !!AlignmentMorph methodsFor: 'layout' stamp: 'di 11/26/1999 21:37'!fullBounds	"This is the hook that triggers lazy re-layout of layout morphs. It works because layoutChanged clears the fullBounds cache. Once per cycle, the fullBounds is requested from every morph in the world, and that request gets propagated through the entire submorph hierarchy, causing re-layout where needed. Note that multiple layoutChanges to the same morph can be done with little cost, since the layout is only done when the morph needs to be displayed."	fullBounds ifNil: [		self resizeIfNeeded.		self fixLayout.		super fullBounds.  "updates cache"		priorFullBounds == nil			ifTrue: [self invalidRect: fullBounds]			ifFalse: [fullBounds = priorFullBounds					ifFalse: ["report change due to layout"							self invalidRect: (fullBounds merge: priorFullBounds)]].		layoutNeeded _ false].	^ super fullBounds! !!AlignmentMorph methodsFor: 'layout' stamp: 'jm 7/19/2003 15:05'!minHeight	"Return the minimum height for this morph."	| minH spaceNeeded |	vResizing = #rigid ifTrue: [^ self fullBounds height].	submorphs isEmpty ifTrue: [^ self minHeightWhenEmpty].	orientation == #horizontal ifTrue:		[minH _ 0.		submorphs do: [:m | minH _ minH max: m minHeight].		spaceNeeded _ minH + (2 * (inset + borderWidth))].	orientation == #vertical ifTrue:		[spaceNeeded _ 2 * (inset + borderWidth).		submorphs do: [:m | spaceNeeded _ spaceNeeded + m minHeight]].	^ spaceNeeded! !!AlignmentMorph methodsFor: 'layout' stamp: 'jm 7/19/2003 15:04'!minWidth	"Return the minimum width for this morph."	| spaceNeeded minW |	hResizing = #rigid ifTrue: [^ self fullBounds width].	submorphs isEmpty ifTrue: [^ self minWidthWhenEmpty].	orientation == #horizontal ifTrue: [		spaceNeeded _ 2 * (inset + borderWidth).		submorphs do: [:m | spaceNeeded _ spaceNeeded + m minWidth]].	orientation == #vertical ifTrue: [		minW _ 0.		submorphs do: [:m | minW _ minW max: m minWidth].		spaceNeeded _ minW + (2 * (inset + borderWidth))].	^ spaceNeeded! !!AlignmentMorph methodsFor: 'menu' stamp: 'jm 10/11/2002 08:56'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'orientation...' action: #chooseOrientation.	aCustomMenu		add: ((self dragNDropEnabled ifTrue: ['close'] ifFalse: ['open']), ' dragNdrop')		action: #toggleDragNDrop.! !!AlignmentMorph methodsFor: 'menu' stamp: 'jm 6/5/2003 18:32'!chooseOrientation	| aMenu emphases reply |	emphases _ #(vertical horizontal).	aMenu _ EmphasizedMenu selections: emphases.	aMenu onlyBoldItem: (emphases indexOf: orientation).	reply _ aMenu startUpWithCaption: 'Choose orientation'.	(reply == nil or: [reply == orientation]) ifTrue: [^ self].	self orientation: reply.	self layoutChanged.! !!AlignmentMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 17:27'!fieldsVersion	^ 1! !!AlignmentMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 17:28'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		orientation		centering		hResizing		vResizing		inset	) from: anObjStream.! !!AlignmentMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 17:28'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		orientation		centering		hResizing		vResizing		inset	) on: anObjStream.! !!AlignmentMorph methodsFor: 'private' stamp: 'sw 5/6/2000 03:09'!drawSubmorphsOn: aCanvas	((self hasProperty: #clipToOwnerWidth) and: [owner isWorldOrHandMorph not])		ifFalse:			[super drawSubmorphsOn: aCanvas]		ifTrue:			[aCanvas				clipBy:					(self bounds intersect: owner bounds)				during:					[:clippedCanvas | super drawSubmorphsOn: clippedCanvas]]! !!AlignmentMorph methodsFor: 'private' stamp: 'jm 7/19/2003 15:04'!extraSpacePerMorph	| spaceFillingMorphs spaceNeeded extra |	spaceFillingMorphs _ 0.	spaceNeeded _ 2 * (inset + borderWidth).	orientation = #horizontal ifTrue: [		submorphs do: [:m |			spaceNeeded _ spaceNeeded + m minWidth.			(m isAlignmentMorph and: [m hResizing = #spaceFill])				ifTrue: [spaceFillingMorphs _ spaceFillingMorphs + 1]].		extra _ (bounds width - spaceNeeded) max: 0.	] ifFalse: [		submorphs do: [:m |			spaceNeeded _ spaceNeeded + m minHeight.			(m isAlignmentMorph and: [m vResizing = #spaceFill])				ifTrue: [spaceFillingMorphs _ spaceFillingMorphs + 1]].		extra _ (bounds height - spaceNeeded) max: 0].	(submorphs size <= 1 or: [spaceFillingMorphs <= 1]) ifTrue: [^ extra].	^ extra asFloat / spaceFillingMorphs! !!AlignmentMorph methodsFor: 'private' stamp: 'jm 11/10/1998 13:33'!fixLayout	| extraPerMorph fractionalExtra fractionAccumulator nextPlace extra space |	extraPerMorph _ self extraSpacePerMorph asFloat.	fractionalExtra _ extraPerMorph fractionPart.	extraPerMorph _ extraPerMorph truncated.	orientation = #horizontal		ifTrue: [nextPlace _ bounds left + inset + borderWidth]		ifFalse: [nextPlace _ bounds top + inset + borderWidth].	fractionAccumulator _ 0.0.	submorphs do: [:m |		fractionAccumulator _ fractionAccumulator + fractionalExtra.		fractionAccumulator > 0.5			ifTrue: [				extra _ extraPerMorph + 1.				fractionAccumulator _ fractionAccumulator - 1.0]			ifFalse: [extra _ extraPerMorph].		space _ self placeAndSize: m at: nextPlace padding: extra.		nextPlace _ nextPlace + space].! !!AlignmentMorph methodsFor: 'private' stamp: 'di 11/26/1999 22:16'!layoutChanged	layoutNeeded ifTrue: [^ self].  "In process."	layoutNeeded _ true.	priorFullBounds _ fullBounds.  "Remember fullBounds"	super layoutChanged.! !!AlignmentMorph methodsFor: 'private' stamp: 'di 11/26/1999 22:11'!layoutInWidth: w height: h	"Adjust the size of the receiver in its space-filling dimensions during layout. This message is sent to only to layout submorphs."	((hResizing = #spaceFill) and: [bounds width ~= w]) ifTrue: [		bounds _ bounds origin extent: (w @ bounds height).		self layoutChanged].	((vResizing = #spaceFill) and: [bounds height ~= h]) ifTrue: [		bounds _ bounds origin extent: (bounds width @ h).		self layoutChanged].! !!AlignmentMorph methodsFor: 'private' stamp: 'jm 7/19/2003 15:06'!placeAndSize: m at: nextPlace padding: padding	| space totalInset fullBnds left top |	totalInset _ inset + borderWidth.	orientation = #horizontal		ifTrue: [			space _ m minWidth.			m isAlignmentMorph ifTrue: [				(m hResizing = #spaceFill) ifTrue: [space _ space + padding].				m layoutInWidth: space height: (bounds height - (2 * totalInset))]]		ifFalse: [			space _ m minHeight.			m isAlignmentMorph ifTrue: [				(m vResizing = #spaceFill) ifTrue: [space _ space + padding].				m layoutInWidth: (bounds width - (2 * totalInset)) height: space]].	fullBnds _ m fullBounds.	orientation = #horizontal		ifTrue: [			left _ nextPlace.			centering = #topLeft				ifTrue: [top _ bounds top + totalInset].			centering = #bottomRight				ifTrue: [top _ bounds bottom - totalInset - fullBnds height].			centering = #center				ifTrue: [top _ bounds top + ((bounds height - fullBnds height) // 2)]]		ifFalse: [			top _ nextPlace.			centering = #topLeft				ifTrue: [left _ bounds left + totalInset].			centering = #bottomRight				ifTrue: [left _ bounds right - totalInset - fullBnds width].			centering = #center				ifTrue: [left _ bounds left + ((bounds width - fullBnds width) // 2)]].	m position: (left + (m bounds left - fullBnds left)) @ (top + (m bounds top - fullBnds top)).	^ space! !!AlignmentMorph methodsFor: 'private' stamp: 'sw 5/6/2000 02:53'!resizeIfNeeded	"Resize this morph if it is space-filling or shrink-wrap and its owner is not a layout morph."	| newWidth newHeight |	newWidth _ bounds width.	newHeight _ bounds height.	(owner == nil or: [owner isAlignmentMorph not]) ifTrue:		"if spaceFill and not in a LayoutMorph, grow to enclose submorphs"		[hResizing = #spaceFill ifTrue:			[newWidth _ self minWidth max: self bounds width.			owner ifNotNil:				[(self hasProperty: #clipToOwnerWidth) ifTrue:					[newWidth _ newWidth min: (owner right - bounds left)]]].		vResizing = #spaceFill ifTrue:			[newHeight _ self minHeight max: self bounds height]].	"if shrinkWrap, adjust size to just fit around submorphs"	hResizing = #shrinkWrap ifTrue: [newWidth _ self minWidth].	vResizing = #shrinkWrap ifTrue: [newHeight _ self minHeight].	((newWidth ~= bounds width) or: [newHeight ~= bounds height])		ifTrue: ["bounds really changed"				bounds _ bounds origin extent: newWidth@newHeight].! !!AlignmentMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:02'!includeInNewMorphMenu	^ true! !Here's a very simple morph that animates itself by queuing messages to be sent to itself once per step. The step time determines the playback rate; a stepTime of 50 milliseconds is 20 frames/sec.Here's a test you can do in a workspace. First create and open the morph:	a _ AnimationTestMorph new.	a openInWorldNow try sending it these messages:	a growShrink.	a rightLeft.	a turnAround.Note that because it queues up actions for later you can send it additional messages before it's finished it's current action. For example, try:	a growShrink; growShrink; rightLeft; turnAround.!!AnimationTestMorph methodsFor: 'initialization' stamp: 'jm 1/29/2003 12:18'!initialize	super initialize.	actionList _ OrderedCollection new.! !!AnimationTestMorph methodsFor: 'animations' stamp: 'jm 1/29/2003 12:30'!growShrink	"Queue up a grow and shrink animation."	| oldExtent |	oldExtent _ self extent.	1.0 to: 1.5 by: 0.1 do: [:scale | actionList addLast: (Array with: #extent: with: scale * oldExtent)].	1.4 to: 1.1 by: -0.1 do: [:scale | actionList addLast: (Array with: #extent: with: scale * oldExtent)].	actionList addLast: (Array with: #extent: with: oldExtent).! !!AnimationTestMorph methodsFor: 'animations' stamp: 'jm 1/29/2003 12:28'!rightLeft	"Queue up a move right-and-left animation."	| startP |	startP _ self position.	10 to: 100 by: 10 do: [:x | actionList addLast: (Array with: #position: with: startP + (x@0))].	90 to: 0 by: -10 do: [:x | actionList addLast: (Array with: #position: with: startP + (x@0))].! !!AnimationTestMorph methodsFor: 'animations' stamp: 'jm 1/29/2003 12:38'!turnAround	"Queue up a rotation of 360 degrees in 20 steps."	| angle |	angle _ self rotationDegrees.	1 to: 11 do: [:i | actionList addLast: (Array with: #rotationDegrees: with: angle + (i * 30))].	actionList addLast: (Array with: #rotationDegrees: with: angle).! !!AnimationTestMorph methodsFor: 'stepping' stamp: 'jm 1/29/2003 12:13'!step	"Perform the next step of my animation."	| action selector |	actionList size > 0 ifTrue: [		action _ actionList removeFirst.		selector _ action first.		self perform: selector withArguments: (action copyFrom: 2 to: action size)].! !!AnimationTestMorph methodsFor: 'stepping' stamp: 'jm 1/29/2003 12:28'!stepTime	^ 50! !!AnimationTestMorph class methodsFor: 'instance creation' stamp: 'jm 6/15/2003 17:38'!includeInNewMorphMenu	^ true! !I am an abstract superclass for all kinds of argument morphs--morphs that are used to hold the argument for various kinds of BlockMorph.!!ArgMorph methodsFor: 'queries' stamp: 'jm 3/15/2003 12:21'!isReporter	"Answer true since every ArgMorph reports a value."	^ true! !!ArgMorph methodsFor: 'queries' stamp: 'jm 3/15/2003 12:23'!isTest	"Answer false by default."	^ false! !!ArgMorph methodsFor: 'dropping/grabbing' stamp: 'jm 3/16/2003 11:26'!acceptDroppingMorph: aMorph event: evt	"Assume: Owner is not nil and is some kind of CommandBlockMorph. These assumptions are checked by wantsDroppedMorph:event:."	owner replaceArgMorph: self by: aMorph.! !!ArgMorph methodsFor: 'dropping/grabbing' stamp: 'jm 3/17/2003 17:51'!wantsDroppedMorph: aMorph event: evt	"Answer true if the dropping morph is a value reporter."	^ ((aMorph respondsTo: #isReporter) and:		[aMorph isReporter and:		[owner isKindOf: CommandBlockMorph]])! !!ArgMorph methodsFor: 'layout' stamp: 'jm 8/24/2003 16:57'!fixArgLayout	"Fix my layout. This default implementation does nothing."! !!ArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:25'!fieldsVersion	^ 1! !!ArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:25'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		labelMorph	) from: anObjStream.! !!ArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:33'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		labelMorph	) on: anObjStream.! !!ArgMorph methodsFor: 'accessing' stamp: 'jm 10/21/2003 12:32'!labelMorph	^ labelMorph! !I present an ArrayedCollection whose elements are objects.!!Array methodsFor: 'converting' stamp: 'sma 5/12/2000 17:32'!asArray	"Answer with the receiver itself."	^ self! !!Array methodsFor: 'converting' stamp: 'di 3/28/1999 10:22'!elementsExchangeIdentityWith: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  At the same time, all pointers to the elements of otherArray are replaced by pointers to the corresponding elements of this array.  The identityHashes remain with the pointers rather than with the objects so that objects in hashed structures should still be properly indexed after the mutation."	<primitive: 128>	self primitiveFailed! !!Array methodsFor: 'converting' stamp: 'di 3/28/1999 10:23'!elementsForwardIdentityTo: otherArray	"This primitive performs a bulk mutation, causing all pointers to the elements of this array to be replaced by pointers to the corresponding elements of otherArray.  The identityHashes remain with the pointers rather than with the objects so that the objects in this array should still be properly indexed in any existing hashed structures after the mutation."	<primitive: 72>	self primitiveFailed! !!Array methodsFor: 'printing' stamp: 'jm 5/29/2003 18:49'!isLiteral	self do: [:each | each isLiteral ifFalse: [^ false]].	^ true! !!Array methodsFor: 'printing' stamp: 'sma 6/1/2000 09:39'!printOn: aStream	aStream nextPut: $#.	self printElementsOn: aStream! !!Array methodsFor: 'private' stamp: 'sma 6/3/2000 21:39'!hasLiteral: literal	"Answer true if literal is identical to any literal in this array, even 	if imbedded in further array structure. This method is only intended 	for private use by CompiledMethod hasLiteralSymbol:"	| lit |	1 to: self size do: 		[:index | 		(lit _ self at: index) == literal ifTrue: [^ true].		(lit class == Array and: [lit hasLiteral: literal]) ifTrue: [^ true]].	^ false! !!Array class methodsFor: 'class initialization' stamp: 'jm 10/13/2002 17:31'!initialize	"This empty array object can be shared, since it is immutable:"	EmptyArray _ Array new.! !!Array class methodsFor: 'constants' stamp: 'jm 10/13/2002 17:32'!empty	^ EmptyArray! !!Array class methodsFor: 'brace support' stamp: 'di 11/18/1999 22:53'!braceStream: nElements	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	^ WriteStream basicNew braceArray: (self new: nElements)! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:16'!braceWith: a	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	| array |	array _ self new: 1.	array at: 1 put: a.	^ array! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:15'!braceWith: a with: b 	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	| array |	array _ self new: 2.	array at: 1 put: a.	array at: 2 put: b.	^ array! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:17'!braceWith: a with: b with: c 	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	| array |	array _ self new: 3.	array at: 1 put: a.	array at: 2 put: b.	array at: 3 put: c.	^ array! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:17'!braceWith: a with: b with: c with: d	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	| array |	array _ self new: 4.	array at: 1 put: a.	array at: 2 put: b.	array at: 3 put: c.	array at: 4 put: d.	^ array! !!Array class methodsFor: 'brace support' stamp: 'di 11/19/1999 08:16'!braceWithNone	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	^ self new: 0! !I am an abstract collection of elements with a fixed range of integers (from 1 to n>=1) as external keys.!!ArrayedCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:36'!size	"Answer how many elements the receiver contains."	<primitive: 62>	^ self basicSize! !!ArrayedCollection methodsFor: 'adding' stamp: 'sma 5/12/2000 14:09'!add: newObject	self shouldNotImplement! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 6/1/2000 11:57'!isSorted	"Return true if the receiver is sorted by the given criterion.	Optimization for isSortedBy: [:a :b | a <= b]."	| lastElm elm |	self isEmpty ifTrue: [^ true].	lastElm _ self first.	2 to: self size do: 		[:index | 		elm _ self at: index.		lastElm <= elm ifFalse: [^ false].		lastElm _ elm].	^ true! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 6/1/2000 11:58'!isSortedBy: aBlock	"Return true if the receiver is sorted by the given criterion."	| lastElm elm |	self isEmpty ifTrue: [^ true].	lastElm _ self first.	2 to: self size do: 		[:index | 		elm _ self at: index.		(aBlock value: lastElm value: elm) ifFalse: [^ false].		lastElm _ elm].	^ true! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:28'!mergeFirst: first middle: middle last: last into: dst by: aBlock	"Private. Merge the sorted ranges [first..middle] and [middle+1..last] 	of the receiver into the range [first..last] of dst."	| i1 i2 val1 val2 out |	i1 _ first.	i2 _ middle + 1.	val1 _ self at: i1.	val2 _ self at: i2.	out _ first - 1.  "will be pre-incremented"	"select 'lower' half of the elements based on comparator"	[(i1 <= middle) and: [i2 <= last]] whileTrue:		[(aBlock value: val1 value: val2)			ifTrue: [dst at: (out _ out + 1) put: val1.					val1 _ self at: (i1 _ i1 + 1)]			ifFalse: [dst at: (out _ out + 1) put: val2.					i2 _ i2 + 1.					i2 <= last ifTrue: [val2 _ self at: i2]]].	"copy the remaining elements"	i1 <= middle		ifTrue: [dst replaceFrom: out + 1 to: last with: self startingAt: i1]		ifFalse: [dst replaceFrom: out + 1 to: last with: self startingAt: i2]! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:25'!mergeSortFrom: startIndex to: stopIndex by: aBlock	"Sort the given range of indices using the mergesort algorithm.	Mergesort is a worst-case O(N log N) sorting algorithm that usually	does only half as many comparisons as heapsort or quicksort."	"Details: recursively split the range to be sorted into two halves,	mergesort each half, then merge the two halves together. An extra 	copy of the data is used as temporary storage and successive merge 	phases copy data back and forth between the receiver and this copy.	The recursion is set up so that the final merge is performed into the	receiver, resulting in the receiver being completely sorted."	self size <= 1 ifTrue: [^ self].  "nothing to do"	startIndex = stopIndex ifTrue: [^ self].	self assert: [startIndex >= 1 and: [startIndex < stopIndex]]. "bad start index"	self assert: [stopIndex <= self size]. "bad stop index"	self		mergeSortFrom: startIndex		to: stopIndex 		src: self clone 		dst: self 		by: aBlock! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:26'!mergeSortFrom: first to: last src: src dst: dst by: aBlock	"Private. Split the range to be sorted in half, sort each half, and 	merge the two half-ranges into dst."	| middle |	first = last ifTrue: [^ self].	middle _ (first + last) // 2.	self mergeSortFrom: first to: middle src: dst dst: src by: aBlock.	self mergeSortFrom: middle + 1 to: last src: dst dst: src by: aBlock.	src mergeFirst: first middle: middle last: last into: dst by: aBlock! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:22'!sort	"Sort this array into ascending order using the '<=' operator."	self sort: [:a :b | a <= b]! !!ArrayedCollection methodsFor: 'sorting' stamp: 'sma 5/12/2000 14:21'!sort: aSortBlock 	"Sort this array using aSortBlock. The block should take two arguments	and return true if the first element should preceed the second one."	self		mergeSortFrom: 1		to: self size		by: aSortBlock! !!ArrayedCollection class methodsFor: 'instance creation' stamp: 'sw 10/24/1998 22:22'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject	"Answer a new instance of me, containing only the 6 arguments as elements."	| newCollection |	newCollection _ self new: 6.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	newCollection at: 6 put: sixthObject.	^ newCollection! !!ArrayedCollection class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 17:37'!withAll: aCollection	"Create a new collection containing all the elements from aCollection."	^ (self new: aCollection size) replaceFrom: 1 to: aCollection size with: aCollection! !!AssignmentNode methodsFor: 'initialize-release' stamp: 'di 3/22/1999 12:00'!variable: aVariable value: expression from: encoder	(aVariable isMemberOf: MessageAsTempNode)		ifTrue: ["Case of remote temp vars"				^ aVariable store: expression from: encoder].	variable _ aVariable.	value _ expression! !I represent a pair of associated objects--a key and a value. My instances can serve as entries in a dictionary.!I represent a single atom (particle) in the BouncingAtomsMorph simulation.!!AtomMorph methodsFor: 'as yet unclassified' stamp: 'jm 8/10/1998 17:40'!bounceIn: aRect	"Move this atom one step along its velocity vector and make it bounce if it goes outside the given rectangle. Return true if it is bounced."	| p vx vy px py bounced |	p _ self position.	vx _ velocity x.		vy _ velocity y.	px _ p x + vx.		py _ p y + vy.	bounced _ false.	px > aRect right ifTrue: [		px _ aRect right - (px - aRect right).		vx _ velocity x negated.		bounced _ true].	py > aRect bottom ifTrue: [		py _  aRect bottom - (py - aRect bottom).		vy _ velocity y negated.		bounced _ true].	px < aRect left ifTrue: [		px _ aRect left - (px - aRect left).		vx _ velocity x negated.		bounced _ true].	py < aRect top ifTrue: [		py _  aRect top - (py - aRect top).		vy _ velocity y negated.		bounced _ true].	self position: px @ py.	bounced ifTrue: [self velocity: vx @ vy].	^ bounced! !!AtomMorph methodsFor: 'as yet unclassified'!drawOn: aCanvas	"Note: Set 'drawAsRect' to true to make the atoms draw faster. When testing the speed of other aspects of Morphic, such as its damage handling efficiency for large numbers of atoms, it is useful to make drawing faster."	| drawAsRect |	drawAsRect _ false.  "rectangles are faster to draw"	drawAsRect		ifTrue: [aCanvas fillRectangle: self bounds color: color]		ifFalse: [super drawOn: aCanvas].! !!AtomMorph methodsFor: 'as yet unclassified'!infected	^ color = Color red! !!AtomMorph methodsFor: 'as yet unclassified'!infected: aBoolean	aBoolean		ifTrue: [self color: Color red]		ifFalse: [self color: Color blue].! !!AtomMorph methodsFor: 'as yet unclassified'!initialize	"Make a new atom with a random position and velocity."	super initialize.	self extent: 8@7.	self color: Color blue.	self borderWidth: 0.	self randomPositionIn: (0@0 corner: 300@300) maxVelocity: 10.! !!AtomMorph methodsFor: 'as yet unclassified'!randomPositionIn: aRectangle maxVelocity: maxVelocity	"Give this atom a random position and velocity."	| origin extent |	origin _ aRectangle origin.	extent _ aRectangle extent - self bounds extent.	self position:		(origin x + extent x atRandom) @		(origin y + extent y atRandom).	velocity _		(maxVelocity - (2 * maxVelocity) atRandom) @		(maxVelocity - (2 * maxVelocity) atRandom).! !!AtomMorph methodsFor: 'as yet unclassified'!velocity	^ velocity! !!AtomMorph methodsFor: 'as yet unclassified'!velocity: newVelocity	velocity _ newVelocity.! !I represent an unordered collection of possibly duplicate elements.	I store these elements in a dictionary, tallying up occurrences of equal objects. Because I store an occurrence only once, my clients should beware that objects they store will not necessarily be retrieved such that == is true. If the client cares, a subclass of me should be created.!!Bag methodsFor: 'accessing' stamp: 'sma 5/12/2000 17:23'!at: index 	self errorNotKeyed! !!Bag methodsFor: 'accessing' stamp: 'sma 5/12/2000 17:23'!at: index put: anObject 	self errorNotKeyed! !!Bag methodsFor: 'accessing' stamp: 'tao 1/5/2000 18:25'!cumulativeCounts	"Answer with a collection of cumulative percents covered by elements so far."	| s n |	s _ self size / 100.0. n _ 0.	^ self sortedCounts asArray collect:		[:a | n _ n + a key. (n / s roundTo: 0.1) -> a value]! !!Bag methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:35'!size	"Answer how many elements the receiver contains."	| tally |	tally _ 0.	contents do: [:each | tally _ tally + each].	^ tally! !!Bag methodsFor: 'adding' stamp: 'sma 5/12/2000 17:18'!add: newObject 	"Include newObject as one of the receiver's elements. Answer newObject."	^ self add: newObject withOccurrences: 1! !!Bag methodsFor: 'adding' stamp: 'sma 5/12/2000 17:20'!add: newObject withOccurrences: anInteger 	"Add newObject anInteger times to the receiver. Answer newObject."	contents at: newObject put: (contents at: newObject ifAbsent: [0]) + anInteger.	^ newObject! !!Bag methodsFor: 'converting' stamp: 'sma 5/12/2000 14:34'!asBag	^ self! !!Bag methodsFor: 'converting' stamp: 'sma 5/12/2000 14:30'!asSet	"Answer a set with the elements of the receiver."	^ contents keys! !!Bag methodsFor: 'copying' stamp: 'sma 5/12/2000 14:53'!copy	^ self shallowCopy setContents: contents copy! !!Bag methodsFor: 'private' stamp: 'sma 5/12/2000 14:49'!setContents: aDictionary	contents _ aDictionary! !!Bag methodsFor: 'removing' stamp: 'sma 5/12/2000 14:32'!remove: oldObject ifAbsent: exceptionBlock 	"Refer to the comment in Collection|remove:ifAbsent:."	| count |	count _ contents at: oldObject ifAbsent: [^ exceptionBlock value].	count = 1		ifTrue: [contents removeKey: oldObject]		ifFalse: [contents at: oldObject put: count - 1].	^ oldObject! !!Bag class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 13:31'!new	^ self new: 4! !!Bag class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 14:49'!new: nElements	^ super new setContents: (Dictionary new: nElements)! !!Bag class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 17:17'!newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	^ self withAll: aCollection"Examples:	Bag newFrom: {1. 2. 3. 3}	{1. 2. 3. 3} as: Bag"! !A balloon with text used for the display of explanatory information.Balloon help is integrated into Morphic as follows:If a Morph has the property #balloonText, then it will respond to #showBalloon by adding a text balloon to the world, and to #deleteBalloon by removing the balloon.Moreover, if mouseOverEnabled is true (see class msg), then the Hand will arrange to cause display of the balloon after the mouse has lingered over the morph for a while, and removal of the balloon when the mouse leaves the bounds of that morph. In any case, the Hand will attempt to remove any such balloons before handling mouseDown events, or displaying other balloons.!!BalloonMorph methodsFor: 'initialization' stamp: 'sw 2/3/2000 00:16'!initialize	super initialize.	color _ Color paleYellow.	borderColor _ Color black.	borderWidth _ 1.	offsetFromTarget _ 0@0! !!BalloonMorph methodsFor: 'stepping' stamp: 'sma 12/23/1999 14:05'!step	"Move with target."	target ifNotNil: [self position: target position + offsetFromTarget].! !!BalloonMorph methodsFor: 'private' stamp: 'sw 2/7/2000 01:49'!adjustedCenter	"This horizontal adjustment is needed because we want the interior TextMorph to be centered within the visual balloon rather than simply within the BalloonMorph's bounding box.  Without this, balloon-help text would be a bit off-center"	^ self center + (offsetFromTarget x sign * (5 @ 0))! !!BalloonMorph methodsFor: 'private' stamp: 'sma 12/23/1999 14:06'!setTarget: aMorph	(target _ aMorph) ifNotNil: [offsetFromTarget _ self position - target position]! !!BalloonMorph class methodsFor: 'instance creation' stamp: 'sma 12/23/1999 20:05'!string: str for: morph	^ self string: str for: morph corner: #bottomLeft! !!BalloonMorph class methodsFor: 'instance creation' stamp: 'sma 12/23/1999 20:04'!string: str for: morph corner: cornerName	"Make up and return a balloon for morph.  Find the quadrant that	clips the text the least, using cornerName as a tie-breaker.  tk 9/12/97"	| tm vertices |	tm _ self getTextMorph: str.	vertices _ self getVertices: tm bounds.	vertices _ self getBestLocation: vertices for: morph corner: cornerName.	^ self new		color: morph balloonColor;		setVertices: vertices;		addMorph: tm;		setTarget: morph! !!BalloonMorph class methodsFor: 'private' stamp: 'sw 2/7/2000 12:10'!getBestLocation: vertices for: morph corner: cornerName	"Try four rel locations of the balloon for greatest unclipped area.   12/99 sma"	| rect maxArea verts rectCorner morphPoint mbc a mp dir bestVerts result usableArea |	rect _ vertices first rect: (vertices at: 5).	maxArea _ -1.	verts _ vertices.	usableArea _ morph world viewBox.	1 to: 4 do: [:i |		dir _ #(vertical horizontal) atWrap: i.		verts _ verts collect: [:p | p flipBy: dir centerAt: rect center].		rectCorner _ #(bottomLeft bottomRight topRight topLeft) at: i.		morphPoint _ #(topCenter topCenter bottomCenter bottomCenter) at: i.		a _ ((rect			align: (rect perform: rectCorner)			with: (mbc _ morph boundsInWorld perform: morphPoint))				intersect: usableArea) area.		(a > maxArea or: [a = rect area and: [rectCorner = cornerName]]) ifTrue:			[maxArea _ a.			bestVerts _ verts.			mp _ mbc]].	result _ bestVerts collect: [:p | p + (mp - bestVerts first)] "Inlined align:with:".	^ result! !!BalloonMorph class methodsFor: 'private' stamp: 'sw 2/2/2000 22:13'!getTextMorph: aStringOrMorph	"Construct text morph."	| m text |	aStringOrMorph isMorph		ifTrue: [m _ aStringOrMorph]		ifFalse:			[BalloonFont				ifNil: [text _ aStringOrMorph]				ifNotNil: [text _ Text					string: aStringOrMorph					attribute: (TextFontReference toFont: BalloonFont)].			m _ (TextMorph new contents: text) centered].	m setToAdhereToEdge: #adjustedCenter.	^ m! !!BalloonMorph class methodsFor: 'private' stamp: 'sma 12/23/1999 15:34'!getVertices: bounds	"Construct vertices for a balloon up and to left of anchor"	| corners |	corners _ bounds corners atAll: #(1 4 3 2).	^ (Array		with: corners first + (0 - bounds width // 3 @ 0)		with: corners first + (0 - bounds width // 6 @ (bounds height // 2))) , corners! !!BalloonMorph class methodsFor: 'utility' stamp: 'sw 1/31/2000 15:43'!balloonFont	^ BalloonFont! !!BalloonMorph class methodsFor: 'utility' stamp: 'sw 1/31/2000 15:39'!chooseBalloonFont	"BalloonMorph chooseBalloonFont"	Preferences chooseFontWithPrompt:  'Select the font to beused for balloon help'		andSendTo: self withSelector: #setBalloonFontTo:! !!BalloonMorph class methodsFor: 'utility' stamp: 'sw 1/31/2000 15:40'!setBalloonFontTo: aFont	aFont ifNotNil: [BalloonFont _ aFont]! !!BeatBox methodsFor: 'initialization' stamp: 'jm 9/27/2003 13:16'!addButtons	"Add buttons to choose a port and to start or stop the GoGo Board."	| y b |	y _ 200.	b _ SimpleButtonMorph new target: self; borderColor: Color black.	self addMorph: (b fullCopy		label: 'Start'; actionSelector: #startPlaying;		position: self position + (10@y)).	self addMorph: (b fullCopy		label: 'Stop'; actionSelector: #stopPlaying;		position: self position + (50@y)).! !!BeatBox methodsFor: 'initialization' stamp: 'jm 8/28/2003 21:38'!addLights	| light m |	lights _ OrderedCollection new.	light _ EllipseMorph new extent: 16@16; color: (Color r: 0.2 g: 0 b: 0).	0 to: 15 do: [:i |		m _ light copy position: (10 + (i * 20))@10.		lights addLast: m.		self addMorph: m].! !!BeatBox methodsFor: 'initialization' stamp: 'jm 9/27/2003 13:10'!addTrack: snd	| trackM button y |	trackM _ Morph new color: self color; extent: 330@20.	button _ ToggleButton new extent: 16@16.	0 to: 15 do: [:i |		trackM addMorphBack: (button copy position: (10 + (i * 20) - borderWidth)@2)].	tracks size = 0 ifTrue: [y _ 30] ifFalse: [y _ tracks last bottom].	trackM position: (self left + borderWidth)@y.	self addMorphBack: trackM.	tracks addLast: trackM.	trackSounds addLast: snd.! !!BeatBox methodsFor: 'initialization' stamp: 'jm 9/20/2003 11:21'!currentMSecs	| now |	now _ Time millisecondClockValue.	now < startTime ifTrue: [startTime _ Time millisecondClockValue].  "clock wrap"	^ now - startTime! !!BeatBox methodsFor: 'initialization' stamp: 'jm 12/8/2003 07:20'!initialize	super initialize.	self extent: 336@300.	self color: Color lightGray.	tracks _ OrderedCollection new.	trackSounds _ OrderedCollection new.	msecsPerSixteeth _ 100.	isPlaying _ false.	self addLights.	self addButtons.	self addTrack: (SampledSound fromFileNamed: 'kick2.wav').	self addTrack: (SampledSound fromFileNamed: 'snare2.wav').! !!BeatBox methodsFor: 'initialization' stamp: 'jm 9/27/2003 13:58'!makeScore	| ch allTracks t notes |	ch _ 0.	allTracks _ tracks collect: [:thisTrack |		ch _ ch + 1. t _ 0.		notes _ OrderedCollection new.		thisTrack submorphs do: [:m |			m isOn ifTrue: [				notes addLast:					((NoteEvent new key: 60 velocity: 127 channel: ch) time: t; duration: 50)].			t _ t + 25].		notes asArray].	scorePlayer _ ScorePlayer onScore: (MIDIScore new tracks: allTracks asArray).	1 to: trackSounds size do: [:i |		scorePlayer instrumentForTrack: i put: (trackSounds at: i)].	scorePlayer repeat: true.! !!BeatBox methodsFor: 'initialization' stamp: 'jm 9/27/2003 13:50'!startPlaying	self stopPlaying.	self makeScore.	scorePlayer play.	startTime _ Time millisecondClockValue.	lastBeat _ 1.	isPlaying _ true.	self startStepping.! !!BeatBox methodsFor: 'initialization' stamp: 'jm 9/27/2003 12:43'!step	| beat |	isPlaying ifFalse: [^ self].	beat _ ((self currentMSecs // msecsPerSixteeth) \\ 16) + 1.	beat = lastBeat ifFalse: [		(lights at: lastBeat) color: (Color r: 0.3 g: 0 b: 0).		(lights at: beat) color: (Color r: 0.8 g: 0 b: 0).		lastBeat _ beat].! !!BeatBox methodsFor: 'initialization' stamp: 'jm 8/28/2003 21:18'!stepTime	^ 0! !!BeatBox methodsFor: 'initialization' stamp: 'jm 9/27/2003 13:59'!stopPlaying	(scorePlayer isKindOf: ScorePlayer) ifTrue: [scorePlayer pause].	scorePlayer _ nil.	isPlaying _ false.	lights do: [:m | m color: (Color r: 0.2 g: 0 b: 0)].! !My instances describe the behavior of other objects. I provide the minimum state necessary for compiling methods, and creating and running instances. Most objects are created as instances of the more fully supported subclass, Class, but I am a good starting point for providing instance-specific behavior (as in Metaclass).!!Behavior methodsFor: 'initialize-release' stamp: 'ar 7/19/1999 23:00'!forgetDoIts	"get rid of old DoIt methods"	self 		removeSelectorSimply: #DoIt;		removeSelectorSimply: #DoItIn:! !!Behavior methodsFor: 'initialize-release' stamp: 'di 3/10/2000 08:40'!nonObsoleteClass	"Attempt to find and return the current version of this obsolete class"	| obsName |	obsName _ self name.	[obsName beginsWith: 'AnObsolete']		whileTrue: [obsName _ obsName copyFrom: 'AnObsolete' size + 1 to: obsName size].	^ Smalltalk at: obsName asSymbol! !!Behavior methodsFor: 'initialize-release' stamp: 'ar 9/10/1999 17:33'!obsolete	"Invalidate and recycle local messages,	e.g., zap the method dictionary if can be done safely."	self canZapMethodDictionary		ifTrue:[ methodDict _ MethodDictionary new ].! !!Behavior methodsFor: 'initialize-release' stamp: 'ar 7/15/1999 16:39'!superclass: aClass methodDictionary: mDict format: fmt	"Basic initialization of the receiver.	Must only be sent to a new instance; else we would need Object flushCache."	superclass _ aClass.	format _ fmt.	methodDict _ mDict.! !!Behavior methodsFor: 'accessing' stamp: 'sw 3/10/2000 16:55'!confirmRemovalOf: aSelector	"Determine if it is okay to remove the given selector.  Answer 1 if it should be removed, 2 if it should be removed followed by a senders browse, and 3 if it should not be removed."	| count aMenu answer caption allCalls |	allCalls _ Smalltalk allCallsOn: aSelector.	(count _ allCalls size) == 0 ifTrue: [^ 1].  "no senders -- let the removal happen without warning"	count == 1 ifTrue:		[MessageSet parse: allCalls first toClassAndSelector:			[:aClass :aSel |				(aClass == self and: [aSel == aSelector]) ifTrue: [^ 1]]].   "only sender is itself"	aMenu _ PopUpMenu labels: 'Remove itRemove, then browse sendersDon''t remove, but show me those sendersForget it -- do nothing -- sorry I asked'.	caption _ 'This message has ', count printString, ' sender'.	count > 1 ifTrue:		[caption _ caption copyWith: $s].	answer _ aMenu startUpWithCaption: caption.	answer == 3 ifTrue:		[Smalltalk browseMessageList: allCalls			name: 'Senders of ', aSelector			autoSelect: aSelector keywords first].	answer == 0 ifTrue: [answer _ 3].  "If user didn't answer, treat it as cancel"	^ answer min: 3! !!Behavior methodsFor: 'accessing' stamp: 'ar 7/11/1999 05:17'!environment	"Return the environment in which the receiver is visible"	^Smalltalk! !!Behavior methodsFor: 'accessing' stamp: 'di 3/27/1999 23:19'!methodDict	methodDict == nil ifTrue: [self recoverFromMDFault].	^ methodDict! !!Behavior methodsFor: 'accessing' stamp: 'ar 7/12/1999 11:10'!name	"Answer a String that is the name of the receiver."	^'a sublcass of ', superclass name! !!Behavior methodsFor: 'accessing' stamp: 'ar 7/13/1999 22:00'!typeOfClass	"Answer a symbol uniquely describing the type of the receiver"	self instSpec = CompiledMethod instSpec ifTrue:[^#compiledMethod]. "Very special!!"	self isBytes ifTrue:[^#bytes].	(self isWords and:[self isPointers not]) ifTrue:[^#words].	self isWeak ifTrue:[^#weak].	self isVariable ifTrue:[^#variable].	^#normal.! !!Behavior methodsFor: 'testing' stamp: 'ar 7/15/1999 14:03'!autoMutateInstances	"Return true if the receiver should automatically mutate its instances to a new class layout on recompilation."	^true! !!Behavior methodsFor: 'testing' stamp: 'ar 9/10/1999 17:29'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	^true! !!Behavior methodsFor: 'testing' stamp: 'ar 7/9/1999 18:18'!isBehavior	"Return true if the receiver is a behavior"	^true! !!Behavior methodsFor: 'testing' stamp: 'ar 7/14/1999 02:38'!isObsolete	"Return true if the receiver is obsolete."	^self instanceCount = 0! !!Behavior methodsFor: 'testing' stamp: 'ar 3/21/98 02:36'!isWeak	"Answer whether the receiver has contains weak references."	^ self instSpec = 4! !!Behavior methodsFor: 'testing' stamp: 'ar 7/11/1999 05:36'!shouldNotBeRedefined	"Return true if the receiver should not be redefined.	The assumption is that compact classes,	classes in Smalltalk specialObjects and 	Behaviors should not be redefined"	^(Smalltalk compactClassesArray includes: self)		or:[(Smalltalk specialObjectsArray includes: self)			or:[self isKindOf: self]]! !!Behavior methodsFor: 'copying' stamp: 'di 2/17/2000 22:37'!copy	"Answer a copy of the receiver without a list of subclasses."	| myCopy |	myCopy _ self shallowCopy.	^myCopy methodDictionary: self methodDict copy! !!Behavior methodsFor: 'copying' stamp: 'di 2/17/2000 22:37'!copyOfMethodDictionary	"Return a copy of the receiver's method dictionary"	^ self methodDict copy! !!Behavior methodsFor: 'copying' stamp: 'tk 4/16/1999 17:30'!deepCopy	"Classes should only be shallowCopied or made anew."^ self shallowCopy! !!Behavior methodsFor: 'creating class hierarchy' stamp: 'ar 7/10/1999 12:10'!superclass: aClass 	"Change the receiver's superclass to be aClass."	"Note: Do not use 'aClass isKindOf: Behavior' here		in case we recompile from Behavior itself."	(aClass == nil or: [aClass isBehavior])		ifTrue: [superclass _ aClass.				Object flushCache]		ifFalse: [self error: 'superclass must be a class-describing object']! !!Behavior methodsFor: 'creating method dictionary' stamp: 'di 2/17/2000 22:41'!addSelector: selector withMethod: compiledMethod 	"Add the message selector with the corresponding compiled method to the 	receiver's method dictionary."	| oldMethod |	oldMethod _ self lookupSelector: selector.	self methodDict at: selector put: compiledMethod.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod == nil ifFalse: [oldMethod flushCache].	selector flushCache! !!Behavior methodsFor: 'creating method dictionary' stamp: 'jm 10/7/2002 05:49'!compileAllFrom: oldClass	"Compile all the methods in the receiver's method dictionary. This validates sourceCode and variable references and forces all methods to use the current bytecode set."	"ar 7/10/1999: Use oldClass selectors not self selectors"	oldClass selectorsDo: [:sel | self recompile: sel from: oldClass].! !!Behavior methodsFor: 'creating method dictionary' stamp: 'di 2/17/2000 22:37'!compress	"Compact the method dictionary of the receiver."	self methodDict rehash! !!Behavior methodsFor: 'creating method dictionary' stamp: 'ar 7/11/1999 05:11'!methodDictionary	"Convenience"	^self methodDict! !!Behavior methodsFor: 'creating method dictionary' stamp: 'ar 7/12/1999 07:45'!methodDictionary: aDictionary 	"Store the argument, aDictionary, as the method dictionary of the 	receiver."	methodDict _ aDictionary.! !!Behavior methodsFor: 'creating method dictionary' stamp: 'di 5/24/2000 16:05'!recompile: selector from: oldClass	"Compile the method associated with selector in the receiver's method dictionary."	"ar 7/10/1999: Use oldClass compiledMethodAt: not self compiledMethodAt:"	| method trailer methodNode |	method _ oldClass compiledMethodAt: selector.	trailer _ (method endPC + 1 to: method size) collect: [:i | method at: i].	methodNode _ self compilerClass new				compile: (oldClass sourceCodeAt: selector)				in: self				notifying: nil				ifFail: [^ self].   "Assume OK after proceed from SyntaxError"	selector == methodNode selector ifFalse: [self error: 'selector changed!!'].	self addSelector: selector withMethod: (methodNode generate: trailer).! !!Behavior methodsFor: 'creating method dictionary' stamp: 'di 1/2/1999 15:16'!removeSelector: selector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	^ self removeSelectorSimply: selector! !!Behavior methodsFor: 'instance creation' stamp: 'di 8/18/2000 22:10'!basicNew: sizeRequested 	"Primitive. Answer an instance of this class with the number	of indexable variables specified by the argument, sizeRequested.	Fail if this class is not indexable or if the argument is not a	positive Integer, or if there is not enough memory available. 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 71>	self isVariable ifFalse:		[self error: self printString, ' cannot have variable sized instances'].	(sizeRequested isInteger and: [sizeRequested >= 0]) ifTrue:		["arg okay; space must be low."		Smalltalk signalLowSpace.		^ self basicNew: sizeRequested  "retry if user proceeds"].	self primitiveFailed! !!Behavior methodsFor: 'instance creation' stamp: 'di 8/18/2000 20:27'!new	"Answer a new instance of the receiver (which is a class) with no indexable variables. Fail if the class is indexable."	<primitive: 70>  "This method runs primitively if successful"	^ self basicNew  "Exceptional conditions will be handled in basicNew"! !!Behavior methodsFor: 'instance creation' stamp: 'di 8/18/2000 20:32'!new: sizeRequested 	"Answer an instance of this class with the number of indexable	variables specified by the argument, sizeRequested."	<primitive: 71>  "This method runs primitively if successful"	^ self basicNew: sizeRequested  "Exceptional conditions will be handled in basicNew:"! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'bf 9/27/1999 17:23'!>> selector 	"Answer the compiled method associated with the argument, selector (a 	Symbol), a message selector in the receiver's method dictionary. If the 	selector is not in the dictionary, create an error notification."	^self compiledMethodAt: selector ! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'sw 10/19/1999 15:12'!changeRecordsAt: selector	"Return a list of ChangeRecords for all versions of the method at selector. Source code can be retrieved by sending string to any one.  Return nil if the method is absent."	"(Pen changeRecordsAt: #go:) collect: [:cRec | cRec string]"	| aList |	aList _ VersionsBrowser new			scanVersionsOf: (self compiledMethodAt: selector ifAbsent: [^ nil])			class: self meta: self isMeta			category: (self whichCategoryIncludesSelector: selector)			selector: selector.	^ aList ifNotNil: [aList changeList]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:37'!compiledMethodAt: selector 	"Answer the compiled method associated with the argument, selector (a 	Symbol), a message selector in the receiver's method dictionary. If the 	selector is not in the dictionary, create an error notification."	^ self methodDict at: selector! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:41'!compiledMethodAt: selector ifAbsent: aBlock	"Answer the compiled method associated with the argument, selector (a Symbol), a message selector in the receiver's method dictionary. If the selector is not in the dictionary, return the value of aBlock"	^ self methodDict at: selector ifAbsent: [aBlock value]! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'tk 4/26/1999 07:28'!formalParametersAt: aSelector	"Return the names of the arguments used in this method."	| source parser message list params |	source _ self sourceCodeAt: aSelector ifAbsent: [^ #()].	"for now"	(parser _ self parserClass new) parseSelector: source.	message _ source copyFrom: 1 to: (parser endOfLastToken min: source size).	list _ message string findTokens: Character separators.	params _ OrderedCollection new.	list withIndexDo: [:token :ind | ind even ifTrue: [params addLast: token]].	^ params! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 1/2/1999 15:45'!lookupSelector: selector	"Look up the given selector in my methodDictionary.	Return the corresponding method if found.	Otherwise chase the superclass chain and try again.	Return nil if no method is found."	| lookupClass |	lookupClass _ self.	[lookupClass == nil]		whileFalse: 			[(lookupClass includesSelector: selector)				ifTrue: [^ lookupClass compiledMethodAt: selector].			lookupClass _ lookupClass superclass].	^ nil! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:41'!methodsDo: aBlock	"Evaluate aBlock for all the compiled methods in my method dictionary."	^ self methodDict valuesDo: aBlock! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 3/27/1999 23:21'!selectorAtMethod: method setClass: classResultBlock 	"Answer both the message selector associated with the compiled method 	and the class in which that selector is defined."	| sel |	sel _ self methodDict keyAtIdentityValue: method				ifAbsent: 					[superclass == nil						ifTrue: 							[classResultBlock value: self.							^self defaultSelectorForMethod: method].					sel _ superclass selectorAtMethod: method setClass: classResultBlock.					"Set class to be self, rather than that returned from 					superclass. "					sel == (self defaultSelectorForMethod: method) ifTrue: [classResultBlock value: self].					^sel].	classResultBlock value: self.	^sel! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:38'!selectors	"Answer a Set of all the message selectors specified in the receiver's 	method dictionary."	^ self methodDict keys  	"Point selectors."! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:41'!selectorsAndMethodsDo: aBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysAndValuesDo: aBlock! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:38'!selectorsDo: selectorBlock	"Evaluate selectorBlock for all the message selectors in my method dictionary."	^ self methodDict keysDo: selectorBlock! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:40'!sourceCodeAt: selector	^ (self methodDict at: selector) getSourceFor: selector in: self! !!Behavior methodsFor: 'accessing method dictionary' stamp: 'di 2/17/2000 22:40'!sourceCodeAt: selector ifAbsent: aBlock	^ (self methodDict at: selector ifAbsent: [^ aBlock value]) getSourceFor: selector in: self! !!Behavior methodsFor: 'testing class hierarchy' stamp: 'ar 3/12/98 12:36'!includesBehavior: aClass	^self == aClass or:[self inheritsFrom: aClass]! !!Behavior methodsFor: 'testing class hierarchy' stamp: 'ar 3/21/98 02:36'!kindOfSubclass 	"Answer a String that is the keyword that describes the receiver's kind of 	subclass, either a regular subclass, a variableSubclass, a 	variableByteSubclass, a variableWordSubclass, or a weakSubclass"	self isWeak ifTrue:[^' weakSubclass: '].	self isVariable		ifTrue: [self isBits					ifTrue: [self isBytes								ifTrue: [^' variableByteSubclass: ']								ifFalse: [^' variableWordSubclass: ']]					ifFalse: [^' variableSubclass: ']]		ifFalse: [^' subclass: ']! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 2/17/2000 22:40'!hasMethods	"Answer whether the receiver has any methods in its method dictionary."	^ self methodDict size > 0! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 3/27/1999 23:20'!includesSelector: aSymbol 	"Answer whether the message whose selector is the argument is in the 	method dictionary of the receiver's class."	^ self methodDict includesKey: aSymbol! !!Behavior methodsFor: 'testing method dictionary' stamp: 'sma 6/3/2000 22:03'!thoroughWhichSelectorsReferTo: literal special: specialFlag byte: specialByte	"Answer a set of selectors whose methods access the argument as a 	literal. Dives into the compact literal notation, making it slow but 	thorough "	| who |	who _ Set new.	self selectorsAndMethodsDo:		[:sel :method |		((method hasLiteralThorough: literal) or: [specialFlag and: [method scanFor: specialByte]])			ifTrue:				[((literal isMemberOf: Association) not					or: [method sendsToSuper not					or: [method literals allButLast includes: literal]])						ifTrue: [who add: sel]]].	^ who! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 2/17/2000 22:39'!whichClassIncludesSelector: aSymbol 	"Answer the class on the receiver's superclass chain where the argument, 	aSymbol (a message selector), will be found. Answer nil if none found."	(self methodDict includesKey: aSymbol) ifTrue: [^ self].	superclass == nil ifTrue: [^ nil].	^ superclass whichClassIncludesSelector: aSymbol	"Rectangle whichClassIncludesSelector: #inspect."! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 2/17/2000 22:40'!whichSelectorsAccess: instVarName 	"Answer a Set of selectors whose methods access the argument, 	instVarName, as a named instance variable."	| instVarIndex |	instVarIndex _ self allInstVarNames indexOf: instVarName ifAbsent: [^Set new].	^ self methodDict keys select: 		[:sel | 		((self methodDict at: sel)			readsField: instVarIndex)			or: [(self methodDict at: sel) writesField: instVarIndex]]	"Point whichSelectorsAccess: 'x'."! !!Behavior methodsFor: 'testing method dictionary' stamp: 'ls 10/10/199913:22'!whichSelectorsReferTo: literal 	"Answer a Set of selectors whose methods access the argument as aliteral."	| special byte |	special _ Smalltalk hasSpecialSelector: literal ifTrueSetByte: [:b |byte _ b].	^self whichSelectorsReferTo: literal special: special byte: byte	"Rectangle whichSelectorsReferTo: #+."! !!Behavior methodsFor: 'testing method dictionary' stamp: 'sma 6/3/2000 22:01'!whichSelectorsReferTo: literal special: specialFlag byte: specialByte	"Answer a set of selectors whose methods access the argument as a literal."	| who |	who _ Set new.	self selectorsAndMethodsDo: 		[:sel :method |		((method hasLiteral: literal) or: [specialFlag and: [method scanFor: specialByte]])			ifTrue:				[((literal isMemberOf: Association) not					or: [method sendsToSuper not					or: [method literals allButLast includes: literal]])						ifTrue: [who add: sel]]].	^ who! !!Behavior methodsFor: 'testing method dictionary' stamp: 'di 2/17/2000 22:39'!whichSelectorsStoreInto: instVarName 	"Answer a Set of selectors whose methods access the argument, 	instVarName, as a named instance variable."	| instVarIndex |	instVarIndex _ self allInstVarNames indexOf: instVarName ifAbsent: [^Set new].	^ self methodDict keys select: 		[:sel | (self methodDict at: sel) writesField: instVarIndex]	"Point whichSelectorsStoreInto: 'x'."! !!Behavior methodsFor: 'enumerating' stamp: 'jm 5/18/2003 14:56'!allSubclassesDo: aBlock 	"Evaluate the given Block for each of my subclasses."	self subclassesDo: [:cl | 		aBlock value: cl.		cl allSubclassesDo: aBlock].! !!Behavior methodsFor: 'enumerating' stamp: 'jm 5/18/2003 14:57'!withAllSubclassesDo: aBlock 	"Evaluate the the given Block for me and each of my subclasses."	aBlock value: self.	self allSubclassesDo: aBlock.! !!Behavior methodsFor: 'enumerating' stamp: 'ar 7/11/1999 04:21'!withAllSuperclassesDo: aBlock 	"Evaluate the argument, aBlock, for each of the receiver's superclasses."	aBlock value: self.	superclass == nil		ifFalse: [superclass withAllSuperclassesDo: aBlock]! !!Behavior methodsFor: 'user interface' stamp: 'ls 10/10/1999 13:22'!allCallsOn: aSymbol	"Answer a SortedCollection of all the methods that call on aSymbol."	| aSortedCollection special byte |	aSortedCollection _ SortedCollection new.	special _ Smalltalk hasSpecialSelector: aSymbol ifTrueSetByte: [:b |byte _ b ].	self withAllSubclassesDo:		[:class | (class whichSelectorsReferTo: aSymbol special: special byte:byte) do:			[:sel | sel ~~ #DoIt ifTrue: [aSortedCollection add: class name , ' ', sel]]].	^aSortedCollection! !!Behavior methodsFor: 'user interface' stamp: 'sw 4/4/2000 11:22'!allUnreferencedInstanceVariables	"Return a list of the instance variables known to the receiver which are not referenced in the receiver or any of its subclasses OR superclasses"	| any definingClass |	^ self allInstVarNames copy reject:		[:ivn | any _ false.		definingClass _ self classThatDefinesInstanceVariable: ivn.		definingClass withAllSubclasses do:			[:class |  any ifFalse:				[(class whichSelectorsAccess: ivn asSymbol) do: 					[:sel | sel ~~ #DoIt ifTrue: [any _ true]]]].			any]! !!Behavior methodsFor: 'private' stamp: 'tk 12/29/1999 22:04'!becomeCompact	"Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Squeak, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."	| cct index |	self isWeak ifTrue:[^ self halt: 'You must not make a weak class compact'].	cct _ Smalltalk compactClassesArray.	(self indexIfCompact > 0 or: [cct includes: self])		ifTrue: [^ self halt: self name , 'is already compact'].	index _ cct indexOf: nil		ifAbsent: [^ self halt: 'compact class table is full'].	"Install this class in the compact class table"	cct at: index put: self.	"Update instspec so future instances will be compact"	format _ format + (index bitShift: 11).	"Make up new instances and become old ones into them"	self updateInstancesFrom: self.	"Purge any old instances"	Smalltalk garbageCollect.! !!Behavior methodsFor: 'private' stamp: 'tk 1/10/2000 14:50'!becomeCompactSimplyAt: index	"Make me compact, but don't update the instances.  For importing segments.""Here are the restrictions on compact classes in order for export segments to work:  A compact class index may not be reused.  If a class was compact in a release of Squeak, no other class may use that index.  The class might not be compact later, and there should be nil in its place in the array."	| cct |	self isWeak ifTrue:[^ self halt: 'You must not make a weak class compact'].	cct _ Smalltalk compactClassesArray.	(self indexIfCompact > 0 or: [cct includes: self])		ifTrue: [^ self halt: self name , 'is already compact'].	(cct at: index) ifNotNil: [^ self halt: 'compact table slot already in use'].	"Install this class in the compact class table"	cct at: index put: self.	"Update instspec so future instances will be compact"	format _ format + (index bitShift: 11).	"Caller must convert the instances"! !!Behavior methodsFor: 'private' stamp: 'di 2/17/2000 22:38'!removeSelectorSimply: selector 	"Assuming that the argument, selector (a Symbol), is a message selector 	in my method dictionary, remove it and its method."	| oldMethod |	oldMethod _ self methodDict at: selector ifAbsent: [^ self].	self methodDict removeKey: selector.	"Now flush Squeak's method cache, either by selector or by method"	oldMethod flushCache.	selector flushCache.! !!Behavior class methodsFor: 'testing' stamp: 'ar 9/10/1999 17:28'!canZapMethodDictionary	"Return false since zapping the method dictionary of Behavior class or its subclasses will cause the system to fail."	^false! !I represent a block transfer (BLT) of pixels into a rectangle (destX, destY, width, height) of the destinationForm.  The source of pixels may be a similar rectangle (at sourceX, sourceY) in the sourceForm, or a constant color, currently called halftoneForm.  If both are specified, their pixel values are combined with a logical AND function prior to transfer.  In any case, the pixels from the source are combined with those of the destination by as specified by the combinationRule.The combination rule whose value is 0 through 15 programs the transfer to produce 1 or 0 according to its 4-bit representation as follows:	8:	if source is 0 and destination is 0	4:	if source is 0 and destination is 1	2:	if source is 1 and destination is 0	1:	if source is 1 and destination is 1.At each pixel the corresponding bits of the source and destination pixel values determine one of these conditions;  if the combination rule has a 1 in the corresponding bit position, then the new destination value will be 1, otherwise it will be zero.  Forms may be of different depths, see the comment in class Form.In addition to the original 16 combination rules, this BitBlt supports	16	fails (to simulate paint bits)	17	fails (to simulate erase bits)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord.  Sum of color components	21	rgbSub: sourceWord with: destinationWord.  Difference of color components	22	OLDrgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	23	OLDtallyIntoMap: destinationWord.  Tallies pixValues into a colorMap			these old versions don't do bitwise dest clipping.  Use 32 and 33 now.	24	alphaBlend: sourceWord with: destinationWord.  32-bit source and dest only	25	pixPaint: sourceWord with: destinationWord.  Wherever the sourceForm is non-zero, it replaces the destination.  Can be used with a 1-bit source color mapped to (0, FFFFFFFF), and a fillColor to fill the dest with that color wherever the source is 1.	26	pixMask: sourceWord with: destinationWord.  Like pixPaint, but fills with 0.	27	rgbMax: sourceWord with: destinationWord.  Max of each color component.	28	rgbMin: sourceWord with: destinationWord.  Min of each color component.	29	rgbMin: sourceWord bitInvert32 with: destinationWord.  Min with (max-source)	30	alphaBlendConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	31	alphaPaintConst: sourceWord with: destinationWord.  alpha is an arg. works in 16 bits.	32	rgbDiff: sourceWord with: destinationWord.  Sum of abs of differences in components	33	tallyIntoMap: destinationWord.  Tallies pixValues into a colorMap	34	alphaBlendScaled: srcWord with: dstWord. Alpha blend of scaled srcWord and destWord.The color specified by halftoneForm may be either a Color or a Pattern.   A Color is converted to a pixelValue for the depth of the destinationForm.  If a Pattern, BitBlt will simply interpret its bitmap as an array of Color pixelValues.  BitBlt aligns the first element of this array with the top scanline of the destinationForm, the second with the second, and so on, cycling through the color array as necessary.  Within each scan line the 32-bit value is repeated from left to right across the form.  If the value repeats on pixels boudaries, the effect will be a constant color;  if not, it will produce a halftone that repeats on 32-bit boundaries.Any transfer specified is further clipped by the specified rectangle (clipX, clipY, clipWidth, clipHeight), and also by the bounds of the source and destination forms.	To make a small Form repeat and fill a big form, use an InfiniteForm as the source.	To write on a form and leave with both transparent and opapue areas, use a MaskedForm as the source.Pixels from a source to a destination whose pixels have a different depth are converted based on the optional colorMap.  If colorMap is nil, then conversion to more bits is done by filling the new high-order bits with zero, and conversion to fewer bits is done by truncating the lost high-order bits.  The colorMap, if specified, must be a word array (ie Bitmap) with 2^n elements, where n is the pixel depth of the source.  For every source pixel, BitBlt will then index this array, and select the corresponding pixelValue and mask it to the destination pixel size before storing.	When blitting from a 32 or 16 bit deep Form to one 8 bits or less, the default is truncation.  This will produce very strange colors, since truncation of the high bits does not produce the nearest encoded color.  Supply a 512 long colorMap, and red, green, and blue will be shifted down to 3 bits each, and mapped.  The message copybits...stdColors will use the best map to the standard colors for destinations of depths 8, 4, 2 and 1.  Two other sized of colorMaps are allowed, 4096 (4 bits per color) and 32786 (five bits per color).	Normal blits between 16 and 32 bit forms truncates or pads the colors automatically to provide the best preservation of colors.	Colors can be remapped at the same depth.  Sometimes a Form is in terms of colors that are not the standard colors for this depth, for example in a GIF file.  Convert the Form to a MaskedForm and send colorMap: the list of colors that the picture is in terms of.  MaskedForm will use the colorMap when copying to the display or another Form. (Note also that a Form can be copied to itself, and transformed in the process, if a non-nil colorMap is supplied.)!!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!clipHeight	^clipHeight! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!clipWidth	^clipWidth! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!clipX	^clipX! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:58'!clipY	^clipY! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/25/2000 19:43'!colorMap: map	"See last part of BitBlt comment. 6/18/96 tk"	(map notNil and:[map isColormap])		ifTrue:[colorMap _ map colors]		ifFalse:[colorMap _ map]! !!BitBlt methodsFor: 'accessing' stamp: 'jm 12/2/2003 15:31'!halftone: aColorOrPattern 	"The destForm will be filled with this color or pattern of colors.  May be an old Color, a new type Color, a Bitmap (see BitBlt comment), a Pattern, or a Form.  6/18/96 tk"	halftoneForm _ aColorOrPattern.! !!BitBlt methodsFor: 'accessing' stamp: 'ar 5/25/2000 19:39'!tallyMap: aBitmap	"Install the map used for tallying pixels"	colorMap _ aBitmap! !!BitBlt methodsFor: 'copying' stamp: 'di 12/26/1998 15:04'!copy: destRectangle from: sourcePt in: srcForm fillColor: hf rule: rule	"Specify a Color to fill, not a Form. 6/18/96 tk"  	| destOrigin |	sourceForm _ srcForm.	self fillColor: hf.	"sets halftoneForm"	combinationRule _ rule.	destOrigin _ destRectangle origin.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourcePt x.	sourceY _ sourcePt y.	width _ destRectangle width.	height _ destRectangle height.	srcForm == nil ifFalse:		[colorMap _ srcForm colormapIfNeededForDepth: destForm depth].	^ self copyBits! !!BitBlt methodsFor: 'copying' stamp: 'di 12/31/1998 14:38'!copyBits	"Primitive. Perform the movement of bits from the source form to the 	destination form. Fail if any variables are not of the right type (Integer, 	Float, or Form) or if the combination rule is not implemented. 	In addition to the original 16 combination rules, this BitBlt supports	16	fail (to simulate paint)	17	fail (to simulate mask)	18	sourceWord + destinationWord	19	sourceWord - destinationWord	20	rgbAdd: sourceWord with: destinationWord	21	rgbSub: sourceWord with: destinationWord	22	rgbDiff: sourceWord with: destinationWord	23	tallyIntoMap: destinationWord	24	alphaBlend: sourceWord with: destinationWord	25	pixPaint: sourceWord with: destinationWord	26	pixMask: sourceWord with: destinationWord	27	rgbMax: sourceWord with: destinationWord	28	rgbMin: sourceWord with: destinationWord	29	rgbMin: sourceWord bitInvert32 with: destinationWord"	<primitive: 96>	"Check for compressed source, destination or halftone forms"	(combinationRule >= 30 and: [combinationRule <= 31]) ifTrue:		["No alpha specified -- re-run with alpha = 1.0"		^ self copyBitsTranslucent: 255].	((sourceForm isKindOf: Form) and: [sourceForm unhibernate])		ifTrue: [^ self copyBits].	((destForm isKindOf: Form) and: [destForm unhibernate])		ifTrue: [^ self copyBits].	((halftoneForm isKindOf: Form) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBits].	"Check for unimplmented rules"	combinationRule = Form oldPaint ifTrue: [^ self paintBits].	combinationRule = Form oldErase1bitShape ifTrue: [^ self eraseBits].	self error: 'Bad BitBlt arg (Fraction?); proceed to convert.'.	"Convert all numeric parameters to integers and try again."	destX _ destX asInteger.	destY _ destY asInteger.	width _ width asInteger.	height _ height asInteger.	sourceX _ sourceX asInteger.	sourceY _ sourceY asInteger.	clipX _ clipX asInteger.	clipY _ clipY asInteger.	clipWidth _ clipWidth asInteger.	clipHeight _ clipHeight asInteger.	^ self copyBitsAgain! !!BitBlt methodsFor: 'copying' stamp: 'di 1/4/1999 01:14'!copyBitsTranslucent: factor	"This entry point to BitBlt supplies an extra argument to specify translucency	for operations 30 and 31.  The argument must be an integer between 0 and 255."	<primitive: 96>	"Check for compressed source, destination or halftone forms"	((sourceForm isKindOf: Form) and: [sourceForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	((destForm isKindOf: Form) and: [destForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	((halftoneForm isKindOf: Form) and: [halftoneForm unhibernate])		ifTrue: [^ self copyBitsTranslucent: factor].	self primitiveFailed  "Later do nicer error recovery -- share copyBits recovery"! !!BitBlt methodsFor: 'copying' stamp: 'ar 5/19/2000 15:08'!displayString: aString from: startIndex to: stopIndex at: aPoint strikeFont: font kern: kernDelta	destY _ aPoint y.	destX _ aPoint x.	^self primDisplayString: aString from: startIndex to: stopIndex			map: font characterToGlyphMap xTable: font xTable			kern: kernDelta.! !!BitBlt methodsFor: 'private' stamp: 'ar 5/23/2000 15:27'!installStrikeFont: aStrikeFont foregroundColor: foregroundColor backgroundColor: backgroundColor	| lastSourceDepth |	sourceForm ifNotNil:[lastSourceDepth _ sourceForm depth].	sourceForm _ aStrikeFont glyphs.	(colorMap notNil and:[lastSourceDepth = sourceForm depth]) ifFalse:		["Set up color map for a different source depth (color font)"		"Note this may need some caching for reasonable efficiency"		colorMap _ (Color cachedColormapFrom: sourceForm depth to: destForm depth) copy.		colorMap at: 1 put: (backgroundColor pixelValueForDepth: destForm depth)].	sourceForm depth = 1 ifTrue:		[colorMap at: 2 put: (foregroundColor pixelValueForDepth: destForm depth).		"Ignore any halftone pattern since we use a color map approach here"		halftoneForm _ nil].	sourceY _ 0.	height _ aStrikeFont height.! !!BitBlt methodsFor: 'private' stamp: 'ar 5/18/2000 21:49'!primDisplayString: aString from: startIndex to: stopIndex map: glyphMap xTable: xTable kern: kernDelta	| ascii glyph |	<primitive:'primitiveDisplayString' module:'BitBltPlugin'>	startIndex to: stopIndex do:[:charIndex|		ascii _ (aString at: charIndex) asciiValue.		glyph _ glyphMap at: ascii + 1.		sourceX _ xTable at: glyph + 1.		width _ (xTable at: glyph + 2) - sourceX.		self copyBits.		destX _ destX + width + kernDelta.	].! !!BitBlt methodsFor: 'private' stamp: 'di 9/11/1998 13:07'!setDestForm: df sourceForm: sf fillColor: hf combinationRule: cr destOrigin: destOrigin sourceOrigin: sourceOrigin extent: extent clipRect: clipRect	| aPoint |	destForm _ df.	sourceForm _ sf.	self fillColor: hf.	"sets halftoneForm"	combinationRule _ cr.	destX _ destOrigin x.	destY _ destOrigin y.	sourceX _ sourceOrigin x.	sourceY _ sourceOrigin y.	width _ extent x.	height _ extent y.	aPoint _ clipRect origin.	clipX _ aPoint x.	clipY _ aPoint y.	aPoint _ clipRect corner.	clipWidth _ aPoint x - clipX.	clipHeight _ aPoint y - clipY.	sourceForm == nil ifFalse:		[colorMap _ sourceForm colormapIfNeededForDepth: destForm depth]! !!BitBlt class methodsFor: 'benchmarks' stamp: 'ar 5/25/2000 17:58'!benchmark		"BitBlt benchmark"	"Run a benchmark on different combinations rules, source/destination depths and BitBlt modes. Note: This benchmark doesn't give you any 'absolute' value - it is intended only for benchmarking improvements in the bitblt code and nothing else.	Attention: *this*may*take*a*while*"	| bb source dest destRect log t |	log _ WriteStream on: String new.	destRect _ 0@0 extent: 600@600.	"Form paint/Form over - the most common rules"	#( 25 3 ) do:[:rule|		Transcript cr; show:'---- Combination rule: ', rule printString,' ----'.		log cr; nextPutAll:'---- Combination rule: ', rule printString,' ----'.		#(1 2 4 8 16 32) do:[:destDepth|			dest _ nil.			dest _ Form extent: destRect extent depth: destDepth.			Transcript cr.			log cr.			#(1 2 4 8 16 32) do:[:sourceDepth|				Transcript cr; show: sourceDepth printString, ' => ', destDepth printString.				log cr; nextPutAll: sourceDepth printString, ' => ', destDepth printString.				source _ nil. bb _ nil.				source _ Form extent: destRect extent depth: sourceDepth.				(source getCanvas) fillOval: dest boundingBox color: Color yellow borderWidth: 30 borderColor: Color black.				bb _ WarpBlt toForm: dest.				bb sourceForm: source.				bb sourceRect: source boundingBox.				bb destRect: dest boundingBox.				bb colorMap: (source colormapIfNeededForDepth: dest depth).				bb combinationRule: rule.				"Measure speed of copyBits"				t _ Time millisecondsToRun:[bb copyBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				bb sourceForm: source destRect: source boundingBox.				"Measure speed of 1x1 warpBits"				bb cellSize: 1.				t _ Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 2x2 warpBits"				bb cellSize: 2.				t _ Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.				"Measure speed of 3x3 warpBits"				bb cellSize: 3.				t _ Time millisecondsToRun:[bb warpBits].				Transcript tab; show: t printString.				log tab; nextPutAll: t printString.			].		].	].	^log contents! !I am a bit-magnifying tool for editing small Forms directly on the display screen. I continue to be active until the user points outside of my viewing area.!!BitEditor methodsFor: 'control defaults' stamp: 'sma 3/11/2000 14:52'!isControlActive	^ super isControlActive and: [sensor keyboardPressed not]! !!BitEditor methodsFor: 'menu messages' stamp: 'sma 3/15/2000 21:10'!setTransparentColor	squareForm fillColor: Color gray.	color _ Color transparent! !!BitEditor methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 15:04'!getPluggableYellowButtonMenu: shiftKeyState	^ YellowButtonMenu! !!BitEditor class methodsFor: 'class initialization' stamp: 'sma 3/11/2000 14:48'!initialize	"The Bit Editor is the only controller to override the use of the blue	button with a different pop-up menu. Initialize this menu."	YellowButtonMenu _ SelectionMenu		labels:'cancelacceptfile outtest'		lines: #(2 3)		selections: #(cancel accept fileOut test)	"BitEditor initialize"! !!BitEditor class methodsFor: 'instance creation' stamp: 'jm 6/1/2003 06:00'!openOnForm: aForm 	"Create and schedule a BitEditor on the form aForm at its top left corner. Show the normal-sized and a magnified view of aForm."	| scaleFactor |	scaleFactor _ 4@4.	^ self openOnForm: aForm		at: (self locateMagnifiedView: aForm scale: scaleFactor) topLeft		scale: scaleFactor! !!BitEditor class methodsFor: 'instance creation' stamp: 'sma 3/11/2000 11:29'!openScreenViewOnForm: aForm at: formLocation magnifiedAt: magnifiedLocation scale: scaleFactor	"Create and schedule a BitEditor on the form aForm. Show the magnified	view of aForm in a scheduled window."	| smallFormView bitEditor savedForm r |	smallFormView _ FormView new model: aForm.	smallFormView align: smallFormView viewport topLeft with: formLocation.	bitEditor _ self bitEdit: aForm at: magnifiedLocation scale: scaleFactor remoteView: smallFormView.	savedForm _ Form fromDisplay: (r _ bitEditor displayBox expandBy: (0@23 corner: 0@0)).	bitEditor controller startUp.	savedForm displayOn: Display at: r topLeft.	bitEditor release.	smallFormView release.	"BitEditor magnifyOnScreen."! !My instances provide contiguous storage of bits, primarily to hold the graphical data of Forms. Forms and their subclasses provide the additional structural information as to how the bits should be interpreted in two dimensions.!!Bitmap methodsFor: 'filing' stamp: 'di 8/5/1998 11:41'!compress: bm toByteArray: ba	"Store a run-coded compression of the receiver into the byteArray ba,	and return the last index stored into. ba is assumed to be large enough.	The encoding is as follows...		S {N D}*.		S is the size of the original bitmap, followed by run-coded pairs.		N is a run-length * 4 + data code.		D, the data, depends on the data code...			0	skip N words, D is absent			1	N words with all 4 bytes = D (1 byte)			2	N words all = D (4 bytes)			3	N words follow in D (4N bytes)		S and N are encoded as follows...			0-223	0-223			224-254	(0-30)*256 + next byte (0-7935)			255		next 4 bytes"			| size k word j lowByte eqBytes i |	<primitive: 237>	self var: #bm declareC: 'int *bm'.	self var: #ba declareC: 'unsigned char *ba'.	size _ bm size.	i _ self encodeInt: size in: ba at: 1.	k _ 1.	[k <= size] whileTrue:		[word _ bm at: k.		lowByte _ word bitAnd: 16rFF.		eqBytes _ ((word >> 8) bitAnd: 16rFF) = lowByte				and: [((word >> 16) bitAnd: 16rFF) = lowByte				and: [((word >> 24) bitAnd: 16rFF) = lowByte]].		j _ k.		[j < size and: [word = (bm at: j+1)]]  "scan for = words..."			whileTrue: [j _ j+1].		j > k ifTrue:			["We have two or more = words, ending at j"			eqBytes				ifTrue: ["Actually words of = bytes"						i _ self encodeInt: j-k+1*4+1 in: ba at: i.						ba at: i put: lowByte.  i _ i+1]				ifFalse: [i _ self encodeInt: j-k+1*4+2 in: ba at: i.						i _ self encodeBytesOf: word in: ba at: i].			k _ j+1]			ifFalse:			["Check for word of 4 = bytes"			eqBytes ifTrue:				["Note 1 word of 4 = bytes"				i _ self encodeInt: 1*4+1 in: ba at: i.				ba at: i put: lowByte.  i _ i+1.				k _ k + 1]				ifFalse:				["Finally, check for junk"				[j < size and: [(bm at: j) ~= (bm at: j+1)]]  "scan for ~= words..."					whileTrue: [j _ j+1].				j = size ifTrue: [j _ j + 1].				"We have one or more unmatching words, ending at j-1"				i _ self encodeInt: j-k*4+3 in: ba at: i.				k to: j-1 do:					[:m | i _ self encodeBytesOf: (bm at: m) in: ba at: i].				k _ j]]].	^ i - 1  "number of bytes actually stored""Space check: | n rawBytes myBytes b |n _ rawBytes _ myBytes _ 0.Form allInstancesDo:	[:f | f unhibernate.	b _ f bits.	n _ n + 1.	rawBytes _ rawBytes + (b size*4).	myBytes _ myBytes + (b compressToByteArray size).	f hibernate].Array with: n with: rawBytes with: myBytesColorForms: (116 230324 160318 )Forms: (113 1887808 1325055 )Integerity check:Form allInstances do:	[:f | f unhibernate.	f bits = (Bitmap decompressFromByteArray: f bits compressToByteArray)		ifFalse: [self halt].	f hibernate]Speed test:MessageTally spyOn: [Form allInstances do:	[:f | Bitmap decompressFromByteArray: f bits compressToByteArray]]"! !!Bitmap methodsFor: 'filing' stamp: 'di 8/5/1998 11:31'!compressToByteArray	"Return a run-coded compression of this bitmap into a byteArray"			| byteArray lastByte |	"Without skip codes, it is unlikely that the compressed bitmap will be any larger than was the original.  The run-code cases are...	N >= 1 words of equal bytes:  4N bytes -> 2 bytes (at worst 4 -> 2)	N > 1 equal words:  4N bytes -> 5 bytes (at worst 8 -> 5)	N > 1 unequal words:  4N bytes -> 4N + M, where M is the number of bytes required to encode the run length.The worst that can happen is that the method begins with unequal words, and than has interspersed occurrences of a word with equal bytes.  Thus we require a run-length at the beginning, and after every interspersed word of equal bytes.  However, each of these saves 2 bytes, so it must be followed by a run of 1984 (7936//4) or more (for which M jumps from 2 to 5) to add any extra overhead.  Therefore the worst case is a series of runs of 1984 or more, with single interspersed words of equal bytes.  At each break we save 2 bytes, but add 5.  Thus the overhead would be no more than 5 (encoded size) + 2 (first run len) + (S//1984*3)."	"NOTE: This code is copied in Form hibernate for reasons given there."	byteArray _ ByteArray new: (self size*4) + 7 + (self size//1984*3).	lastByte _ self compress: self toByteArray: byteArray.	^ byteArray copyFrom: 1 to: lastByte! !!Bitmap methodsFor: 'filing' stamp: 'jm 1/1/2004 18:54'!writeUncompressedOn: aStream 	"Store the array of bits onto the argument, aStream. (leading byte ~= 16r80) identifies this as raw bits (uncompressed)."	aStream int32: self size.	aStream nextPutAll: self.! !!Bitmap methodsFor: 'printing' stamp: 'sma 6/1/2000 09:42'!printOn: aStream	self printNameOn: aStream.	aStream nextPutAll: ' of length '; print: self size! !!Bitmap methodsFor: 'accessing' stamp: 'jm 12/3/2003 08:51'!atAllPut: value	"Fill the receiver with the given value"	<primitive: 145>	super atAllPut: value! !!Bitmap methodsFor: 'accessing' stamp: 'jm 12/3/2003 08:52'!bytesPerElement	"Number of bytes in each item.  This multiplied by (self size)*8 gives the number of bits stored."	^ 4! !!Bitmap methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0! !!Bitmap methodsFor: 'testing' stamp: 'ar 5/25/2000 19:42'!isColormap	"Bitmaps were used as color maps for BitBlt.	This method allows to recognize real color maps."	^false! !!Bitmap class methodsFor: 'instance creation' stamp: 'jm 1/1/2004 18:52'!newFromStream: s	| len result |	s next = 16r80 ifTrue: [  "new compressed format"		len _ self decodeIntFrom: s.		^ Bitmap decompressFromByteArray: (s nextInto: (ByteArray new: len))].	s skip: -1.	len _ s int32.	len <= 0		ifTrue: [  "old compressed format"			^ (self new: len negated) readCompressedFrom: s]		ifFalse: [  "old raw format"			result _ self new: len.			s next: len into: result startingAt: 1.			^ result].! !My instances function similarly to instances of MethodContext, but they hold the dynamic state for execution of a block in Smalltalk. They access all temporary variables and the method sender via their home pointer, so that those values are effectively shared. Their indexable part is used to store their independent value stack during execution.	My instance must hold onto its home in order to work. This can cause circularities if the home is also pointing (via a temp, perhaps) to the instance. In the rare event that this happens (as in SortedCollection sortBlock:) the message fixTemps will replace home with a copy of home, thus defeating the sharing of temps but, nonetheless, eliminating the circularity.BlockContexts must only be created using the method newForMethod:.  Note that it is impossible to determine the real object size of a BlockContext except by asking for the frameSize of its method.  Any fields above the stack pointer (stackp) are truly invisible -- even (and especially!!) to the garbage collector.  Any store into stackp other than by the primitive method stackp: is potentially fatal.!!BlockContext methodsFor: 'evaluating' stamp: 'jm 5/22/2003 20:25'!ifError: errorHandlerBlock	"Evaluate the block represented by the receiver. If an error occurs the given handler block is evaluated. The handler block can be either a zero- or two-argument block; if the latter, then the error message and receiver are supplied to it as parameters. Answer the value returned by the handler block if the receiver gets an error."	"Warning: The receiver should not contain an explicit return since that would leave an obsolete error handler hanging around."	"Examples:		[1 whatsUpDoc] ifError: [:err :rcvr | ^ 'huh?'].		[1 whatsUpDoc] ifError: ['huh'].		[1 / 0] ifError: [:err :rcvr |			'division by 0' = err				ifTrue: [^ Float infinity]				ifFalse: [self error: err]]"	| activeProcess lastHandler val |	activeProcess _ Processor activeProcess.	lastHandler _ activeProcess errorHandler.	activeProcess errorHandler: [:aString :aReceiver |		activeProcess errorHandler: lastHandler.		errorHandlerBlock numArgs = 0 ifTrue: [^ errorHandlerBlock value].		^ errorHandlerBlock value: aString value: aReceiver].	val _ self value.	activeProcess errorHandler: lastHandler.	^ val! !!BlockContext methodsFor: 'evaluating' stamp: 'jm 6/10/2003 12:26'!msecs	"Answer the number of milliseconds taken to execute this block. For typing convenience (shorter than 'timeToRun')."	^ Time millisecondsToRun: self! !!BlockContext methodsFor: 'evaluating' stamp: 'jm 6/3/1998 14:25'!timeToRun	"Answer the number of milliseconds taken to execute this block."	^ Time millisecondsToRun: self! !!BlockContext methodsFor: 'scheduling' stamp: 'jm 5/23/2003 12:30'!bg	"Create and schedule a Process running the code in the receiver at background priority. For conviently running a computation in the background from an expression."	"Example: [(Delay forSeconds: 2) wait. self beep] bg"	^ self forkAt: Processor userBackgroundPriority! !!BlockContext methodsFor: 'scheduling' stamp: 'di 9/12/1998 11:53'!fork	"Create and schedule a Process running the code in the receiver."	^ self newProcess resume! !!BlockContext methodsFor: 'scheduling' stamp: 'jm 11/9/1998 10:16'!forkAt: priority 	"Create and schedule a Process running the code in the receiver at the given priority. Answer the newly created process."	| forkedProcess |	forkedProcess _ self newProcess.	forkedProcess priority: priority.	^ forkedProcess resume! !!BlockContext methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:44'!newProcess	"Answer a Process running the code in the receiver. The process is not 	scheduled."	<primitive: 19> "Simulation guard"	^Process		forContext: 			[self value.			Processor terminateActive]		priority: Processor activePriority! !!BlockContext methodsFor: 'private' stamp: 'jm 5/15/2003 20:52'!cannotReturn: result	"The receiver tried to return result to a method context that no longer exists."	Debugger		openContext: thisContext		label: 'Block cannot return'		contents: thisContext shortStack.! !!BlockContext methodsFor: 'private' stamp: 'di 1/14/1999 22:28'!instVarAt: index put: value	index = 3 ifTrue: [self stackp: value. ^ value].	^ super instVarAt: index put: value! !!BlockContext methodsFor: 'system simulation' stamp: 'di 1/11/1999 10:24'!pushArgs: args from: sendr 	"Simulates action of the value primitive."	args size ~= nargs ifTrue: [^self error: 'incorrect number of args'].	self stackp: 0.	args do: [:arg | self push: arg].	sender _ sendr.	pc _ startpc! !I and my subclasses represent statements in a block-based graphical programming language.!!BlockMorph methodsFor: 'initialization' stamp: 'jm 9/24/2003 18:54'!initialize	super initialize.	blockLayoutNeeded _ true.	isSpecialForm _ false.	self color: (Color r: 0.4 g: 0.7 b: 0.8).! !!BlockMorph methodsFor: 'accessing' stamp: 'jm 10/21/2003 18:54'!codeString	"Answer a human-readable string representing the code for this block sequence."	| s |	s _ WriteStream on: (String new: 5000).	self printCodeOn: s indent: 0.	^ s contents! !!BlockMorph methodsFor: 'accessing' stamp: 'DaveF 8/4/2003 15:07'!color: aColor	"Remember the color of this block, for lighting-up purposes."	super color: aColor.	oldColor _ aColor.! !!BlockMorph methodsFor: 'accessing' stamp: 'DaveF 7/11/2003 00:41'!isSpecialForm	^isSpecialForm.! !!BlockMorph methodsFor: 'accessing' stamp: 'DaveF 7/10/2003 17:39'!isSpecialForm: aBoolean	"Sets a flag indicating that this block has a special evaluation rule."	isSpecialForm _ aBoolean.! !!BlockMorph methodsFor: 'accessing' stamp: 'jm 8/24/2003 11:59'!litUp: aBoolean	"If the argument true, light up this block. Otherwise, revert to it's old color."	"Note: We use super color: so we don't overwrite oldColor. We also force a world update to ensure that the highlighting is seen by the user."	aBoolean		ifTrue:	[super color: Color yellow]		ifFalse:	[super color: oldColor].	aBoolean ifTrue: [		World			cycleWhileWaitingMSecs: ScratchProcess blockHighlightMSecs			doInput: true			doSteps: false].! !!BlockMorph methodsFor: 'accessing' stamp: 'jm 10/21/2003 19:04'!printCodeOn: aStream indent: indent	"Append a human-readable string for this block on the given stream."	indent timesRepeat: [aStream tab].	aStream nextPutAll: self class name; cr.	self nextBlock ifNotNil: [self nextBlock printCodeOn: aStream indent: indent].! !!BlockMorph methodsFor: 'queries' stamp: 'jm 3/13/2003 12:10'!isReporter	"Answer true if this block reports a value. That is, if it can be used in an argument expression. Answer false by default."	^ false! !!BlockMorph methodsFor: 'drawing' stamp: 'jm 4/28/2003 16:56'!drawBFrom: startX to: endX y: y on: aCanvas	"Draw a bottom (shadowed) horizontal edge between the given starting and ending X locations."	aCanvas fillRectangle: (startX@(y - 2) corner: endX@(y - 1)) color: Color gray.	aCanvas fillRectangle: (startX@(y - 1) corner: endX@y) color: self edgeColor.! !!BlockMorph methodsFor: 'drawing' stamp: 'jm 4/28/2003 17:07'!drawCornersOn: aCanvas 	"outer corners"	aCanvas fillRectangle: ((bounds topLeft + (1 @ 1)) extent: 1) color: self edgeColor.	aCanvas fillRectangle: ((bounds topRight + (-2 @ 1)) extent: 1) color: self edgeColor.	aCanvas fillRectangle: ((bounds bottomLeft + (1 @ -2)) extent: 1) color: self edgeColor.	aCanvas fillRectangle: ((bounds bottomRight + (-2 @ -2)) extent: 1) color: self edgeColor.	"extra highlight pixel in top left corner"	aCanvas fillRectangle: ((bounds topLeft + 2) extent: 1) color: Color white.! !!BlockMorph methodsFor: 'drawing' stamp: 'jm 4/28/2003 16:57'!drawLFrom: startY to: endY x: x on: aCanvas	"Draw a left (highlit) vertical edge between the given starting and ending Y locations."	aCanvas fillRectangle: (x@startY corner: (x + 1)@endY) color: self edgeColor.	aCanvas fillRectangle: ((x + 1)@startY corner: (x + 2)@endY) color: Color white.! !!BlockMorph methodsFor: 'drawing' stamp: 'jm 11/24/2002 10:34'!drawOn: aCanvas 	| insetR |	insetR _ bounds insetBy: 2.	aCanvas fillRectangle: insetR color: color.	self drawTFrom: insetR left to: insetR right y: bounds top on: aCanvas.	self drawLFrom: insetR top to: insetR bottom x: bounds left on: aCanvas.	self drawBFrom: insetR left to: insetR right y: bounds bottom on: aCanvas.	self drawRFrom: insetR top to: insetR bottom x: bounds right on: aCanvas.	self drawCornersOn: aCanvas.! !!BlockMorph methodsFor: 'drawing' stamp: 'jm 4/28/2003 16:57'!drawRFrom: startY to: endY x: x on: aCanvas	"Draw a right (shadowed) vertical edge between the given starting and ending Y locations."	aCanvas fillRectangle: ((x - 2)@startY corner: (x - 1)@endY) color: Color gray.	aCanvas fillRectangle: ((x - 1)@startY corner: x@endY) color: self edgeColor.! !!BlockMorph methodsFor: 'drawing' stamp: 'jm 4/28/2003 16:57'!drawTFrom: startX to: endX y: y on: aCanvas	"Draw a top (highlit) horizontal edge between the given starting and ending X locations."	aCanvas fillRectangle: (startX@y corner: endX@(y + 1)) color: self edgeColor.	aCanvas fillRectangle: (startX@(y + 1) corner: endX@(y + 2)) color: Color white.! !!BlockMorph methodsFor: 'event handling' stamp: 'jm 8/4/2003 00:07'!doubleClick: evt	"If I'm a block in a viewer, execute me."	| frame |	((self isKindOf: CommandBlockMorph) and:	 [self wantsName | self wantsPossession]) ifFalse: [^ self].	(self ownerThatIsA: ScratchViewerMorph) ifNil: [^ self].	(frame _ self receiver scratchFrame) ifNil: [^ self].	frame startProcessForStatements: (Array with: self).! !!BlockMorph methodsFor: 'event handling' stamp: 'jm 8/24/2003 20:37'!duplicate	self world activeHand attachMorph: self fullCopy.! !!BlockMorph methodsFor: 'event handling' stamp: 'jm 8/13/2003 10:22'!handlesMouseDown: evt	^ true! !!BlockMorph methodsFor: 'event handling' stamp: 'jm 8/19/2003 13:30'!mouseDown: evt	"Handle a mouse click. Left button either drags or performs click action. Right button brings up a menu."	evt yellowButtonPressed		ifTrue: [Sensor waitNoButton. self rightButtonMenu]		ifFalse:	[evt hand waitForClicksOrDrag: self event: evt].! !!BlockMorph methodsFor: 'event handling' stamp: 'jm 8/24/2003 20:37'!rightButtonMenu	| menu |	(self owner isKindOf: BlockMorph) ifTrue: [^ self].  "we can't yet delete a blocks inside a script"	menu _ CustomMenu new.	menu add: 'copy' action: #duplicate.	menu add: 'delete' action: #delete.	menu invokeOn: self.! !!BlockMorph methodsFor: 'dropping/grabbing' stamp: 'jm 8/24/2003 19:42'!aboutToBeGrabbedBy: aHandMorph	"If I'm being used as an argument, replace myself with an appropriate argument morph. Copied from WatcherMorph."	| m |	(owner isKindOf: CommandBlockMorph) ifTrue: [		"if I was being used as argument, replace myself with a generic argument morph"		m _ owner argMorphToReplace: self.		m ifNotNil: [owner replaceArgMorph: self by: m]].! !!BlockMorph methodsFor: 'dropping/grabbing' stamp: 'jm 8/5/2003 17:14'!justDroppedInto: aMorph event: anEvent	"See if I should click onto another block."	| xThresh yThresh attachPoints possibleTargets targetP dist target |	xThresh _ 80.	yThresh _ 12.	"I am only allowed to be dropped into script editor pane"	((owner isKindOf: ScratchScriptsMorph) or:	 [owner isKindOf: BlockMorph]) ifFalse: [		^ self rejectDropEvent: anEvent].	"get possible attachment points (list of point->morph)"	attachPoints _ OrderedCollection new: 100.	aMorph submorphsDo: [:m |		((m isKindOf: BlockMorph) and: [m ~~ self])			ifTrue: [attachPoints addAll: m blockAttachPoints]].	"find possible targets (list of dist->target)"	possibleTargets _ OrderedCollection new.	attachPoints do: [:assoc |		targetP _ assoc key.		(((self left - targetP x) abs < xThresh) and:		 [(self top - targetP y) abs < yThresh]) ifTrue: [			dist _ (self position - targetP) r.			possibleTargets addLast: (dist -> assoc)]].	possibleTargets size > 0 ifFalse: [^ self].	target _ possibleTargets asArray sort first value.  "sort least distance first"	self position: target key.	target value attachBlock: self.! !!BlockMorph methodsFor: 'dropping/grabbing' stamp: 'jm 8/3/2003 10:02'!rejectDropEvent: evt	"Reject being dropped by the given event."	evt hand rejectDropMorph: self event: evt.! !!BlockMorph methodsFor: 'dropping/grabbing' stamp: 'jm 3/17/2003 17:59'!rootForGrabOf: aMorph	"Allow myself to be extracted."	(owner notNil and: [owner isPartsBin])		ifTrue: [^ super rootForGrabOf: aMorph]		ifFalse: [^ self].! !!BlockMorph methodsFor: 'block enumerating' stamp: 'jm 12/8/2002 19:22'!blockSequence	"Answer the sequence of blocks starting with myself. Each block is a submorph of the previous block."	| result this |	result _ OrderedCollection new: 20.	this _ self.	[this isNil] whileFalse: [		result addLast: this.		this _ this nextBlock].	^ result asArray! !!BlockMorph methodsFor: 'block enumerating' stamp: 'tis 6/27/2003 09:50'!findHatBlock	"I return the script hat of my receiver, or nil if my receiver is not attached to a hat block."	(self isKindOf: HatBlockMorph)		ifTrue: [^ self]		ifFalse: [(self owner isKindOf: BlockMorph) 			ifTrue: [^ self owner findHatBlock]			ifFalse: [^ nil]]! !!BlockMorph methodsFor: 'block enumerating' stamp: 'jm 12/8/2002 19:23'!nextBlock	"Answer the block myself in the block sequence or nil if I am the last block in the sequence. Each block is a submorph of the previous block."	^ self submorphs detect: [:m | m isKindOf: BlockMorph] ifNone: [nil]! !!BlockMorph methodsFor: 'block enumerating' stamp: 'jm 11/5/2003 10:07'!suppressReceiver	"Answer true if the receiver of this block should be suppressed in the current viewer or editor."	| m |	m _ owner.	[m notNil] whileTrue: [		(m isKindOf: ScratchViewerMorph) ifTrue: [^ true].		((m isKindOf: ScratchScriptEditorMorph) and:		 [m suppressBlockReceivers])			ifTrue: [^ true].		m _ m owner].	^ false! !!BlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:51'!fieldsVersion	^ 1! !!BlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:52'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		isSpecialForm		oldColor	) from: anObjStream.! !!BlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:17'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		isSpecialForm		oldColor	) on: anObjStream.! !!BlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 17:03'!attachBlock: aBlockMorph	"Attach the given block to me. Assume the block has been positioned correctly."	self addMorph: aBlockMorph.! !!BlockMorph methodsFor: 'private' stamp: 'jm 3/20/2003 13:30'!blockAttachPoints	"Answer a collection of possible attachment points for me. Each entry is an Association mapping a point to the morph to which a dropping block could be attached."	| nextB |	nextB _ self nextBlock.	nextB		ifNil: [^ Array with: (self bottomLeft -> self)]		ifNotNil: [^ nextB blockAttachPoints].! !!BlockMorph methodsFor: 'private' stamp: 'jm 4/28/2003 16:56'!edgeColor	"Answer the color to use for my outline. Block looks sharp, block color looks soft."	^ color! !!BlockMorph methodsFor: 'private' stamp: 'jm 11/5/2003 09:48'!findScratchEditor	"Answer the scratch editor of my receiver or nil if my receiver is not in a scratch editor."	| m |	m _ self.	[m isKindOf: ScratchScriptEditorMorph] whileFalse: [		m owner ifNil: [^ nil].		m _ m owner].	^ m! !!BlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 12:28'!fixBlockLayout	"Fix my block layout. This default implementation does nothing."! !!BlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 14:18'!fullBounds	"This is the hook that triggers lazy re-layout. It works because layoutChanged clears the fullBounds cache. Once per cycle, the fullBounds is requested from every morph in the world, and that request gets propagated through the entire submorph hierarchy, causing re-layout where needed. Note that multiple layoutChanges to the same morph can be done with little cost, since the layout is only done when the morph needs to be displayed."	fullBounds ifNil: [		"do layout here"		blockLayoutNeeded ifTrue: [			super fullBounds.			self fixBlockLayout.			fullBounds _ nil.			super fullBounds.  "recompute after layout"			self changed].		blockLayoutNeeded _ false].	^ super fullBounds! !!BlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 13:50'!layoutChanged	blockLayoutNeeded ifFalse: [		(fullBounds notNil & owner notNil) ifTrue: [owner invalidRect: fullBounds].		super layoutChanged].	blockLayoutNeeded _ true.! !!BlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 12:54'!nonControlFlowSubmorphs	"Answer a collection of submorphs minus any blocks that are part of the control flow. For example, command blocks omit their submorph that is the next block in the block sequence, C-blocks omit both their next block and the first block of their nested block list, etc."	^ submorphs copyWithout: self nextBlock! !!BlockMorph methodsFor: 'private' stamp: 'jm 10/21/2003 19:46'!printCodeSubmorph: aMorph on: aStream	(aMorph isKindOf: ArgMorph) ifTrue: [aStream nextPutAll: aMorph labelMorph contents].	(aMorph isKindOf: BlockMorph) ifTrue: [aMorph printCodeOn: aStream indent: 0].	(aMorph isKindOf: StringMorph) ifTrue: [aStream nextPutAll: aMorph contents].	(aMorph isKindOf: ParameterMorph) ifTrue: [aStream nextPutAll: aMorph name].! !!BlockMorph class methodsFor: 'class initialization' stamp: 'jm 12/7/2002 15:50'!initialize	"self initialize"	LabelFont _ StrikeFont familyName: 'ComicBold' size: 20.! !!BlockMorph class methodsFor: 'other' stamp: 'jm 12/9/2002 13:42'!labelFont	^ LabelFont! !I represent a bracketed block with 0 or more arguments and 1 or more statements. If I am initialized with no statements, I create one. I have a flag to tell whether my last statement returns a value from the enclosing method. My last three fields remember data needed for code generation. I can emit for value in the usual way, in which case I create a literal method (actually a context remotely copied) to be evaluated by sending it value: at run time. Or I can emit code to be evaluated in line; this only happens at the top level of a method and in conditionals and while-loops, none of which have arguments.!!BlockNode methodsFor: 'initialize-release' stamp: 'sma 3/3/2000 13:38'!statements: statementsCollection returns: returnBool 	"Decompile."	| returnLast |	returnLast _ returnBool.	returns _ false.	statements _ 		(statementsCollection size > 1 			and: [(statementsCollection at: statementsCollection size - 1) 					isReturningIf])				ifTrue: 					[returnLast _ false.					statementsCollection allButLast]				ifFalse: [statementsCollection size = 0						ifTrue: [Array with: NodeNil]						ifFalse: [statementsCollection]].	arguments _ #().	temporaries _ #().	returnLast ifTrue: [self returnLast]! !!BlockNode methodsFor: 'accessing' stamp: 'tk 8/4/1999 22:53'!block	^ self! !!BlockNode methodsFor: 'accessing' stamp: 'sma 2/27/2000 22:37'!temporaries: aCollection	temporaries _ aCollection! !!BlockNode methodsFor: 'code generation' stamp: 'di 11/19/1999 19:32'!emitExceptLast: stack on: aStream	| nextToLast |	nextToLast _ statements size - 1.	nextToLast < 1 ifTrue: [^ self].  "Only one statement"	1 to: nextToLast do:		[:i | (statements at: i) emitForEffect: stack on: aStream].! !!BlockNode methodsFor: 'code generation' stamp: 'di 11/19/1999 19:44'!emitForEvaluatedValue: stack on: aStream	self emitExceptLast: stack on: aStream.	statements last emitForValue: stack on: aStream.! !!BlockNode methodsFor: 'code generation' stamp: 'di 11/19/1999 19:33'!sizeExceptLast: encoder	| codeSize nextToLast |	nextToLast _ statements size - 1.	nextToLast < 1 ifTrue: [^ 0]. "Only one statement"	codeSize _ 0.	1 to: nextToLast do: 		[:i | codeSize _ codeSize + ((statements at: i) sizeForEffect: encoder)].	^ codeSize! !!BlockNode methodsFor: 'printing' stamp: 'sw 11/17/1999 13:56'!printArgumentsOn: aStream indent: level	arguments size = 0		ifFalse: 			[arguments do: 				[:arg | 				aStream nextPut: $:.				aStream withAttributes: (Preferences syntaxAttributesFor: #blockArgument)					do: [aStream nextPutAll: arg key].				aStream space].			aStream nextPutAll: '| '.			"If >0 args and >1 statement, put all statements on separate lines"			statements size > 1 ifTrue: [aStream crtab: level]]! !!BlockNode methodsFor: 'printing' stamp: 'sma 2/27/2000 22:42'!printOn: aStream indent: level	statements size <= 1 ifFalse: [aStream crtab: level].	aStream nextPut: $[.	self printArgumentsOn: aStream indent: level.	self printTemporariesOn: aStream indent: level.	self printStatementsOn: aStream indent: level.	aStream nextPut: $]! !!BlockNode methodsFor: 'printing' stamp: 'di 4/3/1999 23:25'!printStatementsOn: aStream indent: levelOrZero	| len shown thisStatement level |	level _ 1 max: levelOrZero.	comment == nil		ifFalse: 			[self printCommentOn: aStream indent: level.			aStream crtab: level].	len _ shown _ statements size.	(levelOrZero = 0 "top level" and: [statements last isReturnSelf])		ifTrue: [shown _ 1 max: shown - 1]		ifFalse: [(len = 1 and: [((statements at: 1) == NodeNil) & (arguments size = 0)])					ifTrue: [shown _ shown - 1]].	1 to: shown do: 		[:i | 		thisStatement _ statements at: i.		thisStatement printOn: aStream indent: level.		i < shown ifTrue: [aStream nextPut: $.; crtab: level].		(thisStatement comment ~~ nil and: [thisStatement comment size > 0])			ifTrue: 				[i = shown ifTrue: [aStream crtab: level].				thisStatement printCommentOn: aStream indent: level.				i < shown ifTrue: [aStream crtab: level]]]! !!BlockNode methodsFor: 'printing' stamp: 'di 3/6/2000 20:52'!printTemporariesOn: aStream indent: level	(temporaries == nil or: [temporaries size = 0])		ifFalse: 			[aStream nextPut: $|.			temporaries do: 				[:arg | 				aStream					space;					withAttributes: (Preferences syntaxAttributesFor: #temporaryVariable)					do: [aStream nextPutAll: arg key]].			aStream nextPutAll: ' | '.			"If >0 args and >1 statement, put all statements on separate lines"			statements size > 1 ifTrue: [aStream crtab: level]]! !!BlockNode class methodsFor: 'instance creation' stamp: 'sma 3/3/2000 13:34'!statements: statements returns: returns	^ self new statements: statements returns: returns! !!BlockNode class methodsFor: 'instance creation' stamp: 'sma 3/3/2000 13:34'!withJust: aNode	^ self statements: (Array with: aNode) returns: false! !A simple reader for Project Gutenberg books.!!BookReader methodsFor: 'initialization' stamp: 'jm 1/16/2000 12:29'!initialize	pageExtent _ 640@464.	margins _ 35@30 corner: 20@5.	pageColor _ Color r: 1.0 g: 1.0 b: 0.9.	font _ self findFontNamed: 'Palatino' desiredSize: 24.	paragraphs _ #().	pages _ #().	currentPage _ 1.! !!BookReader methodsFor: 'public' stamp: 'jm 1/16/2000 11:21'!interactionLoop	"Handle user interactions. Currenly, the only keys recognized are the arrow keys. The mouse or pen anywhere on the screen is used to jump to an arbitrary page of the book."	| ch |	self displayCurrentPage.	[true] whileTrue: [		Sensor anyButtonPressed ifTrue: [			Sensor cursorPoint x < margins left				ifTrue: [self jumpToPage]				ifFalse: [self fontMenu]].		Sensor keyboardPressed ifTrue: [			ch _ Sensor keyboard asciiValue.			(ch = 28 or: [ch = 30]) ifTrue: [				self goToPage: currentPage - 1.				self displayCurrentPage].			(ch = 29 or: [ch = 31]) ifTrue: [				self goToPage: currentPage + 1.				self displayCurrentPage]]].! !!BookReader methodsFor: 'public' stamp: 'jm 1/16/2000 11:31'!readTextFrom: aStream	"Replace my contents with the text from the given stream."	paragraphs _ OrderedCollection new: 10000.	[aStream atEnd] whileFalse: [		paragraphs addLast: (self nextParagraphFrom: aStream)].	paragraphs _ paragraphs asArray.	self paginateForPageWidth: pageExtent x - margins left - margins right.	self goToPage: 1.! !!BookReader methodsFor: 'public' stamp: 'jm 1/15/2000 21:10'!setFont: aFont	"Set my font to the given font and repaginate."	font _ aFont.	self paginateForPageWidth: pageExtent x - margins left - margins right.	self goToPage: currentPage.	self displayCurrentPage.! !!BookReader methodsFor: 'private-display' stamp: 'jm 9/30/2000 15:24'!displayCurrentPage	"Show the current page on the display."	| page x y printer lineHeight |	((currentPage < 1) or: [currentPage > pages size]) ifTrue: [^ self].	pages isEmpty ifTrue: [^ self].	page _ pages at: currentPage.	x _ margins left.	y _ margins top.	printer _ DisplayScanner quickPrintOn: Display font: font.	lineHeight _ printer lineHeight.	Display fill: (0@0 corner: pageExtent x@y) fillColor: pageColor.	page do: [:line |		Display fill: (0@y extent: pageExtent x@lineHeight) fillColor: pageColor.		printer drawString: line at: x@y.		y _ y + lineHeight].	Display fill: (0@y corner: pageExtent) fillColor: pageColor.	self displayPageNumber.	self displayScroller.! !!BookReader methodsFor: 'private-display' stamp: 'jm 9/30/2000 15:24'!displayPageNumber	| printer numString w x y |	printer _ DisplayScanner quickPrintOn: Display font: font.	numString _ '- ', currentPage printString, ' -'.	w _ printer stringWidth: numString.	x _ (pageExtent x - w) // 2.	y _ pageExtent y - margins bottom - printer lineHeight.	Display fill: ((x - 10)@y extent: (w + 20)@printer lineHeight) fillColor: pageColor.	printer drawString: numString at: x@y.! !!BookReader methodsFor: 'private-display' stamp: 'jm 1/16/2000 13:40'!displayScroller	"Display the left-margin scroll line and current page marker."	| top bottom left markerY |	top _ margins top.	bottom _ pageExtent y - margins top.	left _ 5.	Display fill: ((left - 3)@(top - 2) corner: (left + 3)@(bottom + 2)) fillColor: pageColor.	Display fill: (left@top corner: (left + 1)@bottom) fillColor: Color veryLightGray."xx	Display fill: ((left - 1)@top corner: (left + 2)@(top + 1)) fillColor: Color black.	Display fill: ((left - 1)@(bottom - 1) corner: (left + 2)@bottom) fillColor: Color black.xx"	"draw the marker"	markerY _ top + (((bottom - top - 1) * (currentPage - 1)) // (pages size - 1))."xx	Display fill: ((left - 2)@markerY corner: (left + 3)@(markerY + 2)) fillColor: Color gray. xxx"	Display fill: ((left - 3)@(markerY - 2) corner: (left - 2)@(markerY + 3)) fillColor: Color gray.	Display fill: ((left - 2)@(markerY - 1) corner: (left - 1)@(markerY + 2)) fillColor: Color gray.	Display fill: ((left - 1)@(markerY) corner: (left - 0)@(markerY + 1)) fillColor: Color gray.! !!BookReader methodsFor: 'private-interaction' stamp: 'jm 9/12/2003 16:19'!fontMenu	"Select a new font via a menu."	| menu newFont |	menu _ CustomMenu new.	menu title: 'Select a font (currently ', font name, ' ', font height printString, '):'.	menu addLine.	StrikeFont allInstances do: [:sFont |		menu add: (sFont name, ' ', sFont height printString) action: sFont].	newFont _ menu startUp.	newFont ifNil: [^ self].	(newFont ~= font) ifTrue: [		Cursor wait show.		self setFont: newFont.		Cursor normal show].! !!BookReader methodsFor: 'private-interaction' stamp: 'jm 1/16/2000 13:17'!jumpToPage	"Update the page number based on the vertical pen position. When the mouse button goes up, jump to the chosen page."	| topEdge bottomEdge lastPageNumber y  |	topEdge _ margins top.	bottomEdge _ pageExtent y - margins top.	[Sensor anyButtonPressed] whileTrue: [		lastPageNumber _ currentPage.		y _ Sensor cursorPoint y.		y <= topEdge ifTrue: [currentPage _ 1].		(y > topEdge and: [y < bottomEdge]) ifTrue: [			currentPage _ (((pages size - 1) * (y - topEdge)) // (bottomEdge - topEdge)) + 1].		y >= bottomEdge ifTrue: [currentPage _ pages size].		currentPage = lastPageNumber ifFalse: [			self displayPageNumber.			self displayScroller]].	"when mouse goes up:"	self displayCurrentPage.! !!BookReader methodsFor: 'private-pagination' stamp: 'jm 1/16/2000 19:30'!characterBasedBreakIndexAfter: startIndex in: aString	"Using character-based line wrapping, answer the position in the given string of the next linebreak, where the current line starts at startIndex and the maximum line length is charsPerLine characters. This is faster but less accurate than font-based wrapping. For example, a line with lots of 'm' characters can be much wider than the same length line with lots of 'l' characters in a proportionally-spaced font."	| space endIndex |	space _ Character space.	aString size < (startIndex + charsPerLine) ifTrue: [^ aString size].	endIndex _ startIndex + charsPerLine - 1.	endIndex to: startIndex + 1 by: -1 do: [:i |		(aString at: i) = space ifTrue: [^ i]].	^ endIndex! !!BookReader methodsFor: 'private-pagination' stamp: 'jm 1/16/2000 11:42'!hardBreak: aString after: startIndex pixelWidth: pixelWidth	"Answer the index i such that the characters of aString from startIndex through i consume just under pixelWidth in the current font. This method is purely character-based; no attempt is made to break between words; it is only called as a last resort, when a given line has no spaces before the margin."	| w |	startIndex + 1 to: aString size do: [:i |		w _ printerForFont stringWidth: aString from: startIndex to: i.		w > pixelWidth ifTrue: [^ i]].	^ aString size! !!BookReader methodsFor: 'private-pagination' stamp: 'jm 1/16/2000 11:42'!lineBreakIndexAfter: startIndex in: aString pixelWidth: pixelWidth	"Answer the position in the given string of the next linebreak, where the current line starts at startIndex and the maximum line width is pixelWidth."	| space sz indexOfLastSpace i |	space _ Character space.	sz _ aString size.	"scan forward from lastFullLineLength"	indexOfLastSpace _ nil.	i _ aString indexOf: space startingAt: (startIndex + lastFullLineLength).	[(i > 0) and:	 [(printerForFont stringWidth: aString from: startIndex to: i) <= pixelWidth]]		whileTrue: [			indexOfLastSpace _ i.			i _ aString indexOf: space startingAt: i + 1].	"forward scan succeeded"	indexOfLastSpace ifNotNil: [		lastFullLineLength _ (indexOfLastSpace - startIndex) + 1.		^ indexOfLastSpace].	i = 0 ifTrue: [  "reached end of string"		(printerForFont stringWidth: aString from: startIndex to: sz) <= pixelWidth			ifTrue: [^ sz]].  "remainder of string fits on line"	"scan backward from lastFullLineLength"	i _ startIndex + lastFullLineLength - 1.	i > sz ifTrue: [i _ sz].	[i > startIndex] whileTrue: [		"find previous space"		[(i > startIndex) and: [(aString at: i) ~= space]]			whileTrue: [i _ i - 1].		((i > startIndex) and:		 [(printerForFont stringWidth: aString from: startIndex to: i) <= pixelWidth])			ifTrue: [  "found last space before margin"				lastFullLineLength _ (i - startIndex) + 1.				^ i].		i _ i - 1].	"line has no spaces before margin; must break a word"	^ self hardBreak: aString after: startIndex pixelWidth: pixelWidth! !!BookReader methodsFor: 'private-pagination' stamp: 'jm 9/30/2000 15:32'!linesForPageWidth: pixelWidth	"Break the given string into a collection of lines such that each line is no wider than pixelWidth when displayed using the current font. Attempt to break the lines between words."	| lines lastI i |	printerForFont _ DisplayScanner quickPrintOn: Display font: font.	lastFullLineLength _ 500.	lines _ WriteStream on: (Array new: 10000).	paragraphs do: [:para |		para size = 0			ifTrue: [lines nextPut: para]			ifFalse: [				lastI _ 1.				[lastI < para size] whileTrue: [					QuickPaginate						ifTrue: [i _ self characterBasedBreakIndexAfter: lastI in: para]						ifFalse: [i _ self lineBreakIndexAfter: lastI in: para pixelWidth: pixelWidth].					lines nextPut: (para copyFrom: lastI to: i).					lastI _ i + 1]]].	^ lines contents! !!BookReader methodsFor: 'private-pagination' stamp: 'jm 1/16/2000 12:17'!linesPerPage	"Answer the maximum number of lines per page that can be displayed using the current font."	| lineHeight availableSpace |	lineHeight _ font height.	availableSpace _ pageExtent y - margins top.	availableSpace _ availableSpace - (1.4 * lineHeight).	^ (availableSpace // lineHeight) max: 1! !!BookReader methodsFor: 'private-pagination' stamp: 'jm 1/16/2000 11:45'!nextPageFrom: lineStream maxLines: maxLines	"Answer the next page from the given stream of strings. A page is an array of strings, one for each line of the page. Skip any leading blank lines and break the page if there are more than three blank lines in a row."	| blankLines page line |	blankLines _ 0.	page _ WriteStream on: (Array new: maxLines).	[lineStream atEnd not and:	 [(line _ lineStream next) isEmpty]]		whileTrue.  "skip any leading blank lines"	[lineStream atEnd not and:	 [page size < (maxLines - 1)]] whileTrue: [		page nextPut: line.		line size = 0			ifTrue: [				blankLines _ blankLines + 1.				blankLines = 4 ifTrue: [^ page contents]]			ifFalse: [				blankLines _ 0].		line _ lineStream next].	page nextPut: line.	^ page contents! !!BookReader methodsFor: 'private-pagination' stamp: 'jm 1/16/2000 19:29'!paginateForPageWidth: pixelWidth	"Break the given string into a collection of lines such that each line is no wider than pixelWidth when displayed using the current font. Attempt to break the lines between words."	| maxLines lines |	maxLines _ self linesPerPage.	charsPerLine _		((pageExtent x - margins left - margins right) //			(font widthOf: $o)) max: 1.	QuickPaginate ifNil: [QuickPaginate _ false].	pages _ OrderedCollection new: 1000.	lines _ ReadStream on: (self linesForPageWidth: pixelWidth).	[lines atEnd] whileFalse: [		pages addLast: (self nextPageFrom: lines maxLines: maxLines)].	pages _ pages asArray.! !!BookReader methodsFor: 'private-other' stamp: 'jm 1/12/2000 21:47'!findFontNamed: fontName desiredSize: desiredSize	"Find the of the given name closest to the given size."	| fName fontList closestFont closestFontDiff diff |	fName _ fontName asLowercase.	fontList _ StrikeFont allInstances select: [:f |		f name asLowercase beginsWith: fName].	fontList size = 0 ifTrue: [fontList _ StrikeFont allInstances].	closestFont _ nil.	closestFontDiff _ 10000.  "worse than any real size difference"	fontList do: [:f |		diff _ f height - desiredSize.		diff < 0 ifTrue: [diff _ 1 - diff].  "prefer to go up in size"		diff < closestFontDiff ifTrue: [			closestFont _ f.			closestFontDiff _ diff]].	^ closestFont! !!BookReader methodsFor: 'private-other' stamp: 'jm 1/15/2000 09:44'!goToPage: pageNumber	"Jump to the given page number in the book. Note that pagination depends on the current font size; the same book viewed in a larger font will have more pages."	currentPage _ pageNumber asInteger.	currentPage > pages size ifTrue: [currentPage _ pages size].	currentPage < 1 ifTrue: [currentPage _ 1].! !!BookReader methodsFor: 'private-other' stamp: 'jm 1/15/2000 17:19'!nextParagraphFrom: aStream	"Answer the next paragraph from the given stream. Paragraph breaks are triggered by either an empty line or a line beginning with white space."	| cr tab asciiSpace para ch |	cr _ Character cr.  "carriage return"	tab _ Character tab.	asciiSpace _ Character space asciiValue.	"a blank line by itself is an empty paragraph"	aStream peek = cr ifTrue: [aStream next. ^ ''].	para _ WriteStream on: (String new: 500).	[aStream atEnd] whileFalse: [		ch _ aStream next.		ch = cr			ifTrue: [				(aStream atEnd or: [aStream peek asciiValue <= asciiSpace])					ifTrue: [						"end paragraph if the next line starts with a cr or white space"						^ para contents]					ifFalse: [						"continue paragraph, replacing the cr with a space"						para space]]			ifFalse: [				((ch asciiValue >= asciiSpace) or: [ch == tab])				ifTrue: [para nextPut: ch]]].	^ para contents! !!BookReader class methodsFor: 'all' stamp: 'jm 9/30/2000 17:57'!openBookFileNamed: fileName	"Read the book whose text is in the given file."	"(BookReader openBookFileNamed: 'wiz.txt') interactionLoop"	"StrikeFont new readFromStrike2: 'Palatino24.sf2'"	| b s |	b _ BookReader new initialize.	s _ FileStream fileNamed: fileName.	b readTextFrom: s.	s close.	^ b! !Boolean is an abstract class defining the protocol for logic testing operations and conditional control structures for the logical values represented by the instances of its subclasses True and False.Boolean redefines #new so no instances of Boolean can be created. It also redefines several messages in the 'copying' protocol to ensure that only one instance of each of its subclasses True (the global true, logical assertion) and False (the global false, logical negation) ever exist in the system.!!Boolean methodsFor: 'copying' stamp: 'tk 6/26/1998 11:32'!clone 	"Receiver has two concrete subclasses, True and False.	Only one instance of each should be made, so return self."! !I can have a border of zero or more pixels and a fill color. I have many subclasses.!!BorderedMorph methodsFor: 'initialization' stamp: 'sw 11/29/1999 17:35'!initialize	super initialize.	borderColor _ Color black.	borderWidth _ 2! !!BorderedMorph methodsFor: 'accessing' stamp: 'di 6/4/1999 09:42'!borderWidth: anInteger	borderColor ifNil: [borderColor _ Color black].	borderWidth _ anInteger max: 0.	self changed! !!BorderedMorph methodsFor: 'accessing' stamp: 'sw 11/29/1999 17:52'!cornerStyle	^ self valueOfProperty: #cornerStyle ifAbsent: [#square]! !!BorderedMorph methodsFor: 'accessing' stamp: 'sw 11/29/1999 17:32'!cornerStyle: aSymbol	aSymbol == #square		ifTrue:			[self removeProperty: #cornerStyle]		ifFalse:			[self setProperty: #cornerStyle toValue: aSymbol].	self changed! !!BorderedMorph methodsFor: 'accessing' stamp: 'jm 10/14/2002 07:54'!doesBevels	"Return true if this object can show bevelled borders (i.e., can have #raised or #inset as valid borderColors). This method should be overridden to return false by subclasses that do not support bevelled borders, such as EllipseMorph."	^ true! !!BorderedMorph methodsFor: 'accessing' stamp: 'di 1/3/1999 12:24'!hasTranslucentColor	"Answer true if this any of this morph is translucent but not transparent."	(color isColor and: [color isTranslucentColor]) ifTrue: [^ true].	(borderColor isColor and: [borderColor isTranslucentColor]) ifTrue: [^ true].	^ false! !!BorderedMorph methodsFor: 'accessing' stamp: 'jm 10/14/2002 07:53'!isRectangular	"Return true if this morph is rectangular. Rectangular morphs may or may not have rounded corners. This method should be overridden to return false by non-rectangular subclasses such as EllipseMorph."	^ true! !!BorderedMorph methodsFor: 'accessing' stamp: 'sw 11/29/1999 17:36'!toggleCornerRounding	self cornerStyle == #rounded		ifTrue: [self useSquareCorners]		ifFalse: [self useRoundedCorners].	self changed! !!BorderedMorph methodsFor: 'accessing' stamp: 'sw 11/29/1999 17:36'!useRoundedCorners	self cornerStyle: #rounded! !!BorderedMorph methodsFor: 'accessing' stamp: 'sw 11/29/1999 17:37'!useSquareCorners	self cornerStyle: #square! !!BorderedMorph methodsFor: 'drawing' stamp: 'jm 10/9/2002 07:34'!areasRemainingToFill: aRectangle	(color isColor and: [color isTranslucent]) ifTrue: [^ Array with: aRectangle].	self isRectangular ifFalse: [^ Array with: aRectangle].	self wantsRoundedCorners	ifTrue: [(borderWidth > 0 and: [borderColor isColor and: [borderColor isTranslucent]])				ifTrue: [^ aRectangle areasOutside: (self innerBounds intersect: self boundsWithinCorners)]				ifFalse: [^ aRectangle areasOutside: self boundsWithinCorners]]	ifFalse: [(borderWidth > 0 and: [borderColor isColor and: [borderColor isTranslucent]])				ifTrue: [^ aRectangle areasOutside: self innerBounds]				ifFalse: [^ aRectangle areasOutside: self bounds]]! !!BorderedMorph methodsFor: 'drawing' stamp: 'di 3/25/2000 11:13'!boundsWithinCorners	^ CornerRounder rectWithinCornersOf: self bounds! !!BorderedMorph methodsFor: 'drawing' stamp: 'jm 11/24/2002 10:34'!drawOn: aCanvas 	"Draw a rectangle with a solid, inset, or raised border.	Note: the raised border color is generated from the receiver's own color,	while the inset border color is generated from the color of its owner.	This behavior is visually more consistent. Thanks to Hans-Martin Mosner."	| insetColor |	borderWidth = 0 ifTrue: [  "no border"		"Note: This is the hook for border styles.			When converting to the new borders we'll just put 0 into the borderWidth"		super drawOn: aCanvas.		^ self].	borderColor == #raised ifTrue: [		"Use a hack for now"		aCanvas fillRectangle: self bounds color: color.		^ aCanvas frameAndFillRectangle: bounds			fillColor: Color transparent			borderWidth: borderWidth			topLeftColor: (borderWidth = 1 ifTrue: [color twiceLighter]										ifFalse: [color lighter])			bottomRightColor: (borderWidth = 1 ifTrue: [color twiceDarker]										ifFalse: [color darker])].	borderColor == #inset ifTrue: [		insetColor _ owner colorForInsets.		aCanvas fillRectangle: self bounds color: color.		^ aCanvas frameAndFillRectangle: bounds			fillColor: Color transparent			borderWidth: borderWidth			topLeftColor: (borderWidth = 1 ifTrue: [insetColor twiceDarker]										ifFalse: [insetColor darker])			bottomRightColor: (borderWidth = 1 ifTrue: [insetColor twiceLighter]										ifFalse: [insetColor lighter])].	"solid color border"	aCanvas fillRectangle: (self bounds insetBy: borderWidth) color: color.	aCanvas frameAndFillRectangle: bounds		fillColor: Color transparent		borderWidth: borderWidth		borderColor: borderColor.! !!BorderedMorph methodsFor: 'drawing' stamp: 'jm 11/25/2002 15:47'!fullDrawOn: aCanvas	(self wantsRoundedCorners and: [self width > 15])		ifTrue: [self fullDrawWithRoundedCornersOn: aCanvas]		ifFalse: [super fullDrawOn: aCanvas].! !!BorderedMorph methodsFor: 'drawing' stamp: 'sw 11/6/1999 11:04'!fullDrawWithRoundedCornersOn: aCanvas	CornerRounder roundCornersOf: self on: aCanvas		displayBlock: [super fullDrawOn: aCanvas]		borderWidth: borderWidth! !!BorderedMorph methodsFor: 'drawing' stamp: 'sw 11/29/1999 17:34'!wantsRoundedCorners	^ self cornerStyle == #rounded! !!BorderedMorph methodsFor: 'menu' stamp: 'jm 10/9/2002 07:30'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addList: #(		('border color...' changeBorderColor:)		('border width...' changeBorderWidth:)).	self doesBevels ifTrue: [		borderColor == #raised ifFalse: [aCustomMenu add: 'raised bevel' action: #borderRaised].		borderColor == #inset ifFalse: [aCustomMenu add: 'inset bevel' action: #borderInset].		((borderColor == #raised) or: [borderColor == #inset]) ifTrue: [			aCustomMenu add: 'no bevel...' action: #changeBorderColor:]].	self isRectangular ifTrue: [		aCustomMenu addUpdating: #roundedCornersString target: self action: #toggleCornerRounding].! !!BorderedMorph methodsFor: 'menu' stamp: 'di 9/3/1999 09:17'!changeBorderColor: evt	| aHand |	aHand _ evt ifNotNil: [evt hand] ifNil: [self primaryHand].	aHand changeColorTarget: self selector: #borderColor: originalColor: self borderColor.! !!BorderedMorph methodsFor: 'menu' stamp: 'sw 11/29/1999 17:34'!roundedCornersString	"Answer the string to put in a menu that will invite the user to switch to the opposite  corner-rounding mode"	^ self cornerStyle  == #rounded		ifTrue:			['stop rounding corners']		ifFalse:			['start rounding corners']			! !!BorderedMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 17:26'!fieldsVersion	^ 1! !!BorderedMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 17:26'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		borderWidth		borderColor	) from: anObjStream.! !!BorderedMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 17:27'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		borderWidth		borderColor	) on: anObjStream.! !!BorderedMorph class methodsFor: 'as yet unclassified' stamp: 'jm 5/31/2003 20:03'!includeInNewMorphMenu	^ true! !This morph shows how an ideal gas simulation might work. When it gets step messages, it makes all its atom submorphs move along their velocity vectors, bouncing when they hit a wall. It also exercises the Morphic damage reporting and display architecture. Here are some things to try:  1. Resize this morph as the atoms bounce around.  2. In an inspector on this morph, evaluate "self addAtoms: 10."  3. Try setting quickRedraw to false in invalidRect:. This gives the     default damage reporting and incremental redraw. Try it for     100 atoms.  4. In the drawOn: method of AtomMorph, change drawAsRect to true.  5. Create a HeaterCoolerMorph and embed it in the simulation. Extract	it and use an inspector on it to evaluate "self velocityDelta: -5", then     re-embed it. Note the effect on atoms passing over it.!!BouncingAtomsMorph methodsFor: 'initialization' stamp: 'jm 7/30/97 09:45'!initialize	super initialize.	damageReported _ false.	self extent: 400@250.	self color: (Color r: 0.8 g: 1.0 b: 0.8).	infectionHistory _ OrderedCollection new.	transmitInfection _ false. 	self addAtoms: 30.! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'jm 6/28/1998 18:17'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'startInfection' action: #startInfection.	aCustomMenu add: 'set atom count' action: #setAtomCount.	aCustomMenu add: 'show infection history' action: #showInfectionHistory:.! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'jm 6/28/1998 18:04'!setAtomCount	| countString count |	countString _ FillInTheBlank		request: 'Number of atoms?'		initialAnswer: self submorphCount printString.	countString isEmpty ifTrue: [^ self].	count _ Integer readFrom: (ReadStream on: countString).	self removeAllMorphs.	self addAtoms: count.! !!BouncingAtomsMorph methodsFor: 'menu'!startInfection	self submorphsDo: [:m | m infected: false].	self firstSubmorph infected: true.	infectionHistory _ OrderedCollection new: 500.	transmitInfection _ true.	self startStepping.! !!BouncingAtomsMorph methodsFor: 'stepping' stamp: 'sw 7/15/1999 07:32'!step	"Bounce those atoms!!"	| r bounces |	super step.	bounces _ 0.	r _ bounds origin corner: (bounds corner - (8@8)).	self submorphsDo: [ :m |		(m isMemberOf: AtomMorph) ifTrue: [			(m bounceIn: r) ifTrue: [bounces _ bounces + 1]]].	"compute a 'temperature' that is proportional to the number of bounces	 divided by the circumference of the enclosing rectangle"	self updateTemperature: (10000.0 * bounces) / (r width + r height).	transmitInfection ifTrue: [self transmitInfection].! !!BouncingAtomsMorph methodsFor: 'stepping' stamp: 'jm 6/28/1998 18:10'!stepTime	"As fast as possible."	^ 0! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:10'!addAtoms: n	"Add a bunch of new atoms."	| a |	n timesRepeat: [		a _ AtomMorph new.		a randomPositionIn: bounds maxVelocity: 10.		self addMorph: a].	self stopStepping.! !!BouncingAtomsMorph methodsFor: 'other'!addMorphFront: aMorph	"Called by the 'embed' meta action. We want non-atoms to go to the back."	"Note: A user would not be expected to write this method. However, a sufficiently advanced user (e.g, an e-toy author) might do something equivalent by overridding the drag-n-drop messages when they are implemented."	(aMorph isMemberOf: AtomMorph)		ifTrue: [super addMorphFront: aMorph]		ifFalse: [super addMorphBack: aMorph].! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'di 1/4/1999 20:22'!areasRemainingToFill: aRectangle	color isTranslucent		ifTrue: [^ Array with: aRectangle]		ifFalse: [^ aRectangle areasOutside: self bounds]! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'ls 10/10/1999 13:59'!collisionPairs	"Return a list of pairs of colliding atoms, which are assumed to becircles of known radius. This version uses the morph's positions--i.e.the top-left of their bounds rectangles--rather than their centers."	| count sortedAtoms radius twoRadii radiiSquared collisions p1 continuej p2 distSquared m1 m2 |	count _ submorphs size.	sortedAtoms _ submorphs asSortedCollection:		[ :mt1 :mt2 | mt1 position x < mt2 position x].	radius _ 8.	twoRadii _ 2 * radius.	radiiSquared _ radius squared * 2.	collisions _ OrderedCollection new.	1 to: count - 1 do: [ :i |		m1 _ sortedAtoms at: i.		p1 _ m1 position.		continue _ (j _ i + 1) <= count.		[continue] whileTrue: [			m2 _ sortedAtoms at: j.			p2 _ m2 position.			(p2 x - p1 x) <= twoRadii  ifTrue: [				distSquared _ (p1 x - p2 x) squared + (p1 y - p2 y) squared.				distSquared < radiiSquared ifTrue: [					collisions add: (Array with: m1 with: m2)].				continue _ (j _ j + 1) <= count.			] ifFalse: [				continue _ false.			].		].	].	^ collisions! !!BouncingAtomsMorph methodsFor: 'other'!drawOn: aCanvas	"Clear the damageReported flag when redrawn."	super drawOn: aCanvas.	damageReported _ false.! !!BouncingAtomsMorph methodsFor: 'other'!invalidRect: damageRect	"Try setting 'quickRedraw' to true. This invalidates the entire morph, whose bounds typically subsume all it's submorphs. (However, this code checks that assumption and passes through any damage reports for out-of-bounds submorphs. Note that atoms with super-high velocities do occaisionally shoot through the walls!!) An additional optimization is to only submit only damage report per display cycle by using the damageReported flag, which is reset to false when the morph is drawn."	| quickRedraw |	quickRedraw _ true.  "false gives the original invalidRect: behavior"	(quickRedraw and:	 [(bounds origin <= damageRect topLeft) and:	 [damageRect bottomRight <= bounds corner]]) ifTrue: [		"can use quick redraw if damage is within my bounds"		damageReported ifFalse: [super invalidRect: bounds].  "just report once"		damageReported _ true.	] ifFalse: [super invalidRect: damageRect].  "ordinary damage report"! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:31'!showInfectionHistory: evt	"Place a graph of the infection history in the world."	| graph |	infectionHistory isEmpty ifTrue: [^ self].	graph _ GraphMorph new data: infectionHistory.	graph extent: ((infectionHistory size + (2 * graph borderWidth) + 5)@(infectionHistory last max: 50)).	evt hand attachMorph: graph.! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:20'!transmitInfection	| infected count |	self collisionPairs do: [:pair |		infected _ false.		pair do: [:atom | atom infected ifTrue: [infected _ true]].		infected			ifTrue: [pair do: [:atom | atom infected: true]]].	count _ 0.	self submorphsDo: [:m | m infected ifTrue: [count _ count + 1]].	infectionHistory addLast: count.	count = submorphs size ifTrue: [		transmitInfection _ false.		self stopStepping].! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 8/10/1998 18:32'!updateTemperature: currentTemperature	"Record the current temperature, which is taken to be the number of atoms that have bounced in the last cycle. To avoid too much jitter in the reading, the last several readings are averaged."	recentTemperatures == nil ifTrue: [		recentTemperatures _ OrderedCollection new.		20 timesRepeat: [recentTemperatures add: 0]].	recentTemperatures removeLast.	recentTemperatures addFirst: currentTemperature.	temperature _ recentTemperatures sum asFloat / recentTemperatures size.! !!BouncingAtomsMorph class methodsFor: 'instance creation' stamp: 'jm 6/1/2003 20:48'!includeInNewMorphMenu	^ true! !Used for compiling and decompiling brace constructs.These now compile into either a fast short form for 4 elements or less:	Array braceWith: a with: b ... or a long form of indefinfite length:	(Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray.The erstwhile brace assignment form is no longer supported.!!BraceNode methodsFor: 'initialize-release' stamp: 'di 11/19/1999 11:06'!matchBraceStreamReceiver: receiver messages: messages	((receiver isMessage: #braceStream: receiver: nil arguments: [:arg | arg isConstantNumber])		and: [messages last isMessage: #braceArray receiver: nil arguments: nil])		ifFalse: [^ nil "no match"].	"Appears to be a long form brace construct"	self elements: (messages allButLast collect:		[:msg | (msg isMessage: #nextPut: receiver: nil arguments: nil)					ifFalse: [^ nil "not a brace element"].		msg arguments first])! !!BraceNode methodsFor: 'initialize-release' stamp: 'di 11/19/1999 11:19'!matchBraceWithReceiver: receiver selector: selector arguments: arguments	selector = (self selectorForShortForm: arguments size)		ifFalse: [^ nil "no match"].	"Appears to be a short form brace construct"	self elements: arguments! !!BraceNode methodsFor: 'code generation' stamp: 'di 11/19/1999 08:58'!emitForValue: stack on: aStream	^ emitNode emitForValue: stack on: aStream! !!BraceNode methodsFor: 'code generation' stamp: 'di 1/4/2000 11:24'!selectorForShortForm: nElements	nElements > 4 ifTrue: [^ nil].	^ #(braceWithNone braceWith: braceWith:with:			braceWith:with:with: braceWith:with:with:with:) at: nElements + 1! !!BraceNode methodsFor: 'code generation' stamp: 'di 11/19/1999 11:13'!sizeForValue: encoder	emitNode _ elements size <= 4		ifTrue: ["Short form: Array braceWith: a with: b ... "				MessageNode new					receiver: (encoder encodeVariable: #Array)					selector: (self selectorForShortForm: elements size)					arguments: elements precedence: 3 from: encoder]		ifFalse: ["Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray"				CascadeNode new					receiver: (MessageNode new								receiver: (encoder encodeVariable: #Array)								selector: #braceStream:								arguments: (Array with: (encoder encodeLiteral: elements size))								precedence: 3 from: encoder)					messages: ((elements collect: [:elt | MessageNode new receiver: nil														selector: #nextPut:														arguments: (Array with: elt)														precedence: 3 from: encoder])								copyWith: (MessageNode new receiver: nil														selector: #braceArray														arguments: (Array new)														precedence: 1 from: encoder))].	^ emitNode sizeForValue: encoder! !!BraceNode methodsFor: 'printing' stamp: 'di 11/19/1999 09:17'!printOn: aStream indent: level	aStream nextPut: ${.	1 to: elements size do: 		[:i | (elements at: i) printOn: aStream indent: level.		i < elements size ifTrue: [aStream nextPutAll: '. ']].	aStream nextPut: $}! !!BraceNode class methodsFor: 'examples' stamp: 'di 11/19/1999 09:05'!example	"Test the {a. b. c} syntax."	| x |	x _ {1. {2. 3}. 4}.	^ {x first. x second first. x second last. x last. 5} as: Set"BraceNode example Set (0 1 2 3 4 5 )"! !I represent a query path into the class descriptions, the software of the system.!!Browser methodsFor: 'initialize-release' stamp: 'di 4/13/1999 13:54'!buildCommentSwitchView	| aSwitchView |	aSwitchView _ PluggableButtonView		on: self		getState: #classCommentIndicated		action: #plusButtonHit.	aSwitchView		label: '?' asText allBold;		borderWidthLeft: 0 right: 1 top: 0 bottom: 0;			window: (0@0 extent: 10@8);		askBeforeChanging: true.	^ aSwitchView! !!Browser methodsFor: 'initialize-release' stamp: 'di 4/13/1999 14:05'!buildMorphicSwitches	| instanceSwitch commentSwitch classSwitch row aColor |	instanceSwitch _ PluggableButtonMorph		on: self		getState: #instanceMessagesIndicated		action: #indicateInstanceMessages.	instanceSwitch		label: 'instance';		askBeforeChanging: true.	commentSwitch _ PluggableButtonMorph		on: self		getState: #classCommentIndicated		action: #plusButtonHit.	commentSwitch		label: '?' asText allBold;		askBeforeChanging: true;		setBalloonText: 'class comment'.	classSwitch _ PluggableButtonMorph		on: self		getState: #classMessagesIndicated		action: #indicateClassMessages.	classSwitch		label: 'class';		askBeforeChanging: true.	row _ AlignmentMorph newRow		hResizing: #spaceFill;		vResizing: #spaceFill;		inset: 0;		borderColor: Color transparent;		addMorphBack: instanceSwitch;		addMorphBack: commentSwitch;		addMorphBack: classSwitch.	aColor _ Color colorFrom: self defaultBackgroundColor.	row submorphs do:		[:m | m color: aColor.		m onColor: aColor darker offColor: aColor].	^ row! !!Browser methodsFor: 'initialize-release' stamp: 'sbw 12/8/1999 12:32'!buildOptionalButtonsView	| aView buttonView offset bWidth bHeight first previousView |	aView _ View new model: self.	bHeight _ self optionalButtonHeight.	aView window: (0 @ 0 extent: 200 @ bHeight).	offset _ 0.	first _ true.	previousView _ nil.	self optionalButtonPairs do: [:pair |		buttonView _ PluggableButtonView on: self			getState: nil			action: pair last.		buttonView			label: pair first asParagraph.		bWidth _ buttonView label boundingBox width // 2.  "Need something more deterministic."		buttonView window: (offset@0 extent: bWidth@bHeight).		offset _ offset + bWidth + 0.		first			ifTrue:				[aView addSubView: buttonView.				first _ false]			ifFalse:				[buttonView borderWidthLeft: 1 right: 0 top: 0 bottom: 0.				aView addSubView: buttonView toRightOf: previousView]. 		previousView _ buttonView].	^ aView! !!Browser methodsFor: 'initialize-release' stamp: 'sw 1/13/2000 16:45'!defaultBrowserTitle	^ 'System Browser'! !!Browser methodsFor: 'initialize-release' stamp: 'sw 9/22/1999 17:13'!methodCategoryChanged	self changed: #messageCategoryList.	self changed: #messageList.	self changed: #annotation.	self messageListIndex: 0! !!Browser methodsFor: 'initialize-release' stamp: 'jm 10/11/2002 08:42'!openAsMorphClassEditing: editString	"Create a pluggable version a Browser on just a single class."	| window switches codePane baseline aTextMorph |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #classListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #classListMenu: keystroke: #classListKey:from:)		frame: (0@0 extent: 0.5@0.06).	switches _ self buildMorphicSwitches.	window addMorph: switches frame: (0.5@0 extent: 0.5@0.06).	switches borderWidth: 0.	window addMorph: (PluggableMessageCategoryListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu: keystroke: #arrowKey:from: getRawListSelector: #rawMessageCategoryList)		frame: (0@0.06 extent: 0.5@0.30).	window addMorph: (PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:)		frame: (0.5@0.06 extent: 0.5@0.30).	Preferences useAnnotationPanes		ifFalse:			[baseline _ 0.36]		ifTrue:			[aTextMorph _ PluggableTextMorph on: self					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.36 corner: 1@0.41).			baseline _ 0.41].	Preferences optionalButtons		ifTrue:			[window addMorph: self optionalButtonRow frame: ((0@baseline corner: 1 @ (baseline + 0.08))).			baseline _ baseline + 0.08].	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@baseline corner: 1@1).	window setUpdatablePanesFrom: #(messageCategoryList messageList).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'jm 10/11/2002 08:43'!openAsMorphEditing: editString	"Create a pluggable version of all the morphs for a Browser in Morphic"	| window switches codePane aListMorph baseline aTextMorph |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #systemCategoryList			selected: #systemCategoryListIndex changeSelected: #systemCategoryListIndex:			menu: #systemCategoryMenu: keystroke: #systemCatListKey:from:)		frame: (0@0 extent: 0.25@0.4).	window addMorph: (PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu: keystroke: #classListKey:from:)		frame: (0.25@0 extent: 0.25@0.3).	switches _ self buildMorphicSwitches.	window addMorph: switches frame: (0.25@0.3 extent: 0.25@0.1).	switches borderWidth: 0.	window addMorph: (PluggableMessageCategoryListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu: keystroke: #arrowKey:from: getRawListSelector: #rawMessageCategoryList)		frame: (0.5@0 extent: 0.25@0.4).	aListMorph _ PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0.75@0 extent: 0.25@0.4).	Preferences useAnnotationPanes		ifFalse:			[baseline _ 0.4]		ifTrue:			[aTextMorph _ PluggableTextMorph on: self					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.4 corner: 1@0.45).			baseline _ 0.45].	Preferences optionalButtons		ifTrue:			[window addMorph: self optionalButtonRow frame: ((0@baseline corner: 1 @ (baseline + 0.08))).			baseline _ baseline + 0.08].	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0 @ baseline corner: 1 @ 1).	window setUpdatablePanesFrom: #(systemCategoryList classList messageCategoryList messageList).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'jm 10/11/2002 08:45'!openAsMorphMessageEditing: editString	"Create a pluggable version a Browser that shows just one message"	| window codePane baseline aTextMorph |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #messageListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:)		frame: (0@0 extent: 1.0@0.06).	Preferences useAnnotationPanes		ifFalse:			[baseline _ 0.06]		ifTrue:			[aTextMorph _ PluggableTextMorph on: self					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.06 corner: 1@0.11).			baseline _ 0.11].	Preferences optionalButtons ifTrue: [		window addMorph: self optionalButtonRow frame: ((0@baseline corner: 1 @ (baseline + 0.08))).		baseline _ baseline + 0.08].	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@baseline corner: 1@1).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'jm 10/11/2002 08:45'!openAsMorphMsgCatEditing: editString	"Create a pluggable version a Browser on just a messageCategory."	| window codePane baseline aTextMorph |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #messageCatListSingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #messageCategoryMenu:)		frame: (0@0 extent: 1.0@0.06).	window addMorph: (PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:)		frame: (0@0.06 extent: 1.0@0.30).	Preferences useAnnotationPanes		ifFalse:			[baseline _ 0.30]		ifTrue:			[aTextMorph _ PluggableTextMorph on: self					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.30 corner: 1@0.35).			baseline _ 0.35].	Preferences optionalButtons		ifTrue:			[window addMorph: self optionalButtonRow frame: ((0@baseline corner: 1 @ (baseline + 0.08))).			baseline _ baseline + 0.08].	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@baseline corner: 1@1).	window setUpdatablePanesFrom: #(messageCatListSingleton messageList).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'jm 10/11/2002 08:46'!openAsMorphSysCatEditing: editString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| window switches codePane baseline aTextMorph |	window _ (SystemWindow labelled: 'later') model: self.	window addMorph: (PluggableListMorph on: self list: #systemCategorySingleton			selected: #indexIsOne changeSelected: #indexIsOne:			menu: #systemCatSingletonMenu: keystroke: #systemCatSingletonKey:from:)		frame: (0@0 extent: 1.0@0.06).	window addMorph: (PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu: keystroke: #classListKey:from:)		frame: (0@0.06 extent: 0.3333@0.24).	switches _ self buildMorphicSwitches.	window addMorph: switches frame: (0@0.3 extent: 0.3333@0.06).	switches borderWidth: 0.	window addMorph: (PluggableMessageCategoryListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu: keystroke: #arrowKey:from:	 getRawListSelector: #rawMessageCategoryList)		frame: (0.3333@0.06 extent: 0.3333@0.30).	window addMorph: (PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:)		frame: (0.6666@0.06 extent: 0.3333@0.30).	Preferences useAnnotationPanes		ifFalse: 	[baseline _ 0.36]		ifTrue: [baseline _ 0.41.			aTextMorph _ PluggableTextMorph on: self					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.36 corner: 1@baseline)].	Preferences optionalButtons		ifTrue:			[window addMorph: self optionalButtonRow frame: ((0@baseline corner: 1 @ (baseline + 0.08))).			baseline _ baseline + 0.08].	codePane _ PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	editString ifNotNil: [codePane editString: editString.					codePane hasUnacceptedEdits: true].	window addMorph: codePane		frame: (0@baseline corner: 1@1).	window setUpdatablePanesFrom: #( classList messageCategoryList messageList).	^ window! !!Browser methodsFor: 'initialize-release' stamp: 'sma 4/30/2000 09:20'!openEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| systemCategoryListView classListView 	messageCategoryListView messageListView browserCodeView topView switchView underPane y optionalButtonsView annotationPane |	Smalltalk isMorphic ifTrue: [^ self openAsMorphEditing: aString].	"Sensor leftShiftDown ifTrue: [^ self openAsMorphEditing: aString].		uncomment-out for testing morphic browser embedded in mvc project"	topView _ StandardSystemView new model: self.	topView borderWidth: 1. "label and minSize taken care of by caller"	systemCategoryListView _ PluggableListView on: self		list: #systemCategoryList		selected: #systemCategoryListIndex		changeSelected: #systemCategoryListIndex:		menu: #systemCategoryMenu:		keystroke: #systemCatListKey:from:.	systemCategoryListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: systemCategoryListView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:		keystroke: #classListKey:from:.	classListView window: (0 @ 0 extent: 50 @ 62).	topView addSubView: classListView toRightOf: systemCategoryListView.	switchView _ self buildInstanceClassSwitchView.	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView window: (0 @ 0 extent: 50 @ 70).	messageListView menuTitleSelector: #messageListSelectorTitle.	topView addSubView: messageListView toRightOf: messageCategoryListView.	Preferences useAnnotationPanes		ifTrue:			[annotationPane _ PluggableTextView on: self				text: #annotation accept: nil				readSelection: nil menu: nil.			annotationPane window: (0@0 extent: 200@self optionalAnnotationHeight).			topView addSubView: annotationPane below: systemCategoryListView.			underPane _ annotationPane.			y _ 110 - self optionalAnnotationHeight]		ifFalse: [			underPane _ systemCategoryListView.			y _ 110].	Preferences optionalButtons ifTrue:		[optionalButtonsView _ self buildOptionalButtonsView.		optionalButtonsView borderWidth: 1.		topView addSubView: optionalButtonsView below: underPane.		underPane _ optionalButtonsView.		y _ y - self optionalButtonHeight].	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@y).	topView addSubView: browserCodeView below: underPane.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	topView setUpdatablePanesFrom: #(systemCategoryList classList messageCategoryList messageList).	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'sma 4/30/2000 09:20'!openMessageCatEditString: aString	"Create a pluggable version of the views for a Browser that just shows one message category."	| messageCategoryListView messageListView browserCodeView topView annotationPane underPane y optionalButtonsView |	Smalltalk isMorphic ifTrue: [^ self openAsMorphMsgCatEditing: aString].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	messageCategoryListView _ PluggableListView on: self		list: #messageCatListSingleton		selected: #indexIsOne 		changeSelected: #indexIsOne:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 200 @ 12).	topView addSubView: messageCategoryListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView menuTitleSelector: #messageListSelectorTitle.	messageListView window: (0 @ 0 extent: 200 @ 70).	topView addSubView: messageListView below: messageCategoryListView.	Preferences useAnnotationPanes		ifTrue:			[annotationPane _ PluggableTextView on: self				text: #annotation accept: nil				readSelection: nil menu: nil.			annotationPane window: (0@0 extent: 200@self optionalAnnotationHeight).			topView addSubView: annotationPane below: messageListView.			underPane _ annotationPane.			y _ (200 - 12 - 70) - self optionalAnnotationHeight]		ifFalse:			[underPane _ messageListView.			y _ (200 - 12 - 70)].	Preferences optionalButtons ifTrue:		[optionalButtonsView _ self buildOptionalButtonsView.		optionalButtonsView borderWidth: 1.		topView addSubView: optionalButtonsView below: underPane.		underPane _ optionalButtonsView.		y _ y - self optionalButtonHeight].	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@y).	topView addSubView: browserCodeView below: underPane.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	topView setUpdatablePanesFrom: #(messageCatListSingleton messageList).	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'sma 4/30/2000 09:21'!openMessageEditString: aString	"Create a pluggable version of the views for a Browser that just shows one message."	| messageListView browserCodeView topView annotationPane underPane y |	Smalltalk isMorphic ifTrue: [^ self openAsMorphMessageEditing: aString].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	messageListView _ PluggableListView on: self		list: #messageListSingleton		selected: #indexIsOne 		changeSelected: #indexIsOne:		menu: #messageListMenu:shifted:.	messageListView window: (0 @ 0 extent: 200 @ 12).	topView addSubView: messageListView.	Preferences useAnnotationPanes		ifTrue:			[annotationPane _ PluggableTextView on: self				text: #annotation accept: nil				readSelection: nil menu: nil.			annotationPane window: (0@0 extent: 200@self optionalAnnotationHeight).			topView addSubView: annotationPane below: messageListView.			underPane _ annotationPane.			y _ (200 - 12) - self optionalAnnotationHeight]		ifFalse:			[underPane _ messageListView.			y _ 200 - 12].	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@y).	topView addSubView: browserCodeView below: underPane.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'sma 4/30/2000 09:21'!openOnClassWithEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers."	| classListView messageCategoryListView messageListView browserCodeView topView switchView annotationPane underPane y optionalButtonsView |	Smalltalk isMorphic ifTrue: [^ self openAsMorphClassEditing: aString].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	classListView _ PluggableListView on: self		list: #classListSingleton		selected: #indexIsOne 		changeSelected: #indexIsOne:		menu: #classListMenu:		keystroke: #classListKey:from:.	classListView window: (0 @ 0 extent: 100 @ 12).	topView addSubView: classListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 100 @ 70).	topView addSubView: messageCategoryListView below: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView menuTitleSelector: #messageListSelectorTitle.	messageListView window: (0 @ 0 extent: 100 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	switchView _ self buildInstanceClassSwitchView.	switchView borderWidth: 1.	switchView 		window: switchView window 		viewport: (classListView viewport topRight 					corner: messageListView viewport topRight).	topView addSubView: switchView toRightOf: classListView.	Preferences useAnnotationPanes		ifTrue:			[annotationPane _ PluggableTextView on: self				text: #annotation accept: nil				readSelection: nil menu: nil.			annotationPane window: (0@0 extent: 200@self optionalAnnotationHeight).			topView addSubView: annotationPane below: messageCategoryListView.			underPane _ annotationPane.			y _ (200-12-70) - self optionalAnnotationHeight]		ifFalse:			[underPane _ messageCategoryListView.			y _ (200-12-70)].	Preferences optionalButtons ifTrue:		[optionalButtonsView _ self buildOptionalButtonsView.		optionalButtonsView borderWidth: 1.		topView addSubView: optionalButtonsView below: underPane.		underPane _ optionalButtonsView.		y _ y - self optionalButtonHeight].	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@y).	topView addSubView: browserCodeView below: underPane.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	topView setUpdatablePanesFrom: #(messageCategoryList messageList).	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'sma 4/30/2000 09:21'!openSystemCatEditString: aString	"Create a pluggable version of all the views for a Browser, including views and controllers.  The top list view is of the currently selected system class category--a single item list."	| systemCategoryListView classListView messageCategoryListView messageListView browserCodeView topView switchView y annotationPane underPane optionalButtonsView |	Smalltalk isMorphic ifTrue: [^ self openAsMorphSysCatEditing: aString].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.		"label and minSize taken care of by caller"	systemCategoryListView _ PluggableListView on: self		list: #systemCategorySingleton		selected: #indexIsOne 		changeSelected: #indexIsOne:		menu: #systemCatSingletonMenu:		keystroke: #systemCatSingletonKey:from:.	systemCategoryListView window: (0 @ 0 extent: 200 @ 12).	topView addSubView: systemCategoryListView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:		keystroke: #classListKey:from:.	classListView window: (0 @ 0 extent: 67 @ 62).	topView addSubView: classListView below: systemCategoryListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 66 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	switchView _ self buildInstanceClassSwitchView.	switchView 		window: switchView window 		viewport: (classListView viewport bottomLeft 					corner: messageCategoryListView viewport bottomLeft).	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	messageListView menuTitleSelector: #messageListSelectorTitle.	messageListView window: (0 @ 0 extent: 67 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	Preferences useAnnotationPanes		ifTrue: [			annotationPane _ PluggableTextView on: self				text: #annotation accept: nil				readSelection: nil menu: nil.			annotationPane window: (0@0 extent: 200@self optionalAnnotationHeight).			topView addSubView: annotationPane below: switchView.			y _ 110 - 12 - self optionalAnnotationHeight.			underPane _ annotationPane]		ifFalse: [			y _ 110 - 12.			underPane _ switchView].	Preferences optionalButtons ifTrue:		[optionalButtonsView _ self buildOptionalButtonsView.		optionalButtonsView borderWidth: 1.		topView addSubView: optionalButtonsView below: underPane.		underPane _ optionalButtonsView.		y _ y - self optionalButtonHeight].	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: 200@y).	topView addSubView: browserCodeView below: underPane.	aString ifNotNil: [browserCodeView editString: aString.			browserCodeView hasUnacceptedEdits: true].	topView setUpdatablePanesFrom: #(classList messageCategoryList messageList).	^ topView! !!Browser methodsFor: 'initialize-release' stamp: 'sbw 12/8/1999 12:37'!optionalAnnotationHeight	^ 10! !!Browser methodsFor: 'initialize-release' stamp: 'sbw 12/8/1999 12:23'!optionalButtonHeight	^ 10! !!Browser methodsFor: 'initialize-release' stamp: 'sbw 12/8/1999 06:49'!optionalButtonPairs	^#(('senders' 		browseSendersOfMessages)	('implementors'		browseMessages)	('versions'			browseVersions)	('inheritance'		methodHierarchy)	('hierarchy'		classHierarchy)	('inst vars'			browseInstVarRefs)	('class vars'			browseClassVarRefs))! !!Browser methodsFor: 'initialize-release' stamp: 'jm 10/13/2002 18:05'!optionalButtonRow	| aRow aButton |	aRow _ AlignmentMorph newRow.	aRow isSticky: true.	aRow hResizing: #spaceFill.	aRow centering: #center.	aRow setProperty: #clipToOwnerWidth toValue: true.	aRow addTransparentSpacerOfSize: (5@0).	self optionalButtonPairs  do:			[:pair |				aButton _ PluggableButtonMorph					on: self					getState: nil					action: pair second.				aButton useRoundedCorners;					label: pair first asString;					onColor: Color transparent offColor: Color transparent.				aRow addMorphBack: aButton.				aRow addTransparentSpacerOfSize: (3 @ 0)].	aRow addMorphBack: self diffButton.	^ aRow! !!Browser methodsFor: 'initialize-release' stamp: 'm3r 3/5/1999 22:58'!setClass: aBehavior selector: aSymbol	"Set the state of a new, uninitialized Browser."	| isMeta aClass systemCatIndex messageCatIndex |	aBehavior ifNil: [^ self].	(aBehavior isKindOf: Metaclass)		ifTrue: [isMeta _ true. aClass _ aBehavior soleInstance]		ifFalse: [isMeta _ false. aClass _ aBehavior].	systemCatIndex _ SystemOrganization categories indexOf: aClass category.	self systemCategoryListIndex: systemCatIndex.	self classListIndex:			((SystemOrganization listAtCategoryNumber: systemCatIndex)					indexOf: aClass name).	self metaClassIndicated: isMeta.	aSymbol ifNil: [^ self].	messageCatIndex _ aBehavior organization numberOfCategoryOfElement: aSymbol.	self messageCategoryListIndex: messageCatIndex + 1. "<- FIXED offset"	messageCatIndex = 0 ifTrue: [^ self].	self messageListIndex:			((aBehavior organization listAtCategoryNumber: messageCatIndex)					indexOf: aSymbol)! !!Browser methodsFor: 'initialize-release' stamp: 'sw 5/26/1999 23:46'!setSelector: aSymbol	"Make the receiver point at the given selector, in the currently chosen class"	| aClass messageCatIndex |	aSymbol ifNil: [^ self].	(aClass _ self selectedClassOrMetaClass) ifNil: [^ self].	messageCatIndex _ aClass organization numberOfCategoryOfElement: aSymbol.	self messageCategoryListIndex: messageCatIndex + 1.	messageCatIndex = 0 ifTrue: [^ self].	self messageListIndex:			((aClass organization listAtCategoryNumber: messageCatIndex)					indexOf: aSymbol)! !!Browser methodsFor: 'initialize-release' stamp: 'sw 11/8/1999 13:36'!systemCatSingletonKey: aChar from: aView	^ self messageListKey: aChar from: aView! !!Browser methodsFor: 'accessing' stamp: 'sw 5/4/2000 20:22'!contents	"Depending on the current selection, different information is retrieved.	Answer a string description of that information. This information is the	method of the currently selected class and message."	| comment theClass latestCompiledMethod |	latestCompiledMethod _ currentCompiledMethod.	currentCompiledMethod _ nil.	editSelection == #none ifTrue: [^ ''].	editSelection == #editSystemCategories 		ifTrue: [^ systemOrganizer printString].	editSelection == #newClass 		ifTrue: [^ (theClass _ self selectedClassOrMetaClass)			ifNil:				[Class template: self selectedSystemCategoryName]			ifNotNil:				[Class templateForSubclassOf: theClass category: self selectedSystemCategoryName]].	editSelection == #editClass 		ifTrue: [^ self selectedClassOrMetaClass definition].	editSelection == #editComment 		ifTrue: [(theClass _ self selectedClass) ifNil: [^ ''].				comment _ theClass comment.				comment size = 0				ifTrue: [^ 'This class has not yet been commented.']				ifFalse: [^ comment]].	editSelection == #hierarchy 		ifTrue: [^ self selectedClassOrMetaClass printHierarchy].	editSelection == #editMessageCategories 		ifTrue: [^ self classOrMetaClassOrganizer printString].	editSelection == #newMessage		ifTrue: [^ self selectedClassOrMetaClass sourceCodeTemplate].	editSelection == #editMessage		ifTrue:			[currentCompiledMethod _ latestCompiledMethod.			^ self selectedMessage].	editSelection == #byteCodes ifTrue:		[^ (self selectedClassOrMetaClass compiledMethodAt: self selectedMessageName)			symbolic asText].	self error: 'Browser internal error: unknown edit selection.'! !!Browser methodsFor: 'accessing' stamp: 'sw 9/30/1999 13:19'!contents: input notifying: aController 	"The retrieved information has changed and its source must now be	 updated. The information can be a variety of things, depending on	 the list selections (such as templates for class or message definition,	 methods) or the user menu commands (such as definition, comment,	 hierarchy).  Answer the result of updating the source."	| aString aText theClass |	self changed: #annotation.	aString _ input asString.	aText _ input asText.	editSelection == #editSystemCategories ifTrue: [^ self changeSystemCategories: aString].	editSelection == #editClass | (editSelection == #newClass) ifTrue: [^ self defineClass: aString notifying: aController].	editSelection == #editComment		ifTrue: 			[theClass _ self selectedClass.			theClass				ifNil: 					[PopUpMenu notify: 'You must select a classbefore giving it a comment.'.					^ false].			theClass comment: aText stamp: Utilities changeStamp.			^ true].	editSelection == #hierarchy ifTrue: [^ true].	editSelection == #editMessageCategories ifTrue: [^ self changeMessageCategories: aString].	editSelection == #editMessage | (editSelection == #newMessage)		ifTrue:			[^ self okayToAccept				ifFalse:					[false]				ifTrue:					[self compileMessage: aText notifying: aController]].	editSelection == #none		ifTrue: 			[PopUpMenu notify: 'This text cannot be acceptedin this part of the browser.'.			^ false].	self error: 'unacceptable accept'! !!Browser methodsFor: 'accessing' stamp: 'di 6/21/1998 22:20'!couldBrowseAnyClass	"Answer whether the receiver is equipped to browse any class. This is in support of the system-brower feature that allows the browser to be redirected at the selected class name.  This implementation is clearly ugly, but the feature it enables is handsome enough.  3/1/96 sw"	self dependents		detect: [:d |			((d isKindOf: PluggableListView) or: [d isKindOf: PluggableListMorph]) and: 			[d getListSelector == #systemCategoryList]]		ifNone: [^ false].	^ true! !!Browser methodsFor: 'accessing' stamp: 'sma 5/28/2000 11:28'!doItReceiver	"This class's classPool has been jimmied to be the classPool of the class 	being browsed. A doIt in the code pane will let the user see the value of 	the class variables."	^ self selectedClass ifNil: [FakeClassPool new]! !!Browser methodsFor: 'accessing' stamp: 'sw 10/30/1999 22:59'!noteSelectionIndex: anInteger for: aSymbol	aSymbol == #systemCategoryList		ifTrue:			[systemCategoryListIndex _ anInteger].	aSymbol == #classList		ifTrue:			[classListIndex _ anInteger].	aSymbol == #messageCategoryList		ifTrue:			[messageCategoryListIndex _ anInteger].	aSymbol == #messageList		ifTrue:			[messageListIndex _ anInteger].! !!Browser methodsFor: 'system category list' stamp: 'stp 01/13/2000 12:25'!selectCategoryForClass: theClass	self systemCategoryListIndex: (self systemCategoryList indexOf: theClass category)! !!Browser methodsFor: 'system category list' stamp: 'di 12/6/1999 20:11'!selectedEnvironment	"Answer the name of the selected system category or nil."	systemCategoryListIndex = 0 ifTrue: [^nil].	^ Smalltalk environmentForCategory: self selectedSystemCategoryName! !!Browser methodsFor: 'system category list' stamp: 'sw 1/28/1999 12:30'!systemCategoryListIndex: anInteger 	"Set the selected system category index to be anInteger. Update all other 	selections to be deselected."	systemCategoryListIndex _ anInteger.	classListIndex _ 0.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	editSelection _ anInteger = 0 ifTrue: [#none] ifFalse: [#newClass].	metaClassIndicated _ false.	self setClassOrganizer.	contents _ nil.	self changed: #systemCategorySelectionChanged.	self changed: #systemCategoryListIndex.	"update my selection"	self changed: #classList.	self changed: #messageCategoryList.	self changed: #messageList.	self contentsChanged.! !!Browser methodsFor: 'system category functions' stamp: 'sw 1/28/1999 12:30'!editSystemCategories	"Retrieve the description of the class categories of the system organizer."	self okToChange ifFalse: [^ self].	self systemCategoryListIndex: 0.	editSelection _ #editSystemCategories.	self changed: #editSystemCategories.	self contentsChanged! !!Browser methodsFor: 'system category functions' stamp: 'stp 01/13/2000 12:26'!findClass	"Search for a class by name."	| pattern foundClass classNames index toMatch exactMatch potentialClassNames |	self okToChange ifFalse: [^ self classNotFound].	pattern _ FillInTheBlank request: 'Class name or fragment?'.	pattern isEmpty ifTrue: [^ self classNotFound].	toMatch _ (pattern copyWithout: $.) asLowercase.	potentialClassNames _ self potentialClassNames asOrderedCollection.	classNames _ pattern last = $. 		ifTrue: [potentialClassNames select:					[:nm |  nm asLowercase = toMatch]]		ifFalse: [potentialClassNames select: 					[:n | n includesSubstring: toMatch caseSensitive: false]].	classNames isEmpty ifTrue: [^ self classNotFound].	exactMatch _ classNames detect: [:each | each asLowercase = toMatch] ifNone: [nil].	index _ classNames size = 1		ifTrue:	[1]		ifFalse:	[exactMatch			ifNil: [(PopUpMenu labelArray: classNames lines: #()) startUp]			ifNotNil: [classNames addFirst: exactMatch.				(PopUpMenu labelArray: classNames lines: #(1)) startUp]].	index = 0 ifTrue: [^ self classNotFound].	foundClass _ Smalltalk at: (classNames at: index) asSymbol. 	self selectCategoryForClass: foundClass.	self selectClass: foundClass! !!Browser methodsFor: 'system category functions' stamp: 'sw 11/8/1999 10:04'!potentialClassNames	"Answer the names of all the classes that could be viewed in this browser.  This hook is provided so that HierarchyBrowsers can indicate their restricted subset.  For generic Browsers, the entire list of classes known to Smalltalk is provided, though of course that really only is accurate in the case of full system browsers."	^ Smalltalk classNames! !!Browser methodsFor: 'system category functions' stamp: 'sw 11/8/1999 14:07'!systemCatSingletonMenu: aMenu	^ aMenu labels:'browse allbrowseprintOutfileOutupdaterename...remove' 	lines: #(2 4)	selections:		#(browseAllClasses buildSystemCategoryBrowser		printOutSystemCategory fileOutSystemCategory updateSystemCategories		renameSystemCategory removeSystemCategory)! !!Browser methodsFor: 'system category functions' stamp: 'sma 2/5/2000 13:24'!systemCategoryMenu: aMenu^ aMenu labels:'find class... (f)recent classes... (r)browse allbrowseprintOutfileOutreorganizeupdateadd item...rename...remove' 	lines: #(2 4 6 8)	selections:		#(findClass recent browseAllClasses buildSystemCategoryBrowser		printOutSystemCategory fileOutSystemCategory		editSystemCategories updateSystemCategories		addSystemCategory renameSystemCategory removeSystemCategory )! !!Browser methodsFor: 'class list' stamp: 'sw 4/5/2000 10:54'!classListIndex: anInteger 	"Set anInteger to be the index of the current class selection."	| className |	classListIndex _ anInteger.	self setClassOrganizer.	messageCategoryListIndex _ 0.	messageListIndex _ 0.	self classCommentIndicated		ifTrue: []		ifFalse: [editSelection _ anInteger = 0					ifTrue: [metaClassIndicated | (systemCategoryListIndex == 0)						ifTrue: [#none]						ifFalse: [#newClass]]					ifFalse: [#editClass]].	contents _ nil.	self selectedClass isNil		ifFalse: [className _ self selectedClass name.					(RecentClasses includes: className)				ifTrue: [RecentClasses remove: className].			RecentClasses addFirst: className.			RecentClasses size > 16				ifTrue: [RecentClasses removeLast]].	self changed: #classSelectionChanged.	self changed: #classListIndex.	"update my selection"	self changed: #messageCategoryList.	self changed: #messageList.	self contentsChanged! !!Browser methodsFor: 'class list' stamp: 'stp 01/13/2000 12:57'!recent	"Let the user select from a list of recently visited classes.  11/96 stp.	 12/96 di:  use class name, not classes themselves.	 : dont fall into debugger in empty case"	| className class recentList |	recentList _ RecentClasses select: [:n | Smalltalk includesKey: n].	recentList size == 0 ifTrue: [^ self beep].	className := (SelectionMenu selections: recentList) startUp.	className == nil ifTrue: [^ self].	class := Smalltalk at: className.	self selectCategoryForClass: class.	self classListIndex: (self classList indexOf: class name)! !!Browser methodsFor: 'class list' stamp: 'sr 10/29/1999 20:28'!selectClass: classNotMeta	self classListIndex: (self classList indexOf: classNotMeta name)! !!Browser methodsFor: 'class list' stamp: 'di 12/6/1999 20:41'!selectedClass	"Answer the class that is currently selected. Answer nil if no selection 	exists."	| name envt |	(name _ self selectedClassName) ifNil: [^ nil].	(envt _ self selectedEnvironment) ifNil: [^ nil].	^ envt at: name! !!Browser methodsFor: 'class list' stamp: 'sw 11/24/1999 14:48'!selectedClassName	| aClassList |	"Answer the name of the current class. Answer nil if no selection exists."	(classListIndex = 0 or: [classListIndex > (aClassList _ self classList) size]) ifTrue: [^ nil].	^ aClassList at: classListIndex! !!Browser methodsFor: 'class functions' stamp: 'jm 10/14/2002 19:17'!classListMenu: aMenu 	^ aMenu addList: #(		-		('browse full (b)'			browseMethodFull)		('browse hierarchy (h)'		spawnHierarchy)		('browse protocol'			spawnProtocol)		-		('printOut'					printOutClass)		('fileOut'					fileOutClass)		-		('show hierarchy'			hierarchy)		('show definition'			editClass)		('show comment'			editComment)		-		('inst var refs...'			browseInstVarRefs)		('inst var defs...'			browseInstVarDefs)		-		('class var refs...'			browseClassVarRefs)		('class vars'					browseClassVariables)		('class refs (N)'				browseClassRefs)		-		('rename class ...'			renameClass)		('copy class'				copyClass)		('remove class (x)'			removeClass)		-		('unsent methods'			browseUnusedMethods)		('unreferenced inst vars'	showUnreferencedInstVars)		('subclass template'			makeNewSubclass)		-		('find method...'				findMethod))! !!Browser methodsFor: 'class functions' stamp: 'dwh 11/23/1999 00:09'!copyClass	| originalName copysName class oldDefinition newDefinition |	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	originalName _ self selectedClass name.	copysName _ self request: 'Please type new class name' initialAnswer: originalName.	copysName = '' ifTrue: [^ self].  " Cancel returns '' "	copysName _ copysName asSymbol.	copysName = originalName ifTrue: [^ self].	(Smalltalk includesKey: copysName)		ifTrue: [^ self error: copysName , ' already exists'].	oldDefinition _ self selectedClass definition.	newDefinition _ oldDefinition copyReplaceAll: '#' , originalName asString with: '#' , copysName asString.	Cursor wait 		showWhile: [class _ Compiler evaluate: newDefinition logged: true.					class copyAllCategoriesFrom: (Smalltalk at: originalName).					class class copyAllCategoriesFrom: (Smalltalk at: originalName) class].	self classListIndex: 0.	self changed: #classList! !!Browser methodsFor: 'class functions' stamp: 'di 12/23/1999 11:53'!defineClass: defString notifying: aController 	"The receiver's textual content is a request to define a new class. The 	source code is defString. If any errors occur in compilation, notify 	aController."	| oldClass class newClassName defTokens keywdIx envt |	oldClass _ self selectedClassOrMetaClass.	defTokens _ defString findTokens: Character separators.	keywdIx _ defTokens indexOf: 'category:'.	envt _ Smalltalk environmentForCategory: ((defTokens at: keywdIx+1) copyWithout: $').	keywdIx _ defTokens findFirst: [:x | x endsWith: 'ubclass:'].	newClassName _ (defTokens at: keywdIx+1) copyWithout: $#.	((oldClass isNil or: [oldClass name asString ~= newClassName])		and: [envt includesKeyOrAbove: newClassName asSymbol]) ifTrue:			["Attempting to define new class over existing one when				not looking at the original one in this browser..."			(self confirm: ((newClassName , ' is an existing class in this system.Redefining it might cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: newClassName size))				ifFalse: [^ false]].	"ar 8/29/1999: Use oldClass superclass for defining oldClass	since oldClass superclass knows the definerClass of oldClass."	oldClass ifNotNil:[oldClass _ oldClass superclass].	class _ oldClass subclassDefinerClass				evaluate: defString				notifying: aController				logged: true.	(class isKindOf: Behavior)		ifTrue: 			[self changed: #classList.			self classListIndex: 				(self classList indexOf: 					((class isKindOf: Metaclass)						ifTrue: [class soleInstance name]						ifFalse: [class name])).			self clearUserEditFlag; editClass.			^true]		ifFalse: [^false]! !!Browser methodsFor: 'class functions' stamp: 'sw 1/28/1999 22:56'!editComment	"Retrieve the description of the class comment."	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	self messageCategoryListIndex: 0.	editSelection _ #editComment.	self changed: #classSelectionChanged.	self contentsChanged! !!Browser methodsFor: 'class functions' stamp: 'jm 5/29/2003 19:01'!findMethod	"Pop up a list of the current class's methods, and select the one chosen by the user.	5/21/96 sw, based on a suggestion of John Maloney's."	| aClass selectors reply cat messageCatIndex messageIndex |	self classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	aClass _ self selectedClassOrMetaClass.	selectors _ aClass selectors copy asArray sort.	reply _ (SelectionMenu labelList: selectors selections: selectors) startUp.	reply == nil ifTrue: [^ self].	cat _ aClass whichCategoryIncludesSelector: reply.	messageCatIndex _ self messageCategoryList indexOf: cat.	self messageCategoryListIndex: messageCatIndex.	messageIndex _ (self messageList indexOf: reply).	self messageListIndex: messageIndex.! !!Browser methodsFor: 'class functions' stamp: 'sw 1/28/1999 12:30'!hierarchy	"Display the inheritance hierarchy of the receiver's selected class."	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	self messageCategoryListIndex: 0.	editSelection := #hierarchy.	self changed: #editComment.	self contentsChanged.	^ self! !!Browser methodsFor: 'class functions' stamp: 'sw 5/4/2000 20:19'!makeNewSubclass	self selectedClassOrMetaClass ifNil: [^ self].	self okToChange ifFalse: [^ self].	editSelection _ #newClass.	self contentsChanged! !!Browser methodsFor: 'class functions' stamp: 'sw 1/28/1999 18:27'!plusButtonHit	"Cycle between definition, comment, and hierachy"	editSelection == #editComment		ifTrue: [self hierarchy. ^ self].	editSelection == #hierarchy		ifTrue: [editSelection := #editClass.			classListIndex = 0 ifTrue: [^ self].			self okToChange ifFalse: [^ self].			self changed: #editComment.			self contentsChanged.			^self].	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	self messageCategoryListIndex: 0.	editSelection := #editComment.	self changed: #classSelectionChanged.	self contentsChanged.! !!Browser methodsFor: 'class functions' stamp: 'jm 10/8/2002 05:30'!removeClass	"The selected class should be removed from the system. Make certain the user intends this irrevocable command to be carried out."	| c n |	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	c _ self selectedClass.	(self confirm: 'Really delete ', c name, '?') ifFalse: [^ self].	c subclasses size > 0 ifTrue: [		(self confirm: c name, ' has subclasses. Proceed?') ifFalse: [^ self]].	n _ c instanceCount.	n > 0 ifTrue: [		(self confirm: c name, ' has ', n printString, ' instances. Proceed?')			ifFalse: [^ self]].	((Smalltalk includesKey: c name) and:	 [(Smalltalk allCallsOn: (Smalltalk associationAt: c name)) size > 0])		ifTrue: [			(self confirm: c name, ' is referenced. Proceed?')				ifFalse: [^ self]].	"okay, really remove it"	c removeFromSystem.	self classListIndex: 0.	self changed: #classList.! !!Browser methodsFor: 'class functions' stamp: 'dwh 11/23/1999 00:25'!renameClass	| oldName newName obs |	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	oldName _ self selectedClass name.	newName _ self request: 'Please type new class name' initialAnswer: oldName.	newName = '' ifTrue: [^ self].  " Cancel returns '' "	newName _ newName asSymbol.	newName = oldName ifTrue: [^ self].	(Smalltalk includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	self selectedClass rename: newName.	self changed: #classList.	self classListIndex: ((systemOrganizer listAtCategoryNamed: self selectedSystemCategoryName) indexOf: newName).	obs _ Smalltalk allCallsOn: (Smalltalk associationAt: newName).	obs isEmpty ifFalse:		[Smalltalk browseMessageList: obs			name: 'Obsolete References to ' , oldName			autoSelect: oldName].! !!Browser methodsFor: 'message category list' stamp: 'ccn 2/22/1999 18:45'!categoryOfCurrentMethod	"Determine the category that owns the current method.  Return    	the category name."	^ self selectedClassOrMetaClass whichCategoryIncludesSelector: self selectedMessageName! !!Browser methodsFor: 'message category list' stamp: 'ccn 3/22/1999 17:56'!messageCategoryList	"Answer the selected category of messages."	classListIndex = 0		ifTrue: [^ Array new]		ifFalse: [^ (Array with: ClassOrganizer allCategory), self classOrMetaClassOrganizer categories]! !!Browser methodsFor: 'message category list' stamp: 'sw 5/16/2000 11:29'!messageCategoryListIndex: anInteger 	"Set the selected message category to be the one indexed by anInteger."	messageCategoryListIndex _ anInteger.	messageListIndex _ 0.	editSelection _ 		anInteger = 0			ifTrue: [#none]			ifFalse: [#newMessage].	contents _ nil.	self changed: #messageCategorySelectionChanged.	self changed: #messageCategoryListIndex.	"update my selection"	self changed: #messageList.	self contentsChanged! !!Browser methodsFor: 'message category list' stamp: 'ccn 3/24/1999 11:02'!messageCategoryListSelection	"Return the selected category name or nil."	^ ((self messageCategoryList size = 0 		or: [self messageCategoryListIndex = 0]) 		or: [self messageCategoryList size < self messageCategoryListIndex])			ifTrue: [nil]			ifFalse: [self messageCategoryList at: (self messageCategoryListIndex max: 1)]! !!Browser methodsFor: 'message category list' stamp: 'sw 10/16/1999 22:56'!rawMessageCategoryList	^ classListIndex = 0		ifTrue: [Array new]		ifFalse: [self classOrMetaClassOrganizer categories]! !!Browser methodsFor: 'message category list' stamp: 'ccn+ceg 2/9/1999 20:25'!selectMessageCategoryNamed: aSymbol 	"Given aSymbol, select the category with that name.  Do nothing if 	aSymbol doesn't exist."	(self messageCategoryList includes: aSymbol)		ifFalse: [^ self].	self messageCategoryListIndex: (self messageCategoryList indexOf: aSymbol)! !!Browser methodsFor: 'message category list' stamp: 'ccn 3/22/1999 17:57'!selectOriginalCategoryForCurrentMethod	"private - Select the message category for the current method. 	 	 Note:  This should only be called when somebody tries to save  	 a method that they are modifying while ALL is selected. 	 	 Returns: true on success, false on failure."	| aSymbol |	aSymbol _ self categoryOfCurrentMethod.	(aSymbol notNil and: [aSymbol ~= ClassOrganizer allCategory])		ifTrue: 			[self selectMessageCategoryNamed: aSymbol.			^ true].	^ false! !!Browser methodsFor: 'message category list' stamp: 'ccn+ceg 5/13/1999 19:54'!setOriginalCategoryIndexForCurrentMethod	"private - Set the message category index for the currently selected method. 	 	 Note:  This should only be called when somebody tries to save  	 a method that they are modifying while ALL is selected."	messageCategoryListIndex _ self messageCategoryList indexOf: self categoryOfCurrentMethod	! !!Browser methodsFor: 'message category functions' stamp: 'mir 5/5/2000 16:02'!addCategory	"Present a choice of categories or prompt for a new category name and add it before the current selection, or at the end if no current selection"	| labels reject lines cats menuIndex oldIndex newName |	self okToChange ifFalse: [^ self].	classListIndex = 0 ifTrue: [^ self].	labels _ OrderedCollection with: 'new...'.	reject _ Set new.	reject		addAll: self selectedClassOrMetaClass organization categories;		add: ClassOrganizer nullCategory;		add: ClassOrganizer default.	lines _ OrderedCollection new.	self selectedClassOrMetaClass allSuperclasses do: [:cls |		cls = Object ifFalse: [			cats _ cls organization categories reject:				 [:cat | reject includes: cat].			cats isEmpty ifFalse: [				lines add: labels size.				labels addAll: cats asSortedCollection.				reject addAll: cats]]].	newName _ (labels size = 1 or: [		menuIndex _ (PopUpMenu labelArray: labels lines: lines)		startUpWithCaption: 'Add Category'.		menuIndex = 0 ifTrue: [^ self].		menuIndex = 1])			ifTrue: [				self request: 'Please type new category name'					initialAnswer: 'category name']			ifFalse: [				labels at: menuIndex].	oldIndex _ messageCategoryListIndex.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	self classOrMetaClassOrganizer		addCategory: newName		before: (messageCategoryListIndex = 0				ifTrue: [nil]				ifFalse: [self selectedMessageCategoryName]).	self changed: #messageCategoryList.	self messageCategoryListIndex:		(oldIndex = 0			ifTrue: [self classOrMetaClassOrganizer categories size + 1]			ifFalse: [oldIndex]).	self changed: #messageCategoryList.! !!Browser methodsFor: 'message category functions' stamp: 'di 3/28/2000 15:55'!alphabetizeMessageCategories	classListIndex = 0		ifTrue: [^ false].	self okToChange ifFalse: [^ false].	Smalltalk changes reorganizeClass: self selectedClassOrMetaClass.	self classOrMetaClassOrganizer categories: self rawMessageCategoryList asSortedCollection asArray.	self clearUserEditFlag.	self editClass.	self classListIndex: classListIndex.	^ true! !!Browser methodsFor: 'message category functions' stamp: 'wod 6/24/1998 02:10'!buildMessageCategoryBrowserEditString: aString 	"Create and schedule a message category browser for the currently 	selected	 message category. The initial text view contains the characters 	in aString."	"wod 6/24/1998: set newBrowser classListIndex so that it works whether the	receiver is a standard or a Hierarchy Browser."	| newBrowser |	messageCategoryListIndex ~= 0		ifTrue: 			[newBrowser _ Browser new.			newBrowser systemCategoryListIndex: systemCategoryListIndex.			newBrowser classListIndex: (newBrowser classList indexOf: self selectedClassName).			newBrowser metaClassIndicated: metaClassIndicated.			newBrowser messageCategoryListIndex: messageCategoryListIndex.			newBrowser messageListIndex: messageListIndex.			Browser openBrowserView: (newBrowser openMessageCatEditString: aString)				label: 'Message Category Browser (' , 						newBrowser selectedClassOrMetaClassName , ')']! !!Browser methodsFor: 'message category functions' stamp: 'di 3/28/2000 15:56'!changeMessageCategories: aString 	"The characters in aString represent an edited version of the the message 	categories for the selected class. Update this information in the system 	and inform any dependents that the categories have been changed. This 	message is invoked because the user had issued the categories command 	and edited the message categories. Then the user issued the accept 	command."	Smalltalk changes reorganizeClass: self selectedClassOrMetaClass.	self classOrMetaClassOrganizer changeFromString: aString.	self clearUserEditFlag.	self editClass.	self classListIndex: classListIndex.	^ true! !!Browser methodsFor: 'message category functions' stamp: 'sw 1/28/1999 12:30'!editMessageCategories	"Indicate to the receiver and its dependents that the message categories of 	the selected class have been changed."	self okToChange ifFalse: [^ self].	classListIndex ~= 0		ifTrue: 			[self messageCategoryListIndex: 0.			editSelection _ #editMessageCategories.			self changed: #editMessageCategories.			self contentsChanged]! !!Browser methodsFor: 'message category functions' stamp: 'sw 10/14/1999 16:53'!messageCategoryMenu: aMenu^ aMenu labels:'browseprintOutfileOutreorganizealphabetizeremove empty categoriesnew category...rename...remove'	lines: #(3 7)	selections:		#(buildMessageCategoryBrowser printOutMessageCategories fileOutMessageCategories		editMessageCategories alphabetizeMessageCategories removeEmptyCategories		addCategory renameCategory removeMessageCategory)! !!Browser methodsFor: 'message category functions' stamp: 'sma 2/27/2000 10:14'!removeEmptyCategories	messageCategoryListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	self selectedClassOrMetaClass organization removeEmptyCategories.	self changed: #messageCategoryList! !!Browser methodsFor: 'message category functions' stamp: 'di 3/28/2000 15:56'!renameCategory	"Prompt for a new category name and add it before the	current selection, or at the end if no current selection"	| oldIndex oldName newName |	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(oldIndex _ messageCategoryListIndex) = 0 ifTrue: [^ self].	oldName _ self selectedMessageCategoryName.	newName _ self		request: 'Please type new category name'		initialAnswer: oldName.	newName isEmpty		ifTrue: [^ self]		ifFalse: [newName _ newName asSymbol].	newName = oldName ifTrue: [^ self].	Smalltalk changes reorganizeClass: self selectedClassOrMetaClass.	self classOrMetaClassOrganizer		renameCategory: oldName		toBe: newName.	self classListIndex: classListIndex.	self messageCategoryListIndex: oldIndex.	self changed: #messageCategoryList.! !!Browser methodsFor: 'message list' stamp: 'ccn 3/24/1999 10:48'!messageList	"Answer an Array of the message selectors of the currently selected message category, provided that the messageCategoryListIndex is in proper range.  Otherwise, answer an empty Array  If messageCategoryListIndex is found to be larger than the number of categories (it happens!!), it is reset to zero."	| sel |	(sel _ self messageCategoryListSelection) ifNil: [^ Array new].	^ sel = ClassOrganizer allCategory		ifTrue: 			[self classOrMetaClassOrganizer				ifNil:		[Array new]				ifNotNil:	[self classOrMetaClassOrganizer allMethodSelectors]]		ifFalse:			[(self classOrMetaClassOrganizer listAtCategoryNumber: messageCategoryListIndex - 1)				ifNil: [messageCategoryListIndex _ 0.  Array new]]! !!Browser methodsFor: 'message list' stamp: 'sw 9/22/1999 17:17'!messageListIndex: anInteger 	"Set the selected message selector to be the one indexed by anInteger."	messageListIndex _ anInteger.	editSelection _ 		anInteger = 0			ifTrue: [#newMessage]			ifFalse: [#editMessage].	contents _ nil.	self changed: #messageListIndex.	"update my selection"	self contentsChanged! !!Browser methodsFor: 'message list' stamp: 'hg 3/13/2000 11:49'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector method tempNames |	contents == nil ifFalse: [^ contents copy].	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	method _ class compiledMethodAt: selector ifAbsent: [		^ ''].	"method deleted while in another project"	currentCompiledMethod _ method.	(Sensor controlKeyPressed		or: [method fileIndex > 0 and: [(SourceFiles at: method fileIndex) == nil]])		ifTrue:		["Emergency or no source file -- decompile without temp names"		contents _ (class decompilerClass new decompile: selector in: class method: method)			decompileString.		contents _ contents asText makeSelectorBoldIn: class.		^ contents copy].	Sensor leftShiftDown ifTrue:		["Special request to decompile -- get temps from source file"		tempNames _ (class compilerClass new						parse: method getSourceFromFile asString in: class notifying: nil)						tempNames.		contents _ ((class decompilerClass new withTempNames: tempNames)				decompile: selector in: class method: method) decompileString.		contents _ contents asText makeSelectorBoldIn: class.		^ contents copy].	contents _ class sourceCodeAt: selector.	self validateMessageSource: selector.	Preferences browseWithPrettyPrint ifTrue:		[contents _ class compilerClass new			format: contents in: class notifying: nil decorated: Preferences colorWhenPrettyPrinting].	self showDiffs ifTrue:		[contents _ self diffFromPriorSourceFor: contents].	contents _ contents asText makeSelectorBoldIn: class.	^ contents copy! !!Browser methodsFor: 'message list' stamp: 'sw 10/19/1999 17:39'!selectedMessageName	| aList |	"Answer the message selector of the currently selected message, if any. 	Answer nil otherwise."	messageListIndex = 0 ifTrue: [^ nil].	^ (aList _ self messageList) size >= messageListIndex		ifTrue:			[aList at: messageListIndex]		ifFalse:			[nil]! !!Browser methodsFor: 'message list' stamp: 'hg 3/13/2000 12:07'!validateMessageSource: selector	(self selectedClass compilerClass == Object compilerClass 			and: [(contents asString findString: selector keywords first ) ~= 1])		ifTrue: [			PopUpMenu notify: 'Possible problem with source file!!The method source should start with the method selector but this is not the case!! You may proceed with caution but it is recommended that you get a new source file.This can happen if you download the "SqueakV2.sources" file, or the ".changes" file you use, as TEXT. It must be transfered in BINARY mode, even if it looks like a text file, to preserve the CR line ends.Mac users: This may have been caused by Stuffit Expander. To prevent the files above to be converted to Mac line ends when they are expanded, do this: Start the program, then from Preferences... in the File menu, choose the Cross Platform panel, then select "Never" and press OK. Then expand the compressed archive again.'].! !!Browser methodsFor: 'message functions' stamp: 'di 11/24/1999 13:40'!defineMessageFrom: aString notifying: aController	"Compile the expressions in aString. Notify aController if a syntax error occurs. Install the compiled method in the selected class classified under  the currently selected message category name. Answer the selector obtained if compilation succeeds, nil otherwise."	| selectedMessageName selector category oldMessageList |	selectedMessageName _ self selectedMessageName.	oldMessageList _ self messageList.	contents _ nil.	selector _ (Parser new parseSelector: aString).	(self metaClassIndicated		and: [(self selectedClassOrMetaClass includesSelector: selector) not		and: [Metaclass isScarySelector: selector]])		ifTrue: ["A frist-time definition overlaps the protocol of Metaclasses"				(self confirm: ((selector , ' is used in the existing class system.Overriding it could cause serious problems.Is this really what you want to do?') asText makeBoldFrom: 1 to: selector size))				ifFalse: [^nil]].	selector _ self selectedClassOrMetaClass				compile: aString				classified: (category _ self selectedMessageCategoryName)				notifying: aController.	selector == nil ifTrue: [^ nil].	contents _ aString copy.	selector ~~ selectedMessageName		ifTrue: 			[category = ClassOrganizer nullCategory				ifTrue: [self changed: #classSelectionChanged.						self changed: #classList.						self messageCategoryListIndex: 1].			self setClassOrganizer.  "In case organization not cached"			(oldMessageList includes: selector)				ifFalse: [self changed: #messageList].			self messageListIndex: (self messageList indexOf: selector)].	^ selector! !!Browser methodsFor: 'message functions' stamp: 'jm 10/14/2002 19:17'!messageListMenu: aMenu shifted: shifted	| aList |	aList _ shifted		ifFalse: [#(			('browse full (b)' 						browseMethodFull)			('browse hierarchy (h)'					classHierarchy)			('browse method (O)'					openSingleMessageBrowser)			-			('fileOut'								fileOutMessage)			('printOut'								printOutMessage)			-			('senders of... (n)'						browseSendersOfMessages)			('implementors of... (m)'					browseMessages)			('inheritance (i)'						methodHierarchy)			('versions (v)'							browseVersions)			-			('inst var refs...'						browseInstVarRefs)			('inst var defs...'						browseInstVarDefs)			('class var refs...'						browseClassVarRefs)			('class variables'						browseClassVariables)			('class refs (N)'							browseClassRefs)			-			('remove method (x)'					removeMessage)			-			('more...'								shiftedYellowButtonActivity))]		ifTrue: [#(			('toggle diffing'							toggleDiffing)			('implementors of sent messages'			browseAllMessages)			-			('inspect instances'						inspectInstances)			('inspect subinstances'					inspectSubInstances)			-			('remove from this browser'				removeMessageFromBrowser)			('change category...'					changeCategory)			-			('change sets with this method'			findMethodInChangeSets)			('revert to previous version'				revertToPreviousVersion)			('remove from current change set'		removeFromCurrentChanges)			('revert and forget'						revertAndForget)			-			('more...' 								unshiftedYellowButtonActivity))].	^ aMenu addList: aList! !!Browser methodsFor: 'message functions' stamp: 'di 5/27/1998 15:45'!removeMessage	"If a message is selected, create a Confirmer so the user can verify that 	the currently selected message should be removed from the system. If so, 	remove it.  If the Preference 'confirmMethodRemoves' is set to false, the 	confirmer is bypassed."	| messageName confirmation |	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageName _ self selectedMessageName.	confirmation _ self selectedClassOrMetaClass confirmRemovalOf: messageName.	confirmation == 3 ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: self selectedMessageName.	self messageListIndex: 0.	self changed: #messageList.	self setClassOrganizer.  "In case organization not cached"	confirmation == 2 ifTrue:		[Smalltalk browseAllCallsOn: messageName]! !!Browser methodsFor: 'code pane' stamp: 'sw 5/26/1999 23:43'!compileMessage: aText notifying: aController	"Compile the code that was accepted by the user, placing the compiled method into an appropriate message category.  Return true if the compilation succeeded, else false."	| fallBackCategoryIndex fallBackMethodIndex originalSelectorName result |	self selectedMessageCategoryName asSymbol = ClassOrganizer allCategory		ifTrue:			[ "User tried to save a method while the ALL category was selected"			fallBackCategoryIndex _ messageCategoryListIndex.			fallBackMethodIndex _ messageListIndex.			editSelection == #newMessage				ifTrue:					[ "Select the 'as yet unclassified' category"					messageCategoryListIndex _ 0.					(result _ self defineMessageFrom: aText notifying: aController)						ifNil:							["Compilation failure:  reselect the original category & method"							messageCategoryListIndex _ fallBackCategoryIndex.							messageListIndex _ fallBackMethodIndex]						ifNotNil:							[self setSelector: result]]				ifFalse:					[originalSelectorName _ self selectedMessageName.					self setOriginalCategoryIndexForCurrentMethod.					messageListIndex _ fallBackMethodIndex _ self messageList indexOf: originalSelectorName.								(result _ self defineMessageFrom: aText notifying: aController)						ifNotNil:							[self setSelector: result]						ifNil:							[ "Compilation failure:  reselect the original category & method"							messageCategoryListIndex _ fallBackCategoryIndex.							messageListIndex _ fallBackMethodIndex.							^ result notNil]].			self changed: #messageCategoryList.			^ result notNil]		ifFalse:			[ "User tried to save a method while the ALL category was NOT selected"			^ (self defineMessageFrom: aText notifying: aController) notNil]! !!Browser methodsFor: 'code pane' stamp: 'sma 5/28/2000 11:03'!showBytecodes	"Show or hide the bytecodes of the selected method."	(messageListIndex = 0 or: [self okToChange not])		ifTrue: [^ self changed: #flash].	editSelection == #byteCodes		ifTrue: [editSelection _ #editMessage]		ifFalse: [editSelection _ #byteCodes].	self contentsChanged! !!Browser class methodsFor: 'instance creation' stamp: 'sw 1/13/2000 16:45'!fullOnClass: aClass selector: aSelector	"Open a new full browser set to class."	| brow classToUse |	classToUse _ Preferences browseToolClass.	brow _ classToUse new.	brow setClass: aClass selector: aSelector.	classToUse openBrowserView: (brow openEditString: nil)		label: brow defaultBrowserTitle! !!Browser class methodsFor: 'instance creation' stamp: 'di 10/18/1999 22:03'!new	^super new systemOrganizer: SystemOrganization! !!Browser class methodsFor: 'instance creation' stamp: 'sw 1/13/2000 16:46'!openBrowser	"Create and schedule a BrowserView with label 'System Browser'. The 	view consists of five subviews, starting with the list view of system 	categories of SystemOrganization. The initial text view part is empty."	Browser openBrowserView: (Browser new openEditString: nil)			label: 'System Browser'! !Written by Leo Burd to interface to BusCommander board.!!BusCommanderMessage methodsFor: 'private' stamp: 'JTN 11/18/2002 14:52'!initializeBcmKind: aByteKind bcmId: aByte bcmResponseReq: aByteReq bcmData: aByteArray  	bcmId _ aByte.	bcmData _ aByteArray.	bcmKind _ aByteKind.	bcmResponseReq _ aByteReq ifTrue:[ bcmResponseReq _ 1] ifFalse:[bcmResponseReq _ 0].! !!BusCommanderMessage methodsFor: 'conversion' stamp: 'JTN 11/18/2002 15:52'!asByteArray	"returns the BusCommander message as a ByteArray that	can be sent to the BusCommander board"	| buffer aByteArray stream bcmNumArgs|	"create a stream to assemble the message in a temporary buffer"	buffer _ ByteArray new: 128.	stream _ WriteStream on: buffer.		bcmNumArgs := bcmData size + 2.	"write the message kind and id to the message header, and the response req"	stream nextPutAll: (ByteArray with: bcmKind with: bcmNumArgs with: bcmResponseReq with: bcmId ).	"write the data"	bcmData do: [ :ix |		stream nextPutAll: (ByteArray with: ix).	].		"return the ByteArray"	aByteArray _ stream contents.	^ aByteArray		     ! !!BusCommanderMessage class methodsFor: 'message constructors' stamp: 'JTN 12/5/2002 14:46'!newDisplayMessage: aInteger	"returns a 'display value in LCD' BusCommander message"	| bcm |	"BusCommander expects a message with 70 hex as the id and with the number 	in the body.  The number should between -999 and 9999"	bcm _ super new initializeBcmKind: 255 bcmId: 16r70  bcmResponseReq: false 		bcmData: (ByteArray with: aInteger // 256 with: aInteger \\ 256).	^bcm! !!BusCommanderMessage class methodsFor: 'message constructors' stamp: 'jm 1/23/2003 16:06'!newGetClapDetectedMessage	"returns a 'get clap detected' BusCommander message"	| bcm |	"BusCommander expects an empty message with 6A hex as the id"	"Note: 6A is for a generic clap sensor.  68 is for the red, and 69 is for the blue."	bcm _ super new initializeBcmKind: 255 bcmId: 16r6A  bcmResponseReq: true bcmData: ''.	^bcm! !!BusCommanderMessage class methodsFor: 'message constructors' stamp: 'JTN 11/19/2002 11:16'!newGetDistanceMessage	"returns a 'get value from optical distance sensor' BusCommander message"	| bcm |	"BusCommander expects an empty message with 55 hex as the id"	bcm _ super new initializeBcmKind: 255 bcmId: 16r55  bcmResponseReq: true bcmData: ''.	^bcm! !!BusCommanderMessage class methodsFor: 'message constructors' stamp: 'JTN 11/19/2002 11:29'!newGetGenericSensorValueMessage: sensorNumber	| bcm |	"Generic Sensor Value. sensorNumber refers to the slot the sensor is on"	bcm _ super new initializeBcmKind: 100 bcmId: sensorNumber  bcmResponseReq: true 		bcmData: ''.	^bcm! !!BusCommanderMessage class methodsFor: 'message constructors' stamp: 'JTN 11/18/2002 15:23'!newGetVolumeLevelMessage	"returns a 'get volume level value from clap sensor' BusCommander message"	| bcm |	"BusCommander expects an empty message with 6A hex as the id"	"Note: 6A is for a generic clap sensor.  68 is for the red, and 69 is for the blue."	bcm _ super new initializeBcmKind: 255 bcmId: 16r6A bcmResponseReq: true bcmData: ''.	^bcm! !!BusCommanderMessage class methodsFor: 'message constructors' stamp: 'JTN 11/18/2002 15:22'!newSetTricolorLEDMessageRed: byteRed green: byteGreen blue: byteBlue	"returns a 'set tricolor LED value' BusCommander message. The amount of red, green	 and blue has to be in between 0 and 255"	| bcm |	"BusCommander expects 75 hex as the id and the RGB values as data"	bcm _ super new initializeBcmKind: 255 bcmId: 16r75  bcmResponseReq: false		bcmData: (ByteArray with: byteRed with: byteGreen with: byteBlue).	^bcm! !I am a Switch that turns off automatically after being turned on, that is, I act like a push-button switch.!I represent an ArrayedCollection whose elements are integers between 0 and 255.!!ByteArray methodsFor: 'accessing' stamp: 'sma 4/22/2000 17:47'!atAllPut: value	"Fill the receiver with the given value"	<primitive: 145>	super atAllPut: value! !!ByteArray methodsFor: 'accessing' stamp: 'ar 12/5/1998 14:52'!byteAt: index	<primitive: 60>	^self at: index! !!ByteArray methodsFor: 'accessing' stamp: 'ar 12/5/1998 14:52'!byteAt: index put: value	<primitive: 61>	^self at: index put: value! !!ByteArray methodsFor: 'accessing' stamp: 'tk 3/13/2000 14:46'!bytesPerElement	"Number of bytes in each item.  This multiplied by (self size)*8 gives the number of bits stored."	^ 1! !!ByteArray methodsFor: 'converting' stamp: 'sma 5/12/2000 17:35'!asByteArray	^ self! !!ByteArray methodsFor: 'comparing' stamp: 'jm 8/3/1999 09:33'!hash	"Make sure that equal (=) ByteArrays hash equally."	self size = 0 ifTrue: [^ 2001].	^ ((self at: 1) bitShift: 8) + (self at: self size)! !I am a command block that contains a nested sequence of command blocks, such as a loop.!!CBlockMorph methodsFor: 'initialization' stamp: 'tis 6/24/2003 11:30'!initialize	super initialize.	self color: (Color r: 1.0 g: 0.581 b: 0.194).	self wantsName: false.! !!CBlockMorph methodsFor: 'drawing' stamp: 'jm 4/28/2003 17:49'!drawOn: aCanvas 	| topH thick insetR |	topH _ self topBarHeight.	thick _ self bracketThickness.	insetR _ bounds insetBy: 2.	aCanvas fillRectangle: (insetR topLeft extent: (insetR width@topH)) color: color.	aCanvas fillRectangle: (insetR topLeft extent: (thick@insetR height)) color: color.	aCanvas fillRectangle: ((insetR bottomLeft - (0@thick)) extent: (insetR width@thick)) color: color.	self drawTFrom: insetR left to: insetR right y: bounds top on: aCanvas.	self drawLFrom: insetR top to: insetR bottom x: bounds left on: aCanvas.	self drawBFrom: insetR left to: insetR right y: bounds bottom on: aCanvas.	self drawRFrom: insetR top to: (insetR top + topH - 1) x: bounds right on: aCanvas.	self drawBFrom: (insetR left + thick - 1) to: insetR right + 1 y: (bounds top + topH + 2) on: aCanvas.	self drawRFrom: (insetR top + topH) to: (insetR bottom - topH) x: (bounds left + thick + 2) on: aCanvas.	self drawTFrom: (insetR left + thick - 1) to: insetR right + 1 y: (bounds bottom - thick - 3) on: aCanvas.	self drawRFrom: (insetR bottom - thick) to: insetR bottom x: bounds right on: aCanvas.	self drawCornersOn: aCanvas.! !!CBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:04'!fieldsVersion	^ 1! !!CBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:05'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		nestedBlock		nextBlock	) from: anObjStream.! !!CBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:05'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		nestedBlock		nextBlock	) on: anObjStream.! !!CBlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 17:03'!attachBlock: aBlockMorph	"Attach the given block to me. Assume the block has been positioned correctly."	self addMorph: aBlockMorph.	aBlockMorph top >= self bottom		ifTrue: [nextBlock _ aBlockMorph]		ifFalse: [nestedBlock _ aBlockMorph].! !!CBlockMorph methodsFor: 'private' stamp: 'jm 3/20/2003 13:29'!blockAttachPoints	"Answer a collection of possible attachment points for me.Each entry is an Association mapping a point to the morph to which a dropping block could be attached."	| result |	result _ OrderedCollection new.	nestedBlock		ifNil: [result add: ((self topLeft + (32@32)) -> self)]		ifNotNil: [result addAll: nestedBlock blockAttachPoints].	nextBlock		ifNil: [result add: (self bottomLeft -> self)]		ifNotNil: [result addAll: nextBlock blockAttachPoints].	^ result asArray! !!CBlockMorph methodsFor: 'private' stamp: 'jm 4/28/2003 17:58'!bracketThickness	"Answer the thickness of the bracket bars that surround my nested statements."	^ 12! !!CBlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 12:11'!firstBlockList	"Answer an array containing the block sequence for my first (and only) nested block. (An if-then-else block would have a second block list.)"	nestedBlock		ifNil: [^ #()]		ifNotNil: [^ nestedBlock blockSequence].! !!CBlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 12:32'!fixBlockLayout	"Update the positions of my submorphs."	| oldExtent newH |	super fixBlockLayout.	"fix nestedBlock and nextBlock in case they've been removed from me"	(nestedBlock notNil and: [nestedBlock owner ~~ self]) ifTrue: [nestedBlock _ nil].	(nextBlock notNil and: [nextBlock owner ~~ self]) ifTrue: [nextBlock _ nil].	oldExtent _ self extent.	newH _ self topBarHeight + self bracketThickness + 5.	nestedBlock ifNotNil: [		nestedBlock fixBlockLayout.		newH _ newH + (nestedBlock blockSequence collect: [:m | m height]) sum.		nestedBlock position: self position + ((self bracketThickness@self topBarHeight) + 2)].	self extent: oldExtent x@newH.	nextBlock ifNotNil: [nextBlock position: self left@self bottom].! !!CBlockMorph methodsFor: 'private' stamp: 'jm 3/20/2003 13:21'!nextBlock	"Answer the block myself in the block sequence or nil if I am the last block in the sequence. Each block is a submorph of the previous block."	^ nextBlock! !!CBlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 12:57'!nonControlFlowSubmorphs	"Answer a collection of submorphs minus any blocks that are part of the control flow. For example, command blocks omit their submorph that is the next block in the block sequence, C-blocks omit both their next block and the first block of their nested block list, etc."	^ submorphs select: [:m | (m ~~ nestedBlock) & (m ~~ nextBlock)]! !!CBlockMorph methodsFor: 'private' stamp: 'jm 10/21/2003 19:47'!printCodeOn: aStream indent: indent	"Append a human-readable string for this block on the given stream."	indent timesRepeat: [aStream tab].	submorphs do: [:m |		(m ~~ nestedBlock) & (m ~~ nextBlock) ifTrue: [			self printCodeSubmorph: m on: aStream.			aStream space]].	aStream cr.	nestedBlock ifNotNil: [nestedBlock printCodeOn: aStream indent: indent + 1].	nextBlock ifNotNil: [nextBlock printCodeOn: aStream indent: indent].! !!CBlockMorph methodsFor: 'private' stamp: 'jm 4/28/2003 18:02'!topBarHeight	"Answer the height of the top bar."	| nonBlockSubmorphs |	nonBlockSubmorphs _ self submorphs select: [:m |		(m isKindOf: BlockMorph) not or: [argMorphs includes: m]].	^ nonBlockSubmorphs inject: self bracketThickness into: [:h :m | h max: (m height + 2)].! !A canvas is a two-dimensional medium on which morphs are drawn in a device-independent manner. Canvases keep track of the origin and clipping rectangle, as well as the underlying drawing medium.Subclasses must implement (at least) the following methods:	* Drawing:		#fillOval:color:borderWidth:borderColor:		#frameAndFillRectangle:fillColor:borderWidth:borderColor:		#image:at:sourceRect:rule:		#stencil:at:sourceRect:color:		#line:to:width:color:		#paragraph:bounds:color:		#text:bounds:font:color:	* Support		#clipBy:during:		#translateBy:during:		#translateBy:clippingTo:during:		#transformBy:clippingTo:during:smoothing:!!Canvas methodsFor: 'initialization' stamp: 'jm 10/30/2002 20:55'!reset	"Reset the canvas. This default implementation does nothing."! !!Canvas methodsFor: 'copying' stamp: 'jm 11/24/2002 10:40'!copy	^ self clone! !!Canvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 14:07'!clipRect	"Return the currently active clipping rectangle"	^self subclassResponsibility! !!Canvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 14:15'!extent	"Return the physical extent of the output device"	^self subclassResponsibility! !!Canvas methodsFor: 'accessing' stamp: 'jm 6/2/1998 06:39'!form	^ Display! !!Canvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 14:11'!origin	"Return the current origin for drawing operations"	^self subclassResponsibility! !!Canvas methodsFor: 'accessing' stamp: 'jm 11/24/2002 11:16'!shadowColor	"Return the current override color or nil if not drawing shadows."	^ nil! !!Canvas methodsFor: 'accessing' stamp: 'ar 2/17/2000 01:46'!shadowColor: aColor	"Set a shadow color. If set this color overrides any client-supplied color."! !!Canvas methodsFor: 'testing' stamp: 'ar 6/22/1999 19:03'!isShadowDrawing	^false! !!Canvas methodsFor: 'testing' stamp: 'ar 6/22/1999 14:10'!isVisible: aRectangle	"Return true if the given rectangle is (partially) visible"	^self clipRect intersects: aRectangle! !!Canvas methodsFor: 'converting' stamp: 'jm 11/24/2002 10:54'!asShadowDrawingCanvas	"Answer a canvas like me for drawing translucent shadows."	^ self asShadowDrawingCanvas: (Color black alpha: 0.5)! !!Canvas methodsFor: 'converting' stamp: 'jm 1/8/2003 11:01'!asShadowDrawingCanvas: aColor	"Answer a copy of me for drawing drop-shadows."	^ self copy shadowColor: aColor! !!Canvas methodsFor: 'transforms' stamp: 'ar 6/17/1999 02:53'!clipBy: aRectangle during: aBlock	"Set a clipping rectangle active only during the execution of aBlock.	Note: In the future we may want to have more general clip shapes - not just rectangles"	^self subclassResponsibility! !!Canvas methodsFor: 'transforms' stamp: 'di 10/16/1999 15:56'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock smoothing: cellSize	"Transform the receiver by the given display transformation during the execution of aBlock. The given clip rectangle defines the *global* (e.g., outer) rectangle against which the receiver should clip (which would be equivalent to 'self clipRect: aClipRect; transformBy: aDisplayTransform')."	^ self subclassResponsibility! !!Canvas methodsFor: 'transforms'!translateBy:aPoint clippingTo:aRect during:aBlock	^aBlock value:(self copyOffset:aPoint clipRect:aRect).! !!Canvas methodsFor: 'transforms' stamp: 'ar 6/17/1999 03:00'!translateBy: delta during: aBlock	"Set a translation only during the execution of aBlock."	^self subclassResponsibility! !!Canvas methodsFor: 'transforms' stamp: 'ar 6/22/1999 14:08'!translateTo: newOrigin clippingTo: aRectangle during: aBlock	"Set a new origin and clipping rectangle only during the execution of aBlock."	self translateBy: newOrigin - self origin 		clippingTo: (aRectangle translateBy: self origin negated) 		during: aBlock! !!Canvas methodsFor: 'drawing-morphs' stamp: 'jm 11/24/2002 11:51'!drawMorph: aMorph	(self isVisible: aMorph bounds) ifTrue: [aMorph drawOn: self].! !!Canvas methodsFor: 'drawing-morphs' stamp: 'jm 11/24/2002 11:50'!fullDrawMorph: aMorph	(self isVisible: aMorph fullBounds) ifTrue: [aMorph fullDrawOn: self].! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:32'!fillRectangle: r color: c	"Fill the rectangle using the given color"	^self 		frameAndFillRectangle: r		fillColor: c		borderWidth: 0		borderColor: Color transparent! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:32'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	"Draw the rectangle using the given attributes"	^self subclassResponsibility! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:32'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	"Draw the rectangle using the given attributes.	Note: This is a *very* simple implementation"	| bw pt |	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: bottomRightColor.	bw _ borderWidth asPoint.	pt _ r topLeft + (bw // 2).	self line: pt to: pt + ((r extent x - bw x)@0) width: borderWidth color: topLeftColor.	self line: pt to: pt + (0@(r extent y - bw y)) width: borderWidth color: topLeftColor.! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:33'!frameRectangle: r color: c	self frameRectangle: r width: 1 color: c.! !!Canvas methodsFor: 'drawing-rectangles' stamp: 'ar 6/18/1999 07:33'!frameRectangle: r width: w color: c	^self frameAndFillRectangle: r fillColor: Color transparent borderWidth: w borderColor: c.! !!Canvas methodsFor: 'drawing-ovals' stamp: 'jm 11/24/2002 11:05'!fillOval: r color: c	self fillOval: r color: c borderWidth: 0 borderColor: Color black.! !!Canvas methodsFor: 'drawing-ovals' stamp: 'jm 11/24/2002 11:05'!fillOval: r color: c borderWidth: borderWidth borderColor: borderColor	"Fill the given oval."	^ self subclassResponsibility! !!Canvas methodsFor: 'drawing-ovals' stamp: 'ar 6/18/1999 08:45'!frameOval: r color: c	self fillOval: r color: Color transparent borderWidth: 1 borderColor: c.! !!Canvas methodsFor: 'drawing-ovals' stamp: 'ar 6/18/1999 08:45'!frameOval: r width: w color: c	self fillOval: r color: Color transparent borderWidth: w borderColor: c.! !!Canvas methodsFor: 'drawing-lines and fills' stamp: 'ar 6/17/1999 01:18'!fillColor: aColor	"Fill the receiver with the given color.	Note: This method should be named differently since it is intended to fill the background and thus fills even if the color is transparent"	^self fillRectangle: self clipRect color: (aColor alpha: 1.0).! !!Canvas methodsFor: 'drawing-lines and fills' stamp: 'ar 6/17/1999 01:30'!line: pt1 to: pt2 brushForm: brush	"Obsolete - will be removed in the future"! !!Canvas methodsFor: 'drawing-lines and fills' stamp: 'ar 6/17/1999 01:31'!line: pt1 to: pt2 width: w color: c	"Draw a line using the given width and color"	^self subclassResponsibility! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 2/16/2000 23:45'!drawImage: aForm at: aPoint	"Draw the given Form, which is assumed to be a Form or ColorForm"	self drawImage: aForm		at: aPoint		sourceRect: aForm boundingBox! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 2/17/2000 01:47'!drawImage: aForm at: aPoint sourceRect: sourceRect	"Draw the given form."	self shadowColor ifNotNil:[		^self fillRectangle: ((aForm boundingBox intersect: sourceRect) translateBy: aPoint)				color: self shadowColor].	^self image: aForm		at: aPoint		sourceRect: sourceRect		rule: Form over! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 2/16/2000 23:48'!paintImage: aForm at: aPoint	"Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."	self paintImage: aForm		at: aPoint		sourceRect: aForm boundingBox! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 2/17/2000 01:48'!paintImage: aForm at: aPoint sourceRect: sourceRect	"Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."	self shadowColor ifNotNil:[		^self stencil: aForm at: aPoint sourceRect: sourceRect color: self shadowColor].	^self image: aForm		at: aPoint		sourceRect: sourceRect		rule: Form paint! !!Canvas methodsFor: 'drawing-images' stamp: 'jm 3/18/2003 11:19'!paintImage: aForm at: aPoint sourceRect: sourceRect alpha: alpha	"Draw the given Form, which is assumed to be a Form or ColorForm following the convention that zero is the transparent pixel value."	self shadowColor ifNotNil:[		^ self stencil: aForm at: aPoint sourceRect: sourceRect color: self shadowColor].	^ self image: aForm		at: aPoint		sourceRect: sourceRect		rule: 31		alpha: alpha! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 6/25/1999 12:17'!stencil: stencilForm at: aPoint color: aColor	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"	^self stencil: stencilForm		at: aPoint		sourceRect: stencilForm boundingBox		color: aColor! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 6/25/1999 12:17'!stencil: stencilForm at: aPoint sourceRect: sourceRect color: aColor	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"	^self subclassResponsibility! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 2/17/2000 14:05'!translucentImage: aForm at: aPoint	"Draw a translucent image using the best available way of representing translucency."	self translucentImage: aForm		at: aPoint		sourceRect: aForm boundingBox! !!Canvas methodsFor: 'drawing-images' stamp: 'ar 2/17/2000 01:48'!translucentImage: aForm at: aPoint sourceRect: sourceRect	"Draw a translucent image using the best available way of representing translucency.	Note: This will be fixed in the future."	self shadowColor ifNotNil:[		^self stencil: aForm at: aPoint sourceRect: sourceRect color: self shadowColor].	(self depth < 32 or:[aForm depth < 32]) 		ifTrue:[^self paintImage: aForm at: aPoint sourceRect: sourceRect].	self image: aForm		at: aPoint		sourceRect: sourceRect		rule: Form blend! !!Canvas methodsFor: 'drawing-text' stamp: 'ar 6/17/1999 01:31'!paragraph: paragraph bounds: bounds color: c	"Draw the given paragraph"	^self subclassResponsibility! !!Canvas methodsFor: 'drawing-text' stamp: 'ar 6/17/1999 01:32'!text: s bounds: boundsRect font: fontOrNil color: c	"Draw the given string in the given font and color clipped to the given rectangle. If the font is nil, the default font is used."	^self subclassResponsibility! !!Canvas methodsFor: 'other' stamp: 'jm 6/15/2003 18:40'!contentsOfArea: aRectangle	"Return the contents of the given area"	^ self		contentsOfArea: aRectangle		into: (Form extent: aRectangle extent depth: self depth)! !!Canvas methodsFor: 'other' stamp: 'jm 6/15/2003 18:40'!contentsOfArea: aRectangle into: aForm	"Return a Form containing the contents of the given area."	^ self subclassResponsibility! !!Canvas methodsFor: 'other'!forceToScreen:rect	" dummy "! !!Canvas methodsFor: 'private' stamp: 'ar 2/12/2000 18:12'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Note: The public use of this protocol is deprecated. It will become private. Nobody in the outside world must assume that a thing like a combination rule has any specific effect."	^self subclassResponsibility! !The first message has the common receiver, the rest have receiver == nil, which signifies cascading.!I provide a page of controls or settings for each of my categories. Initially created to provide a muliple category editor for the system preferences.!!CategorizedControlPanel methodsFor: 'initialization' stamp: 'jm 7/7/2003 23:15'!addCategorySelector	| r categoryBar menuIcon menuIconPopUp |	categoryBar _ AlignmentMorph new.	categoryBar inset:0; color: (Color transparent); centering: #right; hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	menuIcon _ ImageMorph new form: ArrowIcon.	menuIconPopUp _ PopUpChoiceMorph new		addMorph: menuIcon;		extent: 16@16;		contentsClipped: '';		target: self;		actionSelector: #currentCategory:;		getItemsSelector: #categories.	chooser _ StringMorph new.	chooser contents: #currentCategory asString.	r _ AlignmentMorph newRow		color: color;		inset: 4;		centering: #right;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	r addMorphBack: (StringMorph		contents: 'Category: ' font: TextStyle default defaultFont emphasis: 1).	r addMorphBack: chooser; addMorphBack: ((AlignmentMorph new) extent: 16@16; color: (Color transparent)); addMorphBack: menuIconPopUp.	categoryBar addMorphBack: (AlignmentMorph newSpacer: (Color transparent)); addMorphBack: r.	self addMorphFront: categoryBar.! !!CategorizedControlPanel methodsFor: 'initialization' stamp: 'jm 6/15/2003 10:28'!initialize	| r tmp |	super initialize.	self		orientation: #vertical;		borderWidth: 2;		inset: 0;		color: Color lightGray;		centering: #center.	self addCategorySelector.	tmp _ Dictionary new.	#(red green blue) collect: [:cName |		r _ BorderedMorph			newBounds: (0@0 extent: 120@160)			color: (Color perform: cName).		tmp at: cName put: r].	self panels: tmp.! !!CategorizedControlPanel methodsFor: 'accessing' stamp: 'jm 10/16/2002 11:25'!categories	"Answer a sorted list of my category names."	^ panels keys asArray sort! !!CategorizedControlPanel methodsFor: 'accessing' stamp: 'jm 10/16/2002 11:25'!currentCategory	"Return the name of the currently display category."	^ currentCategory! !!CategorizedControlPanel methodsFor: 'accessing' stamp: 'jm 10/16/2002 11:45'!currentCategory: aString	"Display the panel morph associated with the given category. Do nothing if there is no category of that name in my panels dictionary."	| newPanel |	currentCategory _ aString.	newPanel _ panels at: currentCategory ifAbsent: [^ self].	chooser contents: aString; fitContents.	currentPanel ifNotNil: [currentPanel delete].	currentPanel _ newPanel.	self addMorphBack: newPanel.	self world ifNotNil: [self world startSteppingSubmorphsOf: newPanel].! !!CategorizedControlPanel methodsFor: 'accessing' stamp: 'jm 10/16/2002 11:25'!panels	"Answer my panels dictionary."	^ panels! !!CategorizedControlPanel methodsFor: 'accessing' stamp: 'jm 10/16/2002 11:30'!panels: aDictionary	"Set my panels to the given dictionary. The keys of this dictionary are my categories; its values are morphs, typically pages full of controls."	panels _ aDictionary.	self currentCategory: panels keys asArray sort first.! !!CategorizedControlPanel class methodsFor: 'class variables' stamp: 'jm 7/7/2003 23:16'!readIconFrom: aDirectory	"Read my icon from the given directory and save them in class variables."	"self readIconFrom: (FileDirectory default directoryNamed: 'ScratchSkin')"	ArrowIcon _ Form fromFileNamed: (aDirectory fullNameFor: 'arrowDOWN.gif').! !A model for a morphic world view which will ask for confirmation before being closed, unless the corresponding preference is set to false. !!CautiousModel methodsFor: 'as yet unclassified' stamp: 'sw 9/15/1998 16:45'!okToChange	Preferences cautionBeforeClosing ifFalse: [^ true].	Sensor leftShiftDown ifTrue: [^ true].	self beep.	^ self confirm: 'Warning!!If you answer "yes" here, thiswindow will disappear andits contents will be lost!!Do you really want to do that?'"CautiousModel new okToChange"! !!ChangeList methodsFor: 'initialization-release' stamp: 'sw 1/7/2000 12:42'!changeListButtonSpecs	^#(		('select all' 			selectAll				'select all entries')		('deselect all'		deselectAll			'deselect all entries')		('select conflicts'	selectAllConflicts	'select all methods that occur in any change set')		('file in selections' 	fileInSelections		'file in all selected entries')		)! !!ChangeList methodsFor: 'initialization-release' stamp: 'sw 1/13/2000 10:50'!initialize	showDiffs _ Preferences diffsInChangeList.	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	super initialize! !!ChangeList methodsFor: 'initialization-release' stamp: 'sbw 12/30/1999 11:02'!optionalButtonHeight	^ 15! !!ChangeList methodsFor: 'initialization-release' stamp: 'sw 1/7/2000 15:43'!optionalButtonsView	| view bHeight vWidth offset specs previousView button wid buttonCount |	view _ View new model: self.	bHeight _ self optionalButtonHeight.	vWidth _ 180.	view window: (0@0 extent: vWidth@bHeight).	offset _ 0.	specs _ self changeListButtonSpecs.	buttonCount _ specs size + 1.	previousView _ nil.	wid _ vWidth // buttonCount.	specs do: [:triplet |		button _ PluggableButtonView on: self getState: nil action: triplet second.		button			label: triplet first asParagraph;			insideColor: Color lightBlue;			borderWidthLeft: 0 right: 1 top: 0 bottom: 0;			window: (offset@0 extent: wid@bHeight).		offset _ offset + wid.		triplet last = specs first last			ifTrue: [view addSubView: button]			ifFalse: [view addSubView: button toRightOf: previousView].		previousView _ button].	button _ PluggableButtonView on: self getState: #showDiffs action: #toggleDiff.	button		label: 'toggle diff' asParagraph;		insideColor: Color lightBlue;		window: (offset@0 extent: (vWidth - offset)@bHeight).	view addSubView: button toRightOf: previousView.	^view! !!ChangeList methodsFor: 'scanning' stamp: 'sw 10/19/1999 15:13'!scanFile: aFile from: startPosition to: stopPosition	| itemPosition item prevChar |	file _ aFile.	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	file position: startPosition.'Scanning ', aFile localName, '...'	displayProgressAt: Sensor cursorPoint	from: startPosition to: stopPosition	during: [:bar |	[file position < stopPosition]		whileTrue:		[bar value: file position.		[file atEnd not and: [file peek isSeparator]]				whileTrue: [prevChar _ file next].		(file peekFor: $!!)		ifTrue:			[(prevChar = Character cr or: [prevChar = Character lf])				ifTrue: [self scanCategory]]		ifFalse:			[itemPosition _ file position.			item _ file nextChunk.			file skipStyleChunk.			item size > 0 ifTrue:				[self addItem: (ChangeRecord new file: file position: itemPosition type: #doIt)					text: 'do it: ' , (item contractTo: 50)]]]].	listSelections _ Array new: list size withAll: false! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 1/7/2000 12:59'!browseCurrentVersionsOfSelections	"Opens a message-list browser on the current in-memory versions of all methods that are currently seleted"	|  aClass aChange aList |	aList _ OrderedCollection new.	Cursor read showWhile: 	[1 to: changeList size do:		[:i | (listSelections at: i) ifTrue:			 [aChange _ changeList at: i.			(aChange type = #method				and: [(aClass _ aChange methodClass) notNil				and: [aClass includesSelector: aChange methodSelector]])					ifTrue:						[aList add: aClass name, ' ', aChange methodSelector]]]].	aList size == 0 ifTrue: [^ self inform: 'no selected methods have in-memory counterparts'].	MessageSet openMessageList: aList name: 'Current versions of selected methods in ', file localName! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 5/6/2000 02:54'!buttonRowForChangeList	| aRow aButton |	aRow _ AlignmentMorph newRow.	aRow setProperty: #clipToOwnerWidth toValue: true.	aRow addTransparentSpacerOfSize: (5@0).	aRow centering: #center.	self changeListButtonSpecs do:		[:triplet |			aButton _ PluggableButtonMorph				on: self				getState: nil				action: triplet second.			aButton useRoundedCorners;				label: triplet first asString;				askBeforeChanging: true;				onColor: Color transparent offColor: Color transparent.			aRow addMorphBack: aButton.			aRow addTransparentSpacerOfSize: (3 @ 0).			aButton setBalloonText: triplet third.			aRow addMorphBack: aButton.			aRow addTransparentSpacerOfSize: (3 @ 0).			aButton setBalloonText: triplet third.			aRow addTransparentSpacerOfSize: (3 @ 0)].	aRow addMorphBack: self diffButton.		^ aRow! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 1/7/2000 13:25'!changeListMenu: aMenu^ aMenu labels:'fileIn selectionsfileOut selections...compare to currenttoggle diffingselect conflicts with any changesetselect conflicts with current changesetselect conflicts with...select unchanged methodsselect methods for this classselect alldeselect allbrowse current versions of selectionsremove doItsremove older versionsremove selections'	lines: #(2 4 6 9 11 12)	selections: #(fileInSelections fileOutSelectionscompareToCurrentVersion toggleDiffing selectAllConflicts  selectConflicts selectConflictsWith selectUnchangedMethods selectMethodsForThisClass  selectAll  deselectAll browseCurrentVersionsOfSelectionsremoveDoIts removeOlderMethodVersions removeSelections)"select such that...   selectSuchThat"! !!ChangeList methodsFor: 'menu actions' stamp: 'di 1/13/1999 14:34'!compareToCurrentVersion	"If the current selection corresponds to a method in the system,	then spawn a window showing the diffs as text"	| change class s1 s2 |	listIndex = 0 ifTrue: [^ self].	change _ changeList at: listIndex.	((class _ change methodClass) notNil			and: [class includesSelector: change methodSelector])	ifTrue:		[s1 _ (class sourceCodeAt: change methodSelector) asString.		s2 _ change string.		s1 = s2 ifTrue: [^ self inform: 'Exact Match'].		(StringHolder new textContents:			(TextDiffBuilder buildDisplayPatchFrom: s1 to: s2))			openLabel: 'Comparison to Current Version']	ifFalse:		[self flash].! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 10/11/1999 17:10'!fileInSelections 	| any |	any _ false.	listSelections with: changeList do: 		[:selected :item | selected ifTrue: [any _ true. item fileIn]].	any ifFalse:		[self inform: 'nothing selected, so nothing done']! !!ChangeList methodsFor: 'menu actions' stamp: 'sma 2/5/2000 19:13'!fileOutSelections 	| f |	f _ FileStream newFileNamed: (FillInTheBlank request: 'Enter file name' initialAnswer: 'Filename.st').	f ifNil: [^ self].	f header; timeStamp.	listSelections with: changeList do: 		[:selected :item | selected ifTrue: [item fileOutOn: f]].	f close! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 10/11/1999 17:18'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If I can respond, then perform it on myself.  If not, send it to otherTarget, presumably the editPane from which the menu was invoked." 	(#accept == selector) ifTrue:		[otherTarget isMorph ifFalse: [^ self acceptFrom: otherTarget view]].			"weird special case just for mvc changlist"	^ super perform: selector orSendTo: otherTarget! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 12/27/1999 12:24'!selectAllConflicts	"Selects all method definitions in the receiver which are also in any existing change set in the system.  This makes no statement about whether the content of the methods differ, only whether there is a change represented."	|  aClass aChange |	Cursor read showWhile: 	[1 to: changeList size do:		[:i | aChange _ changeList at: i.		listSelections at: i put:			(aChange type = #method			and: [(aClass _ aChange methodClass) notNil			and: [(ChangeSorter allChangeSetsWithClass: aClass selector: aChange methodSelector) size > 0]])]].	self changed: #allSelections! !!ChangeList methodsFor: 'menu actions' stamp: 'tk 6/24/1999 07:22'!selectConflictsWith	"Selects all method definitions for which there is ALSO an entry in the specified changeSet or changList chosen by the user. 4/11/96 tk"	| aStream all index |	aStream _ WriteStream on: (String new: 200).	all _ ChangeSet allSubInstances asOrderedCollection.	all do:		[:sel | aStream nextPutAll: (sel name contractTo: 40); cr].	ChangeList allSubInstancesDo:		[:sel | aStream nextPutAll: (sel file name); cr.			all addLast: sel].	aStream skip: -1.	index _ (PopUpMenu labels: aStream contents) startUp.	index > 0 ifTrue: [		self selectConflicts: (all at: index)].! !!ChangeList methodsFor: 'menu actions' stamp: 'ls 11/14/1998 14:30'!selectMethodsForThisClass	| name |	self currentChange ifNil: [ ^self ].	name _ self currentChange methodClassName.	name ifNil: [ ^self ].	^self selectSuchThat: [ :change |		change methodClassName = name ].! !!ChangeList methodsFor: 'menu actions' stamp: 'sw 1/7/2000 15:04'!selectSuchThat	"query the user for a selection criterio.  By Lex Spoon.  NB: the UI for invoking this from a changelist browser is currently commented out; to reenfranchise it, you'll need to mild editing to ChangeList method #changeListMenu:"	| code block |	code _ FillInTheBlank request: 'selection criteria for a change named aChangeRecord?\For instance, ''aChangeRecord category = ''System-Network''''' withCRs.	code isEmpty ifTrue: [^ self ].	block _ Compiler evaluate: '[:aChangeRecord | ', code, ']'.	self selectSuchThat: block! !!ChangeList methodsFor: 'menu actions' stamp: 'ls 5/12/1999 07:56'!selectSuchThat: aBlock	"select all changes for which block returns true"	listSelections _ changeList collect: [ :change | aBlock value: change ].	self changed: #allSelections! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 9/27/1999 16:01'!contents	^ self showDiffs		ifFalse:			[self undiffedContents]		ifTrue:			[self showsVersions				ifTrue:					[self diffedVersionContents]				ifFalse:					[self contentsDiffedFromCurrent]]! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 1/12/1999 12:40'!contentsDiffedFromCurrent	| aChange aClass |	listIndex = 0		ifTrue: [^ ''].	aChange _ changeList at: listIndex.	^ ((aChange type == #method and: [(aClass _ aChange methodClass) notNil]) and: [aClass includesSelector: aChange methodSelector])		ifTrue:			 [Utilities methodDiffFor: aChange text class: aClass selector: aChange methodSelector]		ifFalse:			[(changeList at: listIndex) text]! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 2/7/2000 01:32'!diffedVersionContents	| thisText |	(listIndex = 0 or: [changeList size < listIndex])		ifTrue: [^ ''].	thisText _ (changeList at: listIndex) text.	^ listIndex == changeList size		ifTrue:			[thisText]		ifFalse:			[TextDiffBuilder buildDisplayPatchFrom: (changeList at: (listIndex + 1)) text to: thisText]! !!ChangeList methodsFor: 'viewing access' stamp: 'di 1/13/1999 14:59'!listSelectionAt: index put: value	^ listSelections at: index put: value! !!ChangeList methodsFor: 'viewing access' stamp: 'di 6/15/97 16:46'!restoreDeletedMethod	"If lostMethodPointer is not nil, then this is a version browser for a method that has been removed.  In this case we want to establish a sourceCode link to prior versions.  We do this by installing a dummy method with the correct source code pointer prior to installing this version."	| dummyMethod class selector |	dummyMethod _ CompiledMethod toReturnSelf setSourcePointer: lostMethodPointer.	class _ (changeList at: listIndex) methodClass.	selector _ (changeList at: listIndex) methodSelector.	class addSelector: selector withMethod: dummyMethod.	(changeList at: listIndex) fileIn.	"IF for some reason, the dummy remains, remove it, but (N.B.!!) we might not get control back if the compile (fileIn above) fails."	(class compiledMethodAt: selector) == dummyMethod		ifTrue: [class removeSelectorSimply: selector].	^ true! !!ChangeList methodsFor: 'viewing access' stamp: 'sma 2/5/2000 19:09'!selectedClassOrMetaClass	| c |	^ (c _ self currentChange) ifNotNil: [c methodClass]! !!ChangeList methodsFor: 'viewing access' stamp: 'sma 2/5/2000 19:10'!selectedMessageName	| c |	^ (c _ self currentChange) ifNotNil: [c methodSelector]! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 1/28/1999 12:30'!toggleListIndex: newListIndex	listIndex ~= 0 ifTrue: [listSelections at: listIndex put: false].	newListIndex ~= 0 ifTrue: [listSelections at: newListIndex put: true].	listIndex _ newListIndex.	self changed: #listIndex.	self contentsChanged! !!ChangeList methodsFor: 'viewing access' stamp: 'sw 1/25/1999 14:45'!undiffedContents	^ listIndex = 0		ifTrue: ['']		ifFalse: [(changeList at: listIndex) text]! !!ChangeList methodsFor: 'accessing' stamp: 'ls 5/12/1999 07:55'!currentChange	"return the current change being viewed, or nil if none"	listIndex = 0 ifTrue: [ ^nil ].	^changeList at: listIndex! !!ChangeList methodsFor: 'accessing' stamp: 'TPR 11/28/1998 17:38'!listHasSingleEntry	"does the list of changes have only a single item?"	^list size = 1! !!ChangeList methodsFor: 'accessing' stamp: 'tk 6/21/1999 20:43'!listSelections	listSelections ifNil: [		list ifNotNil: [			listSelections _ Array new: list size withAll: false]].	^ listSelections! !!ChangeList methodsFor: 'accessing' stamp: 'sw 10/19/1999 15:11'!showsVersions	^ false! !!ChangeList class methodsFor: 'public access' stamp: 'di 6/12/1998 16:33'!browseRecentLog    "ChangeList browseRecentLog"	"Prompt with a menu of how far back to go"	| end changesFile banners positions pos chunk i |	changesFile _ (SourceFiles at: 2) readOnlyCopy.	banners _ OrderedCollection new.	positions _ OrderedCollection new.	end _ changesFile size.	pos _ Smalltalk lastQuitLogPosition.	[pos = 0 or: [banners size > 20]] whileFalse:		[changesFile position: pos.		chunk _ changesFile nextChunk.		i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.		i > 0 ifTrue: [positions addLast: pos.					banners addLast: (chunk copyFrom: 5 to: i-2).					pos _ Number readFrom: (chunk copyFrom: i+13 to: chunk size)]			ifFalse: [pos _ 0]].	changesFile close.	pos _ (SelectionMenu labelList: banners selections: positions)				startUpWithCaption: 'Browse as far back as...'.	pos == nil ifTrue: [^ self].	self browseRecent: end-pos! !!ChangeList class methodsFor: 'public access' stamp: 'sw 2/3/2000 16:16'!getRecentLocatorWithPrompt: aPrompt	"Prompt with a menu of how far back to go.  Return nil if user backs out.  Otherwise return the number of characters back from the end of the .changes file the user wishes to include"	 "ChangeList getRecentPosition"	| end changesFile banners positions pos chunk i |	changesFile _ (SourceFiles at: 2) readOnlyCopy.	banners _ OrderedCollection new.	positions _ OrderedCollection new.	end _ changesFile size.	pos _ Smalltalk lastQuitLogPosition.	[pos = 0 or: [banners size > 20]] whileFalse:		[changesFile position: pos.		chunk _ changesFile nextChunk.		i _ chunk indexOfSubCollection: 'priorSource: ' startingAt: 1.		i > 0 ifTrue: [positions addLast: pos.					banners addLast: (chunk copyFrom: 5 to: i-2).					pos _ Number readFrom: (chunk copyFrom: i+13 to: chunk size)]			ifFalse: [pos _ 0]].	changesFile close.	pos _ (SelectionMenu labelList: banners selections: positions)				startUpWithCaption: aPrompt.	pos == nil ifTrue: [^ nil].	^ end - pos! !!ChangeList class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 09:21'!open: aChangeList name: aString multiSelect: multiSelect	"Create a standard system view for the messageSet, whose label is aString.	The listView may be either single or multiple selection type"	| topView aBrowserCodeView aListView underPane pHeight |	Smalltalk isMorphic ifTrue: [^ self openAsMorph: aChangeList name: aString multiSelect: multiSelect].	topView _ (StandardSystemView new) model: aChangeList.	topView label: aString.	topView minimumSize: 180 @ 120.	topView borderWidth: 1.	Preferences optionalButtons		ifTrue:			[underPane _ aChangeList optionalButtonsView.			underPane isNil				ifTrue: [pHeight _ 100]				ifFalse:					[topView addSubView: underPane.					pHeight _ 100 - aChangeList optionalButtonHeight]]		ifFalse:			[underPane _ nil.			pHeight _ 100].	aListView _ (multiSelect					ifTrue: [PluggableListViewOfMany]					ifFalse: [PluggableListView])		on: aChangeList list: #list		selected: #listIndex changeSelected: #toggleListIndex:		menu: (aChangeList showsVersions ifTrue: [#versionsMenu:] ifFalse: [#changeListMenu:])		keystroke: #messageListKey:from:.	aListView window: (0 @ 0 extent: 180 @ pHeight).	underPane isNil		ifTrue: [topView addSubView: aListView]		ifFalse: [topView addSubView: aListView below: underPane].	aBrowserCodeView _ PluggableTextView on: aChangeList 			text: #contents accept: #contents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	aBrowserCodeView controller: ReadOnlyTextController new.	aBrowserCodeView window: (0 @ 0 extent: 180 @ 300).	topView addSubView: aBrowserCodeView below: aListView.	topView controller open! !!ChangeList class methodsFor: 'instance creation' stamp: 'sw 1/7/2000 14:59'!openAsMorph: aChangeList name: labelString multiSelect: multiSelect	"Open a morphic view for the messageSet, whose label is labelString.	The listView may be either single or multiple selection type"	| window boundary  |	window _ (SystemWindow labelled: labelString) model: aChangeList.	Preferences optionalButtons		ifFalse:			[boundary _ 0]		ifTrue:			[boundary _ 0.08.			window addMorph: aChangeList buttonRowForChangeList frame: (0 @ 0 corner: 1 @ boundary)].	window addMorph: ((multiSelect ifTrue: [PluggableListMorphOfMany]									ifFalse: [PluggableListMorph])		on: aChangeList list: #list		selected: #listIndex changeSelected: #toggleListIndex:		menu: (aChangeList showsVersions ifTrue: [#versionsMenu:] ifFalse: [#changeListMenu:])			keystroke: nil)		frame: (0@boundary corner: 1@0.4).	window addMorph: (AcceptableCleanTextMorph on: aChangeList 			text: #contents accept: #contents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.4 corner: 1@1).	^ window openInWorld! !A ChangeRecord represents a change recorded on a file in fileOut format.It includes a type (more needs to be done here), and additional informationfor certain types such as method defs which need class and category.!!ChangeRecord methodsFor: 'access'!category	^category! !!ChangeRecord methodsFor: 'access' stamp: 'sw 8/24/1998 08:16'!fileIn	| methodClass |	Cursor read showWhile:		[(methodClass _ self methodClass) notNil ifTrue:			[methodClass compile: self text classified: category withStamp: stamp notifying: nil].		(type == #doIt) ifTrue:			[Compiler evaluate: self string].		(type == #classComment) ifTrue:			[(Smalltalk at: class asSymbol) comment: self text stamp: stamp]]! !!ChangeRecord methodsFor: 'access' stamp: 'tk 6/24/1999 15:27'!headerFor: selector	^ '    ' , class , (meta ifTrue: [' class '] ifFalse: [' '])				, selector				, (stamp isEmpty ifTrue: [''] ifFalse: ['; ' , stamp])! !!ChangeRecord methodsFor: 'access'!isMetaClassChange	^meta! !!ChangeRecord methodsFor: 'access'!methodClassName	^class! !!ChangeRecord methodsFor: 'access' stamp: 'tk 6/21/1999 20:34'!readStamp	"Get the time stamp of this method off the file"	| item tokens anIndex |	stamp _ ''.	file ifNil: [^ stamp].	file position: position.	item _ file nextChunk.	tokens _ Scanner new scanTokens: item.	tokens size < 3 ifTrue: [^ stamp].	anIndex _ tokens indexOf: #stamp: ifAbsent: [^ stamp].	^ stamp _ tokens at: (anIndex + 1).! !!ChangeRecord methodsFor: 'access' stamp: 'tk 6/23/1999 08:20'!text	| text |	^ file ifNil: ['']		ifNotNil: [			file openReadOnly.			file position: position.			text _ file nextChunkText.			file close.			text]! !!ChangeRecord methodsFor: 'initialization' stamp: 'tk 6/24/1999 14:51'!class: clsName category: cat method: method sourceFiles: fileArray	"This should be enough to find all the information for a method, or method deletion"	file _ fileArray at: method fileIndex.	position _ method filePosition.	type _ #method.	class _ clsName copyUpTo: $ .	"the non-meta part of a class name"	category _ cat.	meta _ clsName endsWith: ' class'.	self readStamp.! !ChangeSets keep track of the changes made to a system, so they can be written on a file as source code (a "fileOut").  Every project has an associated changeSet.  For simple projects, a different changeSet may be designated to capture changes at any time.This implementation of ChangeSet is capable of remembering and manipulating methods for which the classes are not present in the system.  However at the present time, this capability is not used in normal rearranging and fileOuts, but only for invoking and revoking associated with isolation layers.For isolated projects (see Project class comment), the changeSet binding is semi-permanent.  Every project exists in an isolation layer defined by its closest enclosing parent (or itself) that is isolated.  If a project is not isolated, then changes reported to its designated changeSet must also be reported to the permanent changeSet for that layer, designated in the isolated project.  This ensures that that outer project will be able to revert all changes upon exit.Note that only certain changes may be reverted.  Classes may not be added, removed, renamed or reshaped except in the layer in which they are defined because these operations on non-local classes are not revertable.If a Squeak Project is established as being isolated, then its associated changeSet will be declared to be revertable.  In this case all changes stored can be reverted.  The changeSet associated with an isolated project is tied to that project, and cannot be edited in a changeSorter.------name - a String used to name the changeSet, and thus any associated project or fileOut.preamble and postscript:  two strings that serve as prefix (useful for documentation) and suffix (useful for doits) to the fileout of the changeSet.revertable - a BooleanIf this variable is true, then all of the changes recorded by this changeSet can be reverted.isolationSet - a ChangeSet or nilThe isolationSet is the designated changeSet for an isolation layer.  If this changeSet is an isolationSet, then this variable will be nil.  If not, then it points to the isolationSet for this layer, and all changes reported here will also be reported to the isolationSet.isolatedProject - a Project or nilIf this is an isolationSet, then this variable points to the project with which it is associated.changeRecords -  Dictionary {class name -> a ClassChangeRecord}.These classChangeRecords (qv) remember all of the system changes.structures -    Dictionary {#Rectangle -> #(<classVersionInteger> 'origin' 'corner')}.Of  the names of the instances variables before any changes for all classes in classChanges, and all of their superclasses.  In the same format used in SmartRefStream.  Inst var names are strings.  superclasses -    Dictionary {#Rectangle -> #Object}.Of all classes in classChanges, and all of their superclasses.Structures and superclasses save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp).NOTE:  It should be fairly simple, by adding a bit more information to the classChangeRecords, to reconstruct the information now stored in 'structures' and 'superclasses'.  This would be a welcome simplification.!!ChangeSet methodsFor: 'initialize-release' stamp: 'di 4/1/2000 12:00'!clear 	"Reset the receiver to be empty.  "	changeRecords _ Dictionary new.	preamble _ nil.	postscript _ nil! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 4/3/2000 14:46'!initialize 	"Reset the receiver to be empty."	revertable _ false.	self clear. 	"Avoid duplicate entries in AllChanges if initialize gets called twice"	name _ ChangeSet defaultName.! !!ChangeSet methodsFor: 'initialize-release'!isMoribund	"Answer whether the receiver is obsolete and about to die; part of an effort to get such guys cleared out from the change sorter.  2/7/96 sw"	^ name == nil ! !!ChangeSet methodsFor: 'initialize-release' stamp: 'di 3/23/2000 12:14'!wither	"The receiver is to be clobbered.  Clear it out.  2/7/96 sw"	self clear.	name _ nil! !!ChangeSet methodsFor: 'change logging' stamp: 'jm 5/16/2003 09:19'!addClass: class 	"Include indication that a new class was created."	class wantsChangeSetLogging ifFalse: [^ self].	self atClass: class add: #new.	self atClass: class add: #change.	self addCoherency: class name.! !!ChangeSet methodsFor: 'change logging' stamp: 'jm 5/16/2003 09:18'!changeClass: class from: oldClass	"Remember that a class definition has been changed. Record the original structure, so that a conversion method can be built."	class wantsChangeSetLogging ifFalse: [^ self]. 	self atClass: class add: #change.	self addCoherency: class name.	(self changeRecorderFor: class) notePriorDefinition: oldClass.	self noteClassStructure: oldClass.! !!ChangeSet methodsFor: 'change logging' stamp: 'jm 5/16/2003 09:18'!noteNewMethod: newMethod forClass: class selector: selector priorMethod: methodOrNil	class wantsChangeSetLogging ifFalse: [^ self].	(self changeRecorderFor: class)		noteNewMethod: newMethod selector: selector priorMethod: methodOrNil.! !!ChangeSet methodsFor: 'change logging' stamp: 'jm 5/16/2003 09:17'!removeSelector: selector class: class priorMethod: priorMethod lastMethodInfo: info	"Include indication that a method has been forgotten. info is a pair of the source code pointer and message category for the method that was removed."	class wantsChangeSetLogging ifFalse: [^ self].	(self changeRecorderFor: class)		noteRemoveSelector: selector priorMethod: priorMethod lastMethodInfo: info.! !!ChangeSet methodsFor: 'change logging' stamp: 'jm 5/16/2003 09:18'!renameClass: class as: newName 	"Include indication that a class has been renamed."	| recorder |	(recorder _ self changeRecorderFor: class)		noteChangeType: #rename;		noteNewName: newName asSymbol.			"store under new name (metaclass too)"	changeRecords at: newName put: recorder.	changeRecords removeKey: class name.	recorder _ changeRecords at: class class name ifAbsent: [^ nil].	changeRecords at: (newName, ' class') put: recorder.	changeRecords removeKey: class class name.	recorder noteNewName: newName, ' class'.! !!ChangeSet methodsFor: 'accessing' stamp: 'di 4/1/2000 12:00'!classRemoves	^ changeRecords keys select:		[:className | (changeRecords at: className) isClassRemoval]! !!ChangeSet methodsFor: 'accessing' stamp: 'di 4/8/2000 23:16'!editPostscript	"edit the receiver's postscript, in a separate window.  "	| deps found |	self assurePostscriptExists.	deps _ postscript dependents select:		[:m | (m isKindOf: SystemWindow) or:			[m isKindOf: StandardSystemView]].	deps size > 0 ifTrue:		[Smalltalk isMorphic			ifTrue:				[found _ deps detect: [:obj | (obj isKindOf: SystemWindow) and: [obj world == self currentWorld]] ifNone: [nil].				found ifNotNil:  [^ found activate]]			ifFalse:				[found _ deps detect: [:obj | (obj isKindOf: StandardSystemView) and: [ScheduledControllers scheduledControllers includes: obj controller]] ifNone: [nil].				found ifNotNil: [^ ScheduledControllers activateController: found controller]]..		self inform:'Caution -- there', (deps size isOrAreStringWith: 'other window'), 'already open on this postscript elsewhere'].	postscript openLabel: 'Postscript for ChangeSet named ', name! !!ChangeSet methodsFor: 'accessing' stamp: 'sw 6/29/1999 14:44'!hasPostscript	^ postscript notNil! !!ChangeSet methodsFor: 'accessing' stamp: 'di 4/1/2000 12:00'!methodChanges	| methodChangeDict changeTypes |	methodChangeDict _ Dictionary new.	changeRecords associationsDo:		[:assn |		changeTypes _ assn value methodChangeTypes.		changeTypes isEmpty ifFalse: [methodChangeDict at: assn key put: changeTypes]].	^ methodChangeDict! !!ChangeSet methodsFor: 'accessing' stamp: 'di 3/29/2000 16:22'!methodInfoFromRemoval: classAndSelector	^ (self changeRecorderFor: classAndSelector first)		infoFromRemoval: classAndSelector last! !!ChangeSet methodsFor: 'accessing'!name	"The name of this changeSet.	 2/7/96 sw: If name is nil, we've got garbage.  Help to identify."	^ name == nil		ifTrue:			['<no name -- garbage?>']		ifFalse:			[name]! !!ChangeSet methodsFor: 'accessing'!name: anObject	name _ anObject! !!ChangeSet methodsFor: 'accessing' stamp: 'sw 6/29/1999 20:51'!postscriptHasDependents	^ postscript dependents size > 0! !!ChangeSet methodsFor: 'accessing'!printOn: aStream	"2/7/96 sw: provide the receiver's name in the printout"	super printOn: aStream.	aStream nextPutAll: ' named ', self name! !!ChangeSet methodsFor: 'accessing' stamp: 'sw 6/29/1999 14:48'!removePostscript	postscript _ nil! !!ChangeSet methodsFor: 'accessing' stamp: 'tk 6/8/1999 22:25'!structures	^structures! !!ChangeSet methodsFor: 'accessing' stamp: 'tk 6/8/1999 22:25'!superclasses	^superclasses! !!ChangeSet methodsFor: 'testing' stamp: 'di 4/4/2000 16:55'!belongsToAProject	Smalltalk at: #Project ifPresent:		[:projClass | projClass allSubInstancesDo:			[:proj | proj projectChangeSet == self ifTrue: [^ true]]].	^ false! !!ChangeSet methodsFor: 'testing' stamp: 'di 4/4/2000 17:08'!correspondingProject	"If the receiver is the current change set for any project, answer it, else answer nil"	Project allSubInstancesDo: [:proj |		proj projectChangeSet == self ifTrue: [^ proj]].	^ nil! !!ChangeSet methodsFor: 'testing' stamp: 'di 4/1/2000 12:00'!isEmpty	"Answer whether the receiver contains any elements."	^ changeRecords isEmpty ! !!ChangeSet methodsFor: 'testing' stamp: 'sw 8/3/1998 16:25'!okayToRemove	^ self okayToRemoveInforming: true! !!ChangeSet methodsFor: 'testing' stamp: 'sw 8/3/1998 16:25'!okayToRemoveInforming: aBoolean	"Answer whether it is okay to remove the receiver.  If aBoolean is true, inform the receiver if it is not okay"	| aName |	aName _ self name.	self == Smalltalk changes ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '"because it is the current change set.'].		^ false].	self belongsToAProject ifTrue:		[aBoolean ifTrue: [self inform: 'Cannot remove "', aName, '" because it belongs to a project.'].			^ false].	^ true! !!ChangeSet methodsFor: 'testing' stamp: 'di 4/4/2000 17:08'!projectsBelongedTo	"Answer a list of all the projects for which the receiver is the current change set"	^ Project allSubInstances select: [:proj |		proj projectChangeSet == self]! !!ChangeSet methodsFor: 'method changes' stamp: 'di 3/29/2000 11:01'!atSelector: selector class: class put: changeType	(selector == #DoIt or: [selector == #DoItIn:]) ifTrue: [^ self].	(self changeRecorderFor: class) atSelector: selector put: changeType.! !!ChangeSet methodsFor: 'method changes' stamp: 'sw 10/19/1999 15:01'!browseMessagesWithPriorVersions	"Open a message list browser on the new and changed methods in the receiver which have at least one prior version.  6/28/96 sw"	| aList aSelector aClass |	aList _ self changedMessageListAugmented select:		[:msg |  Utilities setClassAndSelectorFrom: msg in: 				[:cl :sl | aClass _ cl.  aSelector _ sl].			(VersionsBrowser versionCountForSelector: aSelector class: aClass) > 1].	aList size > 0 ifFalse: [self inform: 'None!!'.  ^ nil].	Smalltalk browseMessageList: aList name: (self name, ' methods that have prior versions')! !!ChangeSet methodsFor: 'method changes' stamp: 'di 4/1/2000 12:00'!changedMessageList	"Used by a message set browser to access the list view information."	| messageList |	messageList _ SortedCollection new.	changeRecords associationsDo: 		[:clAssoc | 		clAssoc value methodChangeTypes associationsDo: 			[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:				[messageList add: clAssoc key asString, ' ' , mAssoc key]]].	^ messageList asArray! !!ChangeSet methodsFor: 'method changes' stamp: 'tk 6/7/1999 18:57'!changedMessageListAugmented	"Even added classes have all messages in changedMessageList."	^ self changedMessageList asArray! !!ChangeSet methodsFor: 'method changes' stamp: 'di 4/1/2000 12:00'!methodChangesAtClass: className	"Return an old-style dictionary of method change types."	^(changeRecords at: className ifAbsent: [^ Dictionary new])		methodChangeTypes! !!ChangeSet methodsFor: 'method changes' stamp: 'di 4/4/2000 11:14'!removeSelectorChanges: selector class: class 	"Remove all memory of changes associated with the argument, selector, in 	this class."	| chgRecord |	(chgRecord _ changeRecords at: class name ifAbsent: [^ self])		removeSelector: selector.	chgRecord hasNoChanges ifTrue: [changeRecords removeKey: class name]! !!ChangeSet methodsFor: 'method changes' stamp: 'di 4/1/2000 12:00'!selectorsInClass: aClass	"Used by a ChangeSorter to access the list methods."	^ (changeRecords at: aClass ifAbsent: [^#()]) changedSelectors! !!ChangeSet methodsFor: 'class changes' stamp: 'di 4/1/2000 12:00'!changedClassNames	"Answer a OrderedCollection of the names of changed or edited classes.	DOES include removed classes.  Sort alphabetically."	^ changeRecords keysSortedSafely ! !!ChangeSet methodsFor: 'class changes' stamp: 'jm 5/29/2003 19:21'!changedClasses	"Answer an OrderedCollection of changed or edited classes sorted alphabetically by name. Does not include removed classes."	"Note: Much faster to sort names first, then convert back to classes because metaclasses reconstruct their name at every comparison in the sorted collection."	^ (self changedClassNames		collect: [:cName | Smalltalk classNamed: cName])			select: [:aClass | aClass notNil]! !!ChangeSet methodsFor: 'class changes' stamp: 'di 4/1/2000 12:00'!classChangeAt: className	"Return what we know about class changes to this class."	^ (changeRecords at: className ifAbsent: [^ Set new])		allChangeTypes! !!ChangeSet methodsFor: 'class changes'!commentClass: class 	"Include indication that a class comment has been changed."	self atClass: class add: #comment! !!ChangeSet methodsFor: 'class changes' stamp: 'di 3/28/2000 11:44'!fatDefForClass: class	| newDef oldDef oldStrm newStrm outStrm oldVars newVars addedVars |	newDef _ class definition.	oldDef _ (self changeRecorderFor: class) priorDefinition.	oldDef ifNil: [^ newDef].	oldDef = newDef ifTrue: [^ newDef].	oldStrm _ ReadStream on: oldDef.	newStrm _ ReadStream on: newDef.	outStrm _ WriteStream on: (String new: newDef size * 2).	"Merge inst vars from old and new defs..."	oldStrm upToAll: 'instanceVariableNames:'; upTo: $'.	outStrm nextPutAll: (newStrm upToAll: 'instanceVariableNames:'); nextPutAll: 'instanceVariableNames:';		nextPutAll: (newStrm upTo: $'); nextPut: $'.	oldVars _ (oldStrm upTo: $') findTokens: Character separators.	newVars _ (newStrm upTo: $') findTokens: Character separators.	addedVars _ oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.	oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].	outStrm nextPut: $'.	class isMeta ifFalse:		["Merge class vars from old and new defs..."		oldStrm upToAll: 'classVariableNames:'; upTo: $'.		outStrm nextPutAll: (newStrm upToAll: 'classVariableNames:'); nextPutAll: 'classVariableNames:';			nextPutAll: (newStrm upTo: $'); nextPut: $'.		oldVars _ (oldStrm upTo: $') findTokens: Character separators.		newVars _ (newStrm upTo: $') findTokens: Character separators.		addedVars _ oldVars asSet addAll: newVars; removeAll: oldVars; asOrderedCollection.		oldVars , addedVars do: [:var | outStrm nextPutAll: var; space].		outStrm nextPut: $'].	outStrm nextPutAll: newStrm upToEnd.	^ outStrm contents! !!ChangeSet methodsFor: 'class changes' stamp: 'tk 6/9/1999 19:54'!noteClassForgotten: className	"Remove from structures if class is not a superclass of some other one we are remembering"	structures ifNil: [^ self].	Smalltalk at: className ifPresent: [:cls |		cls subclasses do: [:sub | (structures includesKey: sub) ifTrue: [			^ self]]].  "No delete"	structures removeKey: className ifAbsent: [].! !!ChangeSet methodsFor: 'class changes' stamp: 'tk 6/9/1999 21:51'!noteClassStructure: aClass	"Save the instance variable names of this class and all of its superclasses.  Later we can tell how it changed and write a conversion method.  The conversion method is used when old format objects are brought in from the disk from ImageSegment files (.extSeg) or SmartRefStream files (.obj .morph .bo .sp)."	| clsName |	aClass ifNil: [^ self].	structures ifNil: [structures _ Dictionary new.				superclasses _ Dictionary new].	clsName _ (aClass name asLowercase beginsWith: 'anobsolete') 		ifTrue: [(aClass name copyFrom: 11 to: aClass name size) asSymbol]		ifFalse: [aClass name].	(structures includesKey: clsName) ifFalse: [		structures at: clsName put: 			((Array with: aClass classVersion), (aClass allInstVarNames)).		superclasses at: clsName put: aClass superclass name].	"up the superclass chain"	aClass superclass ifNotNil: [self noteClassStructure: aClass superclass].! !!ChangeSet methodsFor: 'class changes' stamp: 'di 4/1/2000 23:17'!noteRemovalOf: class	"The class is about to be removed from the system.	Adjust the receiver to reflect that fact."	(self changeRecorderFor: class)		noteChangeType: #remove fromClass: class.	changeRecords removeKey: class class name ifAbsent: [].! !!ChangeSet methodsFor: 'class changes'!reorganizeClass: class 	"Include indication that a class was reorganized."	self atClass: class add: #reorganize! !!ChangeSet methodsFor: 'class changes' stamp: 'di 5/16/2000 09:03'!trimHistory 	"Drop non-essential history:  methods added and then removed, as well as rename and reorganization of newly-added classes."	changeRecords do: [:chgRecord | chgRecord trimHistory]! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 09:37'!absorbClass: className from: otherChangeSet	"Absorb into the receiver all the changes found in the class in the other change set.	*** Classes renamed in otherChangeSet may have problems"	| cls |	(self changeRecorderFor: className)			assimilateAllChangesIn: (otherChangeSet changeRecorderFor: className).	(cls _ Smalltalk classNamed: className) ifNotNil:		[self absorbStructureOfClass: cls from: otherChangeSet].! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 3/23/2000 11:52'!absorbMethod: selector class: aClass from: aChangeSet	"Absorb into the receiver all the changes for the method in the class in the other change set."	| info |	info _ aChangeSet methodChanges at: aClass name ifAbsent: [Dictionary new].	self atSelector: selector class: aClass put: (info at: selector).! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/3/2000 17:53'!absorbStructureOfClass: aClass from: otherChangeSet	"Absorb into the receiver all the structure and superclass info in the other change set.  Used to write conversion methods."	| sup next |	otherChangeSet structures ifNil: [^ self].	(otherChangeSet structures includesKey: aClass name) ifFalse: [^ self].	structures ifNil:		[structures _ Dictionary new.		superclasses _ Dictionary new].	sup _ aClass name.	[(structures includesKey: sup) 		ifTrue: ["use what is here" true]		ifFalse: [structures at: sup put: (otherChangeSet structures at: sup).				next _ otherChangeSet superclasses at: sup.				superclasses at: sup put: next.				(sup _ next) = 'nil']	] whileFalse.! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 11:21'!assimilateAllChangesFoundIn: otherChangeSet	"Make all changes in otherChangeSet take effect on self as if they happened just now."	otherChangeSet changedClassNames do:		[:className | self absorbClass: className from: otherChangeSet]! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/8/2000 23:16'!editPreamble	"edit the receiver's preamble, in a separate window.  "	self assurePreambleExists.	preamble openLabel: 'Preamble for ChangeSet named ', name! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 11:49'!expungeEmptyClassChangeEntries	changeRecords keysAndValuesRemove:		[:className :classRecord | classRecord hasNoChanges]! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 12:40'!forgetAllChangesFoundIn: otherChangeSet	"Remove from the receiver all method changes found in aChangeSet. The intention is facilitate the process of factoring a large set of changes into disjoint change sets.  To use:  in a change sorter, copy over all the changes you want into some new change set, then use the subtract-other-side feature to subtract those changes from the larger change set, and continue in this manner."	otherChangeSet == self ifTrue: [^ self].	otherChangeSet changedClassNames do:		[:className | self forgetChangesForClass: className in: otherChangeSet].	self expungeEmptyClassChangeEntries."  Old code...	aChangeSet changedClassNames do: 		[:className |			(cls _ Smalltalk classNamed: className) ~~ nil ifTrue:				[itsMethodChanges _ aChangeSet methodChanges at: className 						ifAbsent: [Dictionary new].				itsMethodChanges associationsDo: [:assoc | 					self forgetChange: assoc value forSelector: assoc key class: cls].				myClassChange _ self classChangeAt: className.				myClassChange size > 0 ifTrue:					[(aChangeSet classChangeAt: className) do:						[:aChange | myClassChange remove: aChange ifAbsent: []]].				self noteClassForgotten: className]].	aChangeSet classRemoves do:		[:className | (recorder _ changeRecords at: className ifAbsent: [])			ifNotNil: [recorder forgetClassRemoval]].	self expungeEmptyClassChangeEntries"! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/4/2000 12:04'!forgetChangesForClass: className in: otherChangeSet	"See forgetAllChangesFoundIn:.  Used in culling changeSets."	(self changeRecorderFor: className)			forgetChangesIn: (otherChangeSet changeRecorderFor: className).	self noteClassForgotten: className! !!ChangeSet methodsFor: 'moving changes' stamp: 'sw 3/5/1999 19:27'!hasPreamble	^ preamble notNil! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/1/2000 12:00'!removeClassAndMetaClassChanges: class	"Remove all memory of changes associated with this class and its metaclass.  7/18/96 sw"	changeRecords removeKey: class name ifAbsent: [].	changeRecords removeKey: class class name ifAbsent: [].! !!ChangeSet methodsFor: 'moving changes' stamp: 'di 4/1/2000 12:00'!removeClassChanges: class	"Remove all memory of changes associated with this class"	| cname |	(class isKindOf: String)		ifTrue: [ cname _ class ]		ifFalse: [ cname _ class name ].	changeRecords removeKey: cname ifAbsent: [].	self noteClassForgotten: cname.! !!ChangeSet methodsFor: 'moving changes' stamp: 'sw 3/5/1999 19:32'!removePreamble	preamble _ nil! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 9/11/1998 16:13'!assurePostscriptExists	"Make sure there is a StringHolder holding the postscript.  "	"NOTE: FileIn recognizes the postscript by the line with Postscript: on it"	postscript == nil ifTrue: [postscript _ StringHolder new contents: '"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."']! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 4/7/1999 17:45'!assurePreambleExists	"Make sure there is a StringHolder holding the preamble; if it's found to have reverted to empty contents, put up the template"	(preamble == nil or: [preamble contents isEmptyOrNil])		ifTrue: [preamble _ StringHolder new contents: self preambleTemplate]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/26/2000 10:06'!checkForSlips	"Return a collection of method refs with possible debugging code in them."	| slips method |	slips _ OrderedCollection new.	self changedClasses do:		[:aClass |		(self methodChangesAtClass: aClass name) associationsDo: 				[:mAssoc | (#(remove addedThenRemoved) includes: mAssoc value) ifFalse:					[method _ aClass compiledMethodAt: mAssoc key ifAbsent: [nil].					method ifNotNil:						[method hasReportableSlip							ifTrue: [slips add: aClass name , ' ' , mAssoc key]]]]].	^ slips! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 3/1/2000 15:47'!checkForUnsentMessages	| nameLine allChangedSelectors augList unsent messageList |	nameLine _ '"', self name, '"'.	allChangedSelectors _ Set new.	(augList _ self changedMessageListAugmented) do:		[:aChange |			MessageSet parse: aChange toClassAndSelector: [:cls :sel | cls ifNotNil: [allChangedSelectors add: sel]]].	unsent _ Smalltalk allUnSentMessagesIn: allChangedSelectors.	unsent size = 0		ifTrue:			[self inform: 'There are no unsent messages in change set', nameLine]		ifFalse:			[messageList _ augList select:				[:aChange |					MessageSet parse: aChange toClassAndSelector:						[:cls :sel | unsent includes: sel]].			Smalltalk browseMessageList: messageList name: 'Unsent messages in ', nameLine]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jm 10/30/2002 21:00'!fileOut	"File out the receiver, to a file whose name is a function of the change-set name and either of the date & time or chosen to have a unique numeric tag, depending on the preference 'sequentialChangeSetRevertableFileNames'"	| file slips nameToUse |	nameToUse _ Preferences changeSetVersionNumbers		ifTrue:			[FileDirectory default nextNameFor: self name extension: 'cs']		ifFalse:			[(self name, FileDirectory dot, Utilities dateTimeSuffix, 				FileDirectory dot, 'cs') asFileName].	Cursor write showWhile:		[file _ FileStream newFileNamed: nameToUse.		file header; timeStamp.		self fileOutPreambleOn: file.		self fileOutOn: file.		self fileOutPostscriptOn: file.		file trailer; close].	Preferences checkForSlips ifFalse: [^ self].	slips _ self checkForSlips.	(slips size > 0 and: [self confirm: 'Methods in this fileOut have haltsor references to the Transcriptor other ''slips'' in them.Would you like to browse them?']) ifTrue: [		Smalltalk			browseMessageList: slips			name: 'Possible slips in ', name].! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/28/2000 09:35'!fileOutChangesFor: class on: stream 	"Write out all the method changes for this class."	| changes |	changes _ Set new.	(self methodChangesAtClass: class name) associationsDo: 		[:mAssoc | (mAssoc value = #remove or: [mAssoc value = #addedThenRemoved])			ifFalse: [changes add: mAssoc key]].	changes isEmpty ifFalse: 		[class fileOutChangedMessages: changes on: stream.		stream cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 4/3/2000 14:46'!fileOutOn: stream 	"Write out all the changes the receiver knows about"	| classList |	(self isEmpty and: [stream isKindOf: FileStream])		ifTrue: [self notify: 'Warning: no changes to file out'].	classList _ ChangeSet superclassOrder: self changedClasses asOrderedCollection.	"First put out rename, max classDef and comment changes."	classList do: [:aClass | self fileOutClassDefinition: aClass on: stream].	"Then put out all the method changes"	classList do: [:aClass | self fileOutChangesFor: aClass on: stream].	"Finally put out removals, final class defs and reorganization if any"	classList reverseDo: [:aClass | self fileOutPSFor: aClass on: stream].	self classRemoves asSortedCollection do:		[:aClassName | stream nextChunkPut: 'Smalltalk removeClassNamed: #', aClassName; cr].! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 5/8/2000 20:47'!fileOutPSFor: class on: stream 	"Write out removals and initialization for this class."	| dict changeType classRecord currentDef |	classRecord _ changeRecords at: class name ifAbsent: [^ self].	dict _ classRecord methodChangeTypes.	dict keysSortedSafely do:		[:key | changeType _ dict at: key.		(#(remove addedThenRemoved) includes: changeType)			ifTrue: [stream nextChunkPut: class name,						' removeSelector: ', key storeString; cr]			ifFalse: [(key = #initialize and: [class isMeta]) ifTrue:						[stream nextChunkPut: class soleInstance name, ' initialize'; cr]]].	((classRecord includesChangeType: #change)		and: [(currentDef _ class definition) ~= (self fatDefForClass: class)]) ifTrue:		[stream command: 'H3'; nextChunkPut: currentDef; cr; command: '/H3'].	(classRecord includesChangeType: #reorganize) ifTrue:		[class fileOutOrganizationOn: stream.		stream cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/29/1999 13:35'!fileOutPostscriptOn: stream 	"If the receiver has a postscript, put it out onto the stream.  "	| aString |	aString _ self postscriptString.	(aString ~~ nil and: [aString size > 0])		ifTrue:			[stream nextChunkPut: aString "surroundedBySingleQuotes".			stream cr; cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 3/29/1999 14:58'!fileOutPreambleOn: stream 	"If the receiver has a preamble, put it out onto the stream.  "	| aString |	aString _ self preambleString.	(aString ~~ nil and: [aString size > 0])		ifTrue:			[stream nextChunkPut: aString "surroundedBySingleQuotes".			stream cr; cr]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 3/8/1999 12:07'!lookForSlips	| slips nameLine msg |	nameLine _ '"', self name, '"'.	(slips _ self checkForSlips) size == 0 ifTrue:		[^ self inform: 'No slips detected in change set', nameLine].	msg _ slips size == 1		ifTrue:			[ 'One method in change set', nameLine, 'has a halt, reference to the Transcript,and/or some other ''slip'' in it.Would you like to browse it? ?']		ifFalse:			[ slips size printString,' methods in change set', nameLine, 'have halts or references to theTranscript or other ''slips'' in them.Would you like to browse them?'].	(self confirm: msg)		ifTrue: [Smalltalk browseMessageList: slips							name: 'Possible slips in ', name]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 5/7/1998 12:16'!postscriptString	"Answer the string representing the postscript.  "	^ postscript == nil		ifTrue:			[postscript]		ifFalse:			[postscript contents asString]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 11/27/96'!postscriptString: aString	"Establish aString as the new contents of the postscript.  "	postscript _ StringHolder new contents: aString! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 5/7/1998 12:08'!preambleString	"Answer the string representing the preamble"	^ preamble == nil		ifTrue:			[preamble]		ifFalse:			[preamble contents asString]! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'sw 11/27/96'!preambleString: aString	"Establish aString as the new contents of the preamble.  "	preamble _ StringHolder new contents: aString! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'jm 5/31/2003 16:23'!preambleTemplate	"Answer a string that will form the default contents for a change set's preamble.	Just a first stab at what the content should be."	^ String streamContents: [:strm |		strm nextPutAll: '"Change Set:'.  "NOTE: fileIn recognizes preambles by this string."		strm tab;tab; nextPutAll: self name.		strm cr; nextPutAll: 'Date:'; tab; tab; tab; nextPutAll: Date today printString.		strm cr; nextPutAll: 'Author:'; tab; tab; tab; nextPutAll: Utilities authorName.		strm cr; cr; nextPutAll: '<your descriptive text goes here>"']"Smalltalk changes preambleTemplate"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 9/24/1999 12:33'!summaryString	"Answer the string summarizing this changeSet"	^ self summaryStringDelta: 0"To summarize all recent changeSets on a file...(FileStream newFileNamed: 'Summaries.txt') nextPutAll:	(String streamContents:		[:s | (ChangeSorter changeSetsNamedSuchThat:			[:name | name first isDigit and: [name initialIntegerOrNil >= 948]])			 do: [:cs | s nextPutAll: cs summaryString; cr]]);		closeTo list all changeSets with a certain string in the preamble...	(FileStream newFileNamed: 'MyUpdates.txt') nextPutAll:		(String streamContents:			[:s | ChangeSorter gatherChangeSetRevertables do:				[:cs | (cs preambleString notNil					and: [cs preambleString includesSubString: 'Author Name'])				 	ifTrue: [s nextPutAll: cs summaryString; cr]]]);		close"! !!ChangeSet methodsFor: 'fileIn/Out' stamp: 'di 9/24/1999 12:27'!summaryStringDelta: delta	"Answer the string summarizing this changeSet"	| ps s2 date author line intName |	^ String streamContents:		[:s |		intName _ self name splitInteger.		intName first isNumber			ifTrue: [s nextPutAll: (intName first + delta) printString , intName last]			ifFalse: [s nextPutAll: intName first  "weird convention of splitInteger"].		(ps _ self preambleString)			ifNil: [s cr]			ifNotNil:			[s2 _ ReadStream on: ps.			s2 match: 'Date:'; skipSeparators.  date _ s2 upTo: Character cr.			s2 match: 'Author:'; skipSeparators.  author _ s2 upTo: Character cr.			s nextPutAll: ' -- '; nextPutAll: author; nextPutAll: ' -- '; nextPutAll: date; cr.			[s2 atEnd] whileFalse:				[line _ s2 upTo: Character cr.				(line isEmpty or: [line = '"']) ifFalse: [s nextPutAll: line; cr]]]].! !!ChangeSet methodsFor: 'private' stamp: 'di 3/23/2000 08:37'!addCoherency: className	"SqR!! 19980923: If I recreate the class then don't remove it"	(self changeRecorderFor: className)		checkCoherence."	classRemoves remove: className ifAbsent: [].	(classChanges includesKey: className) ifTrue:		[(classChanges at: className) remove: #remove ifAbsent: []]"! !!ChangeSet methodsFor: 'private' stamp: 'di 3/28/2000 14:40'!atClass: class add: changeType	(self changeRecorderFor: class)		noteChangeType: changeType fromClass: class! !!ChangeSet methodsFor: 'private' stamp: 'di 4/1/2000 12:00'!atClass: class includes: changeType	^(changeRecords at: class name ifAbsent: [^false])		includesChangeType: changeType! !!ChangeSet methodsFor: 'private' stamp: 'di 4/1/2000 12:00'!atSelector: selector class: class	^ (changeRecords at: class name ifAbsent: [^ #none])		atSelector: selector ifAbsent: [^ #none]! !!ChangeSet methodsFor: 'private' stamp: 'jm 5/16/2003 08:57'!changeRecorderFor: class	| cname |	(class isKindOf: String)		ifTrue: [ cname _ class ]		ifFalse: [ cname _ class name ].	"Later this will init the changeRecords so according to whether they should be revertable."	^ changeRecords at: cname ifAbsent: [		^ changeRecords				at: cname				put: (ClassChangeRecord new initForClassNamed: cname)]! !!ChangeSet methodsFor: 'private' stamp: 'di 3/28/2000 09:23'!fileOutClassDefinition: class on: stream 	"Write out class definition for the given class on the given stream, if the class definition was added or changed."	(self atClass: class includes: #rename) ifTrue:		[stream nextChunkPut: 'Smalltalk renameClassNamed: #', (self oldNameFor: class), ' as: #', class name; cr].	((self atClass: class includes: #change) or: [self atClass: class includes: #add]) ifTrue:		[stream command: 'H3'; nextChunkPut: (self fatDefForClass: class); cr; command: '/H3'].	(self atClass: class includes: #comment) ifTrue:		[class theNonMetaClass organization putCommentOnFile: stream numbered: 0 moveSource: false forClass: class theNonMetaClass].! !!ChangeSet methodsFor: 'private' stamp: 'di 4/1/2000 12:00'!oldNameFor: class	^ (changeRecords at: class name) priorName! !!ChangeSet class methodsFor: 'fileIn/Out' stamp: 'RAA 9/30/1999 14:34'!superclassOrder: classes 	"Arrange the classes in the collection, classes, in superclass order so the 	classes can be properly filed in."	| all list i aClass |	list _ classes copy. 			"list is indexable"	all _ OrderedCollection new: list size.	[list size > 0] whileTrue: [		i _ 0.		[			i _ i + 1.			aClass _ list at: i.			(list includesAnyOf: aClass allSuperclasses) or: [				aClass isMeta and: [					(list includes: aClass soleInstance) or: [						list includesAnyOf: aClass soleInstance allSuperclasses					] 				].			].		] whileTrue.		all addLast: aClass.		list _ list copyWithout: aClass	].	^all! !!ChangeSet class methodsFor: 'defaults' stamp: 'di 3/23/2000 15:20'!defaultName	| namesInUse try |	namesInUse _ ChangeSorter gatherChangeSets					collect: [:each | each name].	1 to: 999999 do:		[:i | try _ 'Unnamed' , i printString.		(namesInUse includes: try) ifFalse: [^ try]]! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 3/6/1999 09:33'!morphicWindow	"ChangeSorter new openAsMorph"	|  window |	myChangeSet ifNil: [self myChangeSet: Smalltalk changes]. 	window _ (SystemWindow labelled: self labelString) model: self.	self openAsMorphIn: window rect: (0@0 extent: 1@1).	^ window! !!ChangeSorter methodsFor: 'creation' stamp: 'sma 4/30/2000 09:29'!open	"ChangeSorterPluggable new open"	| topView |	Smalltalk isMorphic | Sensor leftShiftDown ifTrue: [^ self openAsMorph].	topView _ StandardSystemView new.	topView model: self.	myChangeSet ifNil: [self myChangeSet: Smalltalk changes]. 	topView label: self labelString.	topView borderWidth: 1; minimumSize: 360@360.	self openView: topView offsetBy: 0@0.	topView controller open.! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 3/6/1999 09:34'!openAsMorph	"ChangeSorter new openAsMorph"	^ self morphicWindow openInWorld.! !!ChangeSorter methodsFor: 'creation' stamp: 'di 2/1/1999 20:51'!openAsMorphIn: window rect: rect	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 0.5@0."	| chgSetList aListMorph |	contents _ ''.	self addDependent: window.		"so it will get changed: #relabel"	window addMorph: (chgSetList _ PluggableListMorphByItem on: self			list: #changeSetList			selected: #currentCngSet			changeSelected: #showChangeSetNamed:			menu: #changeSetMenu:shifted:			keystroke: #changeSetListKey:from:)		frame: (((0@0 extent: 0.5@0.25) scaleBy: rect extent) translateBy: rect origin).	chgSetList autoDeselect: false.	window addMorph: (PluggableListMorphByItem on: self			list: #classList			selected: #currentClassName			changeSelected: #currentClassName:			menu: #classMenu:			keystroke: #classListKey:from:)		frame: (((0.5@0 extent: 0.5@0.25) scaleBy: rect extent) translateBy: rect origin).	aListMorph _ PluggableListMorphByItem on: self			list: #messageList			selected: #currentSelector			changeSelected: #currentSelector:			menu: #messageMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph  menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (((0@0.25 extent: 1@0.25) scaleBy: rect extent) translateBy: rect origin).	window addMorph: (PluggableTextMorph on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (((0@0.5 corner: 1@1) scaleBy: rect extent) translateBy: rect origin).! !!ChangeSorter methodsFor: 'creation' stamp: 'sw 1/26/1999 09:15'!openView: topView offsetBy: offset	"Add a set of change sorter views to the given top view offset by the given amount. To create a single change sorter, call this once with an offset of 0@0. To create a dual change sorter, call it twice with offsets of 0@0 and 360@0."	| classView messageView codeView cngSetListView |	contents _ ''.	self addDependent: topView.		"so it will get changed: #relabel"	cngSetListView _ PluggableListViewByItem on: self		list: #changeSetList		selected: #currentCngSet		changeSelected: #showChangeSetNamed:		menu: #changeSetMenu:shifted:.	cngSetListView window: ((0 @ 0 extent: 180 @ 100) translateBy: offset).	topView addSubView: cngSetListView.	classView _ PluggableListViewByItem on: self		list: #classList		selected: #currentClassName		changeSelected: #currentClassName:		menu: #classMenu:		keystroke: #classListKey:from:.	classView window: (180 @ 0 extent: 180 @ 100).	topView addSubView: classView toRightOf: cngSetListView.	messageView _ PluggableListViewByItem on: self		list: #messageList		selected: #currentSelector		changeSelected: #currentSelector:		menu: #messageMenu:shifted:		keystroke: #messageListKey:from:.	messageView menuTitleSelector: #messageListSelectorTitle.	messageView window: (0 @ 100 extent: 360 @ 100).	topView addSubView: messageView below: cngSetListView.	codeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	codeView window: (0 @ 0 extent: 360 @ 180).	topView addSubView: codeView below: messageView.! !!ChangeSorter methodsFor: 'access' stamp: 'sw 1/27/2000 11:19'!changeSetCurrentlyDisplayed	^ myChangeSet! !!ChangeSorter methodsFor: 'access' stamp: 'di 6/15/1998 20:33'!modelWakeUp	"A window with me as model is being entered.  Make sure I am up-to-date with the changeSets."	self canDiscardEdits ifTrue: [self update]! !!ChangeSorter methodsFor: 'access' stamp: 'sw 1/28/1999 12:31'!showChangeSet: chgSet	myChangeSet == chgSet ifFalse: [		myChangeSet _ chgSet.		currentClassName _ nil.		currentSelector _ nil].	self changed: #relabel.	self changed: #currentCngSet.	"new -- list of sets"	self changed: #mainButtonName.	"old, button"	self changed: #classList.	self changed: #messageList.	self setContents.	self contentsChanged.! !!ChangeSorter methodsFor: 'access' stamp: 'tk 6/10/1998 07:38'!showChangeSetNamed: aName	aName ifNil: [^ self showChangeSet: nil].	self showChangeSet: 		(AllChangeSets detect: [:each | each name = aName]) ! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/6/1999 23:22'!addPreamble	myChangeSet assurePreambleExists.	self okToChange ifTrue:		[currentClassName _ nil.		currentSelector _ nil.		self showChangeSet: myChangeSet]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/1/2000 15:48'!browseMethodConflicts	"Check to see if any other change set also holds changes to any methods in the selected change set; if so, open a browser on all such."	| aList aClass aSelector |	aList _ myChangeSet changedMessageListAugmented select:		[:aChange |			MessageSet parse: aChange toClassAndSelector: [:cls :sel | aClass _ cls.  aSelector _ sel].			(ChangeSorter allChangeSetsWithClass: aClass selector: aSelector) size > 1].	aList size == 0 ifTrue: [^ self inform: 'No other change set has changesfor any method in this change set.'].		MessageSet openMessageList: aList name: 'Methods in "', myChangeSet name, '" that are also in other change sets (', aList size printString, ')'	! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/12/1998 16:29'!changeSetList	ChangeSet instanceCount > AllChangeSets size ifTrue: [self class gatherChangeSets].	^ AllChangeSets reversed collect: [:each | each name]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 2/1/1999 20:58'!changeSetListKey: aChar from: view	"Respond to a Command key.  I am a model with a listView that has a list of changeSets."	aChar == $f ifTrue: [^ self findCngSet].	^ self arrowKey: aChar from: view! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jm 6/7/2001 15:41'!changeSetMenu: aMenu shifted: isShifted 	"Could be for a single or double changeSorter"	aMenu title: 'Change Set:' , myChangeSet name.	isShifted ifTrue: [^ self shiftedChangeSetMenu: aMenu].	aMenu add: 'make changes go to me' action: #newCurrent.	aMenu addLine.	aMenu add: 'new change set...' action: #newSet.	aMenu add: 'find...' action: #findCngSet.	aMenu add: 'show...' action: #chooseCngSet.	aMenu add: 'rename change set' action: #rename.	aMenu addLine.	aMenu add: 'file out' action: #fileOut.	aMenu add: 'browse methods' action: #browseChangeSet.	aMenu addLine.	parent		ifNotNil: 			[aMenu add: 'copy all to other side' action: #copyAllToOther.			aMenu add: 'submerge into other side' action: #submergeIntoOtherSide.			aMenu add: 'subtract other side' action: #subtractOtherSide.			aMenu addLine].	myChangeSet hasPreamble		ifTrue: 			[aMenu add: 'edit preamble' action: #addPreamble.			aMenu add: 'remove preamble' action: #removePreamble]		ifFalse: [aMenu add: 'add preamble' action: #addPreamble].	"aMenu add: 'edit preamble...' action: #editPreamble."	myChangeSet hasPostscript		ifTrue: 			[aMenu add: 'edit postscript...' action: #editPostscript.			aMenu add: 'remove postscript' action: #removePostscript]		ifFalse: [aMenu add: 'add postscript...' action: #editPostscript].	aMenu addLine.	aMenu add: 'destroy change set' action: #remove.	aMenu addLine.	aMenu add: 'more...' action: #shiftedYellowButtonActivity.	^ aMenu! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 10/27/1999 14:20'!checkForUnsentMessages	"Open a message list browser on all unsent messages in the current change set"	myChangeSet checkForUnsentMessages! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 7/8/1999 13:36'!checkThatSidesDiffer: escapeBlock	"If the change sets on both sides of the dual sorter are the same, put up an error message and escape via escapeBlock, else proceed happily"	(myChangeSet == (parent other: self) changeSet)		ifTrue:			[self inform: 'This command requires that thechange sets selected on the twosides of the change sorter *not*be the same.'.			^ escapeBlock value]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 1/8/1999 14:52'!chooseCngSet	"Present the user with an alphabetical list of change set names, and let her choose one"	| index changeSetsSortedAlphabetically |	self okToChange ifFalse: [^ self].	ChangeSet instanceCount > AllChangeSets size ifTrue: [self class gatherChangeSets].	changeSetsSortedAlphabetically _ AllChangeSets asSortedCollection:		[:a :b | a name asLowercase withoutLeadingDigits < b name asLowercase withoutLeadingDigits].	index _ (PopUpMenu labels: 		(changeSetsSortedAlphabetically collect: [:each | each name]) asStringWithCr) startUp.	index = 0 ifFalse: [self showChangeSet: (changeSetsSortedAlphabetically at: index)].! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 1/28/1999 12:30'!clearChangeSet	"Clear out the current change set, after getting a confirmation."	| message |	self okToChange ifFalse: [^ self].	myChangeSet isEmpty ifFalse:		[message _ 'Are you certain that you want to\forget all the changes in this set?' withCRs.		(self confirm: message) ifFalse: [^ self]].	myChangeSet clear.	self changed: #classList.	self changed: #messageList.	self setContents.	self contentsChanged.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 1/27/2000 11:21'!copyAllToOther	"Copy this entire change set into the one on the other side"	| companionSorter |	self checkThatSidesDiffer: [^ self].	(companionSorter _ parent other: self) changeSetCurrentlyDisplayed assimilateAllChangesFoundIn: myChangeSet.	companionSorter changed: #classList.	"Later the changeSet itself will notice..."	companionSorter changed: #messageList! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'tk 6/5/1998 06:47'!currentCngSet	^ myChangeSet name! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'tk 4/28/1998 08:06'!editPreamble	"Allow the user to edit the receiver's change-set's preamble -- in a separate window."	myChangeSet editPreamble! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 11/22/1998 23:57'!fileIntoNewChangeSet	"Obtain a file designation from the user, and file its contents into a new change set whose name is a function of the filename.  Show the new set and leave the current changeSet unaltered."	| aFileName  aNewChangeSet |	self okToChange ifFalse: [^ self].	aFileName _ FillInTheBlank request: 'Name of file to be imported: '.	aFileName size == 0 ifTrue: [^ self].	(FileDirectory default fileExists: aFileName) ifFalse:		[^ self inform: 'Sorry -- cannot find that file'].	aNewChangeSet _ self class 			newChangesFromStream: (FileStream readOnlyFileNamed: aFileName) 			named: aFileName.	aNewChangeSet ifNotNil: [self showChangeSet: aNewChangeSet]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'tk 6/10/1999 12:44'!fileOut	"File out the current change set."	myChangeSet fileOut.	parent modelWakeUp.	"notice object conversion methods created"! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 2/16/1999 13:30'!findCngSet 	"Search for a changeSet by name.  Pop up a menu of all changeSets whose name contains the string entered by the user.  If only one matches, then the pop-up menu is bypassed"	| index pattern candidates |	self okToChange ifFalse: [^ self].	ChangeSet instanceCount > AllChangeSets size ifTrue: [self class gatherChangeSets].	pattern _ FillInTheBlank request: 'ChangeSet name or fragment?'.	pattern isEmpty ifTrue: [^ self].	candidates _ AllChangeSets select:			[:c | c name includesSubstring: pattern caseSensitive: false].	candidates size = 0 ifTrue: [^ self beep].	candidates size = 1 ifTrue:		[^ self showChangeSet: candidates first].	index _ (PopUpMenu labels: 		(candidates collect: [:each | each name]) asStringWithCr) startUp.	index = 0 ifFalse: [self showChangeSet: (candidates at: index)].! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'tk 10/26/1999 14:24'!goToChangeSetsProject	"Transport the user to a project which bears the selected changeSet as its current changeSet"	| aProject |	(aProject _ myChangeSet correspondingProject) 		ifNotNil:			[aProject enter: false revert: false saveForRevert: false]		ifNil:			[self inform: 'Has no project']! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 1/10/1999 01:01'!inspectChangeSet	"Open a message list browser on the new and changed methods in the current change set"	myChangeSet inspectWithLabel: 'Change set: ', myChangeSet name! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 2/17/1999 11:05'!lookForSlips	"Open a message list browser on the new and changed methods in the current change set"	myChangeSet lookForSlips! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/1/2000 15:48'!methodConflictsWithOtherSide	"Check to see if the change set on the other side shares any methods with the selected change set; if so, open a browser on all such."	| aList aClass aSelector other |	self checkThatSidesDiffer: [^ self].	other _ (parent other: self) changeSet.	aList _ myChangeSet changedMessageListAugmented select:		[:aChange |			MessageSet parse: aChange toClassAndSelector: [:cls :sel | aClass _ cls.  aSelector _ sel].			aClass notNil and: [(other methodChangesAtClass: aClass name) includesKey: aSelector]].	aList size == 0 ifTrue: [^ self inform: 'There are no methods that appearboth in this change set andin the one on the other side.'].		MessageSet openMessageList: aList name: 'Methods in "', myChangeSet name, '" that are also in ', other name,' (', aList size printString, ')'	! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 9/4/1998 09:00'!newSet	"Create a new changeSet and show it., making it the current one.  Reject name if already in use."	| aSet |	self okToChange ifFalse: [^ self].	aSet _ self class newChangeSet.	aSet ifNotNil:		[self update.		self showChangeSet: aSet.		self changed: #relabel]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 1/27/2000 15:03'!promoteToTopChangeSet	self class promoteToTop: myChangeSet! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/14/1998 12:00'!remove	"Completely destroy my change set.  Check if it's OK first"	self okToChange ifFalse: [^ self].	self removePrompting: true.	self update! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 6/29/1999 20:53'!removePostscript	(myChangeSet hasPostscript and: [myChangeSet postscriptHasDependents]) ifTrue:		[^ self inform:'Cannot remove the postscript rightnow because there is at least onewindow open on that postscript.Close that window and try again.'].	myChangeSet removePostscript.	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/5/1999 19:32'!removePreamble	myChangeSet removePreamble.	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 5/26/2000 22:34'!removePrompting: doPrompt	"Completely destroy my change set.  Check if it's OK first,  and if doPrompt is true, get the user to confirm his intentions first"	| message aName |	aName _ myChangeSet name.	myChangeSet okayToRemove ifFalse: [^ self]. "forms current changes for some project"	(myChangeSet isEmpty or: [doPrompt not]) ifFalse:		[message _ 'Are you certain that you want to remove (destroy) the change setnamed  "', aName, '" ?'.		(self confirm: message) ifFalse: [^ self]].	(doPrompt and: [myChangeSet hasPreamble or: [myChangeSet hasPostscript]])		ifTrue:			[(self confirm: 'Caution!!  This change set has a preambleand/or a postscript, which will be lost if you destroy the change set.Do you really want to go ahead with this?') ifFalse: [^ self]].	"Go ahead and remove the change set"	AllChangeSets remove: myChangeSet.	myChangeSet wither.		"clear out its contents"	self showChangeSet: Smalltalk changes.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/14/1998 11:58'!rename	"Store a new name string into the selected ChangeSet.  reject duplicate name; allow user to back out"	| newName |	newName _ FillInTheBlank request: 'New name for this change set'						initialAnswer: myChangeSet name.	(newName = myChangeSet name or: [newName size == 0]) ifTrue:			[^ self inform: 'No change made'].	(self class changeSetNamed: newName) ifNotNil:			[^ Utilities inform: 'Sorry that name is already used'].	myChangeSet name: newName.	self update.	self changed: #mainButtonName.	self changed: #relabel.! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'jm 10/7/2002 06:05'!shiftedChangeSetMenu: aMenu	aMenu add: 'conflicts with other change sets' action: #browseMethodConflicts.	aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in at least one other change set.'.	parent ifNotNil:		[aMenu add: 'conflicts with opposite side' action: #methodConflictsWithOtherSide.			aMenu balloonTextForLastItem: 'Browse all methods that occur both in this change set and in the one on the opposite side of the change sorter.'.].	aMenu addLine.	aMenu add: 'check for slips' action: #lookForSlips.	aMenu balloonTextForLastItem: 'Check this change set for halts and references to Transcript.'.	aMenu add: 'check for unsent messages' action: #checkForUnsentMessages.	aMenu balloonTextForLastItem:'Check this change set for messages that are not sent anywhere in the system'.	aMenu addLine.	aMenu add: 'inspect change set' action: #inspectChangeSet.	aMenu balloonTextForLastItem: 'Open an inspector on this change set. (There are some details in a change set which you don''t see in a change sorter.)'.	aMenu add: 'update' action: #update.	aMenu balloonTextForLastItem: 'Update the display for this change set.  (This is done automatically when you activate this window, so is seldom needed.)'.	aMenu add: 'go to change set''s project' action: #goToChangeSetsProject.	aMenu balloonTextForLastItem: 'If this change set is currently associated with a Project, go to that project right now.'.	aMenu add: 'promote to top of list' action: #promoteToTopChangeSet.	aMenu balloonTextForLastItem:'Make this change set appear first in change-set lists in all change sorters.'.	aMenu add: 'trim history' action: #trimHistory.	aMenu balloonTextForLastItem: ' Drops any methods added and then removed, as well as renaming and reorganization of newly-added classes.  NOTE: can cause confusion if later filed in over an earlier version of these changes'.	aMenu add: 'clear this change set' action: #clearChangeSet.	aMenu balloonTextForLastItem: 'Reset this change set to a pristine state where it holds no information. CAUTION: this is destructive and irreversible!!'.	aMenu addLine.	aMenu add: 'file into new...' action: #fileIntoNewChangeSet.	aMenu balloonTextForLastItem: 'Load a fileout from disk and place its changes into a new change set (seldom needed -- much better to do this from a file-list browser these days.)'.	aMenu addLine.	aMenu add: 'more...' action: #unshiftedYellowButtonActivity.	aMenu balloonTextForLastItem: 'Takes you back to the primary change-set menu.'.	^ aMenu! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 5/26/2000 18:23'!submergeIntoOtherSide	"Copy the contents of the receiver to the other side, then remove the receiver -- all after checking that all is well."	| other message nextToView i |	self checkThatSidesDiffer: [^ self].	self okToChange ifFalse: [^ self].	other _ (parent other: self) changeSet.	other == myChangeSet ifTrue: [^ self inform: 'Both sides are the same!!'].	myChangeSet isEmpty ifTrue: [^ self inform: 'Nothing to copy.  To remove,simply choose "remove".'].	myChangeSet okayToRemove ifFalse: [^ self].	message _ 'Please confirm:  copy all changesin "', myChangeSet name, '" into "', other name, '"and then destroy the change setnamed "', myChangeSet name, '"?'. 	(self confirm: message) ifFalse: [^ self].	(myChangeSet hasPreamble or: [myChangeSet hasPostscript]) ifTrue:		[(self confirm: 'Caution!!  This change set has a preamble ora postscript or both.  If you submerge it intothe other side, these will be lost.Do you really want to go ahead with this?') ifFalse: [^ self]].	other assimilateAllChangesFoundIn: myChangeSet.	nextToView _ ((AllChangeSets includes: myChangeSet)		and: [(i _ AllChangeSets indexOf: myChangeSet) < AllChangeSets size])		ifTrue: [AllChangeSets at: i+1]		ifFalse: [other].	self removePrompting: false.	self showChangeSet: nextToView.	self class gatherChangeSets.	parent modelWakeUp.	"(parent other: self) changed: #classList.	(parent other: self) changed: #messageList."! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 7/8/1999 12:32'!subtractOtherSide	"Subtract the changes found on the other side from the requesting side."	self checkThatSidesDiffer: [^ self].	myChangeSet forgetAllChangesFoundIn: ((parent other: self) changeSet).	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 5/12/2000 15:03'!trimHistory	"Drop non-essential history (rename, reorg, method removals) from newly-added classes."	myChangeSet trimHistory! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'di 6/21/1998 13:02'!update	"recompute all of my panes"	self updateIfNecessary.	parent ifNotNil: [(parent other: self) updateIfNecessary]! !!ChangeSorter methodsFor: 'changeSet menu' stamp: 'sw 3/6/1999 11:01'!updateIfNecessary	"recompute all of my panes"	| newList |	myChangeSet isMoribund ifTrue:		[^ self showChangeSet: Smalltalk changes].	self okToChange ifFalse: [^ self].	priorChangeSetList == nil		ifTrue: [priorChangeSetList _ self changeSetList.				self changed: #changeSetList]		ifFalse: [newList _ self changeSetList.				priorChangeSetList = newList ifFalse:					[priorChangeSetList _ newList.					self changed: #changeSetList]].	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 10/5/1999 18:01'!classListKey: aChar from: view		"Overridden to obviate spurious StringHolder processing of $s for findClass"	^ self messageListKey: aChar from: view! !!ChangeSorter methodsFor: 'class list' stamp: 'jm 10/14/2002 19:17'!classMenu: aMenu	"Set up aMenu for the class-lis."	parent ifNotNil:	[aMenu addList: #(  "These two only apply to dual change sorters"		('copy class chgs to other side'			copyClassToOther)			('move class chgs to other side'			moveClassToOther))].	aMenu addList: #(		('delete class chgs from this change set'	forgetClass)		-		('browse full (b)'						browseMethodFull)		('browse hierarchy (h)'					spawnHierarchy)		('browse protocol'						spawnProtocol)		-		('printOut'								printOutClass)		('fileOut'								fileOutClass)		-		('inst var refs...'						browseInstVarRefs)		('inst var defs...'						browseInstVarDefs)		('class var refs...'						browseClassVarRefs)		('class vars'								browseClassVariables)		('class refs (N)'							browseClassRefs)		-		('unsent methods'						browseUnusedMethods)		('unreferenced inst vars'				showUnreferencedInstVars)).	^ aMenu! !!ChangeSorter methodsFor: 'class list' stamp: 'di 4/4/2000 09:37'!copyClassToOther	"Place these changes in the other changeSet also"	| otherSorter otherChangeSet |	self checkThatSidesDiffer: [^ self].	self okToChange ifFalse: [^ self beep].	currentClassName ifNil: [^ self beep].	otherSorter _ parent other: self.	otherChangeSet _ otherSorter changeSet.	otherChangeSet absorbClass: self selectedClassOrMetaClass name from: myChangeSet.	otherSorter showChangeSet: otherChangeSet.! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 1/28/1999 12:30'!currentClassName: aString	currentClassName _ aString.	currentSelector _ nil.	"fix by wod"	self changed: #currentClassName.	self changed: #messageList.	self setContents.	self contentsChanged.! !!ChangeSorter methodsFor: 'class list' stamp: 'ls 8/12/1998 23:47'!forgetClass	"Remove all mention of this class from the changeSet"	self okToChange ifFalse: [^ self].	currentClassName ifNotNil: [		myChangeSet removeClassChanges: currentClassName.		currentClassName _ nil.		currentSelector _ nil.		self showChangeSet: myChangeSet].! !!ChangeSorter methodsFor: 'class list' stamp: 'di 4/3/2000 20:31'!moveClassToOther	"Place class changes in the other changeSet and remove them from this one"	self copyClassToOther.	self forgetClass! !!ChangeSorter methodsFor: 'class list' stamp: 'sw 12/7/1998 09:43'!selectedClass	"Answer the currently-selected class.  If there is no selection, or if the selection refers to a class no longer extant, return nil"	| c |	^ currentClassName ifNotNil: [(c _ self selectedClassOrMetaClass)		ifNotNil: [c theNonMetaClass]]! !!ChangeSorter methodsFor: 'message list' stamp: 'di 3/23/2000 13:34'!browseVersions	"Create and schedule a changelist browser on the versions of the 	selected message."	| class selector method category pair sourcePointer |	(selector _ self selectedMessageName) ifNil: [^ self].	class _ self selectedClassOrMetaClass.	(class includesSelector: selector)		ifTrue: [method _ class compiledMethodAt: selector.				category _ class whichCategoryIncludesSelector: selector.				sourcePointer _ nil]		ifFalse: [pair _ myChangeSet methodInfoFromRemoval: {class name. selector}.				pair ifNil: [^ nil].				sourcePointer _ pair first.				method _ CompiledMethod toReturnSelf setSourcePointer: sourcePointer.				category _ pair last].	VersionsBrowser		browseVersionsOf: method		class: self selectedClass meta: class isMeta		category: category selector: selector		lostMethodPointer: sourcePointer.! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 7/8/1999 12:31'!copyMethodToOther	"Place this change in the other changeSet also"	| other cls sel |	self checkThatSidesDiffer: [^ self].	currentSelector ifNotNil:		[other _ (parent other: self) changeSet.		cls _ self selectedClassOrMetaClass.		sel _ currentSelector asSymbol.		other absorbMethod: sel class: cls from: myChangeSet.		(parent other: self) showChangeSet: other]! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 1/28/1999 12:31'!currentSelector: messageName	currentSelector _ messageName.	self changed: #currentSelector.	self setContents.	self contentsChanged.! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/22/1998 02:08'!forget	"Drop this method from the changeSet"	self okToChange ifFalse: [^ self].	currentSelector ifNotNil: [		myChangeSet removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.		currentSelector _ nil.		self showChangeSet: myChangeSet]! !!ChangeSorter methodsFor: 'message list' stamp: 'di 4/25/2000 10:33'!messageList 	| probe newSelectors |	currentClassName ifNil: [^ #()].	probe _ (currentClassName endsWith: ' class')		ifTrue: [currentClassName]		ifFalse: [currentClassName asSymbol].	newSelectors _ myChangeSet selectorsInClass: probe.	(newSelectors includes: currentSelector) ifFalse: [currentSelector _ nil].	^ newSelectors asSortedCollection! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 5/8/2000 13:01'!messageMenu: aMenu shifted: shifted	"Could be for a single or double changeSorter"	shifted ifTrue: [^ self shiftedMessageMenu: aMenu].	parent ifNotNil:		[aMenu addList: #(			('copy method to other side'			copyMethodToOther)			('move method to other side'			moveMethodToOther))].	aMenu addList: #(			('delete method from change set'		forget)			-			('remove method from system (x)'	removeMessage)				-			('browse full (b)'					browseMethodFull)			('browse hierarchy (h)'				spawnHierarchy)			('browse method (O)'				openSingleMessageBrowser)			-			('fileOut'							fileOutMessage)			('printOut'							printOutMessage)			-			('senders of... (n)'					browseSendersOfMessages)			('implementors of... (m)'				browseMessages)			('inheritance (i)'					methodHierarchy)			('versions (v)'						browseVersions)			-			('more...'							shiftedYellowButtonActivity)).	^ aMenu! !!ChangeSorter methodsFor: 'message list' stamp: 'sw 7/8/1999 12:31'!moveMethodToOther	"Place this change in the other changeSet and remove it from this side"	| other cls sel |	self checkThatSidesDiffer: [^ self].	self okToChange ifFalse: [^ self beep].	currentSelector ifNotNil:		[other _ (parent other: self) changeSet.		other == myChangeSet ifTrue: [^ self beep].		cls _ self selectedClassOrMetaClass.		sel _ currentSelector asSymbol.		other absorbMethod: sel class: cls from: myChangeSet.			(parent other: self) showChangeSet: other.		self forget "removes the method from this side"]! !!ChangeSorter methodsFor: 'message list' stamp: 'di 6/21/1998 23:13'!removeFromCurrentChanges	"Redisplay after removal in case we are viewing the current changeSet"	super removeFromCurrentChanges.	currentSelector _ nil.	self showChangeSet: myChangeSet! !!ChangeSorter methodsFor: 'message list' stamp: 'di 4/4/2000 10:54'!removeMessage	"Remove the selected msg from the system.  Real work done by the parent, a ChangeSorter"	| confirmation sel |	self okToChange ifFalse: [^ self].	currentSelector ifNotNil: [		confirmation _ self selectedClassOrMetaClass 			confirmRemovalOf: (sel _ self selectedMessageName).		confirmation == 3 ifTrue: [^ self].		self selectedClassOrMetaClass removeSelector: sel.		self update.		confirmation == 2 ifTrue:			[Smalltalk browseAllCallsOn: sel]]! !!ChangeSorter methodsFor: 'message list' stamp: 'tk 2/7/2000 11:01'!selectedMessage	"Answer a copy of the source code for the selected message selector." 	^ contents ifNil: [''] ifNotNil: [contents copy]! !!ChangeSorter methodsFor: 'message list' stamp: 'jm 10/14/2002 19:17'!shiftedMessageMenu: aMenu	^ aMenu addList: #(		-		('toggle diffing'						toggleDiffing)		('implementors of sent messages'		browseAllMessages)		('change category...'				changeCategory)			-		('inspect instances'					inspectInstances)		('inspect subinstances'				inspectSubInstances)		-		('change sets with this method'		findMethodInChangeSets)		('revert to previous version'			revertToPreviousVersion)		('revert and forget'					revertAndForget)		-		('more...'							unshiftedYellowButtonActivity))! !!ChangeSorter methodsFor: 'code pane' stamp: 'jm 5/29/2003 19:13'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Create an error if the category of the selected message is unknown. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answer true."	| category selector class oldSelector |	(class _ self selectedClassOrMetaClass) ifNil:		[(myChangeSet preambleString == nil or: [aString size == 0]) ifTrue: [ ^ false].		(aString select: [:char | char == $"]) size odd 			ifTrue: [self inform: 'unmatched double quotes in preamble']			ifFalse: [(Scanner new scanTokens: aString) size > 0 ifTrue: [				self inform: 'Part of the preamble is not within double-quotes.To put a double-quote inside a comment, type two double-quotes in a row.(Ignore this warning if you are including a doIt in the preamble.)']].		myChangeSet preambleString: aString.		self currentSelector: nil.  "forces update with no 'unsubmitted chgs' feedback"		^ true].	oldSelector _ self selectedMessageName.	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector ifNil: [^ false].	(self messageList includes: selector)		ifTrue: [self currentSelector: selector]		ifFalse: [self currentSelector: oldSelector].	self update.	^ true! !!ChangeSorter methodsFor: 'code pane' stamp: 'mas 5/20/2000 22:03'!setContents	"return the source code that shows in the bottom pane"	| sel class strm changeType |	self clearUserEditFlag.	currentClassName ifNil: [^ contents _ myChangeSet preambleString ifNil: ['']].	class _ self selectedClassOrMetaClass.	(sel _ currentSelector) == nil		ifFalse: [changeType _ (myChangeSet atSelector: (sel _ sel asSymbol) class: class).			changeType == #remove				ifTrue: [^ contents _ 'Method has been removed (see versions)'].			changeType == #addedThenRemoved				ifTrue: [^ contents _ 'Added then removed (see versions)'].			class ifNil: [^ contents _ 'Method was added, but cannot be found!!'].			(class includesSelector: sel)				ifFalse: [^ contents _ 'Method was added, but cannot be found!!'].			contents _ class sourceCodeAt: sel.			Preferences browseWithPrettyPrint ifTrue:				[contents _ class compilerClass new					format: contents in: class notifying: nil decorated: Preferences colorWhenPrettyPrinting].			self showDiffs				ifTrue: [contents _ self diffFromPriorSourceFor: contents].			^ contents _ contents asText makeSelectorBoldIn: class]		ifTrue: [strm _ WriteStream on: (String new: 100).			(myChangeSet classChangeAt: currentClassName) do:				[:each |				each = #remove ifTrue: [strm nextPutAll: 'Entire class was removed.'; cr].				each = #addedThenRemoved ifTrue: [strm nextPutAll: 'Class was added then removed.'].				each = #rename ifTrue: [strm nextPutAll: 'Class name was changed.'; cr].				each = #add ifTrue: [strm nextPutAll: 'Class definition was added.'; cr].				each = #change ifTrue: [strm nextPutAll: 'Class definition was changed.'; cr].				each = #reorganize ifTrue: [strm nextPutAll: 'Class organization was changed.'; cr].				each = #comment ifTrue: [strm nextPutAll: 'New class comment.'; cr.				]].			^ contents _ strm contents].! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'sw 2/21/2000 14:36'!allChangeSetsWithClass: class selector: selector	class ifNil: [^ #()].	^ self gatherChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none]! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 17:25'!changeSetsNamedSuchThat: nameBlock	"(ChangeSorter changeSetsNamedSuchThat:		[:name | name first isDigit and: [name initialInteger >= 373]])		do: [:cs | AllChangeSets remove: cs wither]"	self gatherChangeSets.	^ AllChangeSets select: [:aChangeSet | nameBlock value: aChangeSet name]! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'di 4/3/2000 14:51'!gatherChangeSets		"ChangeSorter gatherChangeSets"	"Collect any change sets created in other projects"	| allChangeSets obsolete |	allChangeSets _ AllChangeSets asSet.	ChangeSet allSubInstances do: [:each |		(allChangeSets includes: each) == (obsolete _ each isMoribund) ifTrue:[			obsolete				ifTrue: ["Was included and is obsolete."						AllChangeSets remove: each]				ifFalse: ["Was not included and is not obsolete."						AllChangeSets add: each]]].	^ AllChangeSets! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'sw 8/20/1999 10:27'!highestNumberedChangeSet	"ChangeSorter highestNumberedChangeSet"	| aList |	aList _ (self allChangeSetNames select: [:aString | aString startsWithDigit] thenCollect:		[:aString | aString initialIntegerOrNil]).	^ (aList size > 0)		ifTrue:			[aList max]		ifFalse:			[nil]! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'sw 2/15/1999 23:02'!mostRecentChangeSetWithChangeForClass: class selector: selector	| hits |	hits _ self gatherChangeSets select: 		[:cs | (cs atSelector: selector class: class) ~~ #none].	hits isEmpty ifTrue: [^ 'not in any change set'].	^ 'recent cs: ', hits last name! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'jm 5/31/2003 16:56'!newChangeSet	"Prompt the user for a name, and establish a new change set of that name (if ok), making it the current changeset.  Return nil of not ok, else return the actual changeset."	| newName newSet |	newName _ FillInTheBlank request: 'Please name the new change set:'			initialAnswer: ChangeSet defaultName.	newName isEmpty ifTrue:		[self inform: 'nothing done'.		^ nil].	(self changeSetNamed: newName) ifNotNil:			[self inform: 'Sorry that name is already used'.			^ nil].	newSet _ ChangeSet new name: newName.	AllChangeSets add: newSet.	Smalltalk newChanges: newSet.	Transcript cr; show: newName, ' is now the current change set'.	^ newSet! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'jm 6/21/2003 11:17'!newChangesFromStream: aStream named: aName	"File in the code from the stream into a new change set whose name is derived from aName.  Leave the 'current change set' unchanged.   Returns the new change set;  Returns nil on failure."	|  newName aNewChangeSet existingChanges |	existingChanges _ Smalltalk changes.	newName _ aName sansPeriodSuffix.	(self changeSetNamed: newName) ~~ nil		ifTrue:			[self inform: 'Sorry -- "', newName, '" is already used as a change-set name'.			aStream close.			^ nil].	aNewChangeSet _ ChangeSet new.	aNewChangeSet name: newName.	AllChangeSets add: aNewChangeSet.	Smalltalk newChanges: aNewChangeSet.	aStream fileInAnnouncing: 'Loading ', newName, '...'.	Transcript cr; show: 'File ', aName, ' successfully filed in to change set ', newName.	Smalltalk newChanges: existingChanges.	^ aNewChangeSet! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'sw 1/27/2000 15:04'!promoteToTop: aChangeSet	"make aChangeSet the first in the list from now on"	self gatherChangeSets.	AllChangeSets remove: aChangeSet ifAbsent: [^ self].	AllChangeSets add: aChangeSet.	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup]! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'sw 8/18/1999 09:44'!removeChangeSet: aChangeSet	"Remove the given changeSet.  Caller must assure that it's cool to do this"	AllChangeSets remove: aChangeSet ifAbsent: [].	aChangeSet wither! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'tk 6/24/1999 11:32'!removeChangeSetsBefore: stopName	"Remove all change sets before the one with the given name."	"ChangeSorter removeChangeSetsBefore: 'Beyond'" 	| stop |	(self confirm:'Really remove all change sets before"', stopName, '"?')		ifFalse: [^ self].	self gatherChangeSets.	stop _ false.	ChangeSet allSubInstancesDo: [:changeSet |		changeSet name = stopName ifTrue: [stop _ true].		stop ifFalse: [			changeSet okayToRemove ifTrue: [				AllChangeSets remove: changeSet ifAbsent: [].				changeSet wither]]].	Smalltalk garbageCollect.	AllChangeSets _ OrderedCollection new.	self gatherChangeSets.! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'di 11/8/1998 16:32'!removeChangeSetsNamedSuchThat: nameBlock	(ChangeSorter changeSetsNamedSuchThat: nameBlock)		do: [:cs | AllChangeSets remove: cs wither]! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'di 11/9/1998 10:23'!removeEmptyUnnamedChangeSets	"Remove all change sets that are empty, whose names start with Unnamed,		and which are not nailed down by belonging to a Project."	"ChangeSorter removeEmptyUnnamedChangeSets"	| toGo |	(toGo _ (self changeSetsNamedSuchThat: [:csName | csName beginsWith: 'Unnamed'])		select: [:cs | cs isEmpty and: [cs okayToRemoveInforming: false]])		do: [:cs | AllChangeSets remove: cs wither].	self inform: toGo size printString, ' change set(s) removed.'! !!ChangeSorter class methodsFor: 'as yet unclassified' stamp: 'sw 1/4/2000 16:31'!reorderChangeSets	"ChangeSorter reorderChangeSets"	"Change the order of the change sets to something more convenient:		First come the unnumbered changesets that come with the release.		Next come the numbered updates.		Next come all remaining changesets	In a ChangeSorter, they will appear in the reversed order."	| newHead newMid newTail itsName |	self gatherChangeSets.	newHead _ OrderedCollection new.	newMid _ OrderedCollection new.	newTail _ OrderedCollection new.	AllChangeSets do:		[:aSet |			itsName _ aSet name.			((itsName beginsWith:  'Play With Me') or: [#('New Changes' 'MakeInternal') includes: itsName])				ifTrue:					[newHead add: aSet]				ifFalse:					[itsName startsWithDigit						ifTrue:							[newMid add: aSet]						ifFalse:							[newTail add: aSet]]].	AllChangeSets _ newHead, newMid, newTail.	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup]! !!ChangedMessageSet methodsFor: 'everything' stamp: 'sw 9/30/1999 12:15'!contents: aString notifying: aController	| selectedMessageName selector oldMessageList cls |	self okayToAccept ifFalse: [^ false].	selectedMessageName _ self selectedMessageName.	oldMessageList _ self messageList.	contents _ nil.	selector _ self selectedClassOrMetaClass				compile: aString				classified:  self selectedMessageCategoryName				notifying: aController.	selector == nil ifTrue: [^ false].	cls _ self selectedClassOrMetaClass.	contents _ aString copy.	selector ~~ selectedMessageName ifTrue: 			[(oldMessageList includes: selector) ifFalse: [					self initializeMessageList: changeSet changedMessageListAugmented.					self changed: #messageList].			self messageListIndex: (self messageList indexOf: (cls name, ' ', selector))].	^ true! !!ChangedMessageSet class methodsFor: 'as yet unclassified' stamp: 'sw 8/5/1998 17:42'!openFor: aChangeSet	"Open up a ChangedMessageSet browser on the given change set; this is a conventional message-list browser whose message list is the list of methods in aChangeSet.  After any method submission, the message list is refigured, making it plausibly dynamic.  "	| messageSet |	messageSet _ aChangeSet changedMessageListAugmented.	self openMessageList: messageSet name: ('Methods in Change Set ', aChangeSet name) autoSelect: nil changeSet: aChangeSet! !!ChangedMessageSet class methodsFor: 'as yet unclassified' stamp: 'sma 4/30/2000 09:22'!openMessageList: messageList name: labelString autoSelect: autoSelectString changeSet: aChangeSet	| messageSet |	messageSet _ self messageList: messageList.	messageSet changeSet: aChangeSet.	messageSet autoSelectString: autoSelectString.	Smalltalk isMorphic		ifTrue: [self openAsMorph: messageSet name: labelString]		ifFalse: [ScheduledControllers scheduleActive:  (self open: messageSet name: labelString)]! !I represent a character by storing its associated ASCII code (extended to 256 codes). My instances are created uniquely, so that all instances of a character ($R, for example) are identical.!!Character methodsFor: 'testing' stamp: 'ls 7/26/1998 20:27'!isSafeForHTTP	"whether a character is 'safe', or needs to be escaped when used, eg, in a URL"	^self isAlphaNumeric or: [ '.~-_' includes: self ]! !!Character methodsFor: 'testing' stamp: 'di 4/3/1999 00:38'!isSpecial	"Answer whether the receiver is one of the special characters"	^'+-/\*~<>=@,%|&?!!' includes: self! !!Character methodsFor: 'converting' stamp: 'sma 3/11/2000 17:21'!asString	^ String with: self! !!Character methodsFor: 'converting' stamp: 'sma 3/15/2000 22:57'!isoToSqueak	"Convert receiver from iso8895-1 (actually CP1252) to mac encoding.	Does not do lf/cr conversion!! Characters not available in MacRoman	encoding have been remapped to their base characters or to $?."	value < 128 ifTrue: [^ self].	^ Character value: (#(		219 63 226 196 227 201 160 224 246 228 83 220 206 63 90 63		"80-8F"		63 212 213 210 211 165 208 209 247 170 115 221 207 63 122 217		"90-9F"		202 193 162 163 63 180 124 164 172 169 187 199 194 45 168 248	 	"A0-AF"		161 177 50 51 171 181 166 225 252 49 188 200 63 63 63 192 			"B0-BF"		203 231 229 204 128 129 174 130 233 131 230 232 237 234 235 236 	"C0-CF"		63 132 241 238 239 205 133 42 175 244 242 243 134 89 63 167	 	"D0-DF"		136 135 137 139 138 140 190 141 143 142 144 145 147 146 148 149		"E0-EF"		63 150 152 151 153 155 154 214 191 157 156 158 159 121 63 216		"F0-FF"	) at: value - 127)! !!Character class methodsFor: 'instance creation' stamp: 'ls 8/15/1998 06:56'!allCharacters	^ (0 to: 255)		collect: [:v | Character value: v]	! !!Character class methodsFor: 'constants' stamp: 'ls 9/8/1998 22:15'!lf	"Answer the Character representing a linefeed."	^self value: 10! !My instances contain information about displayed characters. They are used to return the results of methods:	Paragraph characterBlockAtPoint: aPoint and	Paragraph characterBlockForIndex: stringIndex.Any recomposition or movement of a Paragraph can make the instance obsolete.!!CharacterBlock methodsFor: 'accessing' stamp: 'di 6/7/2000 17:33'!copy	"Overridden because Rectangle does a deepCopy, which goes nuts with the text"	^ self clone! !My instances are used to scan text to compute the CharacterBlock for a character specified by its index in the text or its proximity to the cursor location.!!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:51'!cr 	"Answer a CharacterBlock that specifies the current location of the mouse 	relative to a carriage return stop condition that has just been 	encountered. The ParagraphEditor convention is to denote selections by 	CharacterBlocks, sometimes including the carriage return (cursor is at 	the end) and sometimes not (cursor is in the middle of the text)."	((characterIndex ~= nil		and: [characterIndex > text size])			or: [(line last = text size)				and: [(destY + line lineHeight) < characterPoint y]])		ifTrue:	["When off end of string, give data for next character"				destY _ destY +  line lineHeight.				lastCharacter _ nil.				characterPoint _ ((text at: lastIndex) = CR								ifTrue: [leftMargin]								ifFalse: [nextLeftMargin]) @ destY.				lastIndex _ lastIndex + 1.				self lastCharacterExtentSetX: 0.				^ true].		lastCharacter _ CR.		characterPoint _ destX @ destY.		self lastCharacterExtentSetX: rightMargin - destX.		^true! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:50'!crossedX	"Text display has wrapping. The scanner just found a character past the x 	location of the cursor. We know that the cursor is pointing at a character 	or before one."	| leadingTab currentX |	characterPoint x <= (destX + ((lastCharacterExtent x) // 2))		ifTrue:	[lastCharacter _ (text at: lastIndex).				characterPoint _ destX @ destY.				^true].	lastIndex >= line last 		ifTrue:	[lastCharacter _ (text at: line last).				characterPoint _ destX @ destY.				^true].	"Pointing past middle of a character, return the next character."	lastIndex _ lastIndex + 1.	lastCharacter _ text at: lastIndex.	currentX _ destX + lastCharacterExtent x.	self lastCharacterExtentSetX: (font widthOf: lastCharacter).	characterPoint _ currentX @ destY.	"Yukky if next character is space or tab."	(lastCharacter = Space and: [textStyle alignment = Justified])		ifTrue:	[self lastCharacterExtentSetX:					(lastCharacterExtent x + 	(line justifiedPadFor: (spaceCount + 1))).				^ true].	lastCharacter = Space		ifTrue:			["See tabForDisplay for illumination on the following awfulness."			leadingTab _ true.			(line first to: lastIndex - 1) do:			[:index |			(text at: index) ~= Tab				ifTrue: [leadingTab _ false]].			(textStyle alignment ~= Justified or: [leadingTab])				ifTrue:	[self lastCharacterExtentSetX: (textStyle nextTabXFrom: currentX							leftMargin: leftMargin rightMargin: rightMargin) -								currentX]				ifFalse:	[self lastCharacterExtentSetX:  (((currentX + (textStyle tabWidth -								(line justifiedTabDeltaFor: spaceCount))) -									currentX) max: 0)]].	^ true! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:50'!endOfRun	"Before arriving at the cursor location, the selection has encountered an 	end of run. Answer false if the selection continues, true otherwise. Set 	up indexes for building the appropriate CharacterBlock."	| runLength lineStop |	((characterIndex ~~ nil and:		[runStopIndex < characterIndex and: [runStopIndex < text size]])			or:	[characterIndex == nil and: [lastIndex < line last]])		ifTrue:	["We're really at the end of a real run."				runLength _ (text runLengthFor: (lastIndex _ lastIndex + 1)).				characterIndex ~~ nil					ifTrue:	[lineStop _ characterIndex	"scanning for index"]					ifFalse:	[lineStop _ line last			"scanning for point"].				(runStopIndex _ lastIndex + (runLength - 1)) > lineStop					ifTrue: 	[runStopIndex _ lineStop].				self setStopConditions.				^false].	lastCharacter _ text at: lastIndex.	characterPoint _ destX @ destY.	((lastCharacter = Space and: [textStyle alignment = Justified])		or: [lastCharacter = Tab and: [lastSpaceOrTabExtent notNil]])		ifTrue: [lastCharacterExtent _ lastSpaceOrTabExtent].	characterIndex ~~ nil		ifTrue:	["If scanning for an index and we've stopped on that index,				then we back destX off by the width of the character stopped on				(it will be pointing at the right side of the character) and return"				runStopIndex = characterIndex					ifTrue:	[self characterPointSetX: destX - lastCharacterExtent x.							^true].				"Otherwise the requested index was greater than the length of the				string.  Return string size + 1 as index, indicate further that off the				string by setting character to nil and the extent to 0."				lastIndex _  lastIndex + 1.				lastCharacter _ nil.				self lastCharacterExtentSetX: 0.				^true].	"Scanning for a point and either off the end of the line or off the end of the string."	runStopIndex = text size		ifTrue:	["off end of string"				lastIndex _  lastIndex + 1.				lastCharacter _ nil.				self lastCharacterExtentSetX: 0.				^true].	"just off end of line without crossing x"	lastIndex _ lastIndex + 1.	^true! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:51'!paddedSpace	"When the line is justified, the spaces will not be the same as the font's 	space character. A padding of extra space must be considered in trying 	to find which character the cursor is pointing at. Answer whether the 	scanning has crossed the cursor."	| pad |	pad _ 0.	spaceCount _ spaceCount + 1.	pad _ line justifiedPadFor: spaceCount.	lastSpaceOrTabExtent _ lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX:  spaceWidth + pad.	(destX + lastSpaceOrTabExtent x)  >= characterPoint x		ifTrue: [lastCharacterExtent _ lastSpaceOrTabExtent copy.				^self crossedX].	lastIndex _ lastIndex + 1.	destX _ destX + lastSpaceOrTabExtent x.	^ false! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/8/2000 14:32'!setFont	specialWidth _ nil.	super setFont! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 5/18/2000 16:47'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont.	textStyle alignment = Justified ifTrue:[		"Make a local copy of stop conditions so we don't modify the default"		stopConditions == DefaultStopConditions 			ifTrue:[stopConditions _ stopConditions copy].		stopConditions at: Space asciiValue + 1 put: #paddedSpace]! !!CharacterBlockScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:50'!tab	| currentX |	currentX _ (textStyle alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse:			[textStyle				nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	lastSpaceOrTabExtent _ lastCharacterExtent copy.	self lastSpaceOrTabExtentSetX: (currentX - destX max: 0).	currentX >= characterPoint x		ifTrue: 			[lastCharacterExtent _ lastSpaceOrTabExtent copy.			^ self crossedX].	destX _ currentX.	lastIndex _ lastIndex + 1.	^false! !!CharacterBlockScanner methodsFor: 'private' stamp: 'jm 7/23/2003 16:03'!buildCharacterBlockIn: para	| lineIndex runLength lineStop done stopCondition |	"handle nullText"	(para numberOfLines = 0 or: [text size = 0])		ifTrue:	[^ CharacterBlock new stringIndex: 1  "like being off end of string"					text: para text					topLeft: (para leftMarginForDisplayForLine: 1)								@ para compositionRectangle top					extent: 0 @ textStyle lineGrid].	"find the line"	lineIndex _ para lineIndexOfTop: characterPoint y.	destY _ para topAtLineIndex: lineIndex.	line _ para lines at: lineIndex.	rightMargin _ para rightMarginForDisplay.	(lineIndex = para numberOfLines and:		[(destY + line lineHeight) < characterPoint y])			ifTrue:	["if beyond lastLine, force search to last character"					self characterPointSetX: rightMargin]			ifFalse:	[characterPoint y < (para compositionRectangle) top						ifTrue: ["force search to first line"								characterPoint _ (para compositionRectangle) topLeft].					characterPoint x > rightMargin						ifTrue:	[self characterPointSetX: rightMargin]].	destX _ (leftMargin _ para leftMarginForDisplayForLine: lineIndex).	nextLeftMargin_ para leftMarginForDisplayForLine: lineIndex+1.	lastIndex _ line first.	self setStopConditions.		"also sets font"	runLength _ (text runLengthFor: line first).	characterIndex ~~ nil		ifTrue:	[lineStop _ characterIndex	"scanning for index"]		ifFalse:	[lineStop _ line last].	(runStopIndex _ lastIndex + (runLength - 1)) > lineStop		ifTrue:	[runStopIndex _ lineStop].	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0. done  _ false.	self handleIndentation.	[done]	whileFalse:	[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.	"see setStopConditions for stopping conditions for character block 	operations."	self lastCharacterExtentSetX: (font widthOf: (text at: lastIndex)).	(self perform: stopCondition)		ifTrue:	[^ CharacterBlock new stringIndex: lastIndex text: text					topLeft: characterPoint extent: lastCharacterExtent]]! !!CharacterBlockScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:34'!characterPointSetX: xVal	characterPoint _ xVal @ characterPoint y! !!CharacterBlockScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:34'!lastCharacterExtentSetX: xVal	lastCharacterExtent _ xVal @ lastCharacterExtent y! !!CharacterBlockScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:34'!lastSpaceOrTabExtentSetX: xVal	lastSpaceOrTabExtent _ xVal @ lastSpaceOrTabExtent y! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 19:14'!characterBlockAtPoint: aPoint in: aParagraph	"Answer a CharacterBlock for character in aParagraph at point aPoint. It 	is assumed that aPoint has been transformed into coordinates appropriate 	to the text's destination form rectangle and the composition rectangle."	self initializeFromParagraph: aParagraph clippedBy: aParagraph clippingRectangle.	characterPoint _ aPoint.	^self buildCharacterBlockIn: aParagraph! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'jm 7/23/2003 16:43'!characterBlockAtPoint: aPoint index: index in: textLine	| runLength lineStop done stopCondition |	line _ textLine.	characterIndex _ index.  " == nil means scanning for point"	characterPoint _ aPoint.	(characterPoint == nil or: [characterPoint y > line bottom])		ifTrue: [characterPoint _ line bottomRight].	(text isEmpty or: [(characterPoint y < line top or: [characterPoint x < line left])				or: [characterIndex ~~ nil and: [characterIndex < line first]]])		ifTrue:	[^ (CharacterBlock new stringIndex: line first text: text					topLeft: line leftMargin@line top extent: 0 @ textStyle lineGrid)					textLine: line].	rightMargin _ line rightMargin.	destX _ leftMargin _ line leftMarginForAlignment: textStyle alignment.	destY _ line top.	lastIndex _ line first.	self setStopConditions.		"also sets font"	runLength _ text runLengthFor: line first.	characterIndex ~~ nil		ifTrue:	[lineStop _ characterIndex  "scanning for index"]		ifFalse:	[lineStop _ line last  "scanning for point"].	runStopIndex _ lastIndex + (runLength - 1) min: lineStop.	lastCharacterExtent _ 0 @ line lineHeight.	spaceCount _ 0.	self handleIndentation.	done _ false.	[done] whileFalse:		[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex			in: text string rightX: characterPoint x			stopConditions: stopConditions kern: kern.		"see setStopConditions for stopping conditions for character block 	operations."		self lastCharacterExtentSetX: (specialWidth == nil			ifTrue: [font widthOf: (text at: lastIndex)]			ifFalse: [specialWidth]).		(self perform: stopCondition) ifTrue:			[^ (CharacterBlock new				stringIndex: (characterIndex==nil ifTrue: [lastIndex] ifFalse: [characterIndex])				text: text topLeft: characterPoint extent: lastCharacterExtent)				textLine: line]]! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 19:14'!characterBlockForIndex: targetIndex in: aParagraph 	"Answer a CharacterBlock for character in aParagraph at targetIndex. The 	coordinates in the CharacterBlock will be appropriate to the intersection 	of the destination form rectangle and the composition rectangle."	self 		initializeFromParagraph: aParagraph 		clippedBy: aParagraph clippingRectangle.	characterIndex _ targetIndex.	characterPoint _ 		aParagraph rightMarginForDisplay @ 			(aParagraph topAtLineIndex: 				(aParagraph lineIndexOfCharacterIndex: characterIndex)).	^self buildCharacterBlockIn: aParagraph! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 5/19/2000 14:46'!characterNotInFont 	"See the note in CharacterScanner>>characterNotInFont.	This does not handle character selection nicely, i.e., illegal characters are a 	little tricky to select.  Since the end of a run or line is subverted here by actually	having the scanner scan a different string in order to manage the illegal 	character, things are not in an absolutely correct state for the character 	location code.  If this becomes too odious in use, logic will be added to accurately 	manage the situation."	lastCharacterExtent _ 		(font widthOf: (font maxAscii + 1) asCharacter) @ line lineHeight.	^super characterNotInFont! !!CharacterBlockScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 17:35'!placeEmbeddedObject: anchoredMorph	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	specialWidth _ anchoredMorph width.	^ true! !My instances hold the state associated with scanning text. My subclasses scan characters for specified purposes, such as computing a CharacterBlock or placing characters into Forms.!!CharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:27'!addEmphasis: code	"Set the bold-ital-under-strike emphasis."	emphasisCode _ emphasisCode bitOr: code! !!CharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:27'!addKern: kernDelta	"Set the current kern amount."	kern _ kern + kernDelta! !!CharacterScanner methodsFor: 'private' stamp: 'ar 5/17/2000 17:13'!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	text _ aParagraph text.	textStyle _ aParagraph textStyle. ! !!CharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:27'!setActualFont: aFont	"Set the basal font to an isolated font reference."	font _ aFont! !!CharacterScanner methodsFor: 'private' stamp: 'ar 5/18/2000 18:02'!setFont	"Set the font and other emphasis."	text == nil ifFalse:[		emphasisCode _ 0.		kern _ 0.		indentationLevel _ 0.		alignment _ textStyle alignment.		font _ nil.		(text attributesAt: lastIndex forStyle: textStyle)			do: [:att | att emphasizeScanner: self]].	font == nil ifTrue:		[self setFont: textStyle defaultFontIndex].	font _ font emphasized: emphasisCode.	"Install various parameters from the font."	spaceWidth _ font widthOf: Space.	xTable _ font xTable.	map _ font characterToGlyphMap.	stopConditions _ DefaultStopConditions.! !!CharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:28'!setFont: fontNumber	"Set the font by number from the textStyle."	self setActualFont: (textStyle fontAt: fontNumber)! !!CharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:28'!text: t textStyle: ts	text _ t.	textStyle _ ts! !!CharacterScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:28'!textColor: ignored	"Overridden in DisplayScanner"! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 5/19/2000 14:45'!characterNotInFont	"Note: All fonts should have some sort of a character to glyph mapping.	If a character is not in the font it should be mapped to the appropriate	glyph (that is the glyph describing a non-existing character). If done	correctly, this method should never be called. It is mainly provided	for backward compatibility (and I'd really like to get rid of it - ar).	All fonts have an illegal character to be used when a character is not 	within the font's legal range. When characters out of ranged are 	encountered in scanning text, then this special character indicates the 	appropriate behavior. The character is usually treated as a unary 	message understood by a subclass of CharacterScanner."	| illegalAsciiString saveIndex stopCondition | 	saveIndex _ lastIndex.	illegalAsciiString _ String with: (font maxAscii + 1) asCharacter.	stopCondition _ self scanCharactersFrom: 1 to: 1			in: illegalAsciiString			rightX: rightMargin stopConditions: stopConditions			kern: kern.	lastIndex _ saveIndex + 1.	stopCondition ~= (stopConditions at: EndOfRun)		ifTrue:	[^self perform: stopCondition]		ifFalse: [lastIndex = runStopIndex					ifTrue:	[^self perform: (stopConditions at: EndOfRun)].				^false]! !!CharacterScanner methodsFor: 'scanning' stamp: 'jm 7/23/2003 16:10'!handleIndentation	"Handle indentation at the start of a line."	self indentationLevel timesRepeat: [self plainTab].! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 18:20'!indentationLevel	"return the number of tabs that are currently being placed at the beginning of each line"	^indentationLevel ifNil:[0]! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 1/8/2000 14:23'!indentationLevel: anInteger	"set the number of tabs to put at the beginning of each line"	indentationLevel _ anInteger! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 1/8/2000 14:23'!leadingTab	"return true if only tabs lie to the left"	line first to: lastIndex do:		[:i | (text at: i) == Tab ifFalse: [^ false]].	^ true! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 18:20'!placeEmbeddedObject: anchoredMorph	"Place the anchoredMorph or return false if it cannot be placed.	In any event, advance destX by its width."	| w |	destX _ destX + (w _ anchoredMorph width).	(destX > rightMargin and: [(leftMargin + w) <= rightMargin])		ifTrue: ["Won't fit, but would on next line"				^ false].	lastIndex _ lastIndex + 1.	self setFont.  "Force recalculation of emphasis for next run"	^ true! !!CharacterScanner methodsFor: 'scanning' stamp: 'jm 7/23/2003 16:24'!plainTab	"Adjust destX for a tab."	(alignment == Justified and: [self leadingTab not])		ifTrue: [  "embedded tabs in justified text are weird"			destX _ destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: [			destX _ textStyle				nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].! !!CharacterScanner methodsFor: 'scanning' stamp: 'ar 5/23/2000 12:59'!primScanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"Primitive. This is the inner loop of text display--but see 	scanCharactersFrom: to:rightX: which would get the string, 	stopConditions and displaying from the instance. March through source 	String from startIndex to stopIndex. If any character is flagged with a 	non-nil entry in stops, then return the corresponding value. Determine 	width of each character from xTable, indexed by map. 	If dextX would exceed rightX, then return stops at: 258. 	Advance destX by the width of the character. If stopIndex has been	reached, then return stops at: 257. Optional. 	See Object documentation whatIsAPrimitive."	| ascii nextDestX char |	<primitive: 103>	lastIndex _ startIndex.	[lastIndex <= stopIndex]		whileTrue: 			[char _ (sourceString at: lastIndex).			ascii _ char asciiValue + 1.			(stops at: ascii) == nil ifFalse: [^stops at: ascii].			"Note: The following is querying the font about the width			since the primitive may have failed due to a non-trivial			mapping of characters to glyphs or a non-existing xTable."			nextDestX _ destX + (font widthOf: char).			nextDestX > rightX ifTrue: [^stops at: CrossedX].			destX _ nextDestX + kernDelta.			lastIndex _ lastIndex + 1].	lastIndex _ stopIndex.	^stops at: EndOfRun! !!CharacterScanner methodsFor: 'scanning' stamp: 'jm 7/23/2003 16:10'!scanCharactersFrom: startIndex to: stopIndex in: sourceString rightX: rightX stopConditions: stops kern: kernDelta	"This method will perform text scanning with kerning."	^ self primScanCharactersFrom: startIndex		to: stopIndex		in: sourceString 		rightX: rightX		stopConditions: stops		kern: kernDelta! !!CharacterScanner methodsFor: 'initialize' stamp: 'ar 5/17/2000 17:33'!initialize	destX _ destY _ 0.! !!CharacterScanner class methodsFor: 'class initialization' stamp: 'ar 5/18/2000 16:50'!initialize	"CharacterScanner initialize"	"NewCharacterScanner initialize"	| stopConditions |	stopConditions _ Array new: 258.	stopConditions atAllPut: nil.	stopConditions at: Space asciiValue + 1 put: nil.	stopConditions at: Tab asciiValue + 1 put: #tab.	stopConditions at: CR asciiValue + 1 put: #cr.	stopConditions at: EndOfRun put: #endOfRun.	stopConditions at: CrossedX put: #crossedX.	DefaultStopConditions _ stopConditions.! !A set of characters.  Lookups for inclusion are very fast.!!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:33'!add: aCharacter	map at: aCharacter asciiValue+1  put: 1.! !!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:41'!do: aBlock	"evaluate aBlock with each character in the set"	Character allCharacters do: [ :c |		(self includes: c) ifTrue: [ aBlock value: c ] ]! !!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:31'!includes: aCharacter	^(map at: aCharacter asciiValue + 1) > 0! !!CharacterSet methodsFor: 'collection ops' stamp: 'ls 8/17/1998 20:34'!remove: aCharacter	map at: aCharacter asciiValue + 1  put: 0! !!CharacterSet methodsFor: 'conversion' stamp: 'ls 8/17/1998 20:39'!complement	"return a character set containing precisely the characters the receiver does not"	| set |	set _ CharacterSet allCharacters.	self do: [ :c | set remove: c ].	^set! !!CharacterSet methodsFor: 'comparison' stamp: 'ls 8/17/1998 20:46'!= anObject	^self class == anObject class and: [		self byteArrayMap = anObject byteArrayMap ]! !!CharacterSet methodsFor: 'comparison' stamp: 'ls 8/17/1998 20:46'!hash	^self byteArrayMap hash! !!CharacterSet methodsFor: 'private' stamp: 'ls 8/17/1998 20:35'!byteArrayMap	"return a ByteArray mapping each ascii value to a 1 if that ascii value is in the set, and a 0 if it isn't.  Intended for use by primitives only"	^map! !!CharacterSet methodsFor: 'private' stamp: 'ls 8/17/1998 20:30'!initialize	map _ ByteArray new: 256 withAll: 0.! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/17/1998 20:42'!allCharacters	"return a set containing all characters"	| set |	set _ self empty.	0 to: 255 do: [ :ascii | set add: (Character value: ascii) ].	^set! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/17/1998 20:36'!empty 	"return an empty set of characters"	^super new initialize! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 1/3/1999 12:52'!newFrom: aCollection	| newCollection |	newCollection _ self new.	newCollection addAll: aCollection.	^newCollection! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/18/1998 00:40'!nonSeparators	"return a set containing everything but the whitespace characters"	^self separators complement! !!CharacterSet class methodsFor: 'instance creation' stamp: 'ls 8/18/1998 00:40'!separators	"return a set containing just the whitespace characters"	| set |	set _ self empty.	set addAll: Character separators.	^set! !I am used to represent a BlockMorph argument that that allows the user to choose from a small, finite value set, for example, to select between sensor names ('a', 'b', 'c', or 'd') or between boolean values.!!ChoiceArgMorph methodsFor: 'initialization' stamp: 'jm 9/28/2003 18:18'!beBoolean	"Make myself be a boolean choice."	isBoolean _ true.	self options: #(true false).	self choice: #true.! !!ChoiceArgMorph methodsFor: 'initialization' stamp: 'jm 8/24/2003 18:33'!initialize	super initialize.	self borderInset.	self borderWidth: 1.	self color: Color white.	labelMorph _ StringMorph new.	self addMorph: labelMorph.	isBoolean _ false.	options _ #(a b c d).	self choice: #a.! !!ChoiceArgMorph methodsFor: 'accessing' stamp: 'jm 8/24/2003 18:26'!choice	^ choice! !!ChoiceArgMorph methodsFor: 'accessing' stamp: 'jm 8/24/2003 18:27'!choice: aSymbol	choice _ aSymbol.	labelMorph contents: choice asString.	labelMorph position: self position + borderWidth + (3@3).	self extent: ((labelMorph extent + (8@8) + borderWidth) max: 13@21).! !!ChoiceArgMorph methodsFor: 'accessing' stamp: 'jm 8/24/2003 18:32'!options: stringList	options _ stringList asArray.	(options includes: choice) ifFalse: [self choice: options first].! !!ChoiceArgMorph methodsFor: 'event handling' stamp: 'jm 12/8/2002 22:55'!handlesMouseDown: evt	^ true! !!ChoiceArgMorph methodsFor: 'event handling' stamp: 'jm 8/24/2003 18:30'!mouseDown: evt	"Pop up a menu of choices."	| menu selection |	menu _ CustomMenu new.	options do: [:sym | menu add: sym action: sym].	(selection _ menu startUp) ifNotNil: [self choice: selection].! !!ChoiceArgMorph methodsFor: 'evaluation' stamp: 'jm 8/24/2003 18:33'!evaluate	"Answer my value."	isBoolean ifTrue: [^ 'true' = choice].	^ choice! !!ChoiceArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:17'!fieldsVersion	^ 1! !!ChoiceArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:28'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		isBoolean		options		choice	) from: anObjStream.! !!ChoiceArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:28'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		isBoolean		options		choice	) on: anObjStream.! !I add a number of facilities to those in ClassDescription:	A set of all my subclasses (defined in ClassDescription, but only used here and below)	A name by which I can be found in a SystemDictionary	A classPool for class variables shared between this class and its metaclass	A list of sharedPools which probably should be supplanted by some better mechanism.My instances describe the representation and behavior of objects. I add more comprehensive programming support facilities to the basic attributes of Behavior and the descriptive facilities of ClassDescription.The slot 'subclasses' is a redundant structure.  It is never used during execution, but is used by the development system to simplify or speed certain operations.  !!Class methodsFor: 'initialize-release' stamp: 'ar 9/10/1999 17:34'!obsolete	"Change the receiver and all of its subclasses to an obsolete class."	self == Object 		ifTrue:[^self error:'Object is NOT obsolete'].	name _ 'AnObsolete' , name.	Object class instSize + 1 to: self class instSize do:		[:i | self instVarAt: i put: nil]. "Store nil over class instVars."	classPool _ nil.	sharedPools _ nil.	self class obsolete.	super obsolete.! !!Class methodsFor: 'initialize-release' stamp: 'di 12/20/1999 12:37'!removeFromSystem	"Forget the receiver from the Smalltalk global dictionary. Any existing 	instances will refer to an obsolete version of the receiver."	self environment removeClassFromSystem: self.	self obsolete! !!Class methodsFor: 'initialize-release' stamp: 'sw 8/11/1998 13:23'!removeFromSystemUnlogged	"Forget the receiver from the Smalltalk global dictionary. Any existing instances will refer to an obsolete version of the receiver.  Do not log the removal either to the current change set nor to the system changes log"	Smalltalk removeClassFromSystemUnlogged: self.	self obsolete! !!Class methodsFor: 'initialize-release' stamp: 'ar 2/13/1999 21:04'!sharing: poolString 	"Set up sharedPools. Answer whether recompilation is advisable."	| oldPools found |	oldPools _ self sharedPools.	sharedPools _ OrderedCollection new.	(Scanner new scanFieldNames: poolString) do: 		[:poolName | 		sharedPools add: (Smalltalk at: poolName asSymbol ifAbsent:[			(self confirm: 'The pool dictionary ', poolName,' does not exist.',						'\Do you want it automatically created?' withCRs)				ifTrue:[Smalltalk at: poolName asSymbol put: Dictionary new]				ifFalse:[^self error: poolName,' does not exist']])].	sharedPools isEmpty ifTrue: [sharedPools _ nil].	oldPools do: [:pool | found _ false.				self sharedPools do: [:p | p == pool ifTrue: [found _ true]].				found ifFalse: [^ true "A pool got deleted"]].	^ false! !!Class methodsFor: 'initialize-release' stamp: 'ar 7/15/1999 16:39'!superclass: sup methodDict: md format: ft name: nm organization: org instVarNames: nilOrArray classPool: pool sharedPools: poolSet 	"Answer an instance of me, a new class, using the arguments of the 	message as the needed information.	Must only be sent to a new instance; else we would need Object flushCache."	superclass _ sup.	methodDict _ md.	format _ ft.	name _ nm.	organization _ org.	instanceVariables _ nilOrArray.	classPool _ pool.	sharedPools _ poolSet! !!Class methodsFor: 'initialize-release' stamp: 'ar 7/20/1999 11:23'!superclass: aClass methodDictionary: mDict format: fmt	"Basic initialization of the receiver"	super superclass: aClass methodDictionary: mDict format: fmt.	subclasses _ nil. "Important for moving down the subclasses field into Class"! !!Class methodsFor: 'testing' stamp: 'ar 7/15/1999 15:36'!isObsolete	"Return true if the receiver is obsolete."	^(self environment at: name ifAbsent:[nil]) ~~ self! !!Class methodsFor: 'copying' stamp: 'di 2/17/2000 22:43'!copy 	| newClass |	newClass _ self class copy new		superclass: superclass		methodDict: self methodDict copy		format: format		name: name		organization: self organization copy		instVarNames: instanceVariables copy		classPool: classPool copy		sharedPools: sharedPools.	Class instSize+1 to: self class instSize do:		[:offset | newClass instVarAt: offset put: (self instVarAt: offset)].	^ newClass! !!Class methodsFor: 'class name' stamp: 'bf 5/31/2000 17:24'!rename: aString	"The new name of the receiver is the argument, aString."	| newName |	(newName _ aString asSymbol) ~= self name		ifTrue:			[(Smalltalk includesKey: newName)				ifTrue: [^self error: newName , ' already exists'].			(Undeclared includesKey: newName)				ifTrue: [SelectionMenu notify: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].			Smalltalk renameClass: self as: newName.			name _ newName]! !!Class methodsFor: 'instance variables' stamp: 'ar 7/15/1999 18:56'!addInstVarName: aString	"Add the argument, aString, as one of the receiver's instance variables."	^(ClassBuilder new)		name: self name		inEnvironment: self environment		subclassOf: superclass		type: self typeOfClass		instanceVariableNames: self instanceVariablesString , aString		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category! !!Class methodsFor: 'instance variables' stamp: 'ar 7/15/1999 18:56'!removeInstVarName: aString 	"Remove the argument, aString, as one of the receiver's instance variables."	| newInstVarString |	(self instVarNames includes: aString)		ifFalse: [self error: aString , ' is not one of my instance variables'].	newInstVarString _ ''.	(self instVarNames copyWithout: aString) do: 		[:varName | newInstVarString _ newInstVarString , ' ' , varName].	^(ClassBuilder new)		name: self name		inEnvironment: self environment		subclassOf: superclass		type: self typeOfClass		instanceVariableNames: newInstVarString		classVariableNames: self classVariablesString		poolDictionaries: self sharedPoolsString		category: self category! !!Class methodsFor: 'class variables' stamp: 'di 3/27/2000 21:54'!addClassVarName: aString 	"Add the argument, aString, as a class variable of the receiver.	Signal an error if the first character of aString is not capitalized,	or if it is already a variable named in the class."	| symbol |	aString first isLowercase		ifTrue: [^self error: aString, ' class variable name should be capitalized; proceed to include anyway.'].	symbol _ aString asSymbol.	self withAllSubclasses do: 		[:subclass | 		subclass scopeHas: symbol			ifTrue: [:temp | 					^ self error: aString 						, ' is already used as a variable name in class ' 						, subclass name]].	classPool == nil ifTrue: [classPool _ Dictionary new].	(classPool includesKey: symbol) ifFalse: 		["Pick up any refs in Undeclared"		Smalltalk changes changeClass: self from: self.		classPool declare: symbol from: Undeclared]! !!Class methodsFor: 'class variables' stamp: 'jm 7/24/1999 12:58'!removeClassVarName: aString 	"Remove the class variable whose name is the argument, aString, from 	the names defined in the receiver, a class. Create an error notification if 	aString is not a class variable or if it is still being used in the code of 	the class."	| aSymbol |	aSymbol _ aString asSymbol.	(classPool includesKey: aSymbol)		ifFalse: [^self error: aString, ' is not a class variable'].	self withAllSubclasses do:[:subclass |		(Array with: subclass with: subclass class) do:[:classOrMeta |			(classOrMeta whichSelectorsReferTo: (classPool associationAt: aSymbol))				isEmpty ifFalse: [					(self confirm: (aString,' is still used in code of class ', classOrMeta name,						'.\Is it okay to move it to Undeclared?') withCRs)						ifTrue:[^Undeclared declare: aSymbol from: classPool]						ifFalse:[^self]]]].	classPool removeKey: aSymbol.	classPool isEmpty ifTrue: [classPool _ nil].! !!Class methodsFor: 'compiling' stamp: 'di 12/4/1999 07:18'!canFindWithoutEnvironment: varName	"This method is used for analysis of system structure -- see senders."	"Look up varName, in the context of the receiver. Return true if it can be found without using the declared environment."	| assoc |	"First look in classVar dictionary."	(assoc _ self classPool associationAt: varName ifAbsent: []) == nil		ifFalse: [^ true].	"Next look in shared pools."	self sharedPools do: 		[:pool | 		assoc _ pool associationAt: varName ifAbsent: [			"Hideous string key hack from Hypersqueak now used in Wonderland"			pool associationAt: varName asString ifAbsent: []].		assoc == nil ifFalse: 				[^ true]].	"Finally look higher up the superclass chain and fail at the end."	superclass == nil		ifTrue: [^ false]		ifFalse: [^ superclass scopeHas: varName ifTrue: [:ignored]].! !!Class methodsFor: 'compiling' stamp: 'ar 7/14/1999 04:56'!compileAll	super compileAll.	self class compileAll.! !!Class methodsFor: 'compiling' stamp: 'di 12/4/1999 16:51'!scopeHas: varName ifTrue: assocBlock	"Look up the first argument, varName, in the context of the receiver. If it is there,	pass the association to the second argument, assocBlock, and answer true."	| assoc |	"First look in classVar dictionary."	(assoc _ self classPool associationAt: varName ifAbsent: []) == nil		ifFalse: [assocBlock value: assoc.				^ true].	"Next look in shared pools."	self sharedPools do: 		[:pool | 		assoc _ pool associationAt: varName ifAbsent: [			"String key hack from Hypersqueak now used in Wonderland  **Eliminate this**"			pool associationAt: varName asString ifAbsent: []].		assoc == nil ifFalse: 				[assocBlock value: assoc.				^true]].	"Next look in declared environment."	(assoc _ self environment associationAtOrAbove: varName ifAbsent: [nil]) == nil		ifFalse: [assocBlock value: assoc.				^ true].	"Finally look higher up the superclass chain and fail at the end."	superclass == nil		ifTrue: [^ false]		ifFalse: [^ superclass scopeHas: varName ifTrue: assocBlock].! !!Class methodsFor: 'subclass creation' stamp: 'jm 11/14/2003 09:17'!subclass: t instanceVariableNames: f classVariableNames: d module: m	"Provided for compatability with newer versions of Squeak."	| s |	s _ WriteStream on: String new.	m do: [:each | s nextPutAll: each; space].	s size = 0 ifTrue: [s nextPutAll: 'Uncategorized'] ifFalse: [s skip: -1].	self		subclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: ''		category: s contents.! !!Class methodsFor: 'subclass creation' stamp: 'ar 7/15/1999 18:57'!subclass: t instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver)."	^(ClassBuilder new)		superclass: self		subclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'subclass creation' stamp: 'ar 7/15/1999 18:57'!variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable byte-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableByteSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'subclass creation' stamp: 'ar 7/15/1999 18:56'!variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable pointer variables."	^(ClassBuilder new)		superclass: self		variableSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'subclass creation' stamp: 'ar 7/15/1999 18:56'!variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have indexable word-sized nonpointer variables."	^(ClassBuilder new)		superclass: self		variableWordSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'subclass creation' stamp: 'dwh 11/20/1999 23:44'!weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	^(ClassBuilder new)		superclass: self		weakSubclass: t		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!Class methodsFor: 'fileIn/Out' stamp: 'jm 10/7/2002 06:57'!fileOutAsHtml: useHtml	"File a description of the receiver onto a new file whose base name is the name of the receiver."	| fileStream |	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: self name, FileDirectory dot, 'html') asHtml]		ifFalse: [FileStream newFileNamed: self name, FileDirectory dot, 'st'].	fileStream header; timeStamp.	self sharedPools size > 0 ifTrue: [		self shouldFileOutPools			ifTrue: [self fileOutSharedPoolsOn: fileStream]].	self fileOutOn: fileStream moveSource: false toFile: 0.	fileStream trailer; close.! !!Class methodsFor: 'fileIn/Out' stamp: 'ar 12/22/1999 17:32'!fileOutInitializerOn: aStream	^self class fileOutInitializerOn: aStream! !!Class methodsFor: 'fileIn/Out' stamp: 'ar 12/22/1999 17:30'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the receiver on aFileStream. If the boolean argument,	moveSource, is true, then set the trailing bytes to the position of aFileStream and	to fileIndex in order to indicate where to find the source code."	^self fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex initializing: true! !!Class methodsFor: 'fileIn/Out' stamp: 'ar 12/22/1999 17:29'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex initializing: aBool	"File a description of the receiver on aFileStream. If the boolean argument,	moveSource, is true, then set the trailing bytes to the position of aFileStream and	to fileIndex in order to indicate where to find the source code."	Transcript cr; show: name.	super		fileOutOn: aFileStream		moveSource: moveSource		toFile: fileIndex.	self class nonTrivial		ifTrue:			[aFileStream cr; nextPutAll: '"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!!'; cr; cr.			self class				fileOutOn: aFileStream				moveSource: moveSource				toFile: fileIndex				initializing: aBool]! !!Class methodsFor: 'fileIn/Out' stamp: 'dtl 1/15/2000 17:54'!fileOutPool: aPool onFileStream: aFileStream 	| aPoolName aValue |	aPoolName _ Smalltalk keyAtIdentityValue: aPool.	Transcript cr; show: aPoolName.	aFileStream nextPutAll: 'Transcript show: ''' , aPoolName , '''; cr!!'; cr.	aFileStream nextPutAll: 'Smalltalk at: #' , aPoolName , ' put: Dictionary new!!'; cr.	aPool keys asSortedCollection do: [ :aKey |		aValue _ aPool at: aKey.		aFileStream nextPutAll: aPoolName , ' at: #''' , aKey asString , '''', ' put:  '.		(aValue isKindOf: Number)			ifTrue: [aValue printOn: aFileStream]			ifFalse: [aFileStream nextPutAll: '('.					aValue printOn: aFileStream.					aFileStream nextPutAll: ')'].		aFileStream nextPutAll: '!!'; cr].	aFileStream cr! !!Class methodsFor: 'fileIn/Out' stamp: 'ar 2/13/1999 21:17'!fileOutSharedPoolsOn: aFileStream	"file out the shared pools of this class after prompting the user about each pool"	| poolsToFileOut |	poolsToFileOut _ self sharedPools select: 		[:aPool | (self shouldFileOutPool: (Smalltalk keyAtIdentityValue: aPool))].	poolsToFileOut do: [:aPool | self fileOutPool: aPool onFileStream: aFileStream].	! !!Class methodsFor: 'accessing class hierarchy' stamp: 'tk 10/17/1999 13:31'!addSubclass: aSubclass 	"Make the argument, aSubclass, be one of the subclasses of the receiver. 	Create an error notification if the argument's superclass is not the receiver."		aSubclass superclass ~~ self 		ifTrue: [^self error: aSubclass name , ' is not my subclass'].	subclasses == nil		ifTrue:	[subclasses _ Array with: aSubclass.				^self].	subclasses do:[:cl| cl == aSubclass ifTrue:[^self]]. "Already my subclass"	subclasses _ subclasses copyWith: aSubclass.! !!Class methodsFor: 'accessing class hierarchy' stamp: 'ar 7/14/1999 10:54'!removeSubclass: aSubclass 	"If the argument, aSubclass, is one of the receiver's subclasses, remove it."	subclasses == nil ifFalse:		[subclasses _  subclasses copyWithout: aSubclass.		subclasses isEmpty ifTrue: [subclasses _ nil]].! !!Class methodsFor: 'accessing class hierarchy' stamp: 'ar 7/14/1999 11:00'!subclasses	"Answer a Set containing the receiver's subclasses."	^subclasses == nil		ifTrue: [#()]		ifFalse: [subclasses copy]! !!Class methodsFor: 'accessing class hierarchy' stamp: 'jm 5/18/2003 13:40'!subclassesDo: aBlock 	"Evaluate the given block for each of the receiver's immediate subclasses."	subclasses ifNotNil: [subclasses do: aBlock].! !!Class methodsFor: 'private' stamp: 'ar 7/15/1999 15:37'!setName: aSymbol	"Private - set the name of the class"	name _ aSymbol.! !!Class methodsFor: 'organization' stamp: 'di 11/16/1999 16:25'!environment	environment == nil ifTrue: [^ super environment].	^ environment! !!Class methodsFor: 'organization' stamp: 'di 12/23/1999 11:42'!environment: anEnvironment	environment _ anEnvironment! !!Class class methodsFor: 'instance creation' stamp: 'di 1/11/2000 12:30'!template: aSystemCategoryName 	"Answer an expression that can be edited and evaluated in order to 	define a new class."	^'Object subclass: #NameOfClass	instanceVariableNames: ''instVarName1 instVarName2''	classVariableNames: ''ClassVarName1 ClassVarName2''	poolDictionaries: ''''	category: ''' , aSystemCategoryName , ''''! !!Class class methodsFor: 'instance creation' stamp: 'sw 4/27/2000 16:20'!templateForSubclassOf: priorClassName category: systemCategoryName 	"Answer an expression that can be edited and evaluated in order to define a new class, given that the class previously looked at was as given"	^ priorClassName asString, ' subclass: #NameOfSubclass	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''' , systemCategoryName asString , ''''! !Responsible for creating a new class or changing the format of an existing class (from a class definition in a browser or a fileIn). This includes validating the definition, computing the format of instances, creating or modifying the accompanying Metaclass, setting up the class and metaclass objects themselves, registering the class as a global, recompiling methods, modifying affected subclasses, mutating existing instances to the new format, and more.You typically only need to use or modify this class, or even know how it works, when making fundamental changes to how the Smalltalk system and language works.!!ClassBuilder methodsFor: 'initialize' stamp: 'ar 11/22/1999 10:09'!doneCompiling: aClass	"The receiver has finished modifying the class hierarchy.	Do any necessary cleanup."	aClass doneCompiling.! !!ClassBuilder methodsFor: 'initialize' stamp: 'ar 8/29/1999 12:32'!initialize	environ _ Smalltalk.	instVarMap _ IdentityDictionary new.! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 11/22/1999 03:21'!class: oldClass instanceVariableNames: instVarString unsafe: unsafe	"This is the basic initialization message to change the definition of	an existing Metaclass"	| instVars newClass |	environ _ oldClass environment.	instVars _ Scanner new scanFieldNames: instVarString.	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateInstvars: instVars from: oldClass forSuper: oldClass superclass) ifFalse:[^nil].		(self validateSubclassFormat: oldClass typeOfClass from: oldClass forSuper: oldClass superclass extra: instVars size) ifFalse:[^nil]].	"Create a template for the new class (will return oldClass when there is no change)"	newClass _ self 		newSubclassOf: oldClass superclass 		type: oldClass typeOfClass		instanceVariables: instVars		from: oldClass		unsafe: unsafe.	newClass == nil ifTrue:[^nil]. "Some error"	newClass _ self recompile: false from: oldClass to: newClass mutate: false.	self doneCompiling: newClass.	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 8/26/1999 12:54'!mutate: oldClass to: newClass	"Mutate oldClass to newClass.	Convert all instances of oldClass and recursively update	the subclasses."	| subs newSubclass oldSubclass |	subs _ oldClass subclasses asArray.	"Walk down"	1 to: subs size do:[:i|		oldSubclass _ subs at: i.		self showProgressFor: oldSubclass.		"Create the new class"		newSubclass _ self reshapeClass: oldSubclass to: nil super: newClass.		self mutate: oldSubclass to: newSubclass.	].	oldClass obsolete.	newClass isObsolete ifTrue:[newClass obsolete].	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 8/29/1999 15:34'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category	"Define a new class in the given environment"	^self 		name: className 		inEnvironment: env 		subclassOf: newSuper 		type: type 		instanceVariableNames: instVarString 		classVariableNames: classVarString 		poolDictionaries: poolString 		category: category		unsafe: false! !!ClassBuilder methodsFor: 'class definition' stamp: 'di 12/23/1999 15:23'!name: className inEnvironment: env subclassOf: newSuper type: type instanceVariableNames: instVarString classVariableNames: classVarString poolDictionaries: poolString category: category unsafe: unsafe	"Define a new class in the given environment.	If unsafe is true do not run any validation checks.	This facility is provided to implement important system changes."	| oldClass newClass organization instVars classVars force |	environ _ env.	instVars _ Scanner new scanFieldNames: instVarString.	classVars _ (Scanner new scanFieldNames: classVarString) collect: [:x | x asSymbol].	"Validate the proposed name"	unsafe ifFalse:[(self validateClassName: className) ifFalse:[^nil]].	oldClass _ env at: className ifAbsent:[nil].	oldClass isBehavior 		ifFalse:[oldClass _ nil]. "Already checked in #validateClassName:"	unsafe ifFalse:[		"Run validation checks so we know that we have a good chance for recompilation"		(self validateSuperclass: newSuper forSubclass: oldClass) ifFalse:[^nil].		(self validateInstvars: instVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateClassvars: classVars from: oldClass forSuper: newSuper) ifFalse:[^nil].		(self validateSubclassFormat: type from: oldClass forSuper: newSuper extra: instVars size) ifFalse:[^nil]].	"Create a template for the new class (will return oldClass when there is no change)"	newClass _ self 		newSubclassOf: newSuper 		type: type 		instanceVariables: instVars		from: oldClass		unsafe: unsafe.	newClass == nil ifTrue:[^nil]. "Some error"	newClass == oldClass ifFalse:[newClass setName: className].	"Install the class variables and pool dictionaries... "	force _ (newClass declare: classVarString) | (newClass sharing: poolString).	"... classify ..."	organization _ environ ifNotNil:[environ organization].	organization classify: newClass name under: category asSymbol.	newClass environment: environ.	"... recompile ..."	newClass _ self recompile: force from: oldClass to: newClass mutate: false.	"... export if not yet done ..."	(environ at: newClass name ifAbsent:[nil]) == newClass ifFalse:[		environ at: newClass name put: newClass.		Smalltalk flushClassNameCache.	].	"... and fix eventual references to obsolete globals."	oldClass _ nil. "So we have no references to the old class anymore"	self fixGlobalReferences.	self doneCompiling: newClass.	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 8/29/1999 15:36'!newSubclassOf: newSuper type: type instanceVariables: instVars from: oldClass unsafe: unsafe	"Create a new subclass of the given superclass.	Note: The new class may be meta."	| newFormat newClass meta |	"Compute the format of the new class"	newFormat _ 		self computeFormat: type 			instSize: instVars size 			forSuper: newSuper 			ccIndex: (oldClass ifNil:[0] ifNotNil:[oldClass indexIfCompact]).	newFormat == nil ifTrue:[^nil].	"Check if we really need a new subclass"	(oldClass ~~ nil and:[		newSuper == oldClass superclass and:[			newFormat = oldClass format and:[				instVars = oldClass instVarNames]]]) 					ifTrue:[^oldClass].	unsafe ifFalse:[		"Make sure we don't redefine any dangerous classes"		(self tooDangerousClasses includes: oldClass name) ifTrue:[			self error: oldClass name, ' cannot be changed'.			^nil].		"Check if the receiver should not be redefined"		(oldClass ~~ nil and:[oldClass shouldNotBeRedefined]) ifTrue:[			self notify: oldClass name asText allBold, 						' should not be redefined!! \Proceed to store over it.' withCRs]].	oldClass == nil ifTrue:["Requires new metaclass"		meta _ Metaclass new.		meta			superclass: (newSuper ifNil:[Class] ifNotNil:[newSuper class])			methodDictionary: MethodDictionary new			format: (newSuper ifNil:[Class format] ifNotNil:[newSuper class format]).		meta superclass addSubclass: meta. "In case of Class"		newClass _ meta new.	] ifFalse:[ newClass _ oldClass shallowCopy ].	newClass 		superclass: newSuper		methodDictionary: MethodDictionary new		format: newFormat;		setInstVarNames: instVars;		organization: (oldClass ifNotNil:[oldClass organization]).	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'jm 10/4/2002 07:06'!recompile: force from: oldClass to: aClass mutate: forceMutation	"Do the necessary recompilation after changine oldClass to newClass.	If required (e.g., when oldClass ~~ newClass) mutate oldClass to newClass	and all its subclasses. If forceMutation is true force a mutation even	if oldClass and newClass are the same."	| newClass |	newClass _ aClass.	oldClass == nil ifTrue:[		"newClass has an empty method dictionary		so we don't need to recompile"		Smalltalk changes addClass: newClass.		newClass superclass addSubclass: newClass.		^newClass].	(newClass == oldClass and:[force not and:[forceMutation not]]) ifTrue:[		"No recompilation necessary but we might have added		class vars or class pools so record the change"		Smalltalk changes changeClass: newClass from: oldClass.		^newClass].	currentClassIndex _ 0.	maxClassIndex _ oldClass withAllSubclasses size.	(oldClass == newClass and:[forceMutation not]) ifTrue:[		Smalltalk changes changeClass: newClass from: oldClass.		"Recompile from newClass without mutating"		self informUserDuring:[			newClass withAllSubclassesDo:[:cl|				self showProgressFor: cl.				cl compileAll]].		^newClass].	"Recompile and mutate oldClass to newClass"	classMap _ WeakValueDictionary new.	self informUserDuring:[		self showProgressFor: oldClass.		newClass _ self reshapeClass: oldClass to: newClass super: newClass superclass.		Smalltalk changes changeClass: newClass from: oldClass.		self mutate: oldClass to: newClass.	].	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 9/5/1999 15:23'!reshapeClass: aClass to: templateClass super: newSuper	"Reshape the given class to the new super class.	If templateClass is not nil then it defines the shape of the new class"	| fmt newClass newMeta newSuperMeta oldMeta instVars oldClass |	templateClass == nil		ifTrue:[oldClass _ aClass]		ifFalse:[oldClass _ templateClass].	aClass becomeUncompact.	"Compute the new format of the class"	instVars _ instVarMap at: aClass name ifAbsent:[oldClass instVarNames].	fmt _ self computeFormat: oldClass typeOfClass				instSize: instVars size				forSuper: newSuper				ccIndex: 0."Known to be 0 since we uncompacted aClass first"	fmt == nil ifTrue:[^nil].	aClass isMeta ifFalse:["Create a new meta class"		oldMeta _ aClass class.		newMeta _ oldMeta clone.		newSuperMeta _ newSuper ifNil:[Class] ifNotNil:[newSuper class].		newMeta 			superclass: newSuperMeta			methodDictionary: MethodDictionary new			format: (self computeFormat: oldMeta typeOfClass 							instSize: oldMeta instVarNames size 							forSuper: newSuperMeta							ccIndex: 0);			setInstVarNames: oldMeta instVarNames;			organization: oldMeta organization.		"Recompile the meta class"		oldMeta hasMethods 			ifTrue:[newMeta compileAllFrom: oldMeta].		"Fix up meta class structure"		oldMeta superclass removeSubclass: oldMeta.		newMeta superclass addSubclass: newMeta.		"And record the change so we can fix global refs later"		self recordClass: oldMeta replacedBy: newMeta.	].	newClass _ newMeta == nil		ifTrue:[oldClass clone]		ifFalse:[newMeta adoptInstance: oldClass from: oldMeta].	newClass		superclass: newSuper		methodDictionary: MethodDictionary new		format: fmt;		setInstVarNames: instVars;		organization: aClass organization.	"Recompile the new class"	aClass hasMethods 		ifTrue:[newClass compileAllFrom: aClass].	"Export the new class into the environment"	aClass isMeta ifFalse:[		"Derefence super sends in the old class"		self fixSuperSendsFrom: aClass.		"Export the class"		environ at: newClass name put: newClass.		"And use the ST association in the new class"		self fixSuperSendsTo: newClass].	"Fix up the class hierarchy"	aClass superclass removeSubclass: aClass.	newClass superclass addSubclass: newClass.	"Adopt all the instances of the old class"	aClass autoMutateInstances		ifTrue:[newClass updateInstancesFrom: aClass].	"And record the change"	self recordClass: aClass replacedBy: newClass.	^newClass! !!ClassBuilder methodsFor: 'class definition' stamp: 'ar 11/22/1999 03:20'!silentlyMoveInstVarNamed: instVarName from: srcClass to: dstClass after: prevInstVarName	"Move the instvar from srcClass to dstClass.	Do not perform any checks."	| srcVars dstVars dstIndex |	srcVars _ srcClass instVarNames copyWithout: instVarName.	srcClass == dstClass		ifTrue:[dstVars _ srcVars]		ifFalse:[dstVars _ dstClass instVarNames].	dstIndex _ dstVars indexOf: prevInstVarName.	dstVars _ (dstVars copyFrom: 1 to: dstIndex),				(Array with: instVarName),				(dstVars copyFrom: dstIndex+1 to: dstVars size).	instVarMap at: srcClass name put: srcVars.	instVarMap at: dstClass name put: dstVars.	(srcClass inheritsFrom: dstClass) ifTrue:[		self recompile: false from: dstClass to: dstClass mutate: true.	] ifFalse:[		(dstClass inheritsFrom: srcClass) ifTrue:[			self recompile: false from: srcClass to: srcClass mutate: true.		] ifFalse:[ "Disjunct hierarchies"			srcClass == dstClass ifFalse:[				self recompile: false from: dstClass to: dstClass mutate: true.			].			self recompile: false from: srcClass to: srcClass mutate: true.		].	].	self doneCompiling: srcClass.	self doneCompiling: dstClass.! !!ClassBuilder methodsFor: 'class format' stamp: 'ar 9/10/1999 12:55'!computeFormat: type instSize: newInstSize forSuper: newSuper ccIndex: ccIndex	"Compute the new format for making oldClass a subclass of newSuper.	Return the format or nil if there is any problem."	| instSize isVar isWords isPointers isWeak |	instSize _ newInstSize + (newSuper ifNil:[0] ifNotNil:[newSuper instSize]).	instSize > 254 ifTrue:[		self error: 'Class has too many instance variables (', instSize printString,')'.		^nil].	type == #compiledMethod		ifTrue:[^CompiledMethod instSpec].	type == #normal ifTrue:[isVar _ isWeak _ false. isWords _ isPointers _ true].	type == #bytes ifTrue:[isVar _ true. isWords _ isPointers _ isWeak _ false].	type == #words ifTrue:[isVar _ isWords _ true. isPointers _ isWeak _ false].	type == #variable ifTrue:[isVar _ isPointers _ isWords _ true. isWeak _ false].	type == #weak ifTrue:[isVar _ isWeak _ isWords _ isPointers _ true].	(isPointers not and:[instSize > 0]) ifTrue:[		self error:'A non-pointer class cannot have instance variables'.		^nil].	^(self format: instSize 		variable: isVar 		words: isWords 		pointers: isPointers 		weak: isWeak) + (ccIndex bitShift: 11).! !!ClassBuilder methodsFor: 'class format' stamp: 'ar 7/11/1999 06:39'!format: nInstVars variable: isVar words: isWords pointers: isPointers weak: isWeak	"Compute the format for the given instance specfication."	| cClass instSpec sizeHiBits fmt |	self flag: #instSizeChange."Smalltalk browseAllCallsOn: #instSizeChange.Smalltalk browseAllImplementorsOf: #fixedFieldsOf:.Smalltalk browseAllImplementorsOf: #instantiateClass:indexableSize:.""	NOTE: This code supports the backward-compatible extension to 8 bits of instSize.	For now the format word is...		<2 bits=instSize//64><5 bits=cClass><4 bits=instSpec><6 bits=instSize\\64><1 bit=0>	But when we revise the image format, it should become...		<5 bits=cClass><4 bits=instSpec><8 bits=instSize><1 bit=0>"	sizeHiBits _ (nInstVars+1) // 64.	cClass _ 0.  "for now"	instSpec _ isWeak		ifTrue:[4]		ifFalse:[isPointers				ifTrue: [isVar						ifTrue: [nInstVars>0 ifTrue: [3] ifFalse: [2]]						ifFalse: [nInstVars>0 ifTrue: [1] ifFalse: [0]]]				ifFalse: [isWords ifTrue: [6] ifFalse: [8]]].	fmt _ sizeHiBits.	fmt _ (fmt bitShift: 5) + cClass.	fmt _ (fmt bitShift: 4) + instSpec.	fmt _ (fmt bitShift: 6) + ((nInstVars+1)\\64).  "+1 since prim size field includes header"	fmt _ (fmt bitShift: 1). "This shift plus integer bit lets wordSize work like byteSize"	^fmt! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/20/1999 00:41'!validateClass: srcClass forMoving: iv downTo: dstClass	"Make sure that we don't have any accesses to the instVar left"	srcClass withAllSubclassesDo:[:cls|		(cls == dstClass or:[cls inheritsFrom: dstClass]) ifFalse:[			cls forgetDoIts.			(cls whichSelectorsAccess: iv) isEmpty ifFalse:[				self notify: (iv printString asText allBold), ' is still used in ', cls name asText allBold,'.Proceed to move it to Undeclared'.			].		].	].	^true! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/20/1999 00:39'!validateClass: srcClass forMoving: iv upTo: dstClass	"Make sure we don't have this instvar already"	dstClass withAllSubclassesDo:[:cls|		(cls == srcClass or:[cls inheritsFrom: srcClass]) ifFalse:[			cls isPointers ifFalse:[				self error: dstClass name, ' cannot have instance variables'.				^false].			cls instSize >= 254 ifTrue:[				self error: cls name, ' has more than 254 instance variables'.				^false].			(cls instVarNames includes: iv) ifTrue:[				self notify: (iv printString asText allBold),' is defined in ', cls name asText allBold,'Proceed to move it up to ', dstClass name asText allBold,' as well'.				instVarMap at: cls name put: (cls instVarNames copyWithout: iv)].		].	].	^true! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/13/1999 05:26'!validateClassName: aString	"Validate the new class name"	aString first isUppercase ifFalse:[		self error: 'Class names must be capitalized'.		^false].	environ at: aString ifPresent:[:old|		(old isKindOf: Behavior) ifFalse:[			self notify: aString asText allBold, 						' already exists!!\Proceed will store over it.' withCRs]].	^true! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/15/1999 13:48'!validateClassvars: classVarArray from: oldClass forSuper: newSuper	"Check if any of the classVars of oldClass conflict with the new superclass"	| usedNames classVars temp |	classVarArray isEmpty ifTrue:[^true]. "Okay"	"Validate the class var names"	usedNames _ classVarArray asSet.	usedNames size = classVarArray size 		ifFalse:[	classVarArray do:[:var|					usedNames remove: var ifAbsent:[temp _ var]].				self error: temp,' is multiply defined'. ^false].	(usedNames includesAnyOf: self reservedNames) 		ifTrue:[	self reservedNames do:[:var|					(usedNames includes: var) ifTrue:[temp _ var]].				self error: temp,' is a reserved name'. ^false].	newSuper == nil ifFalse:[		usedNames _ newSuper allClassVarNames asSet.		classVarArray do:[:iv|			(usedNames includes: iv) ifTrue:[				newSuper withAllSuperclassesDo:[:cl|					(cl classVarNames includes: iv) ifTrue:[temp _ cl]].				self error: iv, ' is already defined in ', temp name.				^false]]].	oldClass == nil ifFalse:[		usedNames _ Set new: 20.		oldClass allSubclassesDo:[:cl| usedNames addAll: cl classVarNames].		classVars _ classVarArray.		newSuper == nil ifFalse:[classVars _ classVars, newSuper allClassVarNames asArray].		classVars do:[:iv|			(usedNames includes: iv) ifTrue:[				self error: iv, ' is already defined in a subclass of ', oldClass name.				^false]]].	^true! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/15/1999 13:49'!validateInstvars: instVarArray from: oldClass forSuper: newSuper	"Check if any of the instVars of oldClass conflict with the new superclass"	| instVars usedNames temp |	instVarArray isEmpty ifTrue:[^true]. "Okay"	"Validate the inst var names"	usedNames _ instVarArray asSet.	usedNames size = instVarArray size 		ifFalse:[	instVarArray do:[:var|					usedNames remove: var ifAbsent:[temp _ var]].				self error: temp,' is multiply defined'. ^false].	(usedNames includesAnyOf: self reservedNames) 		ifTrue:[	self reservedNames do:[:var|					(usedNames includes: var) ifTrue:[temp _ var]].				self error: temp,' is a reserved name'. ^false].	newSuper == nil ifFalse:[		usedNames _ newSuper allInstVarNames asSet.		instVarArray do:[:iv|			(usedNames includes: iv) ifTrue:[				newSuper withAllSuperclassesDo:[:cl|					(cl instVarNames includes: iv) ifTrue:[temp _ cl]].				self error: iv,' is already defined in ', temp name.				^false]]].	oldClass == nil ifFalse:[		usedNames _ Set new: 20.		oldClass allSubclassesDo:[:cl| usedNames addAll: cl instVarNames].		instVars _ instVarArray.		newSuper == nil ifFalse:[instVars _ instVars, newSuper allInstVarNames].		instVars do:[:iv|			(usedNames includes: iv) ifTrue:[				self error: iv, ' is already defined in a subclass of ', oldClass name.				^false]]].	^true! !!ClassBuilder methodsFor: 'validation' stamp: 'di 11/24/1999 13:09'!validateSubclassFormat: newType from: oldClass forSuper: newSuper extra: newInstSize	"Validate the # of instVars and the format of the subclasses"	| deltaSize oldType |	oldClass == nil ifTrue: [^ true]. "No subclasses"	"Compute the # of instvars needed for all subclasses"	deltaSize _ newInstSize.	(oldClass notNil)		ifTrue: [deltaSize _ deltaSize - oldClass instVarNames size].	(newSuper notNil)		ifTrue: [deltaSize _ deltaSize + newSuper instSize].	(oldClass notNil and: [oldClass superclass notNil]) 		ifTrue: [deltaSize _ deltaSize - oldClass superclass instSize].	oldClass == nil ifTrue: [		deltaSize > 254 ifTrue: [			self error: 'More than 254 instance variables'.			^ false].		^ true].	oldClass withAllSubclassesDo: [:sub |		sub instSize + deltaSize > 254 ifTrue: [			self error: sub name,' has more than 254 instance variables'.			^ false]].	newType ~~ #normal ifTrue:		["And check if the immediate subclasses of oldClass can keep its layout"		oldClass subclassesDo:[:sub|			oldType _ sub typeOfClass.			oldType == newType ifFalse: [				self error: sub name,' cannot be recompiled'.				^ false]]].	^ true! !!ClassBuilder methodsFor: 'validation' stamp: 'ar 7/15/1999 13:50'!validateSuperclass: aSuperClass forSubclass: aClass	"Check if it is okay to use aSuperClass as the superclass of aClass"	aClass == nil ifTrue:["New class"		(aSuperClass == nil or:[aSuperClass isBehavior and:[aSuperClass isMeta not]])			ifFalse:[self error: aSuperClass name,' is not a valid superclass'.					^false].		^true].	aSuperClass == aClass superclass ifTrue:[^true]. "No change"	(aClass isMeta) "Not permitted - meta class hierarchy is derived from class hierarchy"		ifTrue:[^self error: aClass name, ' must inherit from ', aClass superclass name].	"Check for circular references"	(aSuperClass ~~ nil and:[aSuperClass == aClass or:[aSuperClass inheritsFrom: aClass]])		ifTrue:[self error: aSuperClass name,' inherits from ', aClass name.				^false].	^true! !!ClassBuilder methodsFor: 'private' stamp: 'di 12/6/1999 12:31'!fixGlobalReferences	"Fix all the references to globals which are now outdated.	Care must be taken that we do not accidentally 'fix' dangerous stuff."	| oldClasses newClasses condition |	classMap == nil ifTrue:[^self].	(self retryWithGC: [condition _ classMap anySatisfy: [:any| any notNil and:[anyisObsolete]]. any_nil. condition]		until:[:obsRef| obsRef = false])		ifFalse:[^self]. "GC cleaned up the remaining refs"	"Collect the old and the new refs"	oldClasses _ OrderedCollection new.	newClasses _ OrderedCollection new.	classMap keysAndValuesDo:[:new :old|		old == nil ifFalse:[			newClasses add: new.			oldClasses add: old]].	oldClasses isEmpty ifTrue:[^self]. "GC cleaned up the rest"	"Now fix all the known dangerous pointers to old classes by creating	copies of those still needed. Dangerous pointers should come only	from obsolete subclasses (where the superclass must be preserved)."	self fixObsoleteReferencesTo: oldClasses.	"After this has been done fix the remaining references"	progress == nil ifFalse:[progress value: 'Fixing references toglobals'].	"Forward all old refs to the new ones"	(oldClasses asArray) elementsForwardIdentityTo: (newClasses asArray).	"Done"! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/20/1999 10:45'!fixObsoleteMethodsFrom: oldClasses map: obsoleteClasses	"Fix the methods of the obsolete classes"	| nLits tempMethod |	oldClasses do:[:class|		obsoleteClasses at: class ifPresent:[:tempClass|			class selectorsAndMethodsDo:[:sel :meth|				"Create a clean copy for the temps"				tempMethod _ meth copy.				"Fix the super sends"				tempMethod sendsToSuper ifTrue:[					nLits _ tempMethod numLiterals.					"Hack the method class in the temp class"					tempMethod literalAt: nLits put: 						(Association new value: 							(obsoleteClasses at: class ifAbsent:[class])).				].				"Install in tempClass"				tempClass addSelector: sel withMethod: tempMethod.			].		].	].! !!ClassBuilder methodsFor: 'private' stamp: 'jm 5/16/2003 10:04'!fixObsoleteReferencesTo: oldClasses	"Fix all obsolete references to the given set of outdated classes."	| obsoleteClasses obj |	progress ifNotNil: [progress value: 'Fixing obsolete class references...'].	"Prepare a map of obsolete classes"	obsoleteClasses _ self mapObsoleteClassesToTemps: oldClasses.	"Sanity check for debugging"	"oldClasses size = obsoleteClasses size ifFalse:[self error:'Obsolete classes size mismatch']."	"Fix the methods"	self fixObsoleteMethodsFrom: oldClasses map: obsoleteClasses.	"Now search and fix all dangerous objects"	obj _ 0 someObject.	[0 == obj] whileFalse: [		(obj isBehavior and:[obsoleteClasses includesKey: obj superclass]) ifTrue: [			(obsoleteClasses includesKey: obj) ifFalse: [				obj superclass: (obsoleteClasses at: obj superclass)]].		obj _ obj nextObject].! !!ClassBuilder methodsFor: 'private' stamp: 'ar 8/29/1999 12:03'!fixSuperSendsFrom: oldClass	"The oldClass is about to be removed from the environment.	Fix all references to super so that the association is different from	the original ST association."	| newSuper nLits lastLiteral |	newSuper _ Association key: nil value: oldClass.	oldClass methodsDo:[:meth|		nLits _ meth numLiterals.		nLits > 0 			ifTrue:[lastLiteral _ meth literalAt: nLits]			ifFalse:[lastLiteral _ nil].		(lastLiteral class == Association and:[meth sendsToSuper]) ifTrue:[			meth literalAt: nLits put: newSuper.		].	].! !!ClassBuilder methodsFor: 'private' stamp: 'ar 8/29/1999 12:04'!fixSuperSendsTo: newClass	"The newClass has been exported into the environment.	Fix all references to super so that the association is	the original ST association."	| newSuper nLits lastLiteral |	newSuper _ Smalltalk associationAt: newClass name ifAbsent:[nil].	newSuper == nil ifTrue:[^self].	newSuper value == newClass ifTrue:[^self].	newClass methodsDo:[:meth|		nLits _ meth numLiterals.		nLits > 0 			ifTrue:[lastLiteral _ meth literalAt: nLits]			ifFalse:[lastLiteral _ nil].		(lastLiteral class == Association and:[meth sendsToSuper]) ifTrue:[			meth literalAt: nLits put: newSuper.		].	].! !!ClassBuilder methodsFor: 'private' stamp: 'ar 8/29/1999 13:03'!informUserDuring: aBlock	self class isSilent ifTrue:[^aBlock value].	Utilities informUserDuring:[:bar|		progress _ bar.		aBlock value].	progress _ nil.! !!ClassBuilder methodsFor: 'private' stamp: 'ar 8/29/1999 12:29'!mapObsoleteClassesToTemps: oldClasses	"Map the old classes to temporary classes.	These temporary classes will survive the #become:	operation and be used as the class of any instances	or subclasses of the obsolete classes."	| oldMeta tempMeta obsoleteClasses |	obsoleteClasses _ IdentityDictionary new: oldClasses size.	oldClasses do:[:oldClass| 		"Note: If a class is getting obsolete here so is its metaclass"		oldMeta _ oldClass isMeta ifTrue:[oldClass] ifFalse:[oldClass class].		tempMeta _ obsoleteClasses at: oldMeta ifAbsentPut:[oldMeta clone].		oldClass isMeta ifFalse:[			tempMeta adoptInstance: oldClass from: oldMeta.			obsoleteClasses at: oldClass put: tempMeta soleInstance.			"Note: If we haven't mutated the instances of the old class to the new			layout we must do it here."			oldClass autoMutateInstances ifFalse:[				tempMeta soleInstance updateInstancesFrom: oldClass]]].	"Fix the superclasses of the clones"	obsoleteClasses keysAndValuesDo:[:old :temp|		temp superclass: 			(obsoleteClasses 				at: temp superclass				"Might be a subclass of a live class"				ifAbsent:[temp superclass])].	"And install new method dictionaries"	obsoleteClasses valuesDo:[:temp|		temp methodDictionary: temp methodDictionary copy.	].	^obsoleteClasses! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/20/1999 00:00'!recordClass: oldClass replacedBy: newClass	"Record the replacement of oldClass by newClass so that we can	fix any references to oldClass later on."	classMap at: newClass put: oldClass.	(classMap includesKey: oldClass) ifTrue:[		"This will happen if we recompile from Class		in which case the metaclass gets recorded twice"		classMap at: newClass put: (classMap at: oldClass).		classMap removeKey: oldClass.	].	"And keep the changes up to date"	(instVarMap includesKey: oldClass name) ifTrue:[		Smalltalk changes changeClass: newClass from: oldClass.	].! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/15/1999 13:39'!reservedNames	"Return a list of names that must not be used for variables"	^#('self' 'super' 'thisContext' 'true' 'false' 'nil' 		self super thisContext true false nil).! !!ClassBuilder methodsFor: 'private' stamp: 'ar 7/15/1999 14:01'!showProgressFor: aClass	"Announce that we're processing aClass"	progress == nil ifTrue:[^self].	currentClassIndex _ currentClassIndex + 1.	aClass hasMethods ifTrue:[		progress value: ('Recompiling ', aClass name,' (', currentClassIndex printString,'/', maxClassIndex printString,')')].! !!ClassBuilder methodsFor: 'private' stamp: 'ar 8/29/1999 15:43'!tooDangerousClasses	"Return a list of class names which will not be modified in the public interface"	^#(		"Object will break immediately"		Object		"Contexts and their superclasses"		InstructionStream ContextPart BlockContext MethodContext		"Superclasses of basic collections"		Collection SequenceableCollection ArrayedCollection		"Collections known to the VM"		Array Bitmap String Symbol ByteArray CompiledMethod TranslatedMethod		"Basic Numbers"		Magnitude Number SmallInteger Float		"Misc other"		LookupKey Association Link Point Rectangle Behavior PositionableStream UndefinedObject	)! !!ClassBuilder methodsFor: 'public' stamp: 'ar 8/29/1999 15:38'!class: oldClass instanceVariableNames: instVarString	"This is the basic initialization message to change the definition of	an existing Metaclass"	oldClass isMeta ifFalse:[^self error: oldClass name, 'is not a Metaclass'].	^self class: oldClass instanceVariableNames: instVarString unsafe: false! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:40'!moveInstVarNamed: instVarName from: srcClass to: dstClass after: prevInstVarName	"Move the given instVar from srcClass to dstClass"	(srcClass instVarNames includes: instVarName)		ifFalse:[^self error: instVarName,' is not an instance variable of ', srcClass name].	(prevInstVarName isNil or:[dstClass instVarNames includes: prevInstVarName])		ifFalse:[^self error: prevInstVarName, 'is not an instance variable of', dstClass name].	(srcClass inheritsFrom: dstClass) ifTrue:[		"Move the instvar up the hierarchy."		(self validateClass: srcClass forMoving: instVarName upTo: dstClass)			ifFalse:[^false].	].	(dstClass inheritsFrom: srcClass) ifTrue:[		"Move the instvar down the hierarchy"		(self validateClass: srcClass forMoving: instVarName downTo: dstClass)			ifFalse:[^false].	].	^self silentlyMoveInstVarNamed: instVarName from: srcClass to: dstClass after: prevInstVarName! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:29'!superclass: newSuper	subclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat 	"This is the standard initialization message for creating a new class as a 	subclass of an existing class."	^self 		name: t		inEnvironment: newSuper environment		subclassOf: newSuper		type: newSuper typeOfClass		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:29'!superclass: aClass	variableByteSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable byte-sized nonpointer variables."	(aClass instSize > 0)		ifTrue: [^self error: 'cannot make a byte subclass of a class with named fields'].	(aClass isVariable and: [aClass isWords])		ifTrue: [^self error: 'cannot make a byte subclass of a class with word fields'].	(aClass isVariable and: [aClass isPointers])		ifTrue: [^self error: 'cannot make a byte subclass of a class with pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #bytes		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:29'!superclass: aClass	variableSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable pointer variables."	aClass isBits 		ifTrue: [^self error: 'cannot make a pointer subclass of a class with non-pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #variable		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:30'!superclass: aClass	variableWordSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class in which the subclass is to 	have indexable word-sized nonpointer variables."	(aClass instSize > 0)		ifTrue: [^self error: 'cannot make a word subclass of a class with named fields'].	(aClass isVariable and: [aClass isBytes])		ifTrue: [^self error: 'cannot make a word subclass of a class with byte fields'].	(aClass isVariable and: [aClass isPointers])		ifTrue: [^self error: 'cannot make a word subclass of a class with pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #words		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder methodsFor: 'public' stamp: 'ar 7/19/1999 23:30'!superclass: aClass	weakSubclass: t instanceVariableNames: f 	classVariableNames: d poolDictionaries: s category: cat	"This is the standard initialization message for creating a new class as a 	subclass of an existing class (the receiver) in which the subclass is to 	have weak indexable pointer variables."	aClass isBits 		ifTrue: [^self error: 'cannot make a pointer subclass of a class with non-pointer fields'].	^self 		name: t		inEnvironment: aClass environment		subclassOf: aClass		type: #weak		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat! !!ClassBuilder class methodsFor: 'testing' stamp: 'ar 7/15/1999 14:04'!autoMutateInstances	"Don't mutate me while I'm compiling myself"	^false! !!ClassBuilder class methodsFor: 'accessing' stamp: 'ar 7/15/1999 18:50'!beSilent: aBool	"ClassDefiner beSilent: true"	"ClassDefiner beSilent: false"	QuietMode _ aBool.! !!ClassBuilder class methodsFor: 'accessing' stamp: 'ar 7/15/1999 18:53'!beSilentDuring: aBlock	"Temporarily suppress information about what is going on"	| wasSilent result |	wasSilent _ self isSilent.	self beSilent: true.	result _ aBlock value.	self beSilent: wasSilent.	^result! !!ClassBuilder class methodsFor: 'accessing' stamp: 'ar 7/15/1999 18:48'!isSilent	^QuietMode == true! !I represent a mechanism for retrieving class descriptions stored on a file.!!ClassCategoryReader methodsFor: 'fileIn/Out' stamp: 'tk 1/27/2000 23:24'!scanFromNoCompile: aStream 	"Just move the source code for the methods from aStream."	| methodText selector |	[methodText _ aStream nextChunkText.	 methodText size > 0]		whileTrue:		[(SourceFiles at: 2) ifNotNil: [			selector _ class parserClass new parseSelector: methodText.			(class compiledMethodAt: selector) putSource: methodText 				fromParseNode: nil class: class category: category				withStamp: changeStamp inFile: 2 priorMethod: nil]]! !A ClassChangeRecorder keeps track of most substantive changes premissible in a project, isolated or not.Structure:inForce		a boolean			Tells whether these changes are in effect.			true for all changeSets in and above the current project.			It should be sufficient only to record this for the changeSet			as a whole, but this redundancy could help in error recovery.classIsLocal	a boolean			True if and only if this class is defined in this layer of the			project structure.changeTypes an identitySet			Summarizes which changes have been made in this class.			Values include #comment, #reorganize, #rename,			and the four more summarized below.thisName	a string			Retains the class name for this layer.priorName	a string			Preserves the prior name.thisComment	a text			Retains the class comment for this layer.priorComment	a text			Preserves the prior comment.thisOrganization	a classOrganizer			Retains the class organization for this layer.priorOrganization	a classOrganizer			Preserves the prior organization.thisMD	a methodDictionary			Used to prepare changes for nearly atomic invocation			of this layer (see below).priorMD	a methodDictionary			Preserves the state of an altered class as it exists in the next			outer layer of the project structure.methodChanges		a dictionary of classChangeRecords			Retains all the method changes for this layer.Four of the possible changeTypes are maintained in a mutually exclusive set, analogously to MethodChangeRecords.  Here is a simple summary of the relationship between these four changeType symbols and the recording of prior state			|	prior == nil			|	prior not nil		---------	|----------------------------	|--------------------	add		|	add					|	change	---------	|----------------------------	|--------------------	remove	|	addedThenRemoved	|	removeA classChangeRecorder is notified of changes by the method		noteMethodChange: <ClassChangeRecord>.ClassChangeRecorders are designed to invoke a set of changes relative to the definition of a class in an prior layer.  It is important that both invocation and revocation of these changes take place in a nearly atomic fashion so that interdependent changes will be adopted as a whole, and so that only one flush of the method cache should be necessary.  A further reason for revocation to be simple is that it may be requested as an attempt to recover from an error in a project that is failing.!!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 4/2/2000 21:39'!allChangeTypes	| chgs |	(priorName ~~ nil and: [changeTypes includes: #rename]) ifTrue:		[(chgs _ changeTypes copy) add: 'oldName: ' , priorName.		^ chgs].	^ changeTypes! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 4/2/2000 21:59'!assimilateAllChangesIn: otherRecord	| selector changeRecord changeType |	otherRecord isClassRemoval ifTrue: [^ self noteChangeType: #remove].	otherRecord allChangeTypes do:		[:chg | self noteChangeType: chg fromClass: self realClass].	otherRecord methodChanges associationsDo:		[:assn | selector _ assn key. changeRecord _ assn value.		changeType _ changeRecord changeType.		(changeType == #remove or: [changeType == #addedThenRemoved])			ifTrue:				[changeType == #addedThenRemoved					ifTrue: [self atSelector: selector put: #add].				self noteRemoveSelector: selector priorMethod: nil						lastMethodInfo: changeRecord methodInfoFromRemoval]			ifFalse: 				[self atSelector: selector put: changeType]].! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 3/28/2000 10:59'!hasNoChanges	^ changeTypes isEmpty and: [methodChanges isEmpty]! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 3/24/2000 09:36'!includesChangeType: changeType	changeType == #new ifTrue: [^ changeTypes includes: #add].  "Backwd compat"	^ changeTypes includes: changeType! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'di 3/28/2000 15:14'!noteChangeType: changeSymbol	^ self noteChangeType: changeSymbol fromClass: nil! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'jm 5/29/2003 19:49'!noteChangeType: changeSymbol fromClass: class	(changeSymbol = #new or: [changeSymbol = #add]) ifTrue:		[changeTypes add: #add.		changeTypes remove: #change ifAbsent: [].		^ self].	changeSymbol = #change ifTrue:		[(changeTypes includes: #add) ifTrue: [^ self].		^ changeTypes add: changeSymbol].	changeSymbol = #comment ifTrue:		[^ changeTypes add: changeSymbol].	changeSymbol = #reorganize ifTrue:		[^ changeTypes add: changeSymbol].	changeSymbol = #rename ifTrue:		[^ changeTypes add: changeSymbol].	(changeSymbol beginsWith: 'oldName: ') ifTrue:		["Must only be used when assimilating other changeSets"		(changeTypes includes: #add) ifTrue: [^ self].		priorName _ changeSymbol copyFrom: 'oldName: ' size + 1 to: changeSymbol size.		^ changeTypes add: #rename].	changeSymbol = #remove ifTrue:		[(changeTypes includes: #add)			ifTrue: [changeTypes add: #addedThenRemoved]			ifFalse: [changeTypes add: #remove].		^ changeTypes removeAll: #(add change comment reorganize)].	self error: 'Unrecognized changeType'! !!ClassChangeRecord methodsFor: 'all changes' stamp: 'jm 5/29/2003 19:49'!trimHistory	"Drop non-essential history."	"Forget methods added and later removed"	methodChanges keysAndValuesRemove:		[:sel :chgRecord | chgRecord changeType == #addedThenRemoved].	"Forget renaming and reorganization of newly-added classes."	(changeTypes includes: #add) ifTrue:		[changeTypes removeAll: #(rename reorganize)].! !!ClassChangeRecord methodsFor: 'isolation layers' stamp: 'di 3/30/2000 18:03'!realClass	"Return the actual class (or meta), as determined from my name."	thisName ifNil: [^ nil].	(thisName endsWith: ' class')		ifTrue: [^ (Smalltalk at: (thisName copyFrom: 1 to: thisName size - 6) asSymbol						ifAbsent: [^ nil]) class]		ifFalse: [^ Smalltalk at: thisName ifAbsent: [^ nil]]! !!ClassChangeRecord methodsFor: 'definition' stamp: 'di 3/27/2000 22:06'!checkCoherence	"If I recreate the class then don't remove it"	(changeTypes includes: #remove) ifTrue:		[changeTypes remove: #remove.		changeTypes add: #change].	(changeTypes includes: #addedThenRemoved) ifTrue:		[changeTypes remove: #addedThenRemoved.		changeTypes add: #add].! !!ClassChangeRecord methodsFor: 'definition' stamp: 'di 3/27/2000 22:08'!notePriorDefinition: oldClass	oldClass ifNil: [^ self].	priorDefinition ifNil: [priorDefinition _ oldClass definition]! !!ClassChangeRecord methodsFor: 'definition' stamp: 'di 3/28/2000 09:12'!priorDefinition	^ priorDefinition! !!ClassChangeRecord methodsFor: 'rename' stamp: 'di 5/8/2000 20:39'!noteNewName: newName	thisName _ newName! !!ClassChangeRecord methodsFor: 'rename' stamp: 'di 3/24/2000 09:38'!priorName	^ priorName! !!ClassChangeRecord methodsFor: 'removal' stamp: 'jm 5/29/2003 19:49'!forgetChangesIn: otherRecord	"See forgetAllChangesFoundIn:.  Used in culling changeSets."	| cls otherMethodChanges selector actionToSubtract |	(cls _ self realClass) == nil ifTrue: [^ self].  "We can do better now, though..."	otherMethodChanges _ otherRecord methodChangeTypes.	otherMethodChanges associationsDo:		[:assoc | selector _ assoc key. actionToSubtract _ assoc value.		(cls includesSelector: selector)			ifTrue: [(#(add change) includes: actionToSubtract)					ifTrue: [methodChanges removeKey: selector ifAbsent: []]]			ifFalse: [(#(remove addedThenRemoved) includes: actionToSubtract)					ifTrue: [methodChanges removeKey: selector ifAbsent: []]]].	changeTypes isEmpty ifFalse:		[changeTypes removeAll: otherRecord allChangeTypes.		(changeTypes includes: #rename) ifFalse:			[changeTypes removeAllSuchThat: [:x | x beginsWith: 'oldName: ']]]! !!ClassChangeRecord methodsFor: 'removal' stamp: 'di 4/1/2000 23:05'!isClassRemoval	"NOTE: there are other removals with changeType #addedThenRemoved,	but this message is used to write out removals in fileOut, and those	cases should not be written out."	^ (changeTypes includes: #remove) or: [changeTypes includes: #removeClass]! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/28/2000 10:38'!atSelector: selector ifAbsent: absentBlock	^ (methodChanges at: selector ifAbsent: absentBlock)		changeType! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/28/2000 11:01'!atSelector: selector put: changeType	(self findOrMakeMethodChangeAt: selector priorMethod: nil)		noteChangeType: changeType! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/28/2000 10:07'!changedSelectors	"Return a set of the changed or removed selectors."	^ methodChanges keys! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/28/2000 11:01'!findOrMakeMethodChangeAt: selector priorMethod: priorMethod	^ methodChanges at: selector		ifAbsent: [methodChanges at: selector						put: (MethodChangeRecord new priorMethod: priorMethod)]! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/29/2000 16:26'!infoFromRemoval: selector	^ (methodChanges at: selector ifAbsent: [^ nil])		methodInfoFromRemoval! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/24/2000 09:46'!methodChangeTypes	"Return an old-style dictionary of method change types."	| dict selector record |	dict _ IdentityDictionary new.	methodChanges associationsDo:		[:assn | selector _ assn key.  record _ assn value.		dict at: selector put: record changeType].	^ dict! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 4/1/2000 23:49'!methodChanges	^ methodChanges! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/28/2000 23:28'!noteNewMethod: newMethod selector: selector priorMethod: methodOrNil	| methodChange |	methodChange _ self findOrMakeMethodChangeAt: selector priorMethod: methodOrNil.	methodOrNil == nil		ifTrue: [methodChange noteChangeType: #add]		ifFalse: [methodChange noteChangeType: #change].	methodChange noteNewMethod: newMethod.! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/23/2000 23:00'!noteRemoveSelector: selector priorMethod: priorMethod lastMethodInfo: infoOrNil	| methodChange |	methodChange _ self findOrMakeMethodChangeAt: selector priorMethod: priorMethod.	methodChange changeType == #add		ifTrue: [methodChange noteChangeType: #addedThenRemoved]		ifFalse: [methodChange noteChangeType: #remove].	infoOrNil ifNotNil:		["Save the source code pointer and category so can still browse old versions"		methodChange noteMethodInfoFromRemoval: infoOrNil]! !!ClassChangeRecord methodsFor: 'method changes' stamp: 'di 3/23/2000 11:58'!removeSelector: selector	"Remove all memory of changes associated with the argument, selector, in 	this class."	methodChanges removeKey: selector ifAbsent: []! !!ClassChangeRecord methodsFor: 'initialization' stamp: 'jm 5/16/2003 08:59'!initForClassNamed: className	changeTypes _ IdentitySet new.	methodChanges _ IdentityDictionary new.	priorName _ thisName _ className.! !!ClassCommentReader methodsFor: 'as yet unclassified' stamp: 'tk 1/27/2000 22:56'!scanFromNoCompile: aStream 	"File in the class comment from aStream.  Not string-i-fied, just a text, exactly as it is in the browser.  Move to changes file."	self scanFrom: aStream.	"for comments, the same as usual"! !I add a number of facilities to basic Behaviors:	Named instance variables	Category organization for methods	The notion of a name of this class (implemented as subclass responsibility)	The maintenance of a ChangeSet, and logging changes on a file	Most of the mechanism for fileOut.	I am an abstract class, in particular, my facilities are intended for inheritance by two subclasses, Class and Metaclass.The slots 'organization' and 'methodDict' should ONLY be accessed by message in order for things to work during ImageSegment>>discoverActiveClasses (q.v.).!!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 11/22/1999 10:09'!doneCompiling	"A ClassBuilder has finished the compilation of the receiver.	This message is a notification for a class that needs to do some	cleanup / reinitialization after it has been recompiled."! !!ClassDescription methodsFor: 'initialize-release' stamp: 'ar 7/14/1999 04:41'!obsolete	"Make the receiver obsolete."	superclass removeSubclass: self.	organization _ nil.	super obsolete.! !!ClassDescription methodsFor: 'initialize-release' stamp: 'di 7/21/1999 11:05'!superclass: aClass methodDictionary: mDict format: fmt	"Basic initialization of the receiver"	super superclass: aClass methodDictionary: mDict format: fmt.	organization _ nil.	instanceVariables _ nil.! !!ClassDescription methodsFor: 'initialize-release' stamp: 'tk 10/4/1999 09:43'!updateInstances: oldInstances from: oldClass isMeta: isMeta	"Recreate any existing instances of the argument, oldClass, as instances of the receiver, which is a newly changed class. Permute variables as necessary."	"If there are any contexts having an old instance as receiver it might crash the system because the layout has changed, and the method only knows about the old layout."	| map variable instSize newInstances |	oldInstances isEmpty ifTrue:[^self]. "no instances to convert"	isMeta ifTrue: [		oldInstances size = 1 ifFalse:[^self error:'Metaclasses can only have one instance'].		self soleInstance class == self ifTrue:[			^self error:'Metaclasses can only have one instance']].	map _ self instVarMappingFrom: oldClass.	variable _ self isVariable.	instSize _ self instSize.	newInstances _ Array new: oldInstances size.	1 to: oldInstances size do:[:i|		newInstances at: i put: (			self newInstanceFrom: (oldInstances at: i) variable: variable size: instSize map: map)].	"Now perform a bulk mutation of old instances into new ones"	oldInstances elementsExchangeIdentityWith: newInstances.! !!ClassDescription methodsFor: 'initialize-release' stamp: 'jm 10/14/2002 18:36'!updateInstancesFrom: oldClass 	"Recreate any existing instances of the argument, oldClass, as instances of the receiver, which is a newly changed class. Permute variables as necessary."	"ar 7/15/1999: The updating below is possibly dangerous. If there are any	contexts having an old instance as receiver it might crash the system if	the new receiver in which the context is executed has a different layout.	See bottom below for a simple example:"	| oldInstances |	oldInstances _ oldClass allInstances asArray.	self updateInstances: oldInstances from: oldClass isMeta: false."	| crashingBlock class |	class _ Object subclass: #CrashTestDummy		instanceVariableNames: 'instVar'		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	class compile:'instVar: value instVar _ value'.	class compile:'crashingBlock ^[instVar]'.	crashingBlock _ (class new) instVar: 42; crashingBlock.	Object subclass: #CrashTestDummy		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'Crash-Test'.	crashingBlock.	crashingBlock value.	"! !!ClassDescription methodsFor: 'accessing' stamp: 'di 2/9/2000 17:54'!comment	"Answer the receiver's comment. (If missing, supply a template) "	| aString |	aString _ self theNonMetaClass organization classComment.	aString isEmpty ifFalse: [^ aString].	^'Main comment stating the purpose of this class and relevant relationship to other classes.Possible useful expressions for doIt or printIt.Structure: instVar1		type -- comment about the purpose of instVar1 instVar2		type -- comment about the purpose of instVar2Any further useful comments about the general approach of this implementation.'! !!ClassDescription methodsFor: 'accessing' stamp: 'sw 9/8/1998 14:43'!comment: aStringOrText stamp: aStamp	"Set the receiver's comment to be the argument, aStringOrText."	self theNonMetaClass classComment: aStringOrText stamp: aStamp.	Smalltalk changes commentClass: self theNonMetaClass! !!ClassDescription methodsFor: 'copying' stamp: 'di 2/17/2000 22:35'!copy: sel from: class classified: cat 	"Install the method associated with the first arugment, sel, a message 	selector, found in the method dictionary of the second argument, class, 	as one of the receiver's methods. Classify the message under the third 	argument, cat."	| code category |	"Useful when modifying an existing class"	code _ class sourceMethodAt: sel.	code == nil		ifFalse: 			[cat == nil				ifTrue: [category _ class organization categoryOfElement: sel]				ifFalse: [category _ cat].			(self methodDict includesKey: sel)				ifTrue: [code asString = (self sourceMethodAt: sel) asString 							ifFalse: [self error: self name 										, ' ' 										, sel 										, ' will be redefined if you proceed.']].			self compile: code classified: category]! !!ClassDescription methodsFor: 'copying' stamp: 'sw 6/16/1998 15:01'!copyMethodDictionaryFrom: donorClass	"Copy the method dictionary of the donor class over to the receiver"	methodDict _ donorClass copyOfMethodDictionary.	organization _ donorClass organization deepCopy! !!ClassDescription methodsFor: 'printing' stamp: 'di 12/19/1999 14:37'!sharedPoolsString	"Answer a string of my shared pool names separated by spaces."	| aStream |	aStream _ WriteStream on: (String new: 100).	self sharedPools do: [:x | aStream nextPutAll: (self environment keyAtIdentityValue: x ifAbsent: ['private']); space].	^ aStream contents! !!ClassDescription methodsFor: 'instance variables' stamp: 'RAA 8/9/1999 19:32'!browseClassVarRefs 	"1/17/96 sw: moved here from Browser so that it could be used from a variety of places."	| lines labelStream vars allVars index owningClasses |	lines _ OrderedCollection new.	allVars _ OrderedCollection new.	owningClasses _ OrderedCollection new.	labelStream _ WriteStream on: (String new: 200).	self withAllSuperclasses reverseDo:		[:class |		vars _ class classVarNames asSortedCollection.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var.			owningClasses add: class].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream contents isEmpty ifTrue: [^1 beep]. "handle nil superclass better"	labelStream skip: -1 "cut last CR".	index _ (PopUpMenu labels: labelStream contents lines: lines) startUp.	index = 0 ifTrue: [^ self].	Smalltalk browseAllCallsOn:		((owningClasses at: index) classPool associationAt: (allVars at: index))! !!ClassDescription methodsFor: 'instance variables' stamp: 'di 11/9/1998 20:21'!checkForInstVarsOK: instVarString	"Return true if instVarString does no include any names used in a subclass"	| instVarArray |	instVarArray _ Scanner new scanFieldNames: instVarString.	self allSubclasses do:		[:cl | cl instVarNames do:			[:n | (instVarArray includes: n)				ifTrue: [self error: n , ' is already used in ' , cl name.						^ false]]].	^ true! !!ClassDescription methodsFor: 'instance variables' stamp: 'jm 5/29/2003 19:04'!chooseInstVarAlphabeticallyThenDo: aBlock	"Put up a menu of all the instance variables in the receiver, presented in alphabetical order, and when the user chooses one, evaluate aBlock with the chosen variable as its parameter."	| allVars index |	allVars _ self allInstVarNames copy asArray sort.	allVars isEmpty ifTrue: [^ self inform: 'There are noinstance variables'].	index _ (PopUpMenu labelArray: allVars lines: #()) startUpWithCaption: 'Instance variables in', self name.	index = 0 ifTrue: [^ self].	aBlock value: (allVars at: index)! !!ClassDescription methodsFor: 'instance variables' stamp: 'ls 12/5/199913:40'!chooseInstVarThenDo: aBlock 	"Put up a menu of all the instance variables in the receiver, and whenthe user chooses one, evaluate aBlock with the chosen variable as itsparameter.  If the list is 6 or larger, then offer an alphabeticalformulation as an alternative. triggered by a 'show alphabetically' itemat the top of the list."	| lines labelStream vars allVars index count offerAlpha |	(count _ self allInstVarNames size) = 0 ifTrue: 		[^ self inform: 'There are noinstance variables.'].	allVars _ OrderedCollection new.	lines _ OrderedCollection new.	labelStream _ WriteStream on: (String new: 200).	(offerAlpha _ count > 5)		ifTrue:			[lines add: 1.			allVars add: 'show alphabetically'.			labelStream nextPutAll: allVars first; cr].	self withAllSuperclasses reverseDo:		[:class |		vars _ class instVarNames.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream skip: -1 "cut last CR".	(lines size > 0 and: [lines last = allVars size]) ifTrue:		[lines removeLast].  "dispense with inelegant line beneath last item"	index _ (PopUpMenu labels: labelStream contents lines: lines)startUpWithCaption: 'Instance variables in', self name.	index = 0 ifTrue: [^ self].	(index = 1 and: [offerAlpha]) ifTrue: [^ selfchooseInstVarAlphabeticallyThenDo: aBlock].	aBlock value: (allVars at: index)! !!ClassDescription methodsFor: 'instance variables' stamp: 'sw 5/27/1999 16:46'!classThatDefinesInstanceVariable: instVarName	(instanceVariables notNil and: [instanceVariables includes: instVarName asString]) ifTrue: [^ self]. 	^ superclass ifNotNil: [superclass classThatDefinesInstanceVariable: instVarName]! !!ClassDescription methodsFor: 'instance variables' stamp: 'di 9/14/1998 08:40'!renameInstVar: oldName to: newName	(self confirm: 'WARNING: Renaming of instance variablesis subject to substitution ambiguities.Do you still wish to attempt it?') ifFalse: [self halt].	"...In other words, this does a dumb text search-and-replace,	which might improperly alter, eg, a literal string.  As long as	the oldName is unique, everything should work jes' fine. - di"	^ self renameSilentlyInstVar: oldName to: newName! !!ClassDescription methodsFor: 'instance variables' stamp: 'jm 5/29/2003 19:49'!renameSilentlyInstVar: old  to: new	| i oldCode newCode parser header body sels oldName newName |	oldName _ old asString.	newName _ new asString.	(i _ instanceVariables indexOf: oldName) = 0 ifTrue:		[self error: oldName , ' is not defined in ', self name].	self allSuperclasses , self withAllSubclasses asOrderedCollection do:		[:cls | (cls instVarNames includes: newName) ifTrue:			[self error: newName , ' is already used in ', cls name]].	instanceVariables replaceFrom: i to: i with: (Array with: newName).	self withAllSubclasses do:		[:cls | sels _ cls selectors.		sels removeAll: #(DoIt DoItIn:).		sels do:			[:sel |			oldCode _ cls sourceCodeAt: sel.			"Don't make changes in the method header"			(parser _ cls parserClass new) parseSelector: oldCode.			header _ oldCode copyFrom: 1 to: (parser endOfLastToken min: oldCode size).			body _ header size > oldCode size					ifTrue: ['']					ifFalse: [oldCode copyFrom: header size+1 to: oldCode size].			newCode _ header , (body copyReplaceTokens: oldName with: newName).			newCode ~= oldCode ifTrue:				[cls compile: newCode					classified: (cls organization categoryOfElement: sel)					notifying: nil]].			cls isMeta ifFalse:				[oldCode _ cls comment.				newCode _ oldCode copyReplaceTokens: oldName with: newName.				newCode ~= oldCode ifTrue:					[cls comment: newCode]]]! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 2/17/2000 22:17'!induceMDFault	"Stache a copy of the methodDict in the organization slot (hack!!),	and set the methodDict to nil.  This will induce an MD fault on any message send.	See: ClassDescription>>recoverFromMDFault	and ImageSegment>>discoverActiveClasses."	organization _ Array with: methodDict with: organization.	methodDict _ nil.	self flushCache! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 3/27/1999 23:53'!recoverFromMDFault	(organization isMemberOf: Array) ifFalse: [^ self error: 'oops'].	methodDict _ organization first.	organization _ organization second.! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 3/23/2000 23:08'!removeSelector: selector 	| priorMethod | 	"Remove the message whose selector is given from the method 	dictionary of the receiver, if it is there. Answer nil otherwise."	(self methodDict includesKey: selector) ifFalse: [^ nil].	priorMethod _ self compiledMethodAt: selector.	Smalltalk changes removeSelector: selector class: self		priorMethod: priorMethod		lastMethodInfo: {priorMethod sourcePointer.						(self whichCategoryIncludesSelector: selector)}.	super removeSelector: selector.	self organization removeElement: selector.	self acceptsLoggingOfCompilation ifTrue:		[Smalltalk logChange: self name , ' removeSelector: #' , selector]! !!ClassDescription methodsFor: 'method dictionary' stamp: 'di 2/17/2000 22:34'!removeSelectorUnlogged: aSymbol 	"Remove the message whose selector is aSymbol from the method dictionary of the receiver, if it is there. Answer nil otherwise.  Do not log the action either to the current change set or to the changes log"	(self methodDict includesKey: aSymbol) ifFalse: [^ nil].	super removeSelector: aSymbol.	self organization removeElement: aSymbol! !!ClassDescription methodsFor: 'organization' stamp: 'di 2/17/2000 22:36'!organization	"Answer the instance of ClassOrganizer that represents the organization 	of the messages of the receiver."	organization ifNil:		[organization _ ClassOrganizer defaultList: 						self methodDict keys asSortedCollection asArray].	(organization isMemberOf: Array) ifTrue:		[self recoverFromMDFault].	^ organization! !!ClassDescription methodsFor: 'organization' stamp: 'tk 6/21/1999 12:59'!organization: aClassOrg	"Install an instance of ClassOrganizer that represents the organization of the messages of the receiver."	organization _ aClassOrg! !!ClassDescription methodsFor: 'organization' stamp: 'di 9/10/1999 10:21'!zapAllMethods	"Remove all methods in this class which is assumed to be obsolete"	methodDict _ MethodDictionary new.	self isMeta ifFalse: [self class zapAllMethods]! !!ClassDescription methodsFor: 'compiling' stamp: 'di 2/17/2000 22:34'!compile: text classified: category withStamp: changeStamp notifying: requestor 	| selector priorMethod method methodNode newText |	method _ self		compile: text asString		notifying: requestor		trailer: #(0 0 0 0)		ifFail: [^nil]		elseSetSelectorAndNode: 			[:sel :node | selector _ sel.			priorMethod _ self methodDict at: selector ifAbsent: [nil].			methodNode _ node].	self acceptsLoggingOfCompilation ifTrue:		[newText _ ((requestor == nil or: [requestor isKindOf: SyntaxError]) not						and: [Preferences confirmFirstUseOfStyle])			ifTrue: [text askIfAddStyle: priorMethod req: requestor]			ifFalse: [text].		 method putSource: newText				fromParseNode: methodNode				class: self category: category withStamp: changeStamp 				inFile: 2 priorMethod: priorMethod].	self organization classify: selector under: category.	^selector! !!ClassDescription methodsFor: 'compiling' stamp: 'jm 5/31/2003 15:50'!compile: code notifying: requestor trailer: bytes 		ifFail: failBlock		elseSetSelectorAndNode: selAndNodeBlock	"Intercept this message in order to remember system changes.	 5/15/96 sw: modified so that if the class does not wish its methods logged in the changes file, then they also won't be accumulated in the current change set.	7/12/96 sw: use wantsChangeSetLogging to determine whether to put in change set"	| methodNode selector newMethod priorMethodOrNil |	methodNode _ self compilerClass new				compile: code				in: self				notifying: requestor				ifFail: failBlock.	selector _ methodNode selector.	selAndNodeBlock value: selector value: methodNode.	methodNode encoder requestor: requestor.  "Why was this not preserved?"	newMethod _ methodNode generate: bytes.	priorMethodOrNil _ (methodDict includesKey: selector)		ifTrue: [self compiledMethodAt: selector]		ifFalse: [nil].	Smalltalk changes noteNewMethod: newMethod forClass: self		selector: selector priorMethod: priorMethodOrNil.	self addSelector: selector withMethod: newMethod.	^ newMethod! !!ClassDescription methodsFor: 'compiling' stamp: 'sw 7/1/1999 23:07'!compileProgrammatically: code classified: cat 	| oldInitials |	oldInitials _ Utilities authorInitialsPerSe.	Utilities setAuthorInitials: 'programmatic'.	self compile: code classified: cat.	Utilities setAuthorInitials: oldInitials.! !!ClassDescription methodsFor: 'compiling' stamp: 'sw 8/11/1998 14:40'!compileUnlogged: text classified: category notifying: requestor 	| selector  |	self compile: text asString		notifying: requestor		trailer: #(0 0 0 0)		ifFail: [^ nil]		elseSetSelectorAndNode: 			[:sel :node | selector _ sel].	self organization classify: selector under: category.	^ selector! !!ClassDescription methodsFor: 'compiling' stamp: 'ar 7/20/1999 11:04'!moveInstVarNamed: instVarName to: anotherClass after: prevInstVarName	"Move the given instance variable to another class."	self == anotherClass ifFalse:[		self notify:'Warning:' asText allBold,' moving ', instVarName printString,' from ', self name,' to ', anotherClass name,' will not be recorded in the change set correctly.Proceed to do it anyways.'].	^(ClassBuilder new)		moveInstVarNamed: instVarName 		from: self 		to: anotherClass 		after: prevInstVarName! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 9/8/1998 14:44'!classComment: aString	"Store the comment, aString or Text or RemoteString, associated with the class we are orgainzing.  Empty string gets stored only if had a non-empty one before."	^ self classComment: aString stamp: '<historical>'! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 3/28/2000 14:34'!classComment: aString stamp: aStamp	"Store the comment, aString or Text or RemoteString, associated with the class we are organizing.  Empty string gets stored only if had a non-empty one before."	| ptr header file oldCommentRemoteStr |	(aString isKindOf: RemoteString) ifTrue: [^ self organization classComment: aString].	oldCommentRemoteStr _ self organization commentRemoteStr.	(aString size = 0) & (oldCommentRemoteStr == nil) ifTrue: [^ organization classComment: nil].		"never had a class comment, no need to write empty string out"	ptr _ oldCommentRemoteStr ifNil: [0] ifNotNil: [oldCommentRemoteStr sourcePointer].	SourceFiles ifNotNil: [(file _ SourceFiles at: 2) ifNotNil: [		file setToEnd; cr; nextPut: $!!.	"directly"		"Should be saying (file command: 'H3') for HTML, but ignoring it here"		header _ String streamContents: [:strm | strm nextPutAll: self name;			nextPutAll: ' commentStamp: '.			aStamp storeOn: strm.			strm nextPutAll: ' prior: '; nextPutAll: ptr printString].		file nextChunkPut: header]].	Smalltalk changes commentClass: self.	aStamp size > 0 ifTrue: [self commentStamp: aStamp].	organization classComment: (RemoteString newString: aString onFileNumber: 2).! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 9/2/1998 14:22'!commentStamp: changeStamp	self organization commentStamp: changeStamp.    ^ self commentStamp: changeStamp prior: 0! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 12/19/1999 21:24'!definition	"Answer a String that defines the receiver."	| aStream path |	aStream _ WriteStream on: (String new: 300).	superclass == nil		ifTrue: [aStream nextPutAll: 'nil']		ifFalse: [path _ ''.				self environment scopeFor: superclass name from: nil						envtAndPathIfFound: [:envt :remotePath | path _ remotePath].				aStream nextPutAll: path , superclass name].	aStream nextPutAll: self kindOfSubclass.	self name storeOn: aStream.	aStream cr; tab; nextPutAll: 'instanceVariableNames: '.	aStream store: self instanceVariablesString.	aStream cr; tab; nextPutAll: 'classVariableNames: '.	aStream store: self classVariablesString.	aStream cr; tab; nextPutAll: 'poolDictionaries: '.	aStream store: self sharedPoolsString.	aStream cr; tab; nextPutAll: 'category: '.	(SystemOrganization categoryOfElement: self name) asString storeOn: aStream.	^aStream contents! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 10/15/1999 14:45'!fileOutCategory: aSymbol on: aFileStream moveSource: moveSource toFile: fileIndex 	"File a description of the receiver's category, aString, onto aFileStream. If 	moveSource, is true, then set the method source pointer to the new file position.	Note when this method is called with moveSource=true, it is condensing the	.sources file, and should only write one preamble per method category."	| selectors |	aFileStream cr.	selectors := (aSymbol asString = ClassOrganizer allCategory)				ifTrue: [ self organization allMethodSelectors ]				ifFalse: [ self organization listAtCategoryNamed: aSymbol ].	"Overridden to preserve author stamps in sources file regardless"	selectors do: [:sel |		self printMethodChunk: sel 			withPreamble: true			on: aFileStream 			moveSource: moveSource 			toFile: fileIndex].	^ self! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'ar 3/21/98 02:36'!kindOfSubclass	"Answer a string that describes what kind of subclass the receiver is, i.e.,	weak, variable, variable byte, variable word, or not variable."	self isWeak ifTrue:[^' weakSubclass: '].	self isVariable		ifTrue: [self isBits					ifTrue: [self isBytes								ifTrue: [^' variableByteSubclass: ']								ifFalse: [^' variableWordSubclass: ']]					ifFalse: [^' variableSubclass: ']]		ifFalse: [^' subclass: ']! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 11/13/1998 15:25'!methods	"Answer a ClassCategoryReader for compiling messages that are not classified, as in fileouts made with Smalltalk/V"	^ ClassCategoryReader new setClass: self category: ClassOrganizer default! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 8/15/1998 22:02'!methodsFor: categoryName stamp: changeStamp prior: indexAndOffset	"Prior source link ignored when filing in."	^ ClassCategoryReader new setClass: self				category: categoryName asSymbol				changeStamp: changeStamp"Most importantly, return the new ClassCategoryReader, so a fileIn will let it seize control.  So method will be placed in the proper category.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"!]style[(65 333 22 17)f1b,f1,f1LReadWriteStream fileIn;,f1! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 2/17/2000 22:42'!moveChangesTo: newFile 	"Used in the process of condensing changes, this message requests that 	the source code of all methods of the receiver that have been changed 	should be moved to newFile."	| changes |	self organization moveChangedCommentToFile: newFile numbered: 2.	changes _ self methodDict keys select: [:sel | (self methodDict at: sel) fileIndex > 1].	self fileOutChangedMessages: changes		on: newFile		moveSource: true		toFile: 2! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'di 4/4/1999 11:43'!printCategoryChunk: category on: aFileStream withStamp: changeStamp priorMethod: priorMethod 	"Print a method category preamble.  This must have a category name.	It may have an author/date stamp, and it may have a prior source link.	If it has a prior source link, it MUST have a stamp, even if it is empty.""The current design is that changeStamps and prior source links are preserved in the changes file.  All fileOuts include changeStamps.  Condensing sources, however, eliminates all stamps (and links, natch)."	aFileStream cr; command: 'H3'; nextPut: $!!.	aFileStream nextChunkPut: (String streamContents:		[:strm |		strm nextPutAll: self name; nextPutAll: ' methodsFor: '; print: category asString.		(changeStamp ~~ nil and:			[changeStamp size > 0 or: [priorMethod ~~ nil]]) ifTrue:			[strm nextPutAll: ' stamp: '; print: changeStamp].		priorMethod ~~ nil ifTrue:			[strm nextPutAll: ' prior: '; print: priorMethod sourcePointer]]).	aFileStream command: '/H3'.! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'RAA 5/5/2000 09:08'!printMethodChunk: selector withPreamble: doPreamble on: outStream		moveSource: moveSource toFile: fileIndex	"Copy the source code for the method associated with selector onto the fileStream.  If moveSource true, then also set the source code pointer of the method."	| preamble method oldPos newPos sourceFile endPos |	doPreamble 		ifTrue: [preamble _ self name , ' methodsFor: ' ,					(self organization categoryOfElement: selector) asString printString]		ifFalse: [preamble _ ''].	method _ self methodDict at: selector.	((method fileIndex = 0		or: [(SourceFiles at: method fileIndex) == nil])		or: [(oldPos _ method filePosition) = 0])		ifTrue:		["The source code is not accessible.  We must decompile..."		preamble size > 0 ifTrue: [outStream cr; nextPut: $!!; nextChunkPut: preamble; cr].		outStream nextChunkPut: (self decompilerClass new decompile: selector											in: self method: method) decompileString]		ifFalse:		[sourceFile _ SourceFiles at: method fileIndex.		sourceFile position: oldPos.		preamble size > 0 ifTrue:    "Copy the preamble"			[outStream copyPreamble: preamble from: sourceFile].		"Copy the method chunk"		newPos _ outStream position.		outStream copyMethodChunkFrom: sourceFile.		sourceFile skipSeparators.      "The following chunk may have ]style["		sourceFile peek == $] ifTrue: [			outStream cr; copyMethodChunkFrom: sourceFile].		moveSource ifTrue:    "Set the new method source pointer"			[endPos _ outStream position.			method checkOKToAdd: endPos - newPos at: newPos.			method setSourcePosition: newPos inFile: fileIndex]].	preamble size > 0 ifTrue: [outStream nextChunkPut: ' '].	^ outStream cr! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'sw 11/6/1999 23:08'!reformatMethodAt: selector 	| newCodeString method | 	newCodeString _ (self compilerClass new)		format: (self sourceCodeAt: selector)		in: self		notifying: nil		decorated: false.	method _ self compiledMethodAt: selector.	method		putSource: newCodeString		fromParseNode: nil		class: self		category: (self organization categoryOfElement: selector)		inFile: 2 priorMethod: method! !!ClassDescription methodsFor: 'fileIn/Out' stamp: 'tk 8/15/1998 15:26'!reorganize	"During fileIn, !!Rectangle reorganize!! allows Rectangle to seize control and treat the next chunk as its organization.  See the transfer of control where ReadWriteStream fileIn calls scanFrom:"	Smalltalk changes reorganizeClass: self.	^self organization!]style[(10 156 22 80)f1b,f1,f1LReadWriteStream fileIn;,f1! !!ClassDescription methodsFor: 'private' stamp: 'ar 7/11/1999 11:41'!instVarMappingFrom: oldClass	"Return the mapping from instVars of oldClass to new class that is used for converting old instances of oldClass."	| oldInstVarNames |	oldInstVarNames _ oldClass allInstVarNames.	^self allInstVarNames 			collect: [:instVarName | oldInstVarNames indexOf: instVarName].! !!ClassDescription methodsFor: 'private' stamp: 'di 4/3/1999 22:29'!linesOfCode  "InterpreterSimulator linesOfCode 790"	"An approximate measure of lines of code.	Includes comments, but excludes blank lines."	| lines code strm line |	lines _ 0.	self selectorsDo: [:sel |		code _ self sourceCodeAt: sel.		strm _ ReadStream on: code.		[strm atEnd] whileFalse:			[line _ strm upTo: Character cr.			line isEmpty ifFalse: [lines _ lines+1]]].	self isMeta		ifTrue: [^ lines]		ifFalse: [^ lines + self class linesOfCode]"(SystemOrganization categories select: [:c | 'Fabrik*' match: c]) detectSum:		[:c | (SystemOrganization superclassOrder: c) detectSum: [:cl | cl linesOfCode]] 24878"! !!ClassDescription methodsFor: 'private' stamp: 'ar 7/10/1999 11:17'!newInstanceFrom: oldInstance variable: variable size: instSize map: map	"Create a new instance of the receiver based on the given old instance.	The supplied map contains a mapping of the old instVar names into	the receiver's instVars"	| new |	variable		ifTrue: [new _ self basicNew: oldInstance basicSize]		ifFalse: [new _ self basicNew].	1 to: instSize do: 		[:offset |  (map at: offset) > 0 ifTrue:			[new instVarAt: offset					put: (oldInstance instVarAt: (map at: offset))]].	variable 		ifTrue: [1 to: oldInstance basicSize do: 					[:offset |					new basicAt: offset put: (oldInstance basicAt: offset)]].	^new! !!ClassDescription methodsFor: 'private' stamp: 'ar 7/15/1999 17:04'!setInstVarNames: instVarArray	"Private - for class initialization only"	| required |	required _ self instSize.	superclass notNil ifTrue:[required _ required - superclass instSize].	instVarArray size = required		ifFalse:[^self error: required printString, ' instvar names are required'].	instVarArray isEmpty		ifTrue:[instanceVariables _ nil]		ifFalse:[instanceVariables _ instVarArray asArray].! !!ClassDescription methodsFor: 'private' stamp: 'jm 11/1/1998 11:47'!spaceUsed	"Answer a rough estimate of number of bytes used by this class and its metaclass. Does not include space used by class variables."	| space method |	space _ 0.	self selectorsDo: [:sel |		space _ space + 16.  "dict and org'n space"		method _ self compiledMethodAt: sel.		space _ space + (method size + 6 "hdr + avg pad").		method literals do: [:lit |			(lit isMemberOf: Array) ifTrue: [space _ space + ((lit size + 1) * 4)].			(lit isMemberOf: Float) ifTrue: [space _ space + 12].			(lit isMemberOf: String) ifTrue: [space _ space + (lit size + 6)].			(lit isMemberOf: LargeNegativeInteger) ifTrue: [space _ space + ((lit size + 1) * 4)].			(lit isMemberOf: LargePositiveInteger) ifTrue: [space _ space + ((lit size + 1) * 4)]]].	(self isMemberOf: Metaclass)		ifTrue: [^ space]		ifFalse: [^ space + self class spaceUsed].! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'sma 6/1/2000 12:22'!allSubclasses	"Answer a Set of the receiver's and the receiver's descendent's subclasses."	| scan scanTop |	scan _ OrderedCollection withAll: self subclasses.	scanTop _ 1.	[scanTop > scan size] whileFalse:		[scan addAll: (scan at: scanTop) subclasses.		scanTop _ scanTop + 1].	^ scan asSet! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'jm 5/29/2003 19:26'!classesThatImplementAllOf: selectorSet	"Return an array of any classes that implement all the messages in selectorSet."	| found remaining |	found _ OrderedCollection new.	selectorSet do:		[:sel | (self methodDict includesKey: sel) ifTrue: [found add: sel]].	found isEmpty		ifTrue: [^ self subclasses inject: Array new						into: [:subsThatDo :sub |							subsThatDo , (sub classesThatImplementAllOf: selectorSet)]]		ifFalse: [remaining _ selectorSet select: [:sel | (found includes: sel) not].				remaining isEmpty ifTrue: [^ Array with: self].				^ self subclasses inject: Array new						into: [:subsThatDo :sub |							subsThatDo , (sub classesThatImplementAllOf: remaining)]]! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'ar 7/14/1999 10:57'!printSubclassesOn: aStream level: level 	"As part of the algorithm for printing a description of the receiver, print the	subclass on the file stream, aStream, indenting level times."	| subclassNames |	aStream crtab: level.	aStream nextPutAll: self name.	aStream space; print: self instVarNames.	self == Class		ifTrue: 			[aStream crtab: level + 1; nextPutAll: '[ ... all the Metaclasses ... ]'.			^self].	subclassNames _ self subclasses asSortedCollection:[:c1 :c2| c1 name <= c2 name].	"Print subclasses in alphabetical order"	subclassNames do:		[:subclass | subclass printSubclassesOn: aStream level: level + 1]! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'di 6/10/1999 12:05'!removeUninstantiatedSubclassesSilently	"Remove the classes of any subclasses that have neither instances nor subclasses.  Answer the number of bytes reclaimed"	"Player removeUninstantiatedSubclassesSilently"	| candidatesForRemoval  oldFree |	oldFree _ Smalltalk garbageCollect.	candidatesForRemoval _		self subclasses select: [:c |			(c instanceCount = 0) and: [c subclasses size = 0]].	candidatesForRemoval do: [:c | c removeFromSystem].	^ Smalltalk garbageCollect - oldFree! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'di 7/21/1999 11:05'!subclasses	^ Array new! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'ar 7/10/1999 08:22'!subclassesDo: aBlock	"Evaluate the argument, aBlock, for each of the receiver's immediate subclasses."	^self subclasses do: aBlock! !!ClassDescription methodsFor: 'accessing class hierarchy' stamp: 'SqR 5/25/2000 16:54'!withAllSubclasses	"Answer a Set of the receiver, the receiver's descendent's, and the 	receiver's descendent's subclasses."	^ self allSubclasses add: self; yourself! !!ClassDiffBuilder methodsFor: 'initialize'!split: aString	| lines in out c |	lines := OrderedCollection new.	in := ReadStream on: aString.	out := WriteStream on: String new.	[in atEnd] whileFalse:[		(c := in next) isSeparator ifTrue:[			out nextPut: c.			lines add: out contents.			out reset.		] ifFalse:[			out nextPut: c.		].	].	out position = 0 ifFalse:[		lines add: out contents.	].	^lines! !!ClassDiffBuilder methodsFor: 'printing'!printPatchSequence: ps on: aStream	| type line attr |	ps do:[:assoc|		type := assoc key.		line := assoc value.		attr := TextEmphasis normal.		type == #insert ifTrue:[attr := TextColor red].		type == #remove ifTrue:[attr := TextEmphasis struckOut].		aStream withAttribute: attr do:[aStream nextPutAll: line].	].! !I represent method categorization information for classes.  The handling of class comments has gone through a tortuous evolution.   Grandfathered class comments (before late aug 98) have no time stamps, and historically, fileouts of class comments always substituted the timestamp reflecting the author and date/time at the moment of fileout; and historically any timestamps in a filed out class comment were dropped on the floor, with the author & time prevailing at the moment of filein being substituted.   Such grandfathered comments now go out on fileouts with '<historical>' timestamp; class comments created after the 8/98 changes will have their correct timestamps preserved, though there is not yet a decent ui for reading those stamps other than filing out and looking at the file; nor is there yet any ui for browsing and recovering past versions of such comments.  Everything in good time!!!!ClassOrganizer methodsFor: 'accessing' stamp: 'di 12/2/1999 20:36'!changeFromCategorySpecs: categorySpecs 	"Tokens is an array of categorySpecs as scanned from a browser 'reorganize' pane, or built up by some other process, such as a scan of an environment."	| oldElements newElements newCategories newStops currentStop temp ii cc catSpec |	oldElements _ elementArray asSet.	newCategories _ Array new: categorySpecs size.	newStops _ Array new: categorySpecs size.	currentStop _ 0.	newElements _ WriteStream on: (Array new: 16).	1 to: categorySpecs size do: 		[:i | 		catSpec _ categorySpecs at: i.		newCategories at: i put: catSpec first asSymbol.		catSpec allButFirst asSortedCollection do:			[:elem |			(oldElements remove: elem ifAbsent: [nil]) notNil ifTrue:				[newElements nextPut: elem.				currentStop _ currentStop+1]].		newStops at: i put: currentStop].	"Ignore extra elements but don't lose any existing elements!!"	oldElements _ oldElements collect:		[:elem | Array with: (self categoryOfElement: elem) with: elem].	newElements _ newElements contents.	categoryArray _ newCategories.	(cc _ categoryArray asSet) size = categoryArray size ifFalse: ["has duplicate element"		temp _ categoryArray asOrderedCollection.		temp removeAll: categoryArray asSet asOrderedCollection.		temp do: [:dup | 			ii _ categoryArray indexOf: dup.			[dup _ (dup,' #2') asSymbol.  cc includes: dup] whileTrue.			cc add: dup.			categoryArray at: ii put: dup]].	categoryStops _ newStops.	elementArray _ newElements.	oldElements do: [:pair | self classify: pair last under: pair first].! !!ClassOrganizer methodsFor: 'accessing' stamp: 'di 12/2/1999 10:54'!changeFromString: aString 	"Parse the argument, aString, and make this be the receiver's structure."	| categorySpecs |	categorySpecs _ Scanner new scanTokens: aString.	"If nothing was scanned and I had no elements before, then default me"	(categorySpecs isEmpty and: [elementArray isEmpty])		ifTrue: [^ self setDefaultList: Array new].	^ self changeFromCategorySpecs: categorySpecs! !!ClassOrganizer methodsFor: 'accessing' stamp: 'di 5/4/1999 20:14'!classComment: aString 	"Store the comment, aString, associated with the object that refers to the 	receiver."	(aString isKindOf: RemoteString) 		ifTrue: [globalComment _ aString]		ifFalse: [(aString == nil or: [aString size = 0])			ifTrue: [globalComment _ nil]			ifFalse: [				self error: 'use aClass classComment:'.				globalComment _ RemoteString newString: aString onFileNumber: 2]]				"Later add priorSource and date and initials?"! !!ClassOrganizer methodsFor: 'accessing' stamp: 'sw 8/24/1998 12:29'!commentStamp	^ commentStamp! !!ClassOrganizer methodsFor: 'accessing' stamp: 'sw 8/24/1998 12:29'!commentStamp: aStamp	commentStamp _ aStamp! !!ClassOrganizer methodsFor: 'accessing' stamp: 'sw 3/23/1999 15:58'!listAtCategoryNumber: anInteger 	"Answer the array of elements stored at the position indexed by anInteger.  Answer nil if anInteger is larger than the number of categories."	| firstIndex lastIndex |	firstIndex _ 		(anInteger > 1			ifTrue: [categoryStops at: anInteger - 1]			ifFalse: [0])		+ 1.	(categoryStops size < anInteger) ifTrue:		[^ nil].  "It can happen, if Default category got aggressively removed by some automatic operation"	lastIndex _ categoryStops at: anInteger.	^elementArray copyFrom: firstIndex to: lastIndex! !!ClassOrganizer methodsFor: 'compiler access' stamp: 'sw 3/23/1999 17:04'!classify: element under: heading 	self classify: element under: heading suppressIfDefault: true! !!ClassOrganizer methodsFor: 'compiler access' stamp: 'sw 3/23/1999 17:02'!classify: element under: heading suppressIfDefault: aBoolean	"Store the argument, element, in the category named heading.   If aBoolean is true, then invoke special logic such that the classification is NOT done if the new heading is the Default and the element already had a non-Default classification -- useful for filein"	| catName catIndex elemIndex realHeading |	((heading = NullCategory) or: [heading == nil])		ifTrue: [realHeading _ Default]		ifFalse: [realHeading _ heading asSymbol].	(catName _ self categoryOfElement: element) = realHeading		ifTrue: [^ self].  "done if already under that category"	catName ~~ nil ifTrue: 		[(aBoolean and: [realHeading = Default])				ifTrue: [^ self].	  "return if non-Default category already assigned in memory"		self removeElement: element].	"remove if in another category"	(categoryArray indexOf: realHeading) = 0 ifTrue: [self addCategory: realHeading].	catIndex _ categoryArray indexOf: realHeading.	elemIndex _ 		catIndex > 1			ifTrue: [categoryStops at: catIndex - 1]			ifFalse: [0].	[(elemIndex _ elemIndex + 1) <= (categoryStops at: catIndex) 		and: [element >= (elementArray at: elemIndex)]] whileTrue.	"elemIndex is now the index for inserting the element. Do the insertion before it."	elementArray _ elementArray copyReplaceFrom: elemIndex to: elemIndex-1						with: (Array with: element).	"add one to stops for this and later categories"	catIndex to: categoryArray size do: 		[:i | categoryStops at: i put: (categoryStops at: i) + 1].	(self listAtCategoryNamed: Default) size = 0 ifTrue: [self removeCategory: Default]! !!ClassOrganizer methodsFor: 'method dictionary' stamp: 'di 3/29/2000 21:41'!allMethodSelectors	"give a list of all method selectors."	^ elementArray copy sort! !!ClassOrganizer methodsFor: 'method dictionary' stamp: 'sw 3/23/1999 17:04'!letUserReclassify: anElement	"Put up a list of categories and solicit one from the user.  Answer true if user indeed made a change, else false"	"ClassOrganizer organization letUserReclassify: #letUserReclassify:"	| currentCat newCat |	currentCat _ self categoryOfElement: anElement.	newCat _ self categoryFromUserWithPrompt: 'Choose Category (currently "', currentCat, '")'.	(newCat ~~ nil and: [newCat ~= currentCat])		ifTrue:			[self classify: anElement under: newCat suppressIfDefault: false.			^ true]		ifFalse:			[^ false]! !!ClassOrganizer methodsFor: 'method dictionary' stamp: 'sw 10/20/1999 16:24'!renameCategory: oldCatString toBe: newCatString	"Rename a category. No action if new name already exists, or if old name does not exist."	| index oldCategory newCategory |	oldCategory _ oldCatString asSymbol.	newCategory _ newCatString asSymbol.	(categoryArray indexOf: newCategory) > 0		ifTrue: [^ self].	"new name exists, so no action"	(index _ categoryArray indexOf: oldCategory) = 0		ifTrue: [^ self].	"old name not found, so no action"	categoryArray _ categoryArray copy.  "need to change identity so smart list update will notice the change"	categoryArray at: index put: newCategory! !!ClassOrganizer methodsFor: 'printing' stamp: 'di 4/26/2000 20:22'!printOn: aStream 	"Refer to the comment in Object|printOn:."	| elementIndex |	elementIndex _ 1.	1 to: categoryArray size do: 		[:i | 		aStream nextPut: $(.		(categoryArray at: i) asString printOn: aStream.		[elementIndex <= (categoryStops at: i)]			whileTrue: 				[aStream space; nextPutAll: (elementArray at: elementIndex).				elementIndex _ elementIndex + 1].		aStream nextPut: $); cr]! !!ClassOrganizer methodsFor: 'fileIn/Out' stamp: 'sw 8/24/1998 12:33'!putCommentOnFile: aFileStream numbered: sourceIndex moveSource: moveSource forClass: aClass	"Store the comment about the class onto file, aFileStream."	| header |	globalComment ifNotNil:		[aFileStream cr; nextPut: $!!.		header _ String streamContents: [:strm | 				strm nextPutAll: aClass name;				nextPutAll: ' commentStamp: '.				commentStamp ifNil: [commentStamp _ '<historical>'].				commentStamp storeOn: strm.				strm nextPutAll: ' prior: '; nextPutAll: '0'].		aFileStream nextChunkPut: header.		aClass organization fileOutCommentOn: aFileStream				moveSource: moveSource toFile: sourceIndex.		aFileStream cr]! !!ClassOrganizer methodsFor: 'private' stamp: 'sw 2/24/1999 15:26'!categoryFromUserWithPrompt: aPrompt	"SystemDictionary organization categoryFromUserWithPrompt: 'testing'"	| aMenu  |	aMenu _ CustomMenu new.	self categories do:		[:cat | aMenu add: cat asString action: cat].	^ aMenu startUpWithCaption: aPrompt! !!ClassOrganizer methodsFor: 'private' stamp: 'di 3/29/2000 21:42'!elementArray	^ elementArray! !!ClassOrganizer class methodsFor: 'class initialization' stamp: 'ccn 3/22/1999 17:43'!allCategory	"Return a symbol that represents the virtual all methods category."	^ '-- all --' asSymbol! !Used to make clickable areas which are associated with an object's mousedown, mouseup, mousemove, etc. functions, but where the size and location of the clickable area is not the same as the object it is associated with.  Used with the video viewers.!!ClickArea methodsFor: 'accessing' stamp: 'dh 8/20/2003 13:32'!object	^ object.! !!ClickArea methodsFor: 'accessing' stamp: 'dh 8/20/2003 13:32'!object: obj	object _ obj.! !!ClickArea methodsFor: 'event handling' stamp: 'dh 8/25/2003 21:34'!handlesMouseDown: evt	^ object handlesMouseDown: evt! !!ClickArea methodsFor: 'event handling' stamp: 'dh 8/20/2003 14:01'!handlesMouseOver: evt	^ object handlesMouseOver: evt! !!ClickArea methodsFor: 'event handling' stamp: 'dh 8/20/2003 13:31'!mouseDown: evt	object mouseDown: evt.! !!ClickArea methodsFor: 'event handling' stamp: 'dh 8/20/2003 13:31'!mouseEnter: evt	object mouseEnter: evt.! !!ClickArea methodsFor: 'event handling' stamp: 'dh 8/20/2003 13:31'!mouseLeave: evt	object mouseLeave: evt.! !!ClickArea methodsFor: 'event handling' stamp: 'dh 8/20/2003 13:32'!mouseMove: evt	object mouseMove: evt.! !!ClickArea methodsFor: 'event handling' stamp: 'dh 8/20/2003 13:31'!mouseUp: evt	object mouseUp: evt.! !An ancestor class for all models which can show code.  Eventually, much of the code that currently resides in StringHolder which only applies to code-holding StringHolders might get moved down here.!!CodeHolder methodsFor: 'as yet unclassified' stamp: 'jm 6/15/2003 12:35'!annotation	"Provide a line of annotation material for a middle pane."	| stamp aMessage sendersCount implementorsCount toShow aCategory separator aString aList versionsCount |	(aMessage _ self selectedMessageName)		ifNil: [^ '------'].	toShow _ ReadWriteStream on: ''.	separator _ '  '.	Preferences defaultAnnotationRequests do:		[:aRequest |		(aRequest == #timeStamp) ifTrue:			[stamp _ self timeStamp.			toShow nextPutAll: (stamp size > 0				ifTrue: [stamp, separator]				ifFalse: ['no timeStamp', separator])].		(aRequest == #messageCategory) ifTrue:			[aCategory _ self selectedClassOrMetaClass organization categoryOfElement: self selectedMessageName.			aCategory ifNotNil: "woud be nil for a method no longer present, e.g. in a recent-submissions browser"				[toShow nextPutAll: aCategory, separator]].		(aRequest == #sendersCount) ifTrue:			[sendersCount _ (Smalltalk allCallsOn: aMessage) size.			sendersCount _ sendersCount == 1				ifTrue:					['1 sender']				ifFalse:					[sendersCount printString, ' senders'].			toShow nextPutAll: sendersCount, separator].		(aRequest == #implementorsCount) ifTrue:			[implementorsCount _ (Smalltalk allImplementorsOf: aMessage) size.			implementorsCount _ implementorsCount == 1				ifTrue:					['1 implementor']				ifFalse:					[implementorsCount printString, ' implementors'].			toShow nextPutAll: implementorsCount,  separator].		(aRequest == #priorVersionsCount) ifTrue:			[versionsCount _ VersionsBrowser versionCountForSelector: self selectedMessageName class: self selectedClassOrMetaClass.			toShow nextPutAll: 				((versionsCount > 1					ifTrue:						[versionsCount == 2 ifTrue:							['1 prior version']							ifFalse:								[versionsCount printString, ' prior versions']]					ifFalse:						['no prior versions']), separator)].		(aRequest == #priorTimeStamp) ifTrue:			[stamp _ VersionsBrowser timeStampFor: self selectedMessageName class: self selectedClassOrMetaClass reverseOrdinal: 2.			stamp ifNotNil: [toShow nextPutAll: 'prior time stamp: ', stamp, separator]].		(aRequest == #recentChangeSet) ifTrue:			[aString _ ChangeSorter mostRecentChangeSetWithChangeForClass: self selectedClassOrMetaClass selector: self selectedMessageName.			aString size > 0 ifTrue: [toShow nextPutAll: aString, separator]].		(aRequest == #allChangeSets) ifTrue:			[aList _ ChangeSorter allChangeSetsWithClass: self selectedClassOrMetaClass selector: self selectedMessageName.			aList size > 0				ifTrue:					[aList size = 1						ifTrue:							[toShow nextPutAll: 'only in change set ']						ifFalse:							[toShow nextPutAll: 'in change sets: '].					aList do:						[:aChangeSet | toShow nextPutAll: aChangeSet name, ' ']]				ifFalse:					[toShow nextPutAll: 'in no change set'].			toShow nextPutAll: separator]].			^ toShow contents! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 14:14'!changeCategory	"Present a menu of the categories of messages for the current class, and let the user choose a new category for the current message"	| aClass aSelector |	(aClass _ self selectedClassOrMetaClass) ifNotNil:		[(aSelector _ self selectedMessageName) ifNotNil:			[(aClass organization letUserReclassify: aSelector) ifTrue:				["Smalltalk changes reorganizeClass: aClass."				"Decided on further review that the above, when present, could cause more                    unexpected harm than good"				self methodCategoryChanged]]]! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 14:11'!contentsChanged	self changed: #contents.	self changed: #annotation! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 17:29'!didCodeChangeElsewhere	| aClass aSelector |	"Determine whether the code for the currently selected method and class has been changed somewhere else."	currentCompiledMethod ifNil: [^ false].	(aClass _ self selectedClassOrMetaClass) ifNil: [^ false].	(aSelector _ self selectedMessageName) ifNil: [^ false].	^ (aClass compiledMethodAt: aSelector ifAbsent: [nil]) ~~ currentCompiledMethod	! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'jm 6/15/2003 11:51'!diffButton	|  outerButton aButton |	"Return a checkbox that lets the user decide whether diffs should be shown or not"	outerButton _ AlignmentMorph newRow.	outerButton centering: #center.	outerButton color:  Color transparent.	outerButton hResizing: #shrinkWrap; vResizing: #shrinkWrap.	outerButton addMorph: (aButton _ ThreePhaseButtonMorph checkBox).	aButton		target: self;		actionSelector: #toggleDiff;		getSelector: #showDiffs.	outerButton addMorphBack: (StringMorph contents: 'diffs') lock.	outerButton setBalloonText: 'If checked, then code differences from the previous version, if any, will be shown.'.	^ outerButton! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 14:04'!diffFromPriorSourceFor: sourceCode	| prior |	"If there is a prior version of source for the selected method, return a diff, else just return the source code"	^ (prior _ self priorSourceOrNil)		ifNil:			[sourceCode]		ifNotNil:			[TextDiffBuilder buildDisplayPatchFrom: prior to: sourceCode]! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 14:11'!methodCategoryChanged	self changed: #annotation! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 10/28/1999 13:48'!modelWakeUpIn: aWindow	self updateListsAndCodeIn: aWindow.	super modelWakeUpIn: aWindow! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/30/1999 12:08'!okayToAccept	self showDiffs ifFalse:		[^ true]. 	^ (SelectionMenu confirm: 'Caution!!  You are "showing diffs" here, so there is a danger that some of the text in thecode pane is contaminated by the "diff" display'	trueChoice: 'accept anyway -- I''ll take my chances' falseChoice: 'um, let me reconsider')! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 14:09'!priorSourceOrNil	"If the currently-selected method has a previous version, return its source, else return nil"	| aClass aSelector  changeRecords |	(aClass _ self selectedClassOrMetaClass) ifNil: [^ nil].	(aSelector _ self selectedMessageName) ifNil: [^ nil].	changeRecords _ aClass changeRecordsAt: aSelector.	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [^ nil].	^ (changeRecords at: 2) string ! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 3/22/2000 23:04'!selectedMessageCategoryName	"Answer the name of the message category of the message of the currently selected context."	^ self selectedClass organization categoryOfElement: self selectedMessageName! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 13:56'!showDiffs	^ showDiffs == true! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 13:56'!showDiffs: aBoolean	showDiffs _ aBoolean! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 5/5/2000 09:23'!showUnreferencedInstVars	"Search for all instance variables known to the selected class, and put up a list of those that have no references anywhere in the system.  The search includes superclasses, so that you don't need to navigate your way to the class that defines each inst variable in order to determine whether it is unreferenced"	| cls aList aReport |	(cls _ self selectedClass) ifNil: [^ self].	aList _ cls allUnreferencedInstanceVariables.	aList size == 0 ifTrue: [^ self inform: 'There are no unreferencedinstance variables in', cls name].	aReport _ String streamContents:		[:aStream |			aStream nextPutAll: 'Unreferenced instance variable(s) in ', cls name; cr.			aList do: [:el | aStream tab; nextPutAll: el; cr]].	Transcript cr; show: aReport.	(SelectionMenu labels: aList selections: aList) startUpWithCaption: 'Unreferencedinstance variables in ', cls name! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 5/8/2000 03:18'!spawnHierarchy	"Create and schedule a new class hierarchy browser on the currently selected class or meta."	| newBrowser aSymbol aBehavior messageCatIndex selectedClassOrMetaClass |	(selectedClassOrMetaClass _ self selectedClassOrMetaClass) ifNil: [^ self].	newBrowser _ HierarchyBrowser new initHierarchyForClass: selectedClassOrMetaClass.	(aSymbol _ self selectedMessageName) ifNotNil:		[aBehavior _ selectedClassOrMetaClass.		messageCatIndex _ aBehavior organization numberOfCategoryOfElement: aSymbol.		newBrowser messageCategoryListIndex: messageCatIndex + 1.		newBrowser messageListIndex:			((aBehavior organization listAtCategoryNumber: messageCatIndex)						indexOf: aSymbol)].	Browser openBrowserView: (newBrowser openSystemCatEditString: nil)		label: self selectedClassName , ' hierarchy'! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 5/8/2000 14:24'!spawnProtocol	| aClassOrMetaclass |	"Create and schedule a new protocol browser on the currently selected class or meta."	(aClassOrMetaclass _ self selectedClassOrMetaClass) ifNotNil:       	[ProtocolBrowser openSubProtocolForClass: aClassOrMetaclass]! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 08:37'!stepIn: aSystemWindow	self updateListsAndCodeIn: aSystemWindow! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 16:08'!toggleDiff	self okToChange ifTrue:		[self showDiffs: self showDiffs not.		contents _ nil.		self changed: #contents]! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 16:33'!toggleDiffing	| showing |	showing _ self showDiffs.	self toggleDiff.	showing = self showDiffs ifTrue: ["cancelled out" ^ self].	self inform: (showDiffs		ifTrue:			['Okay, diffs will be shown']		ifFalse:			['Okay, diffs will no longer be shown'])! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 17:30'!updateCodePaneIfNeeded	"If the code for the currently selected method has changed underneath me, then update the contents of my code pane unless it holds unaccepted edits"	self didCodeChangeElsewhere		ifTrue:			[self hasUnacceptedEdits				ifFalse:					[contents _ nil.					self contentsChanged]				ifTrue:					[self changed: #codeChangedElsewhere]]! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 14:14'!updateListsAndCodeIn: aWindow	super updateListsAndCodeIn: aWindow.	self updateCodePaneIfNeeded! !!CodeHolder methodsFor: 'as yet unclassified' stamp: 'sw 10/20/1999 12:22'!wantsStepsIn: aWindow	^ Preferences smartUpdating! !!CollapsedMorph methodsFor: 'as yet unclassified' stamp: 'sw 5/9/2000 00:18'!beReplacementFor: aMorph	| itsWorld priorPosition |	(itsWorld _ aMorph world) ifNil: [^self].	uncollapsedMorph _ aMorph.				self setLabel: aMorph externalName.	aMorph delete.	itsWorld addMorphFront: self.	self collapseOrExpand.	(priorPosition _ aMorph valueOfProperty: #collapsedPosition ifAbsent: [nil])	ifNotNil:		[self position: priorPosition].! !!CollapsedMorph methodsFor: 'as yet unclassified' stamp: 'bf 5/11/2000 11:41'!collapseOrExpand	isCollapsed		ifTrue: 			[uncollapsedMorph setProperty: #collapsedPosition toValue: self position.			mustNotClose _ false.	"We're not closing but expanding"			self delete.			self currentWorld addMorphFront: uncollapsedMorph]		ifFalse:			[super collapseOrExpand]! !I am the abstract superclass of all classes that represent a group of elements.!!Collection methodsFor: 'accessing' stamp: 'jm 11/9/2002 23:00'!average	"Answer the average of my elements. Assume I contain only numbers."	^ self sum asFloat / self size! !!Collection methodsFor: 'accessing' stamp: 'jm 5/29/2003 19:32'!contents	"Compatibility with streams."	^ self! !!Collection methodsFor: 'accessing' stamp: 'jm 5/29/2003 19:38'!max	"Answer the maximum element of this collection. Raise an error if the collection is empty."	^ self inject: self anyOne into: [:max :each | max max: each]! !!Collection methodsFor: 'accessing' stamp: 'jm 5/29/2003 19:38'!min	"Answer the minimum element of this collection. Raise an error if the collection is empty."	^ self inject: self anyOne into: [:min :each | min min: each]! !!Collection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:34'!size	"Answer how many elements the receiver contains."	| tally |	tally _ 0.	self do: [:each | tally _ tally + 1].	^ tally! !!Collection methodsFor: 'accessing' stamp: 'jm 5/29/2003 19:44'!sum	"Answer the sum of the elements of this collection. Answer zero if the collection is empty."	"Details: To allow collections of any kind of object that understands + and - to be summed, the inital sum is an arbitrary sample element (as opposed to 0). This initial value is then subtracted from the final sum."	| sum sample |	self size = 0 ifTrue: [^ 0].	sample _ self anyOne.	sum _ self inject: sample into: [:accum :each | accum + each].	^ sum - sample! !!Collection methodsFor: 'adding' stamp: 'sma 5/12/2000 17:26'!addAll: aCollection 	"Include all the elements of aCollection as the receiver's elements. Answer 	aCollection. Actually, any object responding to #do: can be used as argument."	aCollection do: [:each | self add: each].	^ aCollection! !!Collection methodsFor: 'comparing' stamp: 'sma 5/12/2000 12:08'!hash	"A default hash function for any collection.  Note that this method is 	insensitive to contents when the size is greater than 10, so critical 	applications that compare many large collections of the same length 	will want to refine this behavior."	| hash |	hash _ self species hash.	self size <= 10 ifTrue: [self do: [:elem | hash _ hash bitXor: elem hash]].	^ hash bitXor: self size hash! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:22'!asArray	"Answer an Array whose elements are the elements of the receiver.	Implementation note: Cannot use ''Array withAll: self'' as that only	works for SequenceableCollections which support the replacement 	primitive."	| array index |	array _ Array new: self size.	index _ 0.	self do: [:each | array at: (index _ index + 1) put: each].	^ array! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:10'!asBag	"Answer a Bag whose elements are the elements of the receiver."	^ Bag withAll: self! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:22'!asByteArray	"Answer a ByteArray whose elements are the elements of the receiver.	Implementation note: Cannot use ''ByteArray withAll: self'' as that only	works for SequenceableCollections which support the replacement 	primitive."	| array index |	array _ ByteArray new: self size.	index _ 0.	self do: [:each | array at: (index _ index + 1) put: each].	^ array! !!Collection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:43'!asOrderedCollection	"Answer an OrderedCollection whose elements are the elements of the	receiver. The order in which elements are added depends on the order	in which the receiver enumerates its elements. In the case of unordered	collections, the ordering is not necessarily the same for multiple 	requests for the conversion."	^ self as: OrderedCollection! !!Collection methodsFor: 'converting' stamp: 'sma 5/6/2000 20:29'!asSet	"Answer a Set whose elements are the unique elements of the receiver."	^ Set withAll: self! !!Collection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:44'!asSortedCollection	"Answer a SortedCollection whose elements are the elements of the 	receiver. The sort order is the default less than or equal."	^ self as: SortedCollection! !!Collection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:46'!asSortedCollection: aSortBlock 	"Answer a SortedCollection whose elements are the elements of the 	receiver. The sort order is defined by the argument, aSortBlock."	| aSortedCollection |	aSortedCollection _ SortedCollection new: self size.	aSortedCollection sortBlock: aSortBlock.	aSortedCollection addAll: self.	^ aSortedCollection! !!Collection methodsFor: 'copying' stamp: 'sma 5/12/2000 14:41'!copyWith: newElement	"Answer a new collection with newElement added (as last	element if sequenceable)."	^ self copy		add: newElement;		yourself! !!Collection methodsFor: 'copying' stamp: 'sma 5/12/2000 14:43'!copyWithout: oldElement 	"Answer a copy of the receiver that does not contain any	elements equal to oldElement."	^ self reject: [:each | each = oldElement]"Examples:	'fred the bear' copyWithout: $e	#(2 3 4 5 5 6) copyWithout: 5"! !!Collection methodsFor: 'enumerating' stamp: 'sma 4/30/2000 11:17'!anySatisfy: aBlock	"Evaluate aBlock with the elements of the receiver.	If aBlock returns true for any element return true.	Otherwise return false."	self do: [:each | (aBlock value: each) ifTrue: [^ true]].	^ false! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:45'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection _ self species new.	self do: [:each | newCollection add: (aBlock value: each)].	^ newCollection! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:20'!detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Answer the first element for which aBlock evaluates to true."	^ self detect: aBlock ifNone: [self errorNotFound: aBlock]! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:52'!detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Answer the first element for which aBlock evaluates to true. If none  	evaluate to true, then evaluate the argument, exceptionBlock."	self do: [:each | (aBlock value: each) ifTrue: [^ each]].	^ exceptionBlock value! !!Collection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:59'!select: selectBlock thenCollect: collectBlock	"Utility method to improve readability."	^ (self select: selectBlock) collect: collectBlock! !!Collection methodsFor: 'removing' stamp: 'sma 5/12/2000 11:22'!remove: oldObject 	"Remove oldObject from the receiver's elements. Answer oldObject 	unless no element is equal to oldObject, in which case, raise an error.	ArrayedCollections cannot respond to this message."	^ self remove: oldObject ifAbsent: [self errorNotFound: oldObject]! !!Collection methodsFor: 'removing' stamp: 'sma 5/12/2000 11:14'!remove: oldObject ifAbsent: anExceptionBlock 	"Remove oldObject from the receiver's elements. If several of the 	elements are equal to oldObject, only one is removed. If no element is 	equal to oldObject, answer the result of evaluating anExceptionBlock. 	Otherwise, answer the argument, oldObject. ArrayedCollections cannot 	respond to this message."	self subclassResponsibility! !!Collection methodsFor: 'removing' stamp: 'jm 5/29/2003 19:48'!removeAll: aCollection 	"Remove each element of aCollection which is present in the receiver from the receiver. Answer aCollection. No error is raised if an element isn't found. ArrayedCollections cannot respond to this message."	aCollection do: [:each | self remove: each ifAbsent: []].	^ aCollection! !!Collection methodsFor: 'removing' stamp: 'sma 5/12/2000 11:19'!removeAllSuchThat: aBlock 	"Evaluate aBlock for each element and remove all that elements from	the receiver for that aBlock evaluates to true.  Use a copy to enumerate 	collections whose order changes when an element is removed (i.e. Sets)."	self copy do: [:each | (aBlock value: each) ifTrue: [self remove: each]]! !!Collection methodsFor: 'testing' stamp: 'sma 5/12/2000 14:07'!includes: anObject 	"Answer whether anObject is one of the receiver's elements."	^ self anySatisfy: [:each | each = anObject]! !!Collection methodsFor: 'testing' stamp: 'sw 4/7/1999 17:28'!isEmptyOrNil	"Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil"	^ self size = 0! !!Collection methodsFor: 'printing' stamp: 'sma 6/1/2000 09:39'!printElementsOn: aStream	aStream nextPut: $(.	self do: [:element | aStream print: element; space].	self isEmpty ifFalse: [aStream skip: -1].	aStream nextPut: $)! !!Collection methodsFor: 'printing' stamp: 'sma 6/1/2000 09:41'!printNameOn: aStream	super printOn: aStream! !!Collection methodsFor: 'printing' stamp: 'sma 6/1/2000 09:41'!printOn: aStream 	"Append a sequence of characters that identify the receiver to aStream."	self printNameOn: aStream.	self printElementsOn: aStream! !!Collection methodsFor: 'private' stamp: 'sma 5/12/2000 11:33'!anyOne	"Answer a representative sample of the receiver. This method can	be helpful when needing to preinfer the nature of the contents of 	semi-homogeneous collections."	self emptyCheck.	self do: [:each | ^ each]! !!Collection methodsFor: 'private' stamp: 'sma 5/12/2000 11:22'!errorNotFound: anObject	"Actually, this should raise a special Exception not just an error."	self error: 'Object is not in the collection.'! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 19:58'!with: anObject 	"Answer an instance of me containing anObject."	^ self new		add: anObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:01'!with: firstObject with: secondObject 	"Answer an instance of me containing the two arguments as elements."	^ self new		add: firstObject;		add: secondObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:03'!with: firstObject with: secondObject with: thirdObject 	"Answer an instance of me containing the three arguments as elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:06'!with: firstObject with: secondObject with: thirdObject with: fourthObject 	"Answer an instance of me, containing the four arguments as the elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:06'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer an instance of me, containing the five arguments as the elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		add: fifthObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:06'!with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject	"Answer an instance of me, containing the six arguments as the elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		add: fifthObject;		add: sixthObject;		yourself! !!Collection class methodsFor: 'instance creation' stamp: 'sma 5/6/2000 20:07'!withAll: aCollection	"Create a new collection containing all the elements from aCollection."	^ (self new: aCollection size)		addAll: aCollection;		yourself! !!Collection class methodsFor: 'private' stamp: 'sma 3/3/2000 10:45'!initialize	"Set up a Random number generator to be used by atRandom when the 	user does not feel like creating his own Random generator."	RandomForPicking _ Random new! !!Collection class methodsFor: 'private' stamp: 'sma 5/12/2000 12:31'!randomForPicking	^ RandomForPicking! !This class represents abstract color, regardless of the depth of bitmap it will be shown in.  At the very last moment a Color is converted to a pixelValue that depends on the depth of the actual Bitmap inside the Form it will be used with.  The supported depths (in bits) are 1, 2, 4, 8, 16, and 32.  The number of actual colors at these depths are: 2, 4, 16, 256, 32768, and 16 million.  (See comment in BitBlt.)  To change the depth of the Display and set how many colors you can see, execute: (Display newDepth: 8).  (See comment in DisplayMedium)	Color is represented as the amount of light in red, green, and blue.  White is (1.0, 1.0, 1.0) and black is (0, 0, 0).  Pure red is (1.0, 0, 0).  These colors are "additive".  Think of Color's instance variables as:	r	amount of red, a Float between 0.0 and 1.0.	g	amount of green, a Float between 0.0 and 1.0.	b	amount of blue, a Float between 0.0 and 1.0.(But, in fact, the three are encoded as values from 0 to 1023 and combined in a single integer, rgb.  The user does not need to know this.)	Many colors are named.  You find a color by name by sending a message to class Color, for example (Color lightBlue).  Also, (Color red: 0.2 green: 0.6 blue: 1.0) or (Color r: 0.2 g: 0.6 b: 1.0) creates a color. (see below)	A color is essentially immutable.  Once you set red, green, and blue, you cannot change them.  Instead, create a new Color and use it.	Applications such as contour maps and bar graphs will want to display one of a set of shades based on a number.  Convert the range of this number to an integer from 1 to N.  Then call (Color green lightShades: N) to get an Array of colors from white to green.  Use the Array messages at:, atPin:, or atWrap: to pull out the correct color from the array.  atPin: gives the first (or last) color if the index is out of range.  atWrap: wraps around to the other end if the index is out of range.	Here are some fun things to run in when your screen has color:		Pen new mandala: 30 diameter: Display height-100.		Pen new web  "Draw with the mouse, opt-click to end"		Display fillWhite.  Pen new hilberts: 5.		Form toothpaste: 30  "Draw with mouse, opt-click to end"You might also want to try the comment in	Form>class>examples>tinyText...Messages:	mixed: proportion with: aColor	Answer this color mixed with the given color additively. The proportion, a number between 0.0 and 1.0, determines what what fraction of the receiver to use in the mix.	+ 	add two colors	- 	subtract two colors	*	multiply the values of r, g, b by a number or an Array of factors.  ((Color named: #white) * 0.3) gives a darkish gray.  (aColor * #(0 0 0.9)) gives a color with slightly less blue.	/	divide a color by a factor or an array of three factors.	errorForDepth: d     How close the nearest color at this depth is to this abstract color.  Sum of the squares of the RGB differences, square rooted and normalized to 1.0.  Multiply by 100 to get percent.	hue			Returns the hue of the color. On a wheel from 0 to 360 with pure red at 0 and again at 360.	saturation	Returns the saturation of the color.  0.0 to 1.0	brightness	Returns the brightness of the color.  0.0 to 1.0	name    Look to see if this Color has a name.	display	Show a swatch of this color tracking the cursor.	lightShades: thisMany		An array of thisMany colors from white to the receiver. 	darkShades: thisMany		An array of thisMany colors from black to the receiver.  Array is of length num.	mix: color2 shades: thisMany		An array of thisMany colors from the receiver to color2.	wheel: thisMany			An array of thisMany colors around the color wheel starting and ending at the receiver.	pixelValueForDepth: d    Returns the bits that appear be in a Bitmap of this depth for this color.  Represents the nearest available color at this depth.  Normal users do not need to know which pixelValue is used for which color. Messages to Class Color.	red: r green: g blue: b		Return a color with the given r, g, and b components.	r: g: b:		Same as above, for fast typing. 	hue: h saturation: s brightness: b		Create a color with the given hue, saturation, and brightness.	pink 	blue	red ...	Many colors have messages that return an instance of Color.	canUnderstand: #brown	  Returns true if #brown is a defined color.	names		An OrderedCollection of the names of the colors.	named: #notAllThatGray put: aColor    Add a new color to the list and create an access message and a class variable for it.	fromUser	Shows the palette of colors available at this display depth.  Click anywhere to return the color you clicked on.	hotColdShades: thisMany	An array of thisMany colors showing temperature from blue to red to white hot.    stdColorsForDepth: d        An Array of colors available at this depth.  For 16 bit and 32 bits, returns a ColorGenerator.  It responds to at: with a Color for that index, simulating a very big Array.    colorFromPixelValue: value depth: d    Returns a Color whose bit pattern (inside a Bitmap) at this depth is the number specified.  Normal users do not need to use this.(See also comments in these classes: Form, Bitmap, BitBlt, Pattern, MaskedForm.)!!Color methodsFor: 'equality' stamp: 'di 1/6/1999 20:26'!= aColor	"Return true if the receiver equals the given color. This method handles TranslucentColors, too."	aColor isColor ifFalse: [^ false].	^ aColor privateRGB = rgb and:		[aColor privateAlpha = self privateAlpha]! !!Color methodsFor: 'queries' stamp: 'di 12/30/1998 14:33'!isTranslucent	^ false! !!Color methodsFor: 'queries' stamp: 'di 1/3/1999 12:23'!isTranslucentColor	"This means: self isTranslucent, but isTransparent not"	^ false! !!Color methodsFor: 'transformations' stamp: 'jm 9/23/2003 17:24'!alpha: alphaValue	"Return a new TransparentColor with the given amount of opacity ('alpha')."	alphaValue >= 1.0 ifFalse: [		^ TranslucentColor basicNew			setRgb: rgb			alpha: (255.0 * alphaValue) asInteger].! !!Color methodsFor: 'transformations' stamp: 'jm 6/25/1998 10:12'!darker	"Answer a darker shade of this color."	^ self mixed: 0.8333 with: Color black! !!Color methodsFor: 'transformations' stamp: 'jm 6/17/1998 11:23'!lighter	"Answer a lighter shade of this color."	^ self mixed: 0.8333 with: Color white! !!Color methodsFor: 'transformations' stamp: 'ar 6/19/1999 00:36'!negated	"Return an RGB inverted color"	^Color		r: 1.0 - self red		g: 1.0 - self green		b: 1.0 - self blue! !!Color methodsFor: 'transformations' stamp: 'sw 3/6/1999 01:19'!slightlyDarker	"Answer a slightly darker shade of this color."	^ self mixed: 0.93 with: Color black! !!Color methodsFor: 'transformations' stamp: 'sw 3/6/1999 01:20'!slightlyLighter	"Answer a slightly lighter shade of this color."	^ self mixed: 0.93 with: Color white! !!Color methodsFor: 'transformations' stamp: 'dew 6/18/1999 19:24'!twiceDarker	"Answer a significantly darker shade of this color."	^ self mixed: 0.5 with: Color black! !!Color methodsFor: 'transformations' stamp: 'dew 6/18/1999 19:24'!twiceLighter	"Answer a significantly lighter shade of this color."	^ self mixed: 0.5 with: Color white! !!Color methodsFor: 'printing' stamp: 'bf 5/25/2000 16:52'!printOn: aStream	| name |	(name _ self name) ifNotNil:		[^ aStream			nextPutAll: 'Color ';			nextPutAll: name].	self storeOn: aStream.! !!Color methodsFor: 'printing' stamp: 'mir 7/21/1999 11:41'!storeArrayOn: aStream	aStream nextPutAll: '#('.	self storeArrayValuesOn: aStream.	aStream nextPutAll: ') '! !!Color methodsFor: 'printing' stamp: 'mir 7/21/1999 11:41'!storeArrayValuesOn: aStream	(self red roundTo: 0.001) storeOn: aStream.	aStream space.	(self green roundTo: 0.001) storeOn: aStream.	aStream space.	(self blue roundTo: 0.001) storeOn: aStream.! !!Color methodsFor: 'conversions' stamp: 'sw 10/27/1999 10:51'!asNontranslucentColor	^ self! !!Color methodsFor: 'conversions' stamp: 'di 3/25/2000 10:13'!balancedPatternForDepth: depth	"A generalization of bitPatternForDepth: as it exists.  Generates a 2x2 stipple of color.	The topLeft and bottomRight pixel are closest approx to this color"	| pv1 pv2 mask1 mask2 pv3 c |	(depth == cachedDepth and:[cachedBitPattern size = 2]) ifTrue: [^ cachedBitPattern].	(depth between: 4 and: 16) ifFalse: [^ self bitPatternForDepth: depth].	cachedDepth _ depth.	pv1 _ self pixelValueForDepth: depth."	Subtract error due to pv1 to get pv2.	pv2 _ (self - (err1 _ (Color colorFromPixelValue: pv1 depth: depth) - self))						pixelValueForDepth: depth.	Subtract error due to 2 pv1's and pv2 to get pv3.	pv3 _ (self - err1 - err1 - ((Color colorFromPixelValue: pv2 depth: depth) - self))						pixelValueForDepth: depth."	"Above two statements computed faster by the following..."	pv2 _ (c _ self - ((Color colorFromPixelValue: pv1 depth: depth) - self))						pixelValueForDepth: depth.	pv3 _ (c + (c - (Color colorFromPixelValue: pv2 depth: depth)))						pixelValueForDepth: depth.	"Return to a 2-word bitmap that encodes a 2x2 stipple of the given pixelValues."	mask1 _ (#(- - -				16r01010101 - - -			"replicates every other 4 bits"			16r00010001 - - - - - - -	"replicates every other 8 bits"			16r00000001) at: depth).	"replicates every other 16 bits"	mask2 _ (#(- - -				16r10101010 - - -			"replicates the other 4 bits"			16r01000100 - - - - - - -	"replicates the other 8 bits"			16r00010000) at: depth).	"replicates the other 16 bits"	^ cachedBitPattern _ Bitmap with: (mask1*pv1) + (mask2*pv2) with: (mask1*pv3) + (mask2*pv1)! !!Color methodsFor: 'conversions' stamp: 'hmm 4/25/2000 09:40'!bitPatternForDepth: depth	"Return a Bitmap, possibly containing a stipple pattern, that best represents this color at the given depth. BitBlt calls this method to convert colors into Bitmaps. The resulting Bitmap may be multiple words to represent a stipple pattern of several lines.  "	"See also:	pixelValueAtDepth:	-- value for single pixel				pixelWordAtDepth:	-- a 32-bit word filled with the pixel value"	"Details: The pattern for the most recently requested depth is cached."	"Note for depths > 2, there are stippled and non-stippled versions (generated with #balancedPatternForDepth: and #bitPatternForDepth:, respectively). The stippled versions don't work with the window bit caching of StandardSystemView, so we make sure that for these depths, only unstippled patterns are returned"	(depth == cachedDepth and: [depth <= 2 or: [cachedBitPattern size = 1]]) ifTrue: [^ cachedBitPattern].	cachedDepth _ depth.	depth > 2 ifTrue: [^ cachedBitPattern _ Bitmap with: (self pixelWordForDepth: depth)].	depth = 1 ifTrue: [^ cachedBitPattern _ self halfTonePattern1].	depth = 2 ifTrue: [^ cachedBitPattern _ self halfTonePattern2].! !!Color methodsFor: 'conversions' stamp: 'bf 10/13/1999 14:22'!makeForegroundColor        "Make a foreground color contrasting with me"        ^self luminance >= "Color red luminance" 0.299                ifTrue: [Color black]                ifFalse: [Color white]! !!Color methodsFor: 'conversions' stamp: 'jm 1/26/2001 15:11'!pixelValueForDepth: d	"Returns an integer representing the bits that appear in a single pixel of this color in a Form of the given depth. The depth must be one of 1, 2, 4, 8, 16, or 32. Contrast with pixelWordForDepth: and bitPatternForDepth:, which return either a 32-bit word packed with the given pixel value or a multiple-word Bitmap containing a pattern. The inverse is the class message colorFromPixelValue:depth:"	"Details: For depths of 8 or less, the result is a colorMap index. For depths of 16 and 32, it is a direct color value with 5 or 8 bits per color component."	"Transparency: The pixel value zero is reserved for transparent. For depths greater than 8, black maps to the darkest possible blue."	| rgbBlack val |	d = 8 ifTrue: [^ self closestPixelValue8].  "common case"	d < 8 ifTrue: [		d = 4 ifTrue: [^ self closestPixelValue4].		d = 2 ifTrue: [^ self closestPixelValue2].		d = 1 ifTrue: [^ self closestPixelValue1]].	rgbBlack _ 1.  "closest black that is not transparent in RGB"	d = 16 ifTrue: [		"five bits per component; top bits ignored"		val _ (((rgb bitShift: -15) bitAnd: 16r7C00) bitOr:			 ((rgb bitShift: -10) bitAnd: 16r03E0)) bitOr:			 ((rgb bitShift: -5) bitAnd: 16r001F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 32 ifTrue: [		"eight bits per component; top 8 bits set to all ones (opaque alpha)"		val _ LargePositiveInteger new: 4.		val at: 3 put: ((rgb bitShift: -22) bitAnd: 16rFF).		val at: 2 put: ((rgb bitShift: -12) bitAnd: 16rFF).		val at: 1 put: ((rgb bitShift: -2) bitAnd: 16rFF).		val = 0 ifTrue: [val at: 1 put: 1].  "closest non-transparent black"		val at: 4 put: 16rFF.  "opaque alpha"		^ val].	d = 12 ifTrue: [  "for indexing a color map with 4 bits per color component"		val _ (((rgb bitShift: -18) bitAnd: 16r0F00) bitOr:			 ((rgb bitShift: -12) bitAnd: 16r00F0)) bitOr:			 ((rgb bitShift: -6) bitAnd: 16r000F).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	d = 9 ifTrue: [  "for indexing a color map with 3 bits per color component"		val _ (((rgb bitShift: -21) bitAnd: 16r01C0) bitOr:			 ((rgb bitShift: -14) bitAnd: 16r0038)) bitOr:			 ((rgb bitShift: -7) bitAnd: 16r0007).		^ val = 0 ifTrue: [rgbBlack] ifFalse: [val]].	self error: 'unknown pixel depth: ', d printString! !!Color methodsFor: 'conversions' stamp: 'di 11/30/1998 09:03'!pixelWordFor: depth filledWith: pixelValue	"Return to a 32-bit word that concatenates enough copies of the given pixel value to fill the word (i.e., 32/depth copies). Depth should be one of 1, 2, 4, 8, 16, or 32. The pixel value should be an integer in 0..2^depth-1."	| halfword |	depth = 32 ifTrue: [^ pixelValue].	depth = 16		ifTrue: [halfword _ pixelValue]		ifFalse: [halfword _ pixelValue * 					(#(16rFFFF				"replicates at every bit"						16r5555 -			"replicates every 2 bits"						16r1111 - - -			"replicates every 4 bits"						16r0101) at: depth)	"replicates every 8 bits"].	^ halfword bitOr: (halfword bitShift: 16)! !!Color methodsFor: 'conversions' stamp: 'ar 1/14/1999 15:28'!scaledPixelValue32	"Return the alpha scaled pixel value for depth 32"	^self pixelWordForDepth: 32! !!Color methodsFor: 'private'!privateGreen	"Private!! Return the internal representation of my green component.	Replaced >> by bitShift: 0 -. SqR!! 2/25/1999 23:08"	^ (rgb bitShift: 0 - GreenShift) bitAnd: ComponentMask! !!Color methodsFor: 'private' stamp: 'jm 9/23/2003 17:17'!setRgb: rgbValue	"Initialize this color."	rgb == nil ifFalse: [self attemptToMutateError].	rgb _ rgbValue.! !!Color class methodsFor: 'instance creation' stamp: 'sw 11/9/1998 19:25'!colorFrom: parm	"Return an instantiated color from parm.  If parm is already a color, return it, else return the result of my performing it if it's a symbol, else just return the thing"	(parm isKindOf: Color) ifTrue: [^ parm].	(parm isKindOf: Symbol) ifTrue: [^ self perform: parm].	^ parm! !!Color class methodsFor: 'instance creation' stamp: 'ar 6/29/1999 16:08'!colorFromPixelValue: p depth: d	"Convert a pixel value for the given display depth into a color."	"Details: For depths of 8 or less, the pixel value is simply looked up in a table. For greater depths, the color components are extracted and converted into a color."	| r g b alpha |	d = 8 ifTrue: [^ IndexedColors at: (p bitAnd: 16rFF) + 1].	d = 4 ifTrue: [^ IndexedColors at: (p bitAnd: 16r0F) + 1].	d = 2 ifTrue: [^ IndexedColors at: (p bitAnd: 16r03) + 1].	d = 1 ifTrue: [^ IndexedColors at: (p bitAnd: 16r01) + 1].	(d = 16) | (d = 15) ifTrue: [		"five bits per component"		r _ (p bitShift: -10) bitAnd: 16r1F.		g _ (p bitShift: -5) bitAnd: 16r1F.		b _ p bitAnd: 16r1F.		^ Color r: r g: g b: b range: 31].	d = 32 ifTrue: [		"eight bits per component; 8 bits of alpha"		r _ (p bitShift: -16) bitAnd: 16rFF.		g _ (p bitShift: -8) bitAnd: 16rFF.		b _ p bitAnd: 16rFF.		alpha _ p bitShift: -24.		alpha = 0 ifTrue:[^Color transparent].		alpha < 255			ifTrue: [^ (Color r: r g: g b: b range: 255) alpha: (alpha asFloat / 255.0)]			ifFalse: [^ (Color r: r g: g b: b range: 255)]].	d = 12 ifTrue: [		"four bits per component"		r _ (p bitShift: -8) bitAnd: 16rF.		g _ (p bitShift: -4) bitAnd: 16rF.		b _ p bitAnd: 16rF.		^ Color r: r g: g b: b range: 15].	d = 9 ifTrue: [		"three bits per component"		r _ (p bitShift: -6) bitAnd: 16r7.		g _ (p bitShift: -3) bitAnd: 16r7.		b _ p bitAnd: 16r7.		^ Color r: r g: g b: b range: 7].	self error: 'unknown pixel depth: ', d printString! !!Color class methodsFor: 'instance creation' stamp: 'mir 7/21/1999 11:54'!fromArray: colorDef	colorDef size == 3			ifTrue: [^self r: (colorDef at: 1) g: (colorDef at: 2) b: (colorDef at: 3)].	colorDef size == 0			ifTrue: [^Color transparent].	colorDef size == 4			ifTrue: [^(TranslucentColor r: (colorDef at: 1) g: (colorDef at: 2) b: (colorDef at: 3)) alpha: (colorDef at: 4)].	self error: 'Undefined color definition'! !!Color class methodsFor: 'instance creation' stamp: 'dvf 6/16/2000 17:48'!fromString: aString	"for HTML color spec: #FFCCAA or white/black"	"Color fromString: '#FFCCAA'.	 Color fromString: 'white'.	 Color fromString: 'orange'"	| aColorHex red green blue |	aString isEmptyOrNil ifTrue: [^ Color white].	aString first = $#		ifTrue: [aColorHex _ aString copyFrom: 2 to: aString size]		ifFalse: [aColorHex _ aString].	[aColorHex size = 6		ifTrue:			[aColorHex _ aColorHex asUppercase.			red _ ('16r', (aColorHex copyFrom: 1 to: 2)) asNumber/255.			green _ ('16r', (aColorHex copyFrom: 3 to: 4)) asNumber/255.			blue _ ('16r', (aColorHex copyFrom: 5 to: 6)) asNumber/255.			^ self r: red g: green b: blue]]	ifError: [:err :rcvr | "not a hex color triplet" ].		"try to match aColorHex with known named colors"	aColorHex _ aColorHex asLowercase.	^self perform: (ColorNames detect: [:i | i asString asLowercase = aColorHex]		ifNone: [#white])! !!Color class methodsFor: 'class initialization' stamp: 'dwh 7/7/1999 23:57'!initializeNames	"Name some colors."	"Color initializeNames"	ColorNames _ OrderedCollection new.	self named: #black put: (Color r: 0 g: 0 b: 0).	self named: #veryVeryDarkGray put: (Color r: 0.125 g: 0.125 b: 0.125).	self named: #veryDarkGray put: (Color r: 0.25 g: 0.25 b: 0.25).	self named: #darkGray put: (Color r: 0.375 g: 0.375 b: 0.375).	self named: #gray put: (Color r: 0.5 g: 0.5 b: 0.5).	self named: #lightGray put: (Color r: 0.625 g: 0.625 b: 0.625).	self named: #veryLightGray put: (Color r: 0.75 g: 0.75 b: 0.75).	self named: #veryVeryLightGray put: (Color r: 0.875 g: 0.875 b: 0.875).	self named: #white put: (Color r: 1.0 g: 1.0 b: 1.0).	self named: #red put: (Color r: 1.0 g: 0 b: 0).	self named: #yellow put: (Color r: 1.0 g: 1.0 b: 0).	self named: #green put: (Color r: 0 g: 1.0 b: 0).	self named: #cyan put: (Color r: 0 g: 1.0 b: 1.0).	self named: #blue put: (Color r: 0 g: 0 b: 1.0).	self named: #magenta put: (Color r: 1.0 g: 0 b: 1.0).	self named: #brown put: (Color r: 0.6 g: 0.2 b: 0).	self named: #orange put: (Color r: 1.0 g: 0.6 b: 0).	self named: #lightRed put: (Color r: 1.0 g: 0.8 b: 0.8).	self named: #lightYellow put: (Color r: 1.0 g: 1.0 b: 0.8).	self named: #lightGreen put: (Color r: 0.8 g: 1.0 b: 0.6).	self named: #lightCyan put: (Color r: 0.4 g: 1.0 b: 1.0).	self named: #lightBlue put: (Color r: 0.8 g: 1.0 b: 1.0).	self named: #lightMagenta put: (Color r: 1.0 g: 0.8 b: 1.0).	self named: #lightBrown put: (Color r: 1.0 g: 0.6 b: 0.2).	self named: #lightOrange put: (Color r: 1.0 g: 0.8 b: 0.4).	self named: #transparent put: (TranslucentColor new alpha: 0.0).	self named: #paleBuff put: (Color r: 254 g: 250 b: 235 range: 255).	self named: #paleBlue put: (Color r: 222 g: 249 b: 254 range: 255).	self named: #paleYellow put: (Color r: 255 g: 255 b: 217 range: 255).	self named: #paleGreen put: (Color r: 223 g: 255 b: 213 range: 255).	self named: #paleRed put: (Color r: 255 g: 230 b: 230 range: 255).	self named: #veryPaleRed put: (Color r: 255 g: 242 b: 242 range: 255).	self named: #paleTan put: (Color r: 235 g: 224 b: 199 range: 255).	self named: #paleMagenta put: (Color r: 255 g: 230 b: 255 range: 255).	self named: #paleOrange put: (Color r: 253 g: 237 b: 215 range: 255).	self named: #palePeach put: (Color r: 255 g: 237 b: 213 range: 255).! !!Color class methodsFor: 'class initialization' stamp: 'ar 2/16/2000 21:56'!initializeTranslucentPatterns	"Color initializeTranslucentPatterns"	| mask bits pattern patternList |	TranslucentPatterns _ Array new: 8.	#(1 2 4 8) do:[:d|		patternList _ Array new: 5.		mask _ (1 bitShift: d) - 1.		bits _ 2 * d.		[bits >= 32] whileFalse: [			mask _ mask bitOr: (mask bitShift: bits).  "double the length of mask"			bits _ bits + bits].		"0% pattern"		pattern _ Bitmap with: 0 with: 0.		patternList at: 1 put: pattern.		"25% pattern"		pattern _ Bitmap with: mask with: 0.		patternList at: 2 put: pattern.		"50% pattern"		pattern _ Bitmap with: mask with: mask bitInvert32.		patternList at: 3 put: pattern.		"75% pattern"		pattern _ Bitmap with: mask with: 16rFFFFFFFF.		patternList at: 4 put: pattern.		"100% pattern"		pattern _ Bitmap with: 16rFFFFFFFF with: 16rFFFFFFFF.		patternList at: 5 put: pattern.		TranslucentPatterns at: d put: patternList.	].! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!paleBlue	^PaleBlue! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!paleBuff	^PaleBuff! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!paleGreen	^PaleGreen! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!paleMagenta	^PaleMagenta! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!paleOrange	^PaleOrange! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!palePeach	^PalePeach! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!paleRed	^PaleRed! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!paleTan	^PaleTan! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!paleYellow	^PaleYellow! !!Color class methodsFor: 'named colors' stamp: 'wod 5/24/1998 01:56'!tan	^  Color r: 0.8 g: 0.8 b: 0.5! !!Color class methodsFor: 'named colors' stamp: 'dwh 7/7/1999 23:56'!veryPaleRed	^VeryPaleRed! !!Color class methodsFor: 'colormaps' stamp: 'jm 5/2/1999 07:24'!cachedColormapFrom: sourceDepth to: destDepth	"Return a cached colormap for mapping between the given depths. Always return a real colormap, not nil; this allows the client to get an identity colormap that can then be copied and modified to do color transformations."	"Note: This method returns a shared, cached colormap to save time and space. Clients that need to modify a colormap returned by this method should make a copy and modify that!!"	"Note: The colormap cache may be cleared by evaluating 'Color shutDown'."	| srcIndex map |	CachedColormaps class == Array ifFalse: [CachedColormaps _ (1 to: 9) collect: [:i | Array new: 32]].	srcIndex _ sourceDepth.	sourceDepth > 8 ifTrue: [srcIndex _ 9].	(map _ (CachedColormaps at: srcIndex) at: destDepth) ~~ nil ifTrue: [^ map].	map _ self computeColormapFrom: sourceDepth to: destDepth.	(CachedColormaps at: srcIndex) at: destDepth put: map.	^ map! !!Color class methodsFor: 'colormaps' stamp: 'jm 3/25/1999 19:48'!computeColormapFrom: sourceDepth to: destDepth	"Compute a colorMap for translating between the given depths. A colormap is a Bitmap whose entries contain the pixel values for the destination depth. Typical clients use cachedColormapFrom:to: instead."	| map bitsPerColor |	sourceDepth < 16 ifTrue: [		"source is 1-, 2-, 4-, or 8-bit indexed color"		map _ (IndexedColors copyFrom: 1 to: (1 bitShift: sourceDepth))					collect: [:c | c pixelValueForDepth: destDepth].		map _ map as: Bitmap.	] ifFalse: [		"source is 16-bit or 32-bit RGB"		destDepth > 8			ifTrue: [bitsPerColor _ 5]  "retain maximum color resolution"			ifFalse: [bitsPerColor _ 4].		map _ self computeRGBColormapFor: destDepth bitsPerColor: bitsPerColor].	"Note: zero is transparent except when source depth is one-bit deep"	sourceDepth > 1 ifTrue: [map at: 1 put: 0].	^ map! !!Color class methodsFor: 'other' stamp: 'di 3/29/1999 13:33'!maskingMap: depth	"Return a color map that maps all colors except transparent to words of all ones. Used to create a mask for a Form whose transparent pixel value is zero. Cache the most recently used map."	| sizeNeeded |	depth <= 8		ifTrue: [sizeNeeded _ 1 bitShift: depth]		ifFalse: [sizeNeeded _ 4096].	(MaskingMap == nil or: [MaskingMap size ~= sizeNeeded]) ifTrue:		[MaskingMap _ Bitmap new: sizeNeeded withAll: 16rFFFFFFFF.		MaskingMap at: 1 put: 0.  "transparent"].	^ MaskingMap! !!Color class methodsFor: 'other' stamp: 'jm 1/1/2004 11:07'!shutDown	"Clear caches to save space in snapshots."	"Color shutDown"	ColorChart _ nil.		"Palette of colors for the user to pick from"	CachedColormaps _ nil.	"Maps to translate between color depths"	MaskingMap _ nil.		"Maps all colors except transparent to black for creating a mask"! !!Color class methodsFor: 'other' stamp: 'ar 2/16/2000 21:56'!translucentMaskFor: alphaValue depth: d	"Return a pattern representing a mask usable for stipple transparency"	^(TranslucentPatterns at: d) at: ((alphaValue min: 1.0 max: 0.0) * 4) rounded + 1! !!Color class methodsFor: 'color from user' stamp: 'jm 1/19/1999 11:33'!colorTest: depth extent: chartExtent colorMapper: colorMapper	"Create a palette of colors sorted horizontally by hue and vertically by lightness. Useful for eyeballing the color gamut of the display, or for choosing a color interactively."	"Note: It is slow to build this palette, so it should be cached for quick access."	"(Color colorTest: 32 extent: 570@180 colorMapper: [:c | c]) display"	"(Color colorTest: 32 extent: 570@180 colorMapper:		[:c | Color			r: (c red * 7) asInteger / 7			g: (c green * 7) asInteger / 7			b: (c blue * 3) asInteger / 3]) display"	"(Color colorTest: 32 extent: 570@180 colorMapper:		[:c | Color			r: (c red * 5) asInteger / 5			g: (c green * 5) asInteger / 5			b: (c blue * 5) asInteger / 5]) display"	"(Color colorTest: 32 extent: 570@180 colorMapper:		[:c | Color			r: (c red * 15) asInteger / 15			g: (c green * 15) asInteger / 15			b: (c blue * 15) asInteger / 15]) display"	"(Color colorTest: 32 extent: 570@180 colorMapper:		[:c | Color			r: (c red * 31) asInteger / 31			g: (c green * 31) asInteger / 31			b: (c blue * 31) asInteger / 31]) display"	| basicHue x y c startHue palette transHt vSteps transCaption grayWidth hSteps |	palette _ Form extent: chartExtent depth: depth.	transCaption _ "(DisplayText text: 'no color' asText textStyle: (TextConstants at: #ComicPlain)) form storeString"		(Form extent: 34@9 depth: 1			fromArray: #(0 0 256 0 256 0 3808663859 2147483648 2491688266 2147483648 2491688266 0 2491688266 0 2466486578 0 0 0)			offset: 0@0).	transHt _ transCaption height.	palette fillWhite: (0@0 extent: palette width@transHt).	palette fillBlack: (0@transHt extent: palette width@1).	transCaption displayOn: palette at: palette boundingBox topCenter - ((transCaption width // 2)@0).	grayWidth _ 10.	startHue _ 338.0.	vSteps _ palette height - transHt // 2.	hSteps _ palette width - grayWidth.	x _ 0.	startHue to: startHue + 360.0 by: 360.0/hSteps do: [:h |		basicHue _ Color h: h asFloat s: 1.0 v: 1.0.		y _ transHt+1.		0 to: vSteps do: [:n | 			c _ basicHue mixed: (n asFloat / vSteps asFloat) with: Color white.			c _ colorMapper value: c.			palette fill: (x@y extent: 1@1) fillColor: c.			y _ y + 1].		1 to: vSteps do: [:n | 			c _ Color black mixed: (n asFloat / vSteps asFloat) with: basicHue.			c _ colorMapper value: c.			palette fill: (x@y extent: 1@1) fillColor: c.			y _ y + 1].		x _ x + 1].	y _ transHt + 1.	1 to: vSteps * 2 do: [:n | 		c _ Color black mixed: (n asFloat / (vSteps*2) asFloat) with: Color white.		c _ colorMapper value: c.		palette fill: (x@y extent: 10@1) fillColor: c.		y _ y + 1].	^ palette! !!Color class methodsFor: 'color from user' stamp: 'di 4/13/1999 14:30'!fromUser	"Displays a color palette of colors, waits for a mouse click, and returns the selected color. Any pixel on the Display can be chosen, not just those in the color palette."	"Note: Since the color chart is cached, you may need to do 'ColorChart _ nil' after changing the oldColorPaletteForDepth:extent: method."	"Color fromUser"	| d startPt save tr oldColor c here s |	d _ Display depth.	((ColorChart == nil) or: [ColorChart depth ~= Display depth]) 		ifTrue: [ColorChart _ self oldColorPaletteForDepth: d extent: (2 * 144)@80].	Sensor cursorPoint y < Display center y 		ifTrue: [startPt _ 0@(Display boundingBox bottom - ColorChart height)]		ifFalse: [startPt _ 0@0].	save _ Form fromDisplay: (startPt extent: ColorChart extent).	ColorChart displayAt: startPt.	tr _ ColorChart extent - (50@19) corner: ColorChart extent.	tr _ tr translateBy: startPt.	oldColor _ nil.	[Sensor anyButtonPressed] whileFalse: [		c _ Display colorAt: (here _ Sensor cursorPoint).		(tr containsPoint: here)			ifFalse: [Display fill: (0@61+startPt extent: 20@19) fillColor: c]			ifTrue: [				c _ Color transparent.				Display fill: (0@61+startPt extent: 20@19) fillColor: Color white].		c = oldColor ifFalse: [			Display fillWhite: (20@61 + startPt extent: 135@19).			c isTransparent				ifTrue: [s _ 'transparent']				ifFalse: [s _ c shortPrintString.						s _ s copyFrom: 7 to: s size - 1].			s displayAt: 20@61 + startPt.			oldColor _ c]].	save displayAt: startPt.	Sensor waitNoButton.	^ c! !!Color class methodsFor: 'color from user' stamp: 'di 4/13/1999 14:28'!oldColorPaletteForDepth: depth extent: paletteExtent	"Returns a form of the given size showing a color palette for the given depth."	"(Color oldColorPaletteForDepth: Display depth extent: 720@100) display"	| c p f nSteps rect w h q |	f _ Form extent: paletteExtent depth: depth.	f fill: f boundingBox fillColor: Color white.	nSteps _ depth > 8 ifTrue: [12] ifFalse: [6].	w _ paletteExtent x // (nSteps * nSteps).	h _ paletteExtent y - 20 // nSteps.	0 to: nSteps-1 do: [:r |		0 to: nSteps-1 do: [:g |			0 to: nSteps-1 do: [:b |				c _ Color r: r g: g b: b range: nSteps - 1.				rect _ ((r * nSteps * w) + (b * w)) @ (g * h) extent: w@(h + 1).				f fill: rect fillColor: c]]].	q _ Quadrangle origin: paletteExtent - (50@19) corner: paletteExtent.	q displayOn: f.	'Trans.' displayOn: f at: q origin + (9@1).	w _ ((paletteExtent x - q width - 130) // 64) max: 1.	p _ paletteExtent x - q width - (64 * w) - 1 @ (paletteExtent y - 19).	0 to: 63 do:		[:v | c _ Color r: v g: v b: v range: 63.		f fill: ((v * w)@0 + p extent: (w + 1)@19) fillColor: c].	^ f! !I represent a color argument for a command block. Clicking on me allows the user to change my color value.!!ColorArgMorph methodsFor: 'initialization' stamp: 'jm 12/8/2002 12:29'!initialize	super initialize.	self borderInset.	self borderWidth: 2.	self extent: 17@17.! !!ColorArgMorph methodsFor: 'event handling' stamp: 'jm 4/29/2003 16:29'!handlesMouseDown: evt	^ true! !!ColorArgMorph methodsFor: 'event handling' stamp: 'jm 12/7/2002 16:20'!mouseUp: evt	evt hand		changeColorTarget: self		selector: #color:		originalColor: self color.! !!ColorArgMorph methodsFor: 'evaluation' stamp: 'DaveF 7/11/2003 18:37'!evaluate	"Answer my color."	^ color! !!ColorForm methodsFor: 'accessing' stamp: 'mir 7/21/1999 11:51'!colorsFromArray: colorArray	| colorList |	colorList _ colorArray collect: [:colorDef |		Color fromArray: colorDef].	self colors: colorList! !!ColorForm methodsFor: 'pixel accessing' stamp: 'jm 5/29/2003 17:57'!pixelValueAt: aPoint 	"Return the raw pixel value at the given point. Typical clients use colorAt: to get a Color."	"Details: To get the raw pixel value, be sure the peeker's colorMap is nil."	^ (BitBlt bitPeekerFromForm: self) colorMap: nil; pixelAt: aPoint! !!ColorForm methodsFor: 'color manipulation' stamp: 'di 11/11/1998 13:20'!asGrayScale	"Return a grayscale ColorForm computed by mapping each color into its grayscale equivalent"	^ self copy colors:		(colors collect:			[:c | c isTransparent ifTrue: [c]						ifFalse: [Color gray: c luminance]])! !!ColorForm methodsFor: 'color manipulation' stamp: 'ar 5/25/2000 19:51'!colormapIfNeededForDepth: destDepth	"Return a colormap for displaying the receiver at the given depth, or nil if no colormap is needed."	| newMap |	colors == nil ifTrue: [		"use the standard colormap"		^ Color colorMapIfNeededFrom: depth to: destDepth].	(destDepth = cachedDepth and:[cachedColormap isColormap not]) 		ifTrue: [^ cachedColormap].	newMap _ Bitmap new: colors size.	1 to: colors size do: [:i |		newMap			at: i			put: ((colors at: i) pixelValueForDepth: destDepth)].	cachedDepth _ destDepth.	^ cachedColormap _ newMap.! !!ColorForm methodsFor: 'color manipulation' stamp: 'di 8/28/1998 15:48'!indexOfColor: aColor	"Return the index of aColor in my color array"	self ensureColorArrayExists.	^ colors indexOf: aColor ifAbsent: [0]! !!ColorForm methodsFor: 'color manipulation' stamp: 'jm 10/19/1998 10:52'!mapColor: oldColor to: newColor	"Replace all occurances of the given color with the given new color in my color map."	self ensureColorArrayExists.	1 to: colors size do: [:i | 		(colors at: i) = oldColor ifTrue: [colors at: i put: newColor]].	self clearColormapCache.! !!ColorForm methodsFor: 'color manipulation' stamp: 'jm 5/29/2003 17:57'!twoToneFromDisplay: aRectangle backgroundColor: bgColor	"Copy one-bit deep ColorForm from the Display using a color map that maps all colors except the background color to black. Used for caching the contents of inactive MVC windows."	| map |	(width = aRectangle width and: [height = aRectangle height])		ifFalse: [self setExtent: aRectangle extent depth: depth].	"make a color map mapping the background color	 to zero and all other colors to one"	map _ Bitmap new: (1 bitShift: (Display depth min: 9)).	1 to: map size do: [:i | map at: i put: 16rFFFFFFFF].	map at: (bgColor indexInMap: map) put: 0.	(BitBlt toForm: self)		destOrigin: 0@0;		sourceForm: Display;		sourceRect: aRectangle;		combinationRule: Form over;		colorMap: map;		copyBits.! !!ColorForm methodsFor: 'copying' stamp: 'jm 5/29/2003 17:57'!copy: aRect 	"Return a new ColorForm containing the portion of the receiver delineated by aRect."	| newForm |	newForm _ self class extent: aRect extent depth: depth.	((BitBlt		destForm: newForm		sourceForm: self		fillColor: nil		combinationRule: Form over		destOrigin: 0@0		sourceOrigin: aRect origin		extent: aRect extent		clipRect: newForm boundingBox)		colorMap: nil) copyBits.	colors ifNotNil: [newForm colors: colors copy].	^ newForm! !!ColorForm methodsFor: 'private' stamp: 'jm 9/24/2003 12:27'!privateColors	^ colors! !!ColorForm methodsFor: 'private' stamp: 'jm 9/24/2003 12:43'!privateColors: anObject	colors _ anObject.	cachedDepth _ nil.	cachedColormap _ nil.! !!ColorForm methodsFor: 'private' stamp: 'jm 4/5/1999 10:11'!setColors: colorArray cachedColormap: aBitmap depth: anInteger	"Semi-private. Set the color array, cached colormap, and cached colormap depth to avoid having to recompute the colormap when switching color palettes in animations."	colors _ colorArray.	cachedDepth _ anInteger.	cachedColormap _ aBitmap.! !!ColorForm methodsFor: 'scaling, rotation' stamp: 'ar 3/15/1999 14:28'!flipBy: direction centerAt: aPoint	| oldColors newForm |	oldColors _ colors.	self colors: nil.	newForm _ super flipBy: direction centerAt: aPoint.	self colors: oldColors.	newForm colors: oldColors.	^newForm ! !!ColorForm methodsFor: 'fileIn/Out' stamp: 'jm 7/23/1999 20:42'!hibernate	"Make myself take up less space. See comment in Form>hibernate."	super hibernate.	self clearColormapCache.! !!ColorForm methodsFor: 'fileIn/Out' stamp: 'bf 5/25/2000 16:31'!storeOn: aStream	aStream nextPut: $(.	super storeOn: aStream.	aStream		cr; tab;		nextPutAll: 'colorsFromArray: #('.	self colors do: [:color |		color storeArrayOn: aStream].	aStream nextPutAll: ' ))'.! !!ColorForm methodsFor: 'postscript generation' stamp: 'jm 10/14/2003 18:33'!asFormWithSingleTransparentColor	| pixelCounts transparentIndices newF |	pixelCounts _ self tallyPixelValues.	transparentIndices _		(1 to: colors size) select: [:i |			(colors at: i) isTransparent and: [(pixelCounts at: i) > 0]].	transparentIndices size < 2 ifTrue: [^ self].	newF _ self deepCopy.	newF mapColors: transparentIndices to: transparentIndices first.	^ newF! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:54'!alphaMask	^masks at: 4! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:55'!alphaMask: value	masks at: 4 put: value! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:31'!alphaShift	^shifts at: 4! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:31'!alphaShift: value	shifts at: 4 put: value! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:39'!at: index	^colors at: index! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:39'!at: index put: value	^colors at: index put: value! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:31'!blueMask	^masks at: 3! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:31'!blueMask: value	masks at: 3 put: value! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:31'!blueShift	^shifts at: 3! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:32'!blueShift: value	shifts at: 3 put: value! !!ColorMap methodsFor: 'accessing' stamp: 'ar 2/10/2000 17:12'!colors	^colors! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:32'!greenMask	^masks at: 2! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:32'!greenMask: value	masks at: 2 put: value! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:32'!greenShift	^shifts at: 2! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:36'!greenShift: value	shifts at: 2 put: value.! !!ColorMap methodsFor: 'accessing' stamp: 'ar 5/27/2000 19:16'!masks	^masks! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:36'!redMask	^masks at: 1! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:37'!redMask: value	masks at: 1 put: value! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:37'!redShift	^shifts at: 1! !!ColorMap methodsFor: 'accessing' stamp: 'ar 1/16/2000 15:37'!redShift: value	shifts at: 1 put: value! !!ColorMap methodsFor: 'accessing' stamp: 'ar 5/27/2000 20:48'!rgbaBitMasks	"Return the rgba bit masks for the receiver"	^masks asArray with: shifts collect:[:m :s| m bitShift: s]! !!ColorMap methodsFor: 'accessing' stamp: 'ar 5/27/2000 19:16'!shifts	^shifts! !!ColorMap methodsFor: 'pixel mapping' stamp: 'ar 1/16/2000 20:52'!mapPixel: pixelValue	"Perform a forward pixel mapping operation"	| pv |	(shifts == nil and:[masks == nil]) ifFalse:[		pv _ (((pixelValue bitAnd: self redMask) bitShift: self redShift) bitOr:			((pixelValue bitAnd: self greenMask) bitShift: self greenShift)) bitOr:			(((pixelValue bitAnd: self blueMask) bitShift: self blueShift) bitOr:			((pixelValue bitAnd: self alphaMask) bitShift: self alphaShift)).	] ifTrue:[pv _ pixelValue].	colors == nil		ifTrue:[^pv]		ifFalse:[^colors at: pv].! !!ColorMap methodsFor: 'pixel mapping' stamp: 'ar 1/16/2000 20:52'!pixelMap: pixelValue	"Perform a reverse pixel mapping operation"	| pv |	colors == nil		ifTrue:[pv _ pixelValue]		ifFalse:[pv _ colors at: pixelValue].	(shifts == nil and:[masks == nil]) 		ifTrue:[^pv]		ifFalse:[^(((pv bitAnd: self redMask) bitShift: self redShift) bitOr: 				((pv bitAnd: self greenMask) bitShift: self greenShift)) bitOr:					(((pv bitAnd: self blueMask) bitShift: self blueShift) bitOr: 						((pv bitAnd: self alphaMask) bitShift: self alphaShift))]! !!ColorMap methodsFor: 'private' stamp: 'ar 2/22/2000 16:47'!setShifts: shiftArray masks: maskArray colors: colorArray	shiftArray ifNotNil:[shifts _ shiftArray asIntegerArray].	maskArray ifNotNil:[masks _ maskArray asWordArray].	colorArray ifNotNil:[colors _ colorArray asWordArray].! !!ColorMap methodsFor: 'testing' stamp: 'ar 5/25/2000 19:41'!isColormap	^true! !!ColorMap methodsFor: 'testing' stamp: 'ar 5/27/2000 19:06'!isFixed	"Return true if the receiver does not use a lookup mechanism for pixel mapping"	^self isIndexed not! !!ColorMap methodsFor: 'testing' stamp: 'ar 5/27/2000 19:06'!isIndexed	"Return true if the receiver uses a lookup mechanism for pixel mapping"	^colors notNil! !!ColorMap methodsFor: 'comparing' stamp: 'ar 5/27/2000 19:28'!= aColorMap	"Return true if the receiver is equal to aColorMap"	self species = aColorMap species ifFalse:[^false].	self isIndexed = aColorMap isIndexed ifFalse:[^false].	^self colors = aColorMap colors and:[		self shifts = aColorMap shifts and:[			self masks = aColorMap masks]]! !!ColorMap methodsFor: 'comparing' stamp: 'ar 5/27/2000 19:29'!hash	"Hash is re-implemented because #= is re-implemented"	^colors hash bitXor: (shifts hash bitXor: masks hash)! !!ColorMap class methodsFor: 'instance creation' stamp: 'jm 5/12/2003 18:57'!colors: colorArray	^ self new setShifts: nil masks: nil colors: colorArray! !!ColorMap class methodsFor: 'instance creation' stamp: 'ar 5/27/2000 20:09'!mapBitsFrom: srcBitMask to: dstBitMask	"Return an array consisting of the shift and the mask for	mapping component values out of srcBitMask and into dstBitMask.	While this computation is somewhat complicated it eases the batch	conversion of all the pixels in BitBlt."	| srcBits dstBits srcLow srcHigh dstLow dstHigh bits mask shift |	(srcBitMask = 0 or:[dstBitMask = 0]) ifTrue:[^#(0 0)]. "Zero mask and shift"	"Compute low and high bit position for source and dest bit mask"	srcLow _ srcBitMask lowBit - 1.	srcHigh _ srcBitMask highBit.	dstLow _ dstBitMask lowBit - 1.	dstHigh _ dstBitMask highBit.	"Compute the number of bits in source and dest bit mask"	srcBits _ srcHigh - srcLow.		dstBits _ dstHigh - dstLow.	"Compute the maximum number of bits we can transfer inbetween"	bits _ srcBits min: dstBits.	"Compute the (unshifted) transfer mask"	mask _ (1 bitShift: bits) - 1.	"Shift the transfer mask to the mask the highest n bits of srcBitMask"	mask _ mask bitShift: (srcHigh - bits).	"Compute the delta shift so that the most significant bit of the	source bit mask falls on the most significant bit of the dest bit mask.	Note that delta is used for #bitShift: so		shift > 0 : shift right		shift < 0 : shift left	e.g., if dstHigh > srcHigh we need to shift left and if dstHigh < srcHigh	we need to shift right. This leads to:"	shift _ dstHigh - srcHigh.	"And that's all we need"	^Array with: shift with: mask! !!ColorMap class methodsFor: 'instance creation' stamp: 'jm 5/12/2003 18:57'!shifts: shiftArray masks: maskArray	^ self new setShifts: shiftArray masks: maskArray colors: nil! !!ColorMap class methodsFor: 'instance creation' stamp: 'ar 1/16/2000 16:02'!shifts: shiftArray masks: maskArray colors: colorArray	^self new setShifts: shiftArray masks: maskArray colors: colorArray! !I allow a user to interactively select a color from a palette.!!ColorPickerMorph methodsFor: 'initialization' stamp: 'ar 2/17/2000 01:14'!buildChartForm        | chartForm transText |        chartForm _ ColorChart deepCopy asFormOfDepth: Display depth.        true "Display depth >= 16" ifTrue:                [chartForm fill: ((TransparentBox left + 9)@0 extent: 1@9) fillColor: Color lightGray.                chartForm fill: ((TransparentBox right - 10)@0 extent: 1@9) fillColor: Color lightGray.                transText _ (Form extent: 63@9 depth: 1   "Where there's a will there's a way..."                                        fromArray: #( 0 0 4194306 1024 4194306 1024 15628058 2476592640                                                                        4887714 2485462016 1883804850 2486772764 4756618                                                                        2485462016 4748474 1939416064 0 0)                                        offset: 0@0).                transText displayOn: chartForm at: 62@0.                Display depth = 32 ifTrue:                        ["Set opaque bits for 32-bit display"                        chartForm fill: chartForm boundingBox rule: Form under                                        fillColor: (Color r: 0.0 g: 0.0 b: 0.0 alpha: 1.0)]].        chartForm borderWidth: 1.        self form: chartForm.        self updateSelectorDisplay.! !!ColorPickerMorph methodsFor: 'initialization' stamp: 'RAA 9/25/1999 11:42'!initialize        super initialize.        theSelectorDisplayMorph _ AlignmentMorph newRow                color: Color white;                borderWidth: 1;                borderColor: Color red;                hResizing: #shrinkWrap;                vResizing: #shrinkWrap;                addMorph: (StringMorph contents: 'theSelector').        self addMorph: theSelectorDisplayMorph.        self buildChartForm.        self addMorph: (SimpleButtonMorph new borderWidth: 0;                        label: 'x' font: nil; color: Color transparent;                        actionSelector: #delete; target: self;                        position: 1@0; extent: 10@9).        selectedColor _ Color white.        sourceHand _ nil.        deleteOnMouseUp _ false.        updateContinuously _ true.        selector _ nil.        target _ nil! !!ColorPickerMorph methodsFor: 'initialization' stamp: 'ee 6/25/2003 15:18'!updateSelectorDisplay	theSelectorDisplayMorph ifNil: [^self].	theSelectorDisplayMorph position: self bottomLeft.	theSelectorDisplayMorph firstSubmorph contents: selector asString , ' ' , selectedColor printString! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'ar 6/25/1999 11:33'!argument	^argument! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'ar 6/25/1999 11:33'!argument: anObject	argument _ anObject! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'sw 10/26/1999 00:16'!originalColor: colorOrSymbol	| aColor |	aColor _ (colorOrSymbol isKindOf: Color)		ifTrue:			[colorOrSymbol]		ifFalse:			[Color lightGreen].	originalColor _ aColor.	originalForm fill: RevertBox fillColor: originalColor! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'RAA 9/25/1999 11:35'!selector: aSymbol        selector _ aSymbol.        self updateSelectorDisplay! !!ColorPickerMorph methodsFor: 'accessing' stamp: 'sw 3/8/1999 14:28'!target: anObject	target _ anObject.	(target respondsTo: #color)		ifTrue: [selectedColor _ target color]		ifFalse: [selectedColor _ Color white].! !!ColorPickerMorph methodsFor: 'event handling' stamp: 'ee 6/25/2003 15:08'!mouseDown: evt	| localPt |	localPt _ evt cursorPoint - self topLeft.	(DragBox containsPoint: localPt)		ifTrue: [^ evt hand grabMorph: self].	(RevertBox containsPoint: localPt)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	self comeToFront.	sourceHand _ evt hand.	self startStepping.! !!ColorPickerMorph methodsFor: 'private' stamp: 'ar 2/17/2000 01:12'!pickColorAt: aPoint 	"RAA 27 Nov 99 - aPoint is global, so no need to add viewbox topleft"	| worldBox globalP c alpha localPt |	localPt _ aPoint - self topLeft.	(FeedbackBox containsPoint: localPt) ifTrue: [^ self].	(RevertBox containsPoint: localPt)		ifTrue: [^ self updateColor: originalColor feedbackColor: originalColor].	"pick up color, either inside or outside this world"	worldBox _ self world viewBox.	globalP _ aPoint 		"+ worldBox topLeft".	"get point in screen coordinates"	(worldBox containsPoint: globalP)		ifTrue: [c _ self world colorAt: aPoint belowMorph: Morph new]		ifFalse: [c _ Display colorAt: globalP].	"check for transparent color and update using appropriate feedback color "	(TransparentBox containsPoint: localPt)		ifTrue: [alpha _ (aPoint x - bounds left - TransparentBox left - 10) asFloat /							(TransparentBox width - 20)							min: 1.0 max: 0.0.					"(alpha roundTo: 0.01) printString , '   ' displayAt: 0@0." " -- debug"					self updateColor: (selectedColor alpha: alpha)						feedbackColor: (selectedColor alpha: alpha)]		ifFalse: [self updateColor: ((selectedColor isColor and: [selectedColor isTranslucentColor])					ifTrue: [c alpha: selectedColor alpha]					ifFalse: [c])				feedbackColor: c]! !!ColorPickerMorph methodsFor: 'private' stamp: 'LC 2/2/2000 03:17'!updateTargetColor	| nArgs |	(target ~~ nil and: [selector ~~ nil]) ifTrue:		[self updateSelectorDisplay.		nArgs _ selector numArgs.		nArgs = 1 ifTrue:[^target perform: selector with: selectedColor].		nArgs = 2 ifTrue:[^target perform: selector with: selectedColor with: sourceHand].		nArgs = 3 ifTrue:[^target perform: selector with: selectedColor with: argument with: sourceHand]].! !!ColorPickerMorph methodsFor: 'other' stamp: 'jm 12/7/2002 16:32'!addToWorld: world near: box	| goodLocation |	goodLocation _ self bestPositionNear: box inWorld: world.	world allMorphsDo:		[:p | (p isMemberOf: ColorPickerMorph) ifTrue:		[(p ~~ self and: [p owner notNil and: [p target == target]]) ifTrue:			[(p selector == selector and: [p argument == argument])				ifTrue: [^ p comeToFront  "uncover existing picker"]				ifFalse: ["place second picker relative to first"						goodLocation _ self bestPositionNear: p bounds inWorld: world]]]].	self position: goodLocation.	world addMorphFront: self.	self changed.! !!ColorPickerMorph methodsFor: 'other' stamp: 'jm 12/7/2002 16:54'!bestPositionNear: box inWorld: world	| fullBox points matchingPoints b |	fullBox _ self fullBounds.	points _ #(topLeft bottomLeft topLeft topRight).  "possible anchors"	matchingPoints _ #(bottomLeft topLeft topRight topLeft).  "possible alignment for anchor"	1 to: 4 do: [:i |  "Try the four obvious anchor points"		b _ fullBox			align: (fullBox perform: (points at: i))			with: (box perform: (matchingPoints at: i)).		(world bounds containsRect: b)			ifTrue: [^ b topLeft]].  "found a place!!"	^ box center  "when all else fails"! !!ColorPickerMorph methodsFor: 'other' stamp: 'LC 2/2/2000 04:28'!containsPoint: aPoint 	^ (super containsPoint: aPoint)		or: [RevertBox containsPoint: aPoint - self topLeft]! !!ColorPickerMorph methodsFor: 'other' stamp: 'di 9/3/1999 13:34'!drawOn: aCanvas	aCanvas depth = 1 ifTrue: [aCanvas fillRectangle: self bounds color: Color white].	Display depth = originalForm depth ifFalse: [self buildChartForm].	super drawOn: aCanvas! !!ColorPickerMorph class methodsFor: 'as yet unclassified' stamp: 'jm 5/31/2003 20:04'!includeInNewMorphMenu	^ true! !!ColorPickerMorph class methodsFor: 'as yet unclassified' stamp: 'di 9/3/1999 13:14'!initialize	"ColorPickerMorph initialize"	ColorChart _ Color colorPaletteForDepth: 16 extent: 190@60.	DragBox _  (11@0) extent: 9@8.	RevertBox _ (ColorChart width - 20)@1 extent: 9@8.	FeedbackBox _ (ColorChart width - 10)@1 extent: 9@8.	TransparentBox _ DragBox topRight corner: RevertBox bottomLeft.		ColorChart fillBlack: ((DragBox left - 1)@0 extent: 1@9).		ColorChart fillBlack: ((TransparentBox left)@0 extent: 1@9).		ColorChart fillBlack: ((FeedbackBox left - 1)@0 extent: 1@9).		ColorChart fillBlack: ((RevertBox left - 1)@0 extent: 1@9).		(Form dotOfSize: 5) displayOn: ColorChart at: DragBox center + (0@1).		! !!ColorPickerMorph class methodsFor: 'as yet unclassified' stamp: 'sw 10/27/1999 11:40'!perniciousBorderColor	"Answer the color of the border lines of a color picker; this color gets reported as you drag the mouse through from the translucent box to the true color area, for example, and can cause some difficulties in some special cases, so it is faithfully reported here in this hard-coded fashion in order that energetic clients wishing to handle it as special-case it can do so."	^ Color r: 0.0 g: 0.0 b: 0.032! !I represent a command or reporter. I have a label and may also have one or more arguments. The label text, number of arguments, and ordering of arguments and keywords are defined by my commandSpec string. This string consists of a sequence of keywords interspersed with character sequences that indicate where the arguments appear:	%b	- boolean	%c	- color	%n	- number	%s	- string	%o	- object reference	%r	- receiver reference	%P - popup choice from finite set of optionsExamples:	%b and %b	%r's color %c sees %c	repeat %n times!!CommandBlockMorph methodsFor: 'initialization' stamp: 'jm 11/18/2003 15:08'!initialize	super initialize.	commandSpec _ ''.	argMorphs _ OrderedCollection new.	titleMorph _ StringMorph contents: ''.	receiver _ selector _ nil.	isReporter _ isTimed _ false.	wantsName _ false.	wantsPossession _ false.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 7/21/2003 01:45'!args	"Answer my arguments evaluated."	^ (argMorphs collect: [:m | m evaluate]) asArray! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 8/24/2003 17:05'!color: aColor	super color: aColor.	self layoutChanged.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 11/20/2002 09:16'!commandSpec	^ commandSpec! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'DaveF 7/24/2003 11:55'!commandSpec: aString	"Set my command spec string. See my class comment."	"CommandBlockMorph new commandSpec: 'forward %n'"	"So that we don't do more work than we have to.  MethodCallBlockMorph step method calls this all the time, so we want to be careful about actually doing a relayout."	commandSpec = aString ifTrue: [^self].	commandSpec _ aString.	self addLabel.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 11/5/2003 10:10'!hasContext	"If I have context, I don't want my name displayed."	| e h |	self wantsName ifFalse: [^ true]. "blocks that are not sprite-specific"	self suppressReceiver ifTrue: [^ true].	(e _ self findScratchEditor) ifNotNil: [^ e thumbnail target == self receiver].	(h _ self findHatBlock) ifNotNil: [^ h scriptOwner == self receiver].	^ false! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 12/10/2003 20:54'!isHatBlock	"Answer true if I am a script hat."	^ false! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 3/13/2003 12:09'!isReporter	"Answer true if this block reports a value. That is, if it can be used in an argument expression."	^ isReporter! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 3/12/2003 17:45'!isReporter: aBoolean	"If true, then this command reports a value. That is, it can be used in an argument expression."	isReporter _ aBoolean.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 12/10/2003 20:58'!isTimed	^ isTimed! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'DaveF 7/10/2003 17:41'!isTimed: aBoolean	"Indicates that this block's evaluate method will be called repeatedly throughout some time interval."	isTimed _ aBoolean.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 6/22/2003 21:50'!receiver	^ receiver! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 7/7/2003 20:59'!receiver: anObject	"Set my receiver object."	receiver _ anObject.	"tell variable VariableArgMorphs about their new target"	self submorphsDo: [:m |		(m isKindOf: VariableArgMorph) ifTrue: [m target: receiver]].! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 7/2/2003 11:47'!selector	^ selector! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 8/3/2003 23:52'!selector: aSymbol	selector _ aSymbol.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 8/3/2003 23:52'!setterForUserVar: varName argSpec: argSpec in: anObject	"Initialize me as a setter for the given user variable."	self commandSpec: ('set ', varName, ' to ', argSpec).	self receiver: anObject.	selector _ varName asSymbol.	isReporter _ false.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'jm 6/29/2003 22:05'!titleMorph	^ titleMorph! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'tis 6/24/2003 11:42'!wantsName	^ wantsName! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'tis 6/24/2003 11:24'!wantsName: aBoolean	"If true, then this command is specific to its receiver.  That is, it will show it's name when dropped in the world."	wantsName _ aBoolean.! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'tis 6/24/2003 12:55'!wantsPossession	^ wantsPossession! !!CommandBlockMorph methodsFor: 'accessing' stamp: 'tis 6/27/2003 10:20'!wantsPossession: aBoolean	"If true, then this command want's a possessive form of a name before it.  	For example, Sprite's color x over x, as opposed to Sprite, forward x."	wantsPossession _ aBoolean.! !!CommandBlockMorph methodsFor: 'evaluation' stamp: 'DaveF 7/9/2003 18:59'!argumentAt: index	"Returns the argument morph at the given index."	^argMorphs at: index.! !!CommandBlockMorph methodsFor: 'evaluation' stamp: 'jm 12/10/2003 18:41'!argumentCount	"Returns the number of arguments to this command block."	^ argMorphs size! !!CommandBlockMorph methodsFor: 'evaluation' stamp: 'jm 8/24/2003 12:11'!firstBlockList	"If I am a control block, answer an array containing the block sequences for my first nested block (i.e., the blocks for the 'true' case of an if-then-else block). If I'm not a control structure block, just answer an empty array."	^ #()! !!CommandBlockMorph methodsFor: 'menus' stamp: 'jm 12/1/2003 16:01'!rightButtonMenu	| menu choice |	selector isInfix ifFalse: [^ super rightButtonMenu].	menu _ CustomMenu new.	(#(+ - * / \\) includes: selector) ifTrue: [		#(+ - * / mod) do: [:op | menu add: op action: op]].	(#(& |) includes: selector) ifTrue: [		#(and or) do: [:op | menu add: op action: op]].	(#(< = >) includes: selector) ifTrue: [		#(< = >) do: [:op | menu add: op action: op]].	(self owner isKindOf: BlockMorph) ifFalse: [		menu addLine.		menu add: 'copy' action: #duplicate.		menu add: 'delete' action: #delete].	choice _ menu startUp.	choice ifNil: [^ self].	choice = #duplicate ifTrue: [^ self duplicate].	choice = #delete ifTrue: [^ self delete].	op _ choice.	self commandSpec: '%n ', op, ' %n'.	#mod = op ifTrue: [^ self selector: #\\].	#and = op ifTrue: [^ self selector: #&].	#or = op ifTrue: [^ self selector: #|].	self selector: op.! !!CommandBlockMorph methodsFor: 'stepping' stamp: 'jm 8/18/2003 22:02'!step	super step.	(self ownerThatIsA: HandMorph) ifNil: [self updateReceiverName].! !!CommandBlockMorph methodsFor: 'stepping' stamp: 'ee 8/14/2003 12:50'!stepTime	^ 500! !!CommandBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:54'!fieldsVersion	^ 1! !!CommandBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:01'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		commandSpec		argMorphs		titleMorph		receiver		selector		isReporter		isTimed		wantsName		wantsPossession	) from: anObjStream.! !!CommandBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:01'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		commandSpec		argMorphs		titleMorph		receiver		selector		isReporter		isTimed		wantsName		wantsPossession	) on: anObjStream.! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 17:05'!addLabel	"Add a label for my command and arguments.  This is the method that really creates the whole block."	| tokens args nextArgIndex m next |	commandSpec ifNil: [^ self].	"Basic idea.  We remove all the pieces of this block, and then reassemble them, being careful not to destroy any argument morphs that we might still want to use.   This is helpful if someone adds/removes parameters from a hat block."	"We make sure not to remove the next block."	next _ self nextBlock.	self removeAllMorphsIn: (self submorphs reject: [:t | t = next]).	tokens _ self parseCommandSpec.	args _ tokens select: [:s | self isArgSpec: s].	"Remove any excess arg morphs from the list."	[argMorphs size > args size] whileTrue:		[m _ argMorphs last.		argMorphs remove: m.		"If the argument we're throwing out is anything complicated, we'd like to keep it around in the world."		(m isKindOf: BlockMorph) ifTrue: [m openInWorld]].	"Create new arg morphs."	[argMorphs size < args size] whileTrue:		[argMorphs addLast: (self argMorphFor: (args at: argMorphs size + 1))].	titleMorph _ self labelMorphFor: ''.	self addMorphBack: titleMorph.	nextArgIndex _ 1.		tokens do: [:s |		(self isArgSpec: s)			ifTrue:	[m _ argMorphs at: nextArgIndex.					nextArgIndex _ nextArgIndex + 1]			ifFalse:	[m _ self labelMorphFor: s].		self addMorphBack: m].! !!CommandBlockMorph methodsFor: 'private' stamp: 'TIS 6/19/2003 18:21'!argMorphFor: specString	"Answer an argument morph for the given argument specification string. Set it's color appropriately."	| m |	m _ self uncoloredArgMorphFor: specString.	(m isKindOf: ColorArgMorph)		ifTrue: [m color: Color random]		ifFalse: [m color: (self color mixed: 0.2 with: Color white)].	(m isKindOf: VariableArgMorph)		ifTrue: [m color: (Color r: 0.4 g: 1.0 b: 0.4)].	^ m! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 3/16/2003 11:18'!argMorphToReplace: aMorph	"Answer a new argument morph to be used to replace the given morph. Answer nil if the given morph is not one of my argMorphs."	| i argSpecs |	i _ argMorphs indexOf: aMorph ifAbsent: [^ nil].	argSpecs _ self parseCommandSpec select: [:s | self isArgSpec: s].	i > argSpecs size ifTrue: [^ nil].	^ self argMorphFor: (argSpecs at: i)! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 17:26'!fixBlockLayout	"Update the positions of my submorphs."	| h x |	h _ 10.	self nonControlFlowSubmorphs do: [:m |		(m isKindOf: BlockMorph) ifTrue: [m fixBlockLayout].		(m isKindOf: ArgMorph) ifTrue: [m fixArgLayout].		h _ h max: m height].	h _ h + 5.	x _ self left + 5.	self nonControlFlowSubmorphs do: [:m |		(m isKindOf: StringMorph) ifTrue: [m color: self labelColor].		m position: x@(self top + ((h - m height) // 2)).		x _ x + m width + 5].	self extent: (x - self left) @ h.	self nextBlock ifNotNil: [self nextBlock fixBlockLayout].! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 11/20/2002 09:35'!isArgSpec: aString	"Answer true if the given string is an argument specification."	^ (aString size = 2) and: [aString first = $%]! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 12/9/2002 13:42'!labelColor	"Answer a label color, either black or white, that maximizes the contrast with my color."	^ self color luminance > 0.51		ifTrue: [Color black]		ifFalse: [Color white]! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 11/20/2002 10:23'!labelMorphFor: aString	^ (StringMorph contents: aString font: LabelFont)		color: self labelColor! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 8/5/2003 17:25'!mapReceiver: oldObj to: newObj	"Used in cloning an object to make blocks that refererred to the original object new refer to the new copy."	receiver == oldObj ifTrue: [receiver _ newObj].! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 3/20/2003 13:09'!nextBlock	"Answer the block myself in the block sequence or nil if I am the last block in the sequence. Each block is a submorph of the previous block."	^ self submorphs		detect: [:m | (m isKindOf: BlockMorph) and: [(argMorphs includes: m) not]]		ifNone: [nil]! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 11/20/2002 09:39'!parseCommandSpec	"Answer an array of token strings containing my keywords and argument specs."	| result len i j |	result _ OrderedCollection new.	len _ commandSpec size.	i _ 1.	[(i < len) and: [(commandSpec at: i) isSeparator]] whileTrue: [i _ i + 1].	[i < len] whileTrue: [		j _ commandSpec indexOf: $% startingAt: i.		j > 0			ifTrue: [				j > i ifTrue: [result addLast: (commandSpec copyFrom: i to: j - 1)].				j >= len ifTrue: [self error: 'command spec cannot end with %'].				result addLast: (commandSpec copyFrom: j to: j + 1).				i _ j + 2]			ifFalse: [				result addLast: (commandSpec copyFrom: i to: len).				i _ len]].	^ result asArray collect: [:s | s withBlanksTrimmed]! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 10/21/2003 19:47'!printCodeOn: aStream indent: indent	"Append a human-readable string for this block on the given stream."	| nextB |	indent timesRepeat: [aStream tab].	nextB _ self nextBlock.	submorphs do: [:m |		m ~~ nextB ifTrue: [			self printCodeSubmorph: m on: aStream.			aStream space]].	aStream cr.	self nextBlock ifNotNil: [self nextBlock printCodeOn: aStream indent: indent].! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 17:06'!replaceArgMorph: oldMorph by: newMorph	"Replace oldMorph with newMorph in my argMorphs and submorphs lists. This is done when dropping a reporter block onto one of my arguments."	argMorphs _ argMorphs collect: [:m |		m == oldMorph ifTrue: [newMorph] ifFalse: [m]].	self replaceSubmorph: oldMorph by: newMorph.	self layoutChanged.! !!CommandBlockMorph methodsFor: 'private' stamp: 'LY 6/26/2003 12:04'!uncoloredArgMorphFor: specString	"Answer an argument morph for the given argument specification string."	| code |	code _ specString at: 2.	$b = code ifTrue: [^ ChoiceArgMorph new beBoolean].	$c = code ifTrue: [^ ColorArgMorph new].	$m = code ifTrue: [^ SpriteArgMorph new].	$n = code ifTrue: [^ ExpressionArgMorph new numExpression: '10'].	$p = code ifTrue: [^ PositionArgMorph new morphPos: '(0, 0)'].	$v = code ifTrue: [^ VariableArgMorph new variable: 'x'].	$s = code ifTrue: [^ ExpressionArgMorph new stringExpression: 'fileName'].	$P = code ifTrue: [^ ChoiceArgMorph new].	^ BorderedMorph new		extent: 22@18;		borderWidth: 1;		borderInset;		color: Color gray! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 8/24/2003 17:08'!updateReceiverName	"Update the display of my receiver's name if necessary."	| title |	self hasContext		ifTrue: [title _ '']		ifFalse: [self wantsPossession 			ifTrue: [title _ (' ', self receiver objName, '''s')]			ifFalse: [title _ (' ', self receiver objName, ',')]].	titleMorph contents ~= title ifTrue: [ "do this only if title changed"		titleMorph contents: title.		self layoutChanged].! !!CommandBlockMorph methodsFor: 'private' stamp: 'jm 3/15/2003 11:23'!updateReferencesUsing: aDictionary	"Update my arg morphs."	super updateReferencesUsing: aDictionary.	argMorphs _ argMorphs collect: [:m | aDictionary at: m ifAbsent: [m]].! !I represent a method suitable for interpretation by the virtual machine. My instances have pointer fields, including a header and some literals, followed by non-pointer fields comprising the byte encoded instructions for the method. The header encodes the number of arguments, the number of literals, and the amount of temporary space needed (for context allocation).	An extra three bytes are added after the executable code. These contain an external file address to the source code for the method.!!CompiledMethod methodsFor: 'initialize-release' stamp: 'di 10/22/1999 13:14'!needsFrameSize: newFrameSize	"Set the largeFrameBit to accomodate the newFrameSize"	| largeFrameBit header |	largeFrameBit _ 16r20000.	(self numTemps + newFrameSize) > LargeFrame ifTrue:		[^ self error: 'Cannot compile -- stack including temps is too deep'].	header _ self objectAt: 1.	(header bitAnd: largeFrameBit) ~= 0		ifTrue: [header _ header - largeFrameBit].	self objectAt: 1 put: header			+ ((self numTemps + newFrameSize) > SmallFrame					ifTrue: [largeFrameBit]					ifFalse: [0])! !!CompiledMethod methodsFor: 'accessing' stamp: 'di 1/2/1999 17:00'!flushCache	"Tell the interpreter to remove all references to this method from its method lookup cache, if it has one.  This primitive must be called whenever a method is defined or removed.	NOTE:  Only one of two selective flush methods needs to be used.	Squeak 2.2 and earlier uses 119 (See Symbol flushCache).	Squeak 2.3 and later uses 116 (See CompiledMethod flushCache)."	<primitive: 116>! !!CompiledMethod methodsFor: 'accessing' stamp: 'di 10/23/1999 22:00'!frameSize	"Answer the size of temporary frame needed to run the receiver."	"NOTE:  Versions 2.7 and later use two sizes of contexts."	(self header noMask: 16r20000)		ifTrue: [^ SmallFrame]		ifFalse: [^ LargeFrame]! !!CompiledMethod methodsFor: 'accessing' stamp: 'ar 6/2/1998 16:26'!numArgs	"Answer the number of arguments the receiver takes."	^ (self header bitShift: -24) bitAnd: 16r0F! !!CompiledMethod methodsFor: 'testing' stamp: 'sw 8/20/1998 09:31'!hasReportableSlip	"Answer whether the receiver contains anything that might be brought to the attention of the author when filing out.   Customize the lists to suit your preferences.  If slips do not get reported in spite of your best efforts here, make certain that the Preference 'suppressCheckForSlips' has not been hard-coded to true."	| assoc | 	#(halt halt: urgent hottest) do:		[:aLit | (self hasLiteral: aLit) ifTrue: [^ true]].	#(Transcript AA BB CC DD EE) do:		[:aSymbol | (assoc _ (Smalltalk associationAt: aSymbol ifAbsent: [nil])) ifNotNil:			[(self hasLiteral: assoc) ifTrue: [^ true]]].	^ false! !!CompiledMethod methodsFor: 'testing' stamp: 'di 12/26/1998 21:31'!isQuick	"Answer whether the receiver is a quick return (of self or of an instance 	variable)."	^ self primitive between: 256 and: 519! !!CompiledMethod methodsFor: 'testing' stamp: 'ar 6/2/1998 16:11'!isReturnField	"Answer whether the receiver is a quick return of an instance variable."	^ self primitive between: 264 and: 519! !!CompiledMethod methodsFor: 'printing' stamp: 'sma 2/12/2000 14:01'!decompileString	| clAndSel cl sel |	clAndSel _ self who.	clAndSel = #(unknown unknown)		ifTrue:			[cl _ Object.			sel _ #xxxUnknown.			self numArgs >= 1				ifTrue:					[sel _ sel , ':'.					2 to: self numArgs do: [:i | sel _ sel , 'with:'].					sel _ sel asSymbol]]		ifFalse:			[cl _ clAndSel first.			sel _ clAndSel last].	^ (cl decompilerClass new			decompile: sel in: cl method: self) decompileString! !!CompiledMethod methodsFor: 'printing' stamp: 'jm 10/14/2002 19:07'!printOn: aStream 	"Overrides method inherited from the byte arrayed collection."	self printNameOn: aStream.	aStream nextPutAll: '(', self identityHash printString, ')'.! !!CompiledMethod methodsFor: 'printing' stamp: 'ar 11/28/1999 19:37'!printPrimitiveOn: aStream	"Print the primitive on aStream"	| primIndex primDecl |	primIndex _ self primitive.	primIndex = 0 ifTrue:[^self].	primIndex = 120 "External call spec"		ifTrue:[^aStream print: (self literalAt: 1); cr].	aStream nextPutAll: '<primitive: '.	primIndex = 117 ifTrue:[		primDecl _ self literalAt: 1.		aStream 			nextPut: $';			nextPutAll: (primDecl at: 2);			nextPut:$'.		(primDecl at: 1) notNil ifTrue:[			aStream 				nextPutAll:' module:';				nextPut:$';				nextPutAll: (primDecl at: 1);				nextPut:$'.		].	] ifFalse:[aStream print: primIndex].	aStream nextPut: $>; cr! !!CompiledMethod methodsFor: 'printing' stamp: 'di 12/26/1998 21:30'!symbolic	"Answer a String that contains a list of all the byte codes in a method 	with a short description of each." 	| aStream |	self isQuick ifTrue: 		[self isReturnSpecial ifTrue:			[^ 'Quick return ' , (#('self' 'true' 'false' 'nil' '-1' '0' '1' '2')									at: self primitive - 255)].		^ 'Quick return field ' , self returnField printString , ' (0-based)'].	aStream _ WriteStream on: (String new: 1000).	self printPrimitiveOn: aStream.	(InstructionPrinter on: self) printInstructionsOn: aStream.	^aStream contents! !!CompiledMethod methodsFor: 'printing' stamp: 'di 2/4/2000 21:13'!who 	"Answer an Array of the class in which the receiver is defined and the 	selector to which it corresponds."	| sel |	Smalltalk allBehaviorsDo:		[:class |		(sel _ class methodDict keyAtIdentityValue: self ifAbsent: [nil])			ifNotNil: [^Array with: class with: sel]].	^ Array with: #unknown with: #unknown! !!CompiledMethod methodsFor: 'literals' stamp: 'sma 6/3/2000 21:39'!hasLiteralThorough: literal	"Answer true if any literal in this method is literal,	even if embedded in array structure."	| lit |	2 to: self numLiterals + 1 do: 		[:index | 		(lit _ self objectAt: index) == literal ifTrue: [^ true].		(lit class == Array and: [lit hasLiteral: literal]) ifTrue: [^ true]].	^ false! !!CompiledMethod methodsFor: 'scanning' stamp: 'di 12/26/1998 21:30'!writesField: field 	"Answer whether the receiver stores into the instance variable indexed 	by the argument."	self isQuick ifTrue: [^ false].	field <= 8 ifTrue:		[^ (self scanFor: 96 + field - 1) or: [self scanLongStore: field - 1]].	field <= 64 ifTrue:		[^ self scanLongStore: field - 1].	^ self scanVeryLongStore: 160 offset: field - 1! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 4/21/2000 07:54'!checkOKToAdd: size at: filePosition	"Issue several warnings as the end of the changes file approaches its limit,	and finally halt with an error when the end is reached."	| fileSizeLimit margin |	fileSizeLimit _ 16r2000000.	3 to: 1 by: -1 do:		[:i | margin _ i*100000.		(filePosition + size + margin) > fileSizeLimit			ifTrue: [(filePosition + margin) > fileSizeLimit ifFalse:						[self notify: 'WARNING: your changes file is within' , margin printString , ' characters of its size limit.You should take action soon to reduce its size.You may proceed.']]			ifFalse: [^ self]].	(filePosition + size > fileSizeLimit) ifFalse: [^ self].	self error: 'You have reached the size limit of the changes file.You must take action now to reduce it.Close this error.  Do not attempt to proceed.'! !!CompiledMethod methodsFor: 'source code management' stamp: 'hmm 4/26/2000 20:44'!fileIndex	^SourceFiles fileIndexFromSourcePointer: self sourcePointer! !!CompiledMethod methodsFor: 'source code management' stamp: 'hmm 4/26/2000 20:45'!filePosition	^SourceFiles filePositionFromSourcePointer: self sourcePointer! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 12/26/1998 22:34'!getSourceFor: selector in: class	"Retrieve or reconstruct the source code for this method."	| source flagByte |	flagByte _ self last.	(flagByte = 0		or: [flagByte = 251 "some source-less methods have flag = 251, rest = 0"			and: [((1 to: 3) collect: [:i | self at: self size - i]) = #(0 0 0)]])		ifTrue:		["No source pointer -- decompile without temp names"		^ (class decompilerClass new decompile: selector in: class method: self)			decompileString].	flagByte < 252 ifTrue:		["Magic sources -- decompile with temp names"		^ ((class decompilerClass new withTempNames: self tempNames)				decompile: selector in: class method: self)			decompileString].	"Situation normal;  read the sourceCode from the file"	(source _ self getSourceFromFile) == nil ifFalse: [^ source].	"Something really wrong -- decompile blind (no temps)"	^ (class decompilerClass new decompile: selector in: class method: self)			decompileString! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 4/21/2000 07:53'!putSource: sourceStr fromParseNode: methodNode inFile: fileIndex withPreamble: preambleBlock	"Store the source code for the receiver on an external file.	If no sources are available, i.e., SourceFile is nil, then store	temp names for decompilation at the end of the method.	If the fileIndex is 1, print on *.sources;  if it is 2, print on *.changes,	in each case, storing a 4-byte source code pointer at the method end."	| file remoteString  |	(SourceFiles == nil or: [(file _ SourceFiles at: fileIndex) == nil]) ifTrue:		[^ self become: (self copyWithTempNames: methodNode tempNames)].	Smalltalk assureStartupStampLogged.	file setToEnd.	preambleBlock value: file.  "Write the preamble"	remoteString _ RemoteString newString: sourceStr						onFileNumber: fileIndex toFile: file.	file nextChunkPut: ' '; flush.	self checkOKToAdd: sourceStr size at: remoteString position.	self setSourcePosition: remoteString position inFile: fileIndex! !!CompiledMethod methodsFor: 'source code management' stamp: 'di 9/23/1998 19:22'!qCompress: str	"A very simple text compression routine designed for method temp names.	Most common 12 chars get values 0-11 packed in one 4-bit nibble;	others get values 12-15 (2 bits) * 16 plus next nibble.	Last char of str must be a space so it may be dropped without	consequence if output ends on odd nibble."	| charTable odd ix oddNibble |	charTable _  "Character encoding table must match qDecompress:"	' eatrnoislcm bdfghjkpquvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'.	^ ByteArray streamContents:		[:strm | odd _ true.  "Flag for odd or even nibble out"		str do:			[:char | ix _ (charTable indexOf: char) - 1.			(ix <= 12 ifTrue: [Array with: ix]				ifFalse: [Array with: ix//16+12 with: ix\\16])				do:				[:nibble | (odd _ odd not)					ifTrue: [strm nextPut: oddNibble*16 + nibble]					ifFalse: [oddNibble _ nibble]]].		strm nextPut: strm position]"  | m s |  m _ CompiledMethod new.s _ 'charTable odd ix oddNibble '.^ Array with: s size with: (m qCompress: s) size	with: (m qDecompress: (m qCompress: s))"! !!CompiledMethod methodsFor: 'source code management' stamp: 'hmm 4/26/2000 21:00'!setSourcePointer: srcPointer	srcPointer = 0 ifTrue: [		self at: self size put: 0.		^self].	(srcPointer between: 16r1000000 and: 16r4FFFFFF) ifFalse: [self error: 'Source pointer out of range'].	self at: self size put: (srcPointer bitShift: -24) + 251.	1 to: 3 do: [:i |		self at: self size-i put: ((srcPointer bitShift: (i-3)*8) bitAnd: 16rFF)]! !!CompiledMethod methodsFor: 'source code management' stamp: 'hmm 4/26/2000 21:02'!setSourcePosition: position inFile: fileIndex 	self setSourcePointer: (SourceFiles sourcePointerFromFileIndex: fileIndex andPosition: position)! !!CompiledMethod methodsFor: 'source code management' stamp: 'hmm 4/26/2000 20:44'!sourcePointer	"Answer the integer which can be used to find the source file and position for this method.	The returned value is either 0 (if no source is stored) or a number between 16r1000000 and 16r4FFFFFF.	The actual interpretation of this number is up to the SourceFileArray stored in the global variable SourceFiles."	| pos |	self last < 252 ifTrue: [^ 0  "no source"].	pos _ self last - 251.	self size - 1 to: self size - 3 by: -1 do: [:i | pos _ pos * 256 + (self at: i)].	^pos! !!CompiledMethod class methodsFor: 'class initialization' stamp: 'di 1/11/1999 22:13'!fullFrameSize  "CompiledMethod fullFrameSize"	^ LargeFrame! !!CompiledMethod class methodsFor: 'class initialization' stamp: 'di 10/22/1999 09:56'!initialize    "CompiledMethod initialize"	"Initialize class variables specifying the size of the temporary frame	needed to run instances of me."	SmallFrame _ 16.	"Context range for temps+stack"	LargeFrame _ 56.! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'tk 1/21/2000 15:25'!new: size	self error: 'CompiledMethods may only be created with newMethod:header:'! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'di 5/25/2000 06:37'!newBytes: numberOfBytes trailerBytes: trailer nArgs: nArgs nTemps: nTemps nStack: stackSize nLits: nLits primitive: primitiveIndex	"Answer an instance of me. The header is specified by the message 	arguments. The remaining parts are not as yet determined."	| largeBit primBits method |	nTemps > 64 ifTrue:		[^ self error: 'Cannot compile -- too many temporary variables'].		largeBit _ (nTemps + stackSize) > SmallFrame ifTrue: [1] ifFalse: [0].	primBits _ primitiveIndex <= 16r1FF		ifTrue: [primitiveIndex]		ifFalse: ["For now the high 2 bits of primitive no. are in high bits of header"				(primitiveIndex bitAnd: 16r1FF) + ((primitiveIndex bitAnd: 16r600) bitShift: 19)].	method _ self newMethod: numberOfBytes + trailer size		header: (nArgs bitShift: 24) +				(nTemps bitShift: 18) +				(largeBit bitShift: 17) +				(nLits bitShift: 9) +				primBits.	1 to: trailer size do:  "Copy the source code trailer to the end"		[:i | method at: method size - trailer size + i put: (trailer at: i)].	^ method! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'di 5/25/2000 06:43'!toReturnConstant: index trailerBytes: trailer	"Answer an instance of me that is a quick return of the constant	indexed in (true false nil -1 0 1 2)."	^ self newBytes: 0 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 0 primitive: 256 + index! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'di 5/25/2000 06:44'!toReturnField: field trailerBytes: trailer	"Answer an instance of me that is a quick return of the instance variable 	indexed by the argument, field."	^ self newBytes: 0 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 0 primitive: 264 + field! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'di 5/25/2000 06:51'!toReturnSelf	"Answer an instance of me that is a quick return of the instance (^self)."	^ self toReturnSelfTrailerBytes: #(0 0 0 0)! !!CompiledMethod class methodsFor: 'instance creation' stamp: 'di 5/25/2000 06:44'!toReturnSelfTrailerBytes: trailer	"Answer an instance of me that is a quick return of the instance (^self)."	^ self newBytes: 0 trailerBytes: trailer nArgs: 0 nTemps: 0 nStack: 0 nLits: 0 primitive: 256! !The compiler accepts Smalltalk source code and compiles it with respect to a given class. The user of the compiler supplies a context so that temporary variables are accessible during compilation. If there is an error, a requestor (usually a kind of StringHolderController) is sent the message notify:at:in: so that the error message can be displayed. If there is no error, then the result of compilation is a MethodNode, which is the root of a parse tree whose nodes are kinds of ParseNodes. The parse tree can be sent messages to (1) generate code for a CompiledMethod (this is done for compiling methods or evaluating expressions); (2) pretty-print the code (for formatting); or (3) produce a map from object code back to source code (used by debugger program-counter selection). See also Parser, Encoder, ParseNode.!!Compiler methodsFor: 'error handling' stamp: 'di 10/9/1998 16:50'!notify: aString at: location	"Refer to the comment in Object|notify:."	requestor == nil		ifTrue: [^SyntaxError 					errorInClass: class					withCode: 						(sourceStream contents							copyReplaceFrom: location							to: location - 1							with: aString)					doitFlag: false]		ifFalse: [^requestor					notify: aString					at: location					in: sourceStream]! !!Compiler methodsFor: 'public access' stamp: 'bf 10/14/1999 19:55'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock	"Compiles the sourceStream into a parse tree, then generates code into a 	method. This method is then installed in the receiver's class so that it 	can be invoked. In other words, if receiver is not nil, then the text can 	refer to instance variables of that receiver (the Inspector uses this). If 	aContext is not nil, the text can refer to temporaries in that context (the 	Debugger uses this). If aRequestor is not nil, then it will receive a 	notify:at: message before the attempt to evaluate is aborted. Finally, the 	compiled method is invoked from here as DoIt or (in the case of 	evaluation in aContext) DoItIn:. The method is subsequently removed 	from the class, but this will not get done if the invocation causes an 	error which is terminated. Such garbage can be removed by executing: 	Smalltalk allBehaviorsDo: [:cl | cl removeSelector: #DoIt; removeSelector: 	#DoItIn:]."	| methodNode method value |	class _ (aContext == nil ifTrue: [receiver] ifFalse: [aContext receiver]) class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode _ self translate: sourceStream noPattern: true ifFail:		[^failBlock value].	method _ methodNode generate: #(0 0 0 0).	self interactive ifTrue:		[method _ method copyWithTempNames: methodNode tempNames].	context == nil		ifTrue: [class addSelector: #DoIt withMethod: method.				value _ receiver DoIt.				class removeSelectorSimply: #DoIt.				^value]		ifFalse: [class addSelector: #DoItIn: withMethod: method.				value _ receiver DoItIn: context.				class removeSelectorSimply: #DoItIn:.				^value]! !!Compiler methodsFor: 'public access' stamp: 'sw 11/7/1999 00:11'!format: textOrStream in: aClass notifying: aRequestor decorated: aBoolean	"Compile a parse tree from the argument, textOrStream. Answer a string containing the original code, formatted nicely.  If aBoolean is true, then decorate the resulting text with color and hypertext actions"	| aNode |	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	aNode _ self format: sourceStream noPattern: false ifFail: [^ nil].	^ aBoolean		ifTrue: [aNode decompileText]		ifFalse: [aNode decompileString]! !!Compiler methodsFor: 'private' stamp: 'mn 5/25/2000 07:36'!format: aStream noPattern: noPattern ifFail: failBlock	| tree |	tree _ 		self class parserClass new			parse: aStream			class: class			noPattern: noPattern			context: context			notifying: requestor			ifFail: [^ failBlock value].	^ tree! !!Compiler methodsFor: 'private' stamp: 'mn 5/25/2000 07:37'!translate: aStream noPattern: noPattern ifFail: failBlock	| tree |	tree _ 		self class parserClass new			parse: aStream			class: class			noPattern: noPattern			context: context			notifying: requestor			ifFail: [^ failBlock value].	^ tree! !A composite transform provides the effect of several levels of coordinate transformations.!!CompositeTransform methodsFor: 'initialization' stamp: 'di 10/26/1999 17:08'!composedWith: aTransform	"Return a new transform that has the effect of transforming points first by the receiver and then by the argument."	self isIdentity ifTrue: [^ aTransform].	aTransform isIdentity ifTrue: [^ self].	^ CompositeTransform new globalTransform: self							localTransform: aTransform! !!CompositeTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 20:00'!isCompositeTransform	^true! !!CompositeTransform methodsFor: 'transformations' stamp: 'di 10/1/1998 13:51'!invert: aPoint	^ globalTransform invert: (localTransform invert: aPoint)! !!CompositeTransform methodsFor: 'accessing' stamp: 'di 10/26/1999 17:06'!angle	^ localTransform angle + globalTransform angle! !!CompositeTransform methodsFor: 'accessing' stamp: 'ar 11/2/1998 19:45'!inverseTransformation	"Return the inverse transformation of the receiver"	^self species new		globalTransform: localTransform inverseTransformation		localTransform: globalTransform inverseTransformation! !!CompositeTransform methodsFor: 'accessing' stamp: 'di 10/26/1999 15:40'!offset	^ (self localPointToGlobal: 0@0) negated! !!CompositeTransform methodsFor: 'accessing' stamp: 'di 10/26/1999 15:39'!scale	^ localTransform scale * globalTransform scale! !!CompositeTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:39'!globalPointToLocal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^localTransform globalPointToLocal:		(globalTransform globalPointToLocal: aPoint)! !!CompositeTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:39'!localPointToGlobal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^globalTransform localPointToGlobal:		(localTransform localPointToGlobal: aPoint)! !!CompositeTransform methodsFor: 'converting' stamp: 'ar 11/2/1998 20:00'!asCompositeTransform	^self! !!CompositeTransform methodsFor: 'converting' stamp: 'ar 11/2/1998 19:56'!asMatrixTransform2x3	^globalTransform asMatrixTransform2x3		composedWithLocal: localTransform asMatrixTransform2x3! !!CompositeTransform methodsFor: 'converting' stamp: 'di 10/26/1999 17:03'!asMorphicTransform	"Squash a composite transform down to a simple one"	^ MorphicTransform offset: self offset angle: self angle scale: self scale! !!CompositeTransform methodsFor: 'encoding' stamp: 'ls 3/19/2000 16:28'!encodeForRemoteCanvas	^String streamContents: [ :str |		str			nextPutAll: 'Composite,';			nextPutAll: '(';			nextPutAll: globalTransform encodeForRemoteCanvas;			nextPutAll: ')(';			nextPutAll: localTransform encodeForRemoteCanvas;			nextPutAll: ')' ]! !!CompositeTransform class methodsFor: 'instance creation' stamp: 'ls 3/19/2000 16:49'!fromRemoteCanvasEncoding: encoding	| firstStart firstEnd firstEncoding firstTransform secondStart secondEnd secondEncoding secondTransform |	"format: Composite,(enc1)(enc2)"	"decode the first encoding"	firstStart := encoding indexOf: $(.	firstStart = 0 ifTrue: [ self error: 'invalid encoding' ].	firstEnd := encoding findCloseParenthesisFor: firstStart.	firstEncoding := encoding copyFrom: firstStart+1 to: firstEnd-1.	firstTransform := DisplayTransform fromRemoteCanvasEncoding: firstEncoding.	"decode the second encoding"	secondStart := firstEnd + 1.	(encoding at: secondStart) = $( ifFalse: [ ^self error: 'invalid encoding' ].	secondEnd := encoding findCloseParenthesisFor: secondStart.	secondEncoding := encoding copyFrom: secondStart+1 to: secondEnd-1.	secondTransform := DisplayTransform fromRemoteCanvasEncoding: secondEncoding.		"put it together"	^self globalTransform: firstTransform localTransform: secondTransform! !CompositionScanners are used to measure text and determine where line breaks and space padding should occur.!!CompositionScanner methodsFor: 'scanning' stamp: 'jm 7/22/2003 20:46'!composeFrom: startIndex inRectangle: lineRectangle	firstLine: firstLine leftSide: leftSide rightSide: rightSide	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	"Set up margins"	leftMargin _ lineRectangle left.	leftSide ifTrue: [leftMargin _ leftMargin +						(firstLine ifTrue: [textStyle firstIndent]								ifFalse: [textStyle restIndent])].	destX _ spaceX _ leftMargin.	rightMargin _ lineRectangle right.	rightSide ifTrue: [rightMargin _ rightMargin - textStyle rightIndent].	lastIndex _ startIndex.	"scanning sets last index"	destY _ lineRectangle top.	lineHeight _ baseline _ 0.  "Will be increased by setFont"	self setStopConditions.	"also sets font"	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ (TextLine start: lastIndex stop: 0 internalSpaces: 0 paddingWidth: 0)				rectangle: lineRectangle;				leftMargin: leftMargin.		spaceCount _ 0.	self handleIndentation.	leftMargin _ destX.	line leftMargin: leftMargin.	done _ false.	[done]		whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^ line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!CompositionScanner methodsFor: 'scanning' stamp: 'jm 7/22/2003 20:47'!composeLine: lineIndex fromCharacterIndex: startIndex inParagraph: aParagraph 	"Answer an instance of TextLineInterval that represents the next line in the paragraph."	| runLength done stopCondition |	destX _ spaceX _ leftMargin _ aParagraph leftMarginForCompositionForLine: lineIndex.	destY _ 0.	rightMargin _ aParagraph rightMarginForComposition.	leftMargin >= rightMargin ifTrue: [self error: 'No room between margins to compose'].	lastIndex _ startIndex.	"scanning sets last index"	lineHeight _ textStyle lineGrid.  "may be increased by setFont:..."	baseline _ textStyle baseline.	self setStopConditions.	"also sets font"	self handleIndentation.	runLength _ text runLengthFor: startIndex.	runStopIndex _ (lastIndex _ startIndex) + (runLength - 1).	line _ TextLineInterval		start: lastIndex		stop: 0		internalSpaces: 0		paddingWidth: 0.	spaceCount _ 0.	done _ false.	[done]		whileFalse: 			[stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex				in: text string rightX: rightMargin stopConditions: stopConditions				kern: kern.			"See setStopConditions for stopping conditions for composing."			(self perform: stopCondition)				ifTrue: [^line lineHeight: lineHeight + textStyle leading							baseline: baseline + textStyle leading]]! !!CompositionScanner methodsFor: 'scanning' stamp: 'ar 1/8/2000 14:36'!setActualFont: aFont	"Keep track of max height and ascent for auto lineheight"	| descent |	super setActualFont: aFont.	lineHeight == nil		ifTrue: [descent _ font descent.				baseline _ font ascent.				lineHeight _ baseline + descent]		ifFalse: [descent _ lineHeight - baseline max: font descent.				baseline _ baseline max: font ascent.				lineHeight _ lineHeight max: baseline + descent]! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:54'!cr	"Answer true. Set up values for the text line interval currently being 	composed."	line stop: lastIndex.	spaceX _ destX.	line paddingWidth: rightMargin - spaceX.	^true! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:54'!crossedX	"There is a word that has fallen across the right edge of the composition 	rectangle. This signals the need for wrapping which is done to the last 	space that was encountered, as recorded by the space stop condition."	spaceCount >= 1 ifTrue:		["The common case. First back off to the space at which we wrap."		line stop: spaceIndex.		lineHeight _ lineHeightAtSpace.		baseline _ baselineAtSpace.		spaceCount _ spaceCount - 1.		spaceIndex _ spaceIndex - 1.		"Check to see if any spaces preceding the one at which we wrap.			Double space after punctuation, most likely."		[(spaceCount > 1 and: [(text at: spaceIndex) = Space])]			whileTrue:				[spaceCount _ spaceCount - 1.				"Account for backing over a run which might					change width of space."				font _ text fontAt: spaceIndex withStyle: textStyle.				spaceIndex _ spaceIndex - 1.				spaceX _ spaceX - (font widthOf: Space)].		line paddingWidth: rightMargin - spaceX.		line internalSpaces: spaceCount]	ifFalse:		["Neither internal nor trailing spaces -- almost never happens."		lastIndex _ lastIndex - 1.		[destX <= rightMargin]			whileFalse:				[destX _ destX - (font widthOf: (text at: lastIndex)).				lastIndex _ lastIndex - 1].		spaceX _ destX.		line paddingWidth: rightMargin - destX.		line stop: (lastIndex max: line first)].	^true! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:54'!endOfRun	"Answer true if scanning has reached the end of the paragraph. 	Otherwise step conditions (mostly install potential new font) and answer 	false."	| runLength |	lastIndex = text size	ifTrue:	[line stop: lastIndex.			spaceX _ destX.			line paddingWidth: rightMargin - destX.			^true]	ifFalse:	[runLength _ (text runLengthFor: (lastIndex _ lastIndex + 1)).			runStopIndex _ lastIndex + (runLength - 1).			self setStopConditions.			^false]! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/8/2000 14:37'!placeEmbeddedObject: anchoredMorph	| descent |	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	descent _ lineHeight - baseline.	lineHeight _ lineHeight max: anchoredMorph height.	baseline _ lineHeight - descent.	^ true! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 5/18/2000 16:48'!setFont	super setFont.	stopConditions == DefaultStopConditions 		ifTrue:[stopConditions _ stopConditions copy].	stopConditions at: Space asciiValue + 1 put: #space.! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/8/2000 14:37'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:55'!space	"Record left x and character index of the space character just encounted. 	Used for wrap-around. Answer whether the character has crossed the 	right edge of the composition rectangle of the paragraph."	spaceX _ destX.	destX _ spaceX + spaceWidth.	spaceIndex _ lastIndex.	lineHeightAtSpace _ lineHeight.	baselineAtSpace _ baseline.	lastIndex _ lastIndex + 1.	spaceCount _ spaceCount + 1.	destX > rightMargin ifTrue: 	[^self crossedX].	^false! !!CompositionScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:59'!tab	"Advance destination x according to tab settings in the paragraph's 	textStyle. Answer whether the character has crossed the right edge of 	the composition rectangle of the paragraph."	destX _ textStyle				nextTabXFrom: destX leftMargin: leftMargin rightMargin: rightMargin.	destX > rightMargin ifTrue:	[^self crossedX].	lastIndex _ lastIndex + 1.	^false! !!CompositionScanner methodsFor: 'accessing' stamp: 'ar 1/8/2000 14:35'!rightX	"Meaningful only when a line has just been composed -- refers to the 	line most recently composed. This is a subtrefuge to allow for easy 	resizing of a composition rectangle to the width of the maximum line. 	Useful only when there is only one line in the form or when each line 	is terminated by a carriage return. Handy for sizing menus and lists."	^spaceX! !!CompositionScanner methodsFor: 'intialize-release' stamp: 'ar 5/17/2000 19:14'!forParagraph: aParagraph	"Initialize the receiver for scanning the given paragraph."	self		initializeFromParagraph: aParagraph		clippedBy: aParagraph clippingRectangle.! !Instances of this class hold the data resulting from compressing a sound.  Each carries a reference to the codec class that created it, so that it can reconstruct a sound similar to the original in response to the message asSound.In order to facilitate integration with existing sounds, a CompressedSoundData instance can masquerade as a sound by caching a copy of its original sound and delegating the essential sound-playing protocol to that cached copy.  It should probably be made a subclass of AbstractSound to complete the illusion.!!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 08:10'!channels	"Answer an array of ByteArrays containing the compressed sound data for each channel."	^ channels! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:34'!channels: anArray	channels _ anArray.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:34'!codecName	"Answer the name of the sound codec used to compress this sound. Typically, this is the name of a class that can be used to decode the sound, but it is possible that the codec has not yet been implemented or is not filed into this image."	^ codecName! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:45'!codecName: aStringOrSymbol	codecName _ aStringOrSymbol asSymbol.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:56'!firstSample	"Answer the firstSample of the original sound."	^ firstSample! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:56'!firstSample: anInteger	firstSample _ anInteger.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:55'!gain	"Answer the gain of the original sound."	^ gain! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:56'!gain: aNumber	gain _ aNumber.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 08:11'!loopEnd	"Answer index of the last sample of the loop, or nil if the original sound was not looped."	^ loopEnd! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:35'!loopEnd: anInteger	loopEnd _ anInteger.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 08:11'!loopLength	"Answer length of the loop, or nil if the original sound was not looped."	^ loopLength! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:35'!loopLength: anInteger	loopLength _ anInteger.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:39'!perceivedPitch	"Answer the perceived pitch of the original sound. By convention, unpitched sounds (like drum hits) are given an arbitrary pitch of 100.0."	^ perceivedPitch! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:39'!perceivedPitch: aNumber	perceivedPitch _ aNumber.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 08:13'!samplingRate	"Answer the samplingRate of the original sound."	^ samplingRate! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:36'!samplingRate: aNumber	samplingRate _ aNumber.! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:46'!soundClassName	"Answer the class name of the uncompressed sound."	^ soundClassName! !!CompressedSoundData methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:46'!soundClassName: aStringOrSymbol	soundClassName _ aStringOrSymbol asSymbol.! !!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 08:15'!asSound	"Answer the result of decompressing the receiver."	| codecClass |	codecClass _ Smalltalk at: codecName		ifAbsent: [^ self error: 'The codec for decompressing this sound is not available'].	^ (codecClass new decompressSound: self) reset! !!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 08:49'!doControl	cachedSound doControl! !!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 08:49'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	cachedSound mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol! !!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 20:49'!reset	"This message is the cue to start behaving like a real sound in order to be played.	We do this by caching a decompressed version of this sound.	See also samplesRemaining."	cachedSound == nil ifTrue: [cachedSound _ self asSound].	cachedSound reset! !!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 20:44'!samples	^ self asSound samples! !!CompressedSoundData methodsFor: 'asSound' stamp: 'di 2/17/1999 20:49'!samplesRemaining	"This message is the cue that the cached sound may no longer be needed.	We know it is done playing when samplesRemaining=0."	| samplesRemaining |	samplesRemaining _ cachedSound samplesRemaining.	samplesRemaining <= 0 ifTrue: [cachedSound _ nil].	^ samplesRemaining! !To the instruction parsing ability of InstructionStream I add the actual semantics for execution. The execution state is stored in the indexable fields of my subclasses. This includes temporary variables and a stack of values used in evaluating expressions. The actual semantics of execution can be found in my category "system simulation" and "instruction decode". These methods exactly parallel the operation of the Smalltalk machine itself.	The simulator is a group of my methods that do what the Smalltalk interpreter does: execute Smalltalk bytecodes. By adding code to the simulator, you may take statistics on the running of Smalltalk methods. For example,	Transcript show: (ContextPart runSimulated: [3 factorial]) printString.!!ContextPart methodsFor: 'instruction decoding' stamp: 'jm 6/1/2003 23:18'!jump: distance if: condition 	"Simulate the action of a 'conditional jump' bytecode whose offset is the 	argument, distance, and whose condition is the argument, condition."	(self pop == condition) ifTrue: [self jump: distance]! !!ContextPart methodsFor: 'instruction decoding' stamp: 'ar 5/25/2000 20:45'!send: selector super: superFlag numArgs: numArgs	"Simulate the action of bytecodes that send a message with selector, 	selector. The argument, superFlag, tells whether the receiver of the 	message was specified with 'super' in the source method. The arguments 	of the message are found in the top numArgs locations on the stack and 	the receiver just below them."	| receiver arguments answer |	arguments _ Array new: numArgs.	numArgs to: 1 by: -1 do: [ :i | arguments at: i put: self pop].	receiver _ self pop.	(selector == #halt or: [selector == #halt:]) ifTrue:		[self error: 'Cant simulate halt.  Proceed to bypass it.'.		self push: nil. ^self].	selector == #doPrimitive:method:receiver:args:		ifTrue: [answer _ receiver 					doPrimitive: (arguments at: 1)					method: (arguments at: 2)					receiver: (arguments at: 3)					args: (arguments at: 4).				self push: answer.				^self].	^self send: selector to: receiver with: arguments super: superFlag! !!ContextPart methodsFor: 'debugger access' stamp: 'ls 12/5/1999 13:43'!mclass 	"Answer the class in which the receiver's method was found."	| mclass |	self receiver class selectorAtMethod: self method setClass: [:mc |mclass _ mc ].	^mclass! !!ContextPart methodsFor: 'debugger access' stamp: 'di 8/31/1999 09:42'!shortStack	"Answer a String showing the top ten contexts on my sender chain."	^ String streamContents:		[:strm |		(self stackOfSize: 10)			do: [:item | strm print: item; cr]]! !!ContextPart methodsFor: 'debugger access' stamp: 'ar 7/9/1999 19:01'!sourceCode	| selector methodClass |	selector _ self receiver class selectorAtMethod: self method		setClass: [:mclass | methodClass _ mclass].	^self method getSourceFor: selector in: methodClass	"Note: The above is a bit safer than		^ methodClass sourceCodeAt: selector	which may fail if the receiver's method has been changed in	the debugger (e.g., the method is no longer in the methodDict	and thus the above selector is something like #Doit:with:with:with:)	but the source code is still available."! !!ContextPart methodsFor: 'debugger access' stamp: 'jm 5/23/2003 11:51'!stackOfSize: limit 	"Answer an OrderedCollection of the top 'limit' contexts on the receiver's sender chain."	| a stack |	stack _ OrderedCollection new.	stack addLast: (a _ self).	[(a _ a sender) ~~ nil and: [stack size < limit]]		whileTrue: [stack addLast: a].	^ stack! !!ContextPart methodsFor: 'debugger access' stamp: 'ls 10/10/1999 13:53'!tempNames	"Answer an OrderedCollection of the names of the receiver's temporary 	variables, which are strings."	| names |	self method setTempNamesIfCached: [:n | ^n].	names _ (self mclass compilerClass new			parse: self sourceCode			in: self mclass			notifying: nil) tempNames.	self method cacheTempNames: names.	^names! !!ContextPart methodsFor: 'controlling' stamp: 'di 10/23/1999 17:03'!blockCopy: numArgs 	"Primitive. Distinguish a block of code from its enclosing method by 	creating a new BlockContext for that block. The compiler inserts into all 	methods that contain blocks the bytecodes to send the message 	blockCopy:. Do not use blockCopy: in code that you write!! Only the 	compiler can decide to send the message blockCopy:. Fail if numArgs is 	not a SmallInteger. Optional. No Lookup. See Object documentation 	whatIsAPrimitive."	<primitive: 80>	^ (BlockContext newForMethod: self home method)		home: self home		startpc: pc + 2		nargs: numArgs! !!ContextPart methodsFor: 'controlling' stamp: 'di 1/11/1999 22:40'!pop	"Answer the top of the receiver's stack and remove the top of the stack."	| val |	val _ self at: stackp.	self stackp: stackp - 1.	^ val! !!ContextPart methodsFor: 'controlling' stamp: 'di 1/11/1999 22:39'!push: val 	"Push val on the receiver's stack."	self stackp: stackp + 1.	self at: stackp put: val! !!ContextPart methodsFor: 'controlling' stamp: 'jm 5/15/2003 23:09'!send: selector to: rcvr with: args super: superFlag 	"Simulate the action of sending a message with selector, selector, and 	arguments, args, to receiver. The argument, superFlag, tells whether the 	receiver of the message was specified with 'super' in the source method."	| class meth val |	class _ superFlag			ifTrue: [(self method literalAt: self method numLiterals) value superclass]			ifFalse: [rcvr class].	meth _ class lookupSelector: selector.	meth == nil		ifTrue: [^ self send: #doesNotUnderstand:					to: rcvr					with: (Array with: (Message selector: selector arguments: args))					super: superFlag]		ifFalse: [val _ self tryPrimitiveFor: meth						receiver: rcvr						args: args.				val == PrimitiveFailToken ifFalse: [^ val].				^ self activateMethod: meth					withArgs: args					receiver: rcvr					class: class]! !!ContextPart methodsFor: 'controlling' stamp: 'crl 2/26/1999 15:34'!terminate	"Make myself unresumable."	sender _ nil! !!ContextPart methodsFor: 'printing' stamp: 'ls 10/10/1999 11:57'!printOn: aStream 	| selector class mclass |	self method == nil ifTrue: [^ super printOn: aStream].	selector _ 		(class _ self receiver class) 			selectorAtMethod: self method 			setClass: [:c | mclass _ c].	selector == #?		ifTrue: 			[aStream nextPut: $?; print: self method who.			^self].	aStream nextPutAll: class name.	mclass == class 		ifFalse: 			[aStream nextPut: $(.			aStream nextPutAll: mclass name.			aStream nextPut: $)].	aStream nextPutAll: '>>'.	aStream nextPutAll: selector! !!ContextPart methodsFor: 'private' stamp: 'ar 5/25/2000 20:47'!doPrimitive: primitiveIndex method: meth receiver: receiver args: arguments 	"Simulate a primitive method whose index is primitiveIndex.  The	simulated receiver and arguments are given as arguments to this message."	| value |	<primitive: 19> "Simulation guard"	"If successful, push result and return resuming context,		else ^ PrimitiveFailToken"	(primitiveIndex = 19) ifTrue:[		Debugger 			openContext: self			label:'Code simulation error'			contents: self shortStack].	(primitiveIndex = 80 and: [receiver isKindOf: ContextPart])		ifTrue: [^self push: ((BlockContext newForMethod: receiver home method)						home: receiver home						startpc: pc + 2						nargs: (arguments at: 1))].	(primitiveIndex = 81 and: [receiver isMemberOf: BlockContext])		ifTrue: [^receiver pushArgs: arguments from: self].	primitiveIndex = 83 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: arguments allButFirst					super: false].	primitiveIndex = 84 "afr 9/11/1998 19:50"		ifTrue: [^ self send: arguments first to: receiver					with: (arguments at: 2)					super: false].	arguments size > 6 ifTrue: [^ PrimitiveFailToken].	primitiveIndex = 117 		ifTrue:[value _ self tryNamedPrimitiveIn: meth for: receiver withArgs: arguments]		ifFalse:[value _ receiver tryPrimitive: primitiveIndex withArgs: arguments].	value == PrimitiveFailToken		ifTrue: [^ PrimitiveFailToken]		ifFalse: [^ self push: value]! !!ContextPart methodsFor: 'private' stamp: 'di 1/11/1999 10:12'!push: numObjects fromIndexable: anIndexableCollection	"Push the elements of anIndexableCollection onto the receiver's stack.	 Do not call directly.  Called indirectly by {1. 2. 3} constructs."	1 to: numObjects do:		[:i | self push: (anIndexableCollection at: i)]! !!ContextPart methodsFor: 'private' stamp: 'di 10/23/1999 17:31'!stackp: newStackp	"Storing into the stack pointer is a potentially dangerous thing.	This primitive stores nil into any cells that become accessible as a result,	and it performs the entire operation atomically."	"Once this primitive is implemented, failure code should cause an error"	<primitive: 76>	self error: 'stackp store failure'."	stackp == nil ifTrue: [stackp _ 0].	newStackp > stackp  'effectively checks that it is a number'		ifTrue: [oldStackp _ stackp.				stackp _ newStackp.				'Nil any newly accessible cells'				oldStackp + 1 to: stackp do: [:i | self at: i put: nil]]		ifFalse: [stackp _ newStackp]"! !!ContextPart methodsFor: 'private' stamp: 'ar 5/25/2000 20:41'!tryNamedPrimitiveIn: aCompiledMethod for: aReceiver withArgs: arguments	"Hack. Attempt to execute the named primitive from the given compiled method"	| selector theMethod spec |	arguments size > 8 ifTrue:[^PrimitiveFailToken].	selector _ #(		tryNamedPrimitive 		tryNamedPrimitive: 		tryNamedPrimitive:with: 		tryNamedPrimitive:with:with: 		tryNamedPrimitive:with:with:with:		tryNamedPrimitive:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:		tryNamedPrimitive:with:with:with:with:with:with:with:) at: arguments size+1.	theMethod _ aReceiver class lookupSelector: selector.	theMethod == nil ifTrue:[^PrimitiveFailToken].	spec _ theMethod literalAt: 1.	spec replaceFrom: 1 to: spec size with: (aCompiledMethod literalAt: 1) startingAt: 1.	^aReceiver perform: selector withArguments: arguments! !!ContextPart methodsFor: 'private' stamp: 'ar 5/25/2000 20:45'!tryPrimitiveFor: method receiver: receiver args: arguments 	"If this method has a primitive index, then run the primitive and return its result.	Otherwise (and also if the primitive fails) return PrimitiveFailToken,	as an indication that the method should be activated and run as bytecodes."	| primIndex |	(primIndex _ method primitive) = 0 ifTrue: [^ PrimitiveFailToken].	^ self doPrimitive: primIndex method: method receiver: receiver args: arguments! !!ContextPart class methodsFor: 'examples' stamp: 'sma 4/22/2000 17:03'!trace: aBlock		"ContextPart trace: [3 factorial]"	"This method uses the simulator to print calls and returned values in the Transcript."	Transcript clear.	^ self trace: aBlock on: Transcript! !!ContextPart class methodsFor: 'examples' stamp: 'sma 4/22/2000 17:03'!trace: aBlock on: aStream		"ContextPart trace: [3 factorial]"	"This method uses the simulator to print calls to a file."	| prev |	prev _ aBlock.	^ thisContext sender		runSimulated: aBlock		contextAtEachStep:			[:current |			Sensor anyButtonPressed ifTrue: [^ nil].			current == prev				ifFalse:					[prev sender ifNil:						[aStream space; nextPut: $^.						self carefullyPrint: current top on: aStream].					aStream cr.					(current depthBelow: aBlock) timesRepeat: [aStream space].					self carefullyPrint: current receiver on: aStream.					aStream space; nextPutAll: current selector; flush.					prev _ current]]! !!ContextPart class methodsFor: 'examples' stamp: 'jm 5/23/2003 11:09'!trace: aBlock onFileNamed: fileName	"This method uses the simulator to print calls to a file."	"ContextPart trace: [3 factorial] onFileNamed: 'trace'"	| aStream |	aStream _ FileStream newFileNamed: fileName.	self trace: aBlock on: aStream.	aStream close.! !!ContextPart class methodsFor: 'simulation' stamp: 'di 2/10/1999 22:15'!initialize	"A unique object to be returned when a primitive fails during simulation"	PrimitiveFailToken _ Object new  ! !!ContextPart class methodsFor: 'simulation' stamp: 'di 2/10/1999 22:15'!primitiveFailToken	^ PrimitiveFailToken! !!ContextPart class methodsFor: 'instance creation' stamp: 'di 10/23/1999 17:09'!basicNew: size	self error: 'Contexts must only be created with newForMethod:'! !!ContextPart class methodsFor: 'instance creation' stamp: 'di 10/23/1999 17:09'!new	self error: 'Contexts must only be created with newForMethod:'! !!ContextPart class methodsFor: 'instance creation' stamp: 'di 10/23/1999 17:09'!new: size	self error: 'Contexts must only be created with newForMethod:'! !!ContextPart class methodsFor: 'instance creation' stamp: 'di 10/23/1999 17:55'!newForMethod: aMethod	"This is the only method for creating new contexts, other than primitive cloning.	Any other attempts, such as inherited methods like shallowCopy, should be	avoided or must at least be rewritten to determine the proper size from the	method being activated.  This is because asking a context its size (even basicSize!!)	will not return the real object size but only the number of fields currently	accessible, as determined by stackp."	^ super basicNew: aMethod frameSize! !!ContextPart class methodsFor: 'private' stamp: 'jm 5/22/2003 20:32'!carefullyPrint: anObject on: aStream	aStream nextPutAll:		([anObject printString] ifError: ['an unprintable ', anObject class name])! !I represent a query path into the internal representation of a ContextPart. Typically this is a context at a point in the query path of a Debugger. As a StringHolder, the string I represent is the value of the currently selected variable of the observed temporary variable of the context.!!ContextVariablesInspector methodsFor: 'selecting' stamp: 'ar 5/29/1998 18:32'!selection 	"Refer to the comment in Inspector|selection."	selectionIndex = 0 ifTrue:[^''].	selectionIndex = 1 ifTrue: [^object].	selectionIndex = 2		ifTrue: [^object tempsAndValues]		ifFalse: [^object tempAt: selectionIndex - 2]! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel	^ channel! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel: midiChannel	channel _ midiChannel.! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!control	^ control! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!control: midiControl	control _ midiControl.! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:03'!control: midiControl value: midiControlValue channel: midiChannel	control _ midiControl.	value _ midiControlValue.	channel _ midiChannel.! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:02'!value	^ value! !!ControlChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 08:03'!value: midiControlValue	value _ midiControlValue.! !!ControlChangeEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:45'!isControlChange	^ true! !!ControlChangeEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port."	aMidiPort		midiCmd: 16rB0		channel: channel		byte: control		byte: value.! !!ControlChangeEvent methodsFor: 'printing' stamp: 'sma 6/1/2000 09:34'!printOn: aStream	aStream		nextPut: $(;		print: time;		nextPutAll: ': ctrl[';		print: control;		nextPutAll: ']=';		print: value;		nextPut: $)! !I represent the top level control over scheduling which controller of a view on the screen the user is actively using. ScheduledControllers is the global reference to an instance of me, the one attached to the Project currently being used.!!ControlManager methodsFor: 'accessing' stamp: 'ar 6/5/1998 21:49'!activeController: aController 	"Set aController to be the currently active controller. Give the user 	control in it."	<primitive: 19> "Simulation guard"	activeController _ aController.	(activeController == screenController)		ifFalse: [self promote: activeController].	activeControllerProcess _ 			[activeController startUp.			self searchForActiveController] newProcess.	activeControllerProcess priority: Processor userSchedulingPriority.	activeControllerProcess resume! !!ControlManager methodsFor: 'scheduling' stamp: 'wod 6/17/1998 15:46'!findWindowSatisfying: aBlock	"Present a menu of window titles, and activate the one that gets chosen"	| sortAlphabetically controllers listToUse labels index |	sortAlphabetically _ Sensor shiftPressed.	controllers _ OrderedCollection new.	scheduledControllers do: [:controller |		controller == screenController ifFalse:			[(aBlock value: controller) ifTrue: [controllers addLast: controller]]].	controllers size == 0 ifTrue: [^ self].	listToUse _ sortAlphabetically		ifTrue: [controllers asSortedCollection: [:a :b | a view label < b view label]]		ifFalse: [controllers].	labels _ String streamContents:		[:strm | 			listToUse do: [:controller | strm nextPutAll: (controller view label contractTo: 40); cr].		strm skip: -1  "drop last cr"].	index _ (PopUpMenu labels: labels) startUp.	index > 0 ifTrue:		[self activateController: (listToUse at: index)].! !!ControlManager methodsFor: 'scheduling' stamp: 'ar 11/19/1998 18:31'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label. Make the Notifier the active controller."	| suspendingList newActiveController |	(suspendingList _ activeControllerProcess suspendingList) == nil		ifTrue: [activeControllerProcess == Processor activeProcess					ifTrue: [activeControllerProcess suspend]]		ifFalse: [suspendingList remove: activeControllerProcess ifAbsent:[].				activeControllerProcess offList].	activeController ~~ nil ifTrue: [		"Carefully de-emphasis the current window."		activeController view topView deEmphasizeForDebugger].	newActiveController _		(Debugger			openInterrupt: labelString			onProcess: activeControllerProcess) controller.	newActiveController centerCursorInView.	self activeController: newActiveController.! !!ControlManager methodsFor: 'scheduling' stamp: 'ar 6/5/1998 21:48'!scheduleActive: aController 	"Make aController be scheduled as the active controller. Presumably the 	active scheduling process asked to schedule this controller and that a 	new process associated this controller takes control. So this is the last act 	of the active scheduling process."	<primitive: 19> "Simulation guard"	self scheduleActiveNoTerminate: aController.	Processor terminateActive! !!ControlManager methodsFor: 'scheduling'!scheduleActiveNoTerminate: aController 	"Make aController be the active controller. Presumably the process that 	requested the new active controller wants to keep control to do more 	activites before the new controller can take control. Therefore, do not 	terminate the currently active process."	self schedulePassive: aController.	self scheduled: aController		from: Processor activeProcess! !!ControlManager methodsFor: 'displaying' stamp: 'hmm 1/5/2000 07:00'!restore: aRectangle	"Restore all windows visible in aRectangle"	^ self restore: aRectangle without: nil! !!ControlManager methodsFor: 'displaying' stamp: 'jm 5/29/2003 17:57'!restore: aRectangle below: index without: aView	"Restore all windows visible in aRectangle, but without aView"	| view | 	view _ (scheduledControllers at: index) view.	view == aView ifTrue: 		[index >= scheduledControllers size ifTrue: [^ self].		^ self restore: aRectangle below: index+1 without: aView].	view displayOn: ((BitBlt toForm: Display) clipRect: aRectangle).	index >= scheduledControllers size ifTrue: [^ self].	(aRectangle areasOutside: view windowBox) do:		[:rect | self restore: rect below: index + 1 without: aView]! !!ControlManager methodsFor: 'displaying' stamp: 'hmm 12/30/1999 19:35'!restore: aRectangle without: aView	"Restore all windows visible in aRectangle"	Display deferUpdates: true.	self restore: aRectangle below: 1 without: aView.	Display deferUpdates: false; forceToScreen: aRectangle! !!ControlManager methodsFor: 'private' stamp: 'sw 12/6/1999 23:40'!unCacheWindows	scheduledControllers ifNotNil: [scheduledControllers do:		[:aController | aController view uncacheBits]]! !!ControlManager class methodsFor: 'snapshots' stamp: 'jm 1/1/2004 11:08'!shutDown	"Clear MVC window caches to save space in snapshots."	Smalltalk isMorphic ifFalse: [ScheduledControllers unCacheWindows].! !!ControlManager class methodsFor: 'snapshots' stamp: 'jm 1/1/2004 11:16'!startUp	Smalltalk isMorphic ifFalse: [ScheduledControllers restore].! !A Controller coordinates a View, its model, and user actions. It provides scheduling (control) behavior to determine when the user wants to communicate with the model or view.!!Controller methodsFor: 'basic control sequence' stamp: 'ls 7/11/1998 06:33'!controlLoop 	"Sent by Controller|startUp as part of the standard control sequence. 	Controller|controlLoop sends the message Controller|isControlActive to test 	for loop termination. As long as true is returned, the loop continues. 	When false is returned, the loop ends. Each time through the loop, the 	message Controller|controlActivity is sent."	[self isControlActive] whileTrue: [		self interActivityPause. self controlActivity. Processor yield]! !!Controller methodsFor: 'basic control sequence' stamp: 'di 4/27/2000 20:23'!interActivityPause	"if we are looping quickly, insert a short delay.  Thus if we are just doing UI stuff, we won't take up much CPU"	| currentTime wait |	MinActivityLapse ifNotNil: [		lastActivityTime ifNotNil: [ 			currentTime _ Time millisecondClockValue.			wait _ lastActivityTime + MinActivityLapse - currentTime.			wait > 0 ifTrue: [ 				wait < MinActivityLapse  "big waits happen after a snapshot"					ifTrue: [DisplayScreen checkForNewScreenSize.							(Delay forMilliseconds: wait) wait ]. ]. ]. ].	lastActivityTime _ Time millisecondClockValue.! !!Controller methodsFor: 'basic control sequence' stamp: 'jm 1/1/2004 11:16'!startUp	"Give control to the receiver. The default control sequence is to initialize 	(see Controller|controlInitialize), to loop (see Controller|controlLoop), and 	then to terminate (see Controller|controlTerminate). After this sequence, 	control is returned to the sender of Control|startUp. The receiver's control 	sequence is used to coordinate the interaction of its view and model. In 	general, this consists of polling the sensor for user input, testing the 	input with respect to the current display of the view, and updating the 	model to reflect intended changes."	self controlInitialize.	self controlLoop.	self controlTerminate.! !!Controller methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:23'!isControlActive	"Answer whether receiver wishes to continue evaluating its controlLoop 	method. It is sent by Controller|controlLoop in order to determine when 	the receiver's control loop should terminate, and should be redefined in 	a subclass if some special condition for terminating the main control loop 	is needed."	^ self viewHasCursor		and: [sensor blueButtonPressed not		and: [sensor yellowButtonPressed not]]! !!Controller methodsFor: 'cursor' stamp: 'sw 7/13/1999 18:42'!viewHasCursor	"Answer whether the cursor point of the receiver's sensor lies within the 	inset display box of the receiver's view (see View|insetDisplayBox). 	Controller|viewHasCursor is normally used in internal methods."	^ view ifNotNil: [view containsPoint: sensor cursorPoint] ifNil: [false]! !!Controller class methodsFor: 'initialization' stamp: 'ls 7/13/1998 00:47'!MinActivityLapse: milliseconds	"minimum time to delay between calls to controlActivity"	MinActivityLapse _ milliseconds ifNotNil: [ milliseconds rounded ].! !!Controller class methodsFor: 'initialization' stamp: 'ls 7/13/1998 00:47'!initialize	"Controller initialize"	self MinActivityLapse: 10.! !This class is a quick hack to support rounded corners in morphic.Rather than produce rounded rectangles, it tweaks the display of corners.Rather than work for any radius, it only supports a radius of 6.Rather than work for any border width, it only supports widths 0, 1 and 2.The corners, while apparently transparent, still behave opaquely to mouse clicks.Worse than this, the approach relies on the ability to extract underlying bits from the canvas prior to display.  This ran afoul of top-down display, it seems, in SystemWindow spawnReframeHandle: (qv).  It will also make a postscript printer very unhappy.But, hey, it's cute.!!CornerRounder methodsFor: 'all' stamp: 'di 6/24/1999 09:35'!masterMask: maskForm masterOverlay: overlayForm	cornerMasks _ #(none left pi right) collect:		[:dir | (maskForm rotateBy: dir centerAt: 0@0) offset: 0@0].	cornerOverlays _ #(none left pi right) collect:		[:dir | (overlayForm rotateBy: dir centerAt: 0@0) offset: 0@0].! !!CornerRounder methodsFor: 'all' stamp: 'ar 2/12/2000 18:33'!saveBitsUnderCornersOf: aMorph on: aCanvas	| offset corner mask form |	underBits _ (1 to: 4) collect:		[:i | 		mask _ cornerMasks at: i.		corner _ aMorph bounds corners at: i.		i = 1 ifTrue: [offset _ 0@0].		i = 2 ifTrue: [offset _ 0@mask height negated].		i = 3 ifTrue: [offset _ mask extent negated].		i = 4 ifTrue: [offset _ mask width negated@0].		form _ aCanvas contentsOfArea: (corner + offset extent: mask extent).		form copyBits: form boundingBox from: mask at: 0@0 clippingBox: form boundingBox rule: Form and fillColor: nil map: (Bitmap with: 16rFFFFFFFF with: 0)].! !!CornerRounder methodsFor: 'all' stamp: 'ar 3/24/2000 01:10'!tweakCornersOf: aMorph on: aCanvas borderWidth: w	| offset corner saveBits c fourColors c14 c23 mask nonShadowCanvas outBits |	nonShadowCanvas _ aCanvas copy shadowColor: nil.	w > 0 ifTrue:		[c _ aMorph borderColor.		fourColors _ Array new: 4 withAll: c.		c == #raised ifTrue:			[c _ aMorph color.			w = 1				ifTrue: [c14 _ c twiceLighter. c23 _ c twiceDarker]				ifFalse: [c14 _ c lighter. c23 _ c darker].			fourColors _ Array with: c14 with: c with: c23 with: c].		(c == #inset and: [aMorph owner notNil]) ifTrue:			[c _ aMorph owner colorForInsets.			w = 1				ifTrue: [c14 _ c twiceLighter. c23 _ c twiceDarker]				ifFalse: [c14 _ c lighter. c23 _ c darker].			fourColors _ Array with: c23 with: c with: c14 with: c]].	mask _ Form extent: cornerMasks first extent depth: aCanvas depth.	(1 to: 4) do:		[:i | 		corner _ aMorph bounds corners at: i.		saveBits _ underBits at: i.		i = 1 ifTrue: [offset _ 0@0].		i = 2 ifTrue: [offset _ 0@saveBits height negated].		i = 3 ifTrue: [offset _ saveBits extent negated].		i = 4 ifTrue: [offset _ saveBits width negated@0].		"Mask out corner area (painting saveBits won't clear if transparent)."		mask copyBits: mask boundingBox from: (cornerMasks at: i) at: 0@0 clippingBox: mask boundingBox rule: Form over fillColor: nil map: (Bitmap with: 0 with: 16rFFFFFFFF).		outBits _ aCanvas contentsOfArea: (corner + offset extent: mask extent).		mask displayOn: outBits at: 0@0 rule: Form and.		"Paint back corner bits."		saveBits displayOn: outBits at: 0@0 rule: Form paint.		nonShadowCanvas drawImage: outBits at: corner + offset.		w > 0 ifTrue:			["Paint over with border if any"			aCanvas stencil: (cornerOverlays at: i) at: corner + offset					color: (fourColors at: i)]].! !!CornerRounder methodsFor: 'all' stamp: 'ar 2/12/2000 18:31'!tweakCornersOf: aMorph on: aCanvas borderWidth: w corners: cornerList	"This variant has a cornerList argument, to allow some corners to be rounded and others not"	| offset corner saveBits c fourColors c14 c23 insetColor mask outBits |	w > 0 ifTrue:		[c _ aMorph borderColor.		fourColors _ Array new: 4 withAll: c.		c == #raised ifTrue:			[c14 _ aMorph color lighter. c23 _ aMorph color darker.			fourColors _ Array with: c14 with: c23 with: c23 with: c14].		(c == #inset and: [aMorph owner notNil]) ifTrue:			[insetColor _ aMorph owner colorForInsets.			c14 _ insetColor lighter. c23 _ insetColor darker.			fourColors _ Array with: c14 with: c23 with: c23 with: c14]].	mask _ Form extent: cornerMasks first extent depth: aCanvas depth.	(1 to: 4) do: 		[:i | (cornerList includes: i) ifTrue:			[corner _ aMorph bounds corners at: i.			saveBits _ underBits at: i.			i = 1 ifTrue: [offset _ 0@0].			i = 2 ifTrue: [offset _ 0@saveBits height negated].			i = 3 ifTrue: [offset _ saveBits extent negated].			i = 4 ifTrue: [offset _ saveBits width negated@0].			"Mask out corner area (painting saveBits won't clear if transparent)."			mask copyBits: mask boundingBox from: (cornerMasks at: i) at: 0@0 clippingBox: mask boundingBox rule: Form over fillColor: nil map: (Bitmap with: 0 with: 16rFFFFFFFF).			outBits _ aCanvas contentsOfArea: (corner + offset extent: mask extent).			mask displayOn: outBits at: 0@0 rule: Form and.			"Paint back corner bits."			saveBits displayOn: outBits at: 0@0 rule: Form paint.			"Paint back corner bits."			aCanvas drawImage: outBits at: corner + offset.			w > 0 ifTrue:				["Paint over with border if any"				aCanvas stencil: (cornerOverlays at: i) at: corner + offset						color: (fourColors at: i)]]]! !!CornerRounder class methodsFor: 'all' stamp: 'di 6/28/1999 15:51'!initialize  "CornerRounder initialize"	CR0 _ CR1 _ self new		masterMask:			(Form extent: 6@6				fromArray: #(2r1e26 2r111e26 2r1111e26 2r11111e26 2r11111e26 2r111111e26)				offset: 0@0)		masterOverlay:			(Form extent: 6@6				fromArray: #(2r1e26 2r110e26 2r1000e26 2r10000e26 2r10000e26 2r100000e26)				offset: 0@0).	CR2 _ self new		masterMask:			(Form extent: 6@6				fromArray: #(2r1e26 2r111e26 2r1111e26 2r11111e26 2r11111e26 2r111111e26)				offset: 0@0)		masterOverlay:			(Form extent: 6@6				fromArray: #(2r1e26 2r111e26 2r1111e26 2r11100e26 2r11000e26 2r111000e26)				offset: 0@0).! !!CornerRounder class methodsFor: 'all' stamp: 'di 3/25/2000 11:12'!rectWithinCornersOf: aRectangle	"Return a single sub-rectangle that lies entirely inside corners	that are made by me.	Used to identify large regions of window that do not need to be redrawn."	^ aRectangle insetBy: 0@6! !!CornerRounder class methodsFor: 'all' stamp: 'hmm 3/8/2000 17:42'!roundCornersOf: aMorph on: aCanvas displayBlock: displayBlock borderWidth: w	| rounder |	rounder _ CR0.	w = 1 ifTrue: [rounder _ CR1].	w = 2 ifTrue: [rounder _ CR2].	rounder _ rounder copy.	rounder saveBitsUnderCornersOf: aMorph on: aCanvas.	displayBlock value.	rounder tweakCornersOf: aMorph on: aCanvas borderWidth: w! !!CornerRounder class methodsFor: 'all' stamp: 'hmm 3/8/2000 17:42'!roundCornersOf: aMorph on: aCanvas displayBlock: displayBlock borderWidth: w corners: aList	| rounder |	rounder _ CR0.	w = 1 ifTrue: [rounder _ CR1].	w = 2 ifTrue: [rounder _ CR2].	rounder _ rounder copy.	rounder saveBitsUnderCornersOf: aMorph on: aCanvas.	displayBlock value.	rounder tweakCornersOf: aMorph on: aCanvas borderWidth: w corners: aList! !!CoupledOscSim methodsFor: 'as yet unclassified' stamp: 'jm 6/15/2003 20:16'!graphData	SimpleWaveEditor openOn: data.! !!CoupledOscSim methodsFor: 'as yet unclassified' stamp: 'jm 5/14/2003 20:23'!init: n	| rand |	rand _ Random new.	oscillators _ (1 to: n) collect: [:i | 100.0 * rand next].	data _ OrderedCollection new: 1000.! !!CoupledOscSim methodsFor: 'as yet unclassified' stamp: 'jm 5/14/2003 18:49'!plotAll	| f w h x |	w _ 5.	h _ 100.	f _ Form extent: (w * oscillators size)@100 depth: 1.	1 to: oscillators size do: [:i |		x _ w * (i - 1).		f fillBlack: (x@(h - (oscillators at: i) truncated) corner: (x + w)@h)].	f display.! !!CoupledOscSim methodsFor: 'as yet unclassified' stamp: 'jm 5/14/2003 20:33'!stepAll	| n bumps |	bumps _ 0.	1 to: oscillators size do: [:i |		n _ oscillators at: i.		n _ n + 4.1 - ((4 * n) / 100.0).		n > 100 ifTrue: [bumps _ bumps + 1].		oscillators at: i put: n].	1 to: oscillators size do: [:i |		oscillators at: i put: (oscillators at: i) + (0.05 * bumps)].	1 to: oscillators size do: [:i |		(oscillators at: i) > 100 ifTrue: [oscillators at: i put: 0.0]].	data addLast: (oscillators at: 1).! !!CrLfFileStream methodsFor: 'open/close' stamp: 'ar 1/20/98 16:15'!open: aFileName forWrite: writeMode 	"Open the receiver.  If writeMode is true, allow write, else access will be 	read-only. "	| result |	result _ super open: aFileName forWrite: writeMode.	result ifNotNil: [self detectLineEndConvention].	^ result! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:16'!ascii	super ascii.	self detectLineEndConvention! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:16'!binary	super binary.	lineEndConvention _ nil! !!CrLfFileStream methodsFor: 'access' stamp: 'ls 7/10/1998 23:35'!detectLineEndConvention	"Detect the line end convention used in this stream. The result may be either #cr, #lf or #crlf."	| char numRead pos |	self isBinary ifTrue: [^ self error: 'Line end conventions are not used on binary streams'].	lineEndConvention _ LineEndDefault.	"Default if nothing else found"	numRead _ 0.	pos _ super position.	[super atEnd not and: [numRead < LookAheadCount]]		whileTrue: 			[char _ super next.			char = Lf				ifTrue: 					[super position: pos.					^ lineEndConvention _ #lf].			char = Cr				ifTrue: 					[super peek = Lf						ifTrue: [lineEndConvention _ #crlf]						ifFalse: [lineEndConvention _ #cr].					super position: pos.					^ lineEndConvention].			numRead _ numRead + 1].	super position: pos.	^ lineEndConvention! !!CrLfFileStream methodsFor: 'access' stamp: 'ls 11/5/1998 23:37'!next    | char secondChar |    char _ super next.    self isBinary ifTrue: [^char].    char == Cr ifTrue:        [secondChar _ super next.        secondChar ifNotNil: [secondChar == Lf ifFalse: [self skip: -1]].        ^Cr].    char == Lf ifTrue: [^Cr].    ^char! !!CrLfFileStream methodsFor: 'access' stamp: 'ls 12/29/1998 17:15'!next: n		| string peekChar |		string _ super next: n.		string size = 0 ifTrue: [ ^string ].		self isBinary ifTrue: [ ^string ].		"if we just read a CR, and the next character is an LF, then skip the LF"		( string last = Character cr ) ifTrue: [			peekChar _ super next.		"super peek doesn't work because it relies on #next"			peekChar ~= Character lf ifTrue: [				super position: (super position - 1) ]. ]. 		string _ string withSqueakLineEndings.		string size = n ifTrue: [ ^string ].		"string shrunk due to embedded crlfs; make up the difference"		^string, (self next: n - string size)! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:18'!nextPut: char 	(lineEndConvention notNil and: [char = Cr])		ifTrue: [super nextPutAll: (LineEndStrings at: lineEndConvention)]		ifFalse: [super nextPut: char].	^ char! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:18'!nextPutAll: aString 	super nextPutAll: (self convertStringFromCr: aString).	^ aString! !!CrLfFileStream methodsFor: 'access' stamp: 'wod 6/18/1998 13:52'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next pos |	self atEnd ifTrue: [^ nil].	pos _ self position.	next _ self next.	self position: pos.	^ next! !!CrLfFileStream methodsFor: 'access' stamp: 'wod 11/5/1998 14:15'!upTo: aCharacter	| newStream char |	newStream _ WriteStream on: (String new: 100).	[(char _ self next) isNil or: [char == aCharacter]]		whileFalse: [newStream nextPut: char].	^ newStream contents! !!CrLfFileStream methodsFor: 'access' stamp: 'ar 1/20/98 16:18'!verbatim: aString 	super verbatim: (self convertStringFromCr: aString).	^ aString! !!CrLfFileStream methodsFor: 'private' stamp: 'ar 1/20/98 16:21'!convertStringFromCr: aString 	| inStream outStream |	lineEndConvention ifNil: [^ aString].	lineEndConvention == #cr ifTrue: [^ aString].	lineEndConvention == #lf ifTrue: [^ aString copy replaceAll: Cr with: Lf].	"lineEndConvention == #crlf"	inStream _ ReadStream on: aString.	outStream _ WriteStream on: (String new: aString size).	[inStream atEnd]		whileFalse: 			[outStream nextPutAll: (inStream upTo: Cr).			(inStream atEnd not or: [aString last = Cr])				ifTrue: [outStream nextPutAll: CrLf]].	^ outStream contents! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:10'!defaultToCR	"CrLfFileStream defaultToCR"	LineEndDefault := #cr.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:10'!defaultToCRLF	"CrLfFileStream defaultToCRLF"	LineEndDefault := #crlf.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:10'!defaultToLF	"CrLfFileStream defaultToLF"	LineEndDefault := #lf.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'ar 1/20/98 16:13'!guessDefaultLineEndConvention	"Lets try to guess the line end convention from what we know about the path name delimiter from FileDirectory."	FileDirectory pathNameDelimiter = $: ifTrue:[^self defaultToCR].	FileDirectory pathNameDelimiter = $/ ifTrue:[^self defaultToLF].	FileDirectory pathNameDelimiter = $\ ifTrue:[^self defaultToCRLF].	"in case we don't know"	^self defaultToCR! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'jm 1/1/2004 10:32'!initialize	"CrLfFileStream initialize"	Cr _ Character cr.	Lf _ Character lf.	CrLf _ String with: Cr with: Lf.	LineEndStrings _ Dictionary new.	LineEndStrings at: #cr put: (String with: Character cr).	LineEndStrings at: #lf put: (String with: Character lf).	LineEndStrings at: #crlf put: (String with: Character cr with: Character lf).	LookAheadCount _ 2048.	self startUp.! !!CrLfFileStream class methodsFor: 'class initialization' stamp: 'jm 1/1/2004 11:15'!startUp	self guessDefaultLineEndConvention.! !I am a 16 x 16 dot matrix suitable for use as the Alto hardware cursor.!!Cursor methodsFor: 'displaying' stamp: 'jm 9/22/1998 23:33'!beCursorWithMask: maskForm	"Primitive. Tell the interpreter to use the receiver as the current cursor image with the given mask Form. Both the receiver and the mask should have extent 16@16 and a depth of one. The mask and cursor bits are combined as follow:			mask	cursor	effect			 0		  0		transparent (underlying pixel shows through)			 1		  1		opaque black			 1		  0		opaque white			 0		  1		invert the underlying pixel""Essential. See Object documentation whatIsAPrimitive."	<primitive: 101>	self primitiveFailed! !!Cursor methodsFor: 'displaying' stamp: 'jm 5/23/2003 11:08'!showWhile: aBlock 	"Show this cursor while evaluating the given Block."	| oldcursor value |	oldcursor _ Sensor currentCursor.	self show.	value _ aBlock value.	oldcursor show.	^ value! !!Cursor methodsFor: 'testing' stamp: 'bf 2/2/1999 19:34'!hasMask	^false! !!Cursor methodsFor: 'converting' stamp: 'di 3/7/1999 13:40'!asCursorForm	| form |	form _ Form extent: self extent depth: 8.	form fillShape: self fillColor: Color black at: offset negated.	^ form offset: offset! !!Cursor methodsFor: 'converting' stamp: 'bf 2/2/1999 19:32'!withMask	^CursorWithMask derivedFrom: self! !!Cursor class methodsFor: 'class initialization' stamp: 'di 10/8/1998 17:04'!initNormalWithMask    "Cursor initNormalWithMask.  Cursor normal show"	"Next two lines work simply for any cursor..."	self initNormal.	NormalCursor _ CursorWithMask derivedFrom: NormalCursor.	"But for a good looking cursor, you have to tweak things..."	NormalCursor _ (CursorWithMask extent: 16@16 depth: 1			fromArray: #( 0 1073741824 1610612736 1879048192				2013265920 2080374784 2113929216 2130706432				2080374784 2080374784 1275068416 100663296				100663296 50331648 50331648 0)			offset: -1@-1)		setMaskForm: (Form extent: 16@16 depth: 1			fromArray: #( 3221225472 3758096384 4026531840 4160749568				4227858432 4261412864 4278190080 4286578688				4278190080 4261412864 4261412864 3472883712				251658240 125829120 125829120 50331648)			offset: 0@0).! !!Cursor class methodsFor: 'class initialization' stamp: 'di 3/6/1999 21:27'!initialize	"Create all the standard cursors..."		self initOrigin.		self initRightArrow.		self initMenu.		self initCorner.		self initRead.		self initWrite.		self initWait.		BlankCursor _ Cursor new.		self initXeq.		self initSquare.		self initNormalWithMask.		self initCrossHair.		self initMarker.		self initUp.		self initDown.		self initMove.		self makeCursorsWithMask.		"Cursor initialize"! !!Cursor class methodsFor: 'class initialization' stamp: 'bf 2/2/1999 19:33'!makeCursorsWithMask	"Cursor initialize;makeCursorsWithMask"	self classPool associationsDo: [:var |		var value hasMask			ifFalse: [var value: var value withMask]] ! !!Cursor class methodsFor: 'class initialization' stamp: 'jm 1/1/2004 11:15'!startUp	self currentCursor: self currentCursor.! !!Cursor class methodsFor: 'instance creation' stamp: 'di 10/6/1998 13:53'!new	^ self extent: 16 @ 16		fromArray: (Array new: 16 withAll: 0)		offset: 0 @ 0	"Cursor new bitEdit show"! !!Cursor class methodsFor: 'current cursor' stamp: 'di 10/6/1998 13:57'!currentCursor: aCursor 	"Make the instance of cursor, aCursor, be the current cursor. Display it. 	Create an error if the argument is not a Cursor."	(aCursor isKindOf: self)		ifTrue: [CurrentCursor _ aCursor.				aCursor beCursor]		ifFalse: [self error: 'The new cursor must be an instance of class Cursor']! !!Cursor class methodsFor: 'constants' stamp: 'jm 9/29/2003 10:53'!eyeDropper	"Cursor eyeDropper showWhile: [Sensor waitButton]"	| cursor |	cursor _ CursorWithMask		extent: 16@16		fromArray: #(14 31 31 255 126 184 280 552 1088 2176 4352 8704 17408 18432 45056 16384)		offset: 0@-16.	cursor setMaskForm: (Form		extent: 16@16		depth: 1		fromArray: #(917504 2031616 2031616 16711680 8257536 16252928 33030144 65536000 130023424 260046848 520093696 1040187392 2080374784 2013265920 4026531840 3221225472)		offset: 0@0).	^ cursor! !!Cursor class methodsFor: 'constants' stamp: 'jm 9/29/2003 10:42'!handClosed	"Cursor handOpen showWhile: [Sensor waitButton].	 Cursor handClosed showWhile: [Sensor waitNoButton]"	| cursor |	cursor _ CursorWithMask		extent: 16@16		fromArray: #(0 0 0 448 3704 4686 4105 14337 18434 16386 8194 8196 4100 2056 1032 1032)		offset: -8@-8.	cursor setMaskForm: (Form		extent: 16@16		depth: 1		fromArray: #(0 0 0 29360128 267911168 536739840 536805376 1073676288 2147352576 2147352576 1073610752 1073479680 536608768 267911168 133693440 133693440)		offset: 0@0).	^ cursor! !!Cursor class methodsFor: 'constants' stamp: 'jm 9/29/2003 10:38'!handOpen	"Cursor handOpen showWhile: [Sensor waitButton]"	| cursor |	cursor _ CursorWithMask		extent: 16@16		fromArray: #(384 6768 9800 9802 4685 4681 26633 38913 34818 16386 8194 8196 4100 2056 1032 1032)		offset: -8@-8.	cursor setMaskForm: (Form		extent: 16@16		depth: 1		fromArray: #(25165824 468713472 1073217536 1073348608 536805376 536805376 1878982656 4294901760 4294836224 2147352576 1073610752 1073479680 536608768 267911168 133693440 133693440)		offset: 0@0).	^ cursor! !!CursorWithMask methodsFor: 'as yet unclassified' stamp: 'di 3/7/1999 13:40'!asCursorForm	| form |	form _ Form extent: self extent depth: 8.	form fillShape: maskForm fillColor: Color white.	form fillShape: self fillColor: Color black at: offset negated.	^ form offset: offset! !!CursorWithMask methodsFor: 'as yet unclassified' stamp: 'di 10/6/1998 15:16'!beCursor	maskForm unhibernate.	^ self beCursorWithMask: maskForm! !!CursorWithMask methodsFor: 'as yet unclassified' stamp: 'bf 2/2/1999 19:34'!hasMask	^true! !!CursorWithMask methodsFor: 'as yet unclassified' stamp: 'di 10/8/1998 16:46'!maskForm	^ maskForm! !!CursorWithMask methodsFor: 'as yet unclassified' stamp: 'di 10/8/1998 16:46'!setMaskForm: aForm	maskForm _ aForm! !!CursorWithMask methodsFor: 'as yet unclassified' stamp: 'bf 2/2/1999 19:30'!storeOn: aStream base: anInteger	aStream nextPut: $(.	super storeOn: aStream base: anInteger.	aStream nextPutAll: ' setMaskForm: '.	maskForm storeOn: aStream base: anInteger.	aStream nextPut: $)! !!CursorWithMask methodsFor: 'as yet unclassified' stamp: 'bf 2/2/1999 19:31'!withMask	^self! !!CursorWithMask class methodsFor: 'as yet unclassified' stamp: 'di 2/18/1999 08:56'!derivedFrom: aForm      "Cursor initNormalWithMask.  Cursor normal show"	"aForm is presumably a cursor"	| cursor mask ext |	ext _ aForm extent.	cursor _ self extent: ext.	cursor copy: (1@1 extent: ext) from: 0@0 in: aForm rule: Form over.	mask _ Form extent: ext.	(1@1) eightNeighbors do:		[:p | mask copy: (p extent: ext) from: 0@0 in: aForm rule: Form under].	cursor setMaskForm: mask.	cursor offset: ((aForm offset - (1@1)) max: ext negated).	^ cursor! !I am a subclass of polygon morph whose sides are curves rather than line segments.!!CurveMorph methodsFor: 'private' stamp: 'jm 6/5/2003 21:36'!addHandles	super addHandles.	self updateHandles.! !!CurveMorph methodsFor: 'private' stamp: 'di 1/6/1999 21:59'!coefficients	"Compute an array for the coefficients.  This is copied from Flegal's old	code in the Spline class."	| length extras verts |	coefficients ifNotNil: [^ coefficients].	verts _ closed ifTrue: [vertices copyWith: vertices first]				ifFalse: [vertices].	length _ verts size.	extras _ 0.	coefficients _ Array new: 8.	1 to: 8 do: [:i | coefficients at: i put: (Array new: length + extras)].	1 to: 5 by: 4 do: 		[:k | 		1 to: length do:			[:i | (coefficients at: k)					at: i put: (k = 1						ifTrue: [(verts at: i) x asFloat]						ifFalse: [(verts at: i) y asFloat])].			1 to: extras do: [:i | (coefficients at: k)					at: length + i put: ((coefficients at: k)						at: i + 1)].			self derivs: (coefficients at: k)				first: (coefficients at: k + 1)				second: (coefficients at: k + 2)				third: (coefficients at: k + 3)].	extras > 0 		ifTrue: [1 to: 8 do: 					[:i | 					coefficients at: i put: ((coefficients at: i)											copyFrom: 2 to: length + 1)]].	^ coefficients! !!CurveMorph methodsFor: 'private' stamp: 'jm 7/17/2003 22:52'!curveBounds	"Compute the bounds from actual curve traversal, with leeway for borderWidth.	Also note the next-to-first and next-to-last points for arrow directions."	| curveBounds |	curveBounds _ vertices first corner: vertices last.	coefficients _ nil.  "Force recomputation"	ntfPoint _ nil.	self lineSegmentsDo:		[:p1 :p2 | ntfPoint == nil ifTrue: [ntfPoint _ p2 truncated].		curveBounds _ curveBounds encompass: p2 truncated.		ntlPoint _ p1 truncated].	^ curveBounds expandBy: borderWidth+1//2! !!CurveMorph methodsFor: 'private' stamp: 'ar 6/18/1999 09:36'!getVertices	| vtx |	vtx _ WriteStream on: Array new.	self lineSegmentsDo:[:pt1 :pt2| vtx nextPut: pt1].	^vtx contents! !!CurveMorph methodsFor: 'private' stamp: 'di 1/6/1999 22:01'!lineSegmentsDo: endPointsBlock	"Emit a sequence of line segments into endPointsBlock to approximate this spline."	| n t x y x1 x2 x3 y1 y2 y3 beginPoint endPoint coeffs |	vertices size < 1 ifTrue: [^ self].	coeffs _ self coefficients.	beginPoint _ (x _ (coeffs at: 1) at: 1) @ (y _ (coeffs at: 5) at: 1).	1 to: (coeffs at: 1) size - 1 do: 		[:i |  "taylor series coeffs"		x1 _ (coeffs at: 2) at: i.		y1 _ (coeffs at: 6) at: i.		x2 _ ((coeffs at: 3) at: i) / 2.0.		y2 _ ((coeffs at: 7) at: i) / 2.0.		x3 _ ((coeffs at: 4) at: i) / 6.0.		y3 _ ((coeffs at: 8) at: i) / 6.0.		"guess n"		n _ 5 max: (x2 abs + y2 abs * 2.0 + ((coeffs at: 3) at: i+1) abs									+ ((coeffs at: 7) at: i+1) abs / 100.0) rounded.		1 to: n - 1 do: 			[:j | 			t _ j asFloat / n.			endPoint _ (x3 * t + x2 * t + x1 * t + x) @ (y3 * t + y2 * t + y1 * t + y).			endPointsBlock value: beginPoint							value: endPoint.			beginPoint _ endPoint].		endPoint _ (x _ (coeffs at: 1) at: i+1) @ (y _ (coeffs at: 5) at: i+1).		endPointsBlock value: beginPoint						value: endPoint.		beginPoint _ endPoint]! !!CurveMorph methodsFor: 'private' stamp: 'di 1/6/1999 22:04'!privateMoveBy: delta	super privateMoveBy: delta.	coefficients _ nil.  "Force recomputation"! !!CurveMorph methodsFor: 'private' stamp: 'di 1/6/1999 22:07'!releaseCachedState	super releaseCachedState.	coefficients _ nil.! !!CurveMorph methodsFor: 'private' stamp: 'di 12/17/1998 13:44'!updateHandles	| midPts nextVertIx tweens newVert |	midPts _ OrderedCollection new.	nextVertIx _ 2.	tweens _ OrderedCollection new.	self lineSegmentsDo:		[:p1 :p2 | 		tweens addLast: p2 asIntegerPoint.		p2 = (vertices atWrap: nextVertIx) ifTrue:			["Found endPoint."			midPts addLast: (tweens at: tweens size // 2)						+ (tweens at: tweens size + 1 // 2) // 2.			tweens _ OrderedCollection new.			nextVertIx _ nextVertIx + 1]].	midPts withIndexDo:		[:midPt :vertIndex |		(closed or: [vertIndex < vertices size]) ifTrue:			[newVert _ handles at: vertIndex*2.			newVert position: midPt - (newVert extent // 2)]].! !!CurveMorph class methodsFor: 'as yet unclassified' stamp: 'jm 5/31/2003 20:04'!includeInNewMorphMenu	^ true! !I am used to build menus on-the-fly. I maintain lists of menu items, actions (usually symbols to be sent as messages), and menu section dividing lines to which my clients may append new entries and lines by sending me the messages:	add: aString action: anAction	addLineAfter the menu is constructed, it may be invoked with one of the following messages:	startUp: initialSelection	startUpI am a subclass of ActionMenu, so I inherit a number of instance variables. The ones I am particularly concerned with are:	items _ an OrderedCollection of strings to appear in the menu	selectors _ an OrderedCollection of Symbols to be used as message selectors	lineArray _ an OrderedCollection of line positions	lastLine _ used to keep track of the last line to avoid making duplicate entries in lineArray!!CustomMenu methodsFor: 'initialize-release' stamp: 'sw 8/18/1998 12:01'!title: aTitle	title _ aTitle! !!CustomMenu methodsFor: 'construction' stamp: 'sw 7/20/1999 18:47'!balloonTextForLastItem: aString	"Vacuous backstop provided for compatibility with MorphicMenu"! !!CustomMenu methodsFor: 'construction' stamp: 'jm 8/20/1998 08:34'!labels: aString font: aFont lines: anArrayOrNil	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	| labelList linesArray |	labelList _ (aString findTokens: String cr) asArray.	anArrayOrNil		ifNil: [linesArray _ #()]		ifNotNil: [linesArray _ anArrayOrNil].	1 to: labelList size do: [:i |		self add: (labelList at: i) action: (labelList at: i).		(linesArray includes: i) ifTrue: [self addLine]].	font ifNotNil: [font _ aFont].! !!CustomMenu methodsFor: 'construction' stamp: 'di 8/20/1998 09:24'!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	(labelList isMemberOf: String)		ifTrue: [labelArray _ labelList findTokens: String cr]		ifFalse: [labelArray _ labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!CustomMenu methodsFor: 'invocation' stamp: 'jm 1/1/2004 11:16'!startUp	"Build and invoke this menu with no initial selection. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	^ self startUp: nil! !!CustomMenu methodsFor: 'invocation' stamp: 'sw 8/18/1998 12:01'!startUp: initialSelection	"Build and invoke this menu with the given initial selection. Answer the selection associated with the menu item chosen by the user or nil if none is chosen."	^ self startUp: initialSelection withCaption: title! !!CustomMenu methodsFor: 'private' stamp: 'sw 12/10/1999 11:21'!build	"Turn myself into an invokable ActionMenu."	| stream |	stream _ WriteStream on: (String new).	labels do: [:label | stream nextPutAll: label; cr].	(labels isEmpty) ifFalse: [stream skip: -1].  "remove final cr"	super labels: stream contents		font: MenuStyle defaultFont		lines: dividers! !!CustomMenu methodsFor: 'private' stamp: 'di 4/14/1999 21:28'!preSelect: action	"Pre-select and highlight the menu item associated with the given action."	| i |	i _ selections indexOf: action ifAbsent: [^ self].	marker ifNil: [self computeForm].	marker _ marker		align: marker topLeft		with: (marker left)@(frame inside top + (marker height * (i - 1))).	selection _ i.! !!CustomMenu class methodsFor: 'example' stamp: 'sw 11/8/1999 17:27'!example	"CustomMenu example"	| menu |	menu _ CustomMenu new.	menu add: 'apples' action: #apples.	menu add: 'oranges' action: #oranges.	menu addLine.	menu addLine.  "extra lines ignored"	menu add: 'peaches' action: #peaches.	menu addLine.	menu add: 'pears' action: #pears.	menu addLine.	^ menu startUp: #apples"NB:  The following is equivalent to the above, but uses the compact #fromArray: consruct:	(CustomMenu fromArray:		#(	('apples'		apples)			('oranges'		oranges)			-			-			('peaches'		peaches)			-			('pears'			pears)			-))				startUp: #apples"! !I am used by Morphic to keep track of the rectangular areas on the screen that need to be redrawn.!!DamageRecorder methodsFor: 'initialization' stamp: 'jm 5/30/2003 10:22'!initialize	self reset.! !!DamageRecorder methodsFor: 'initialization' stamp: 'sma 6/5/2000 11:55'!reset	"Clear the damage list."	invalidRects _ OrderedCollection new: 15.	totalRepaint _ false! !!DamageRecorder methodsFor: 'recording' stamp: 'jm 6/16/2003 09:48'!recordInvalidRect: aRectangle	"Record the given rectangle in my damage list, a list of rectagular areas of the display that should be redraw on the next display cycle."	"Details: Damaged rectangles are often identical or overlap significantly. In these cases, we merge them to reduce the number of damage rectangles that must be processed when the display is updated. Moreover, above a certain threshold, we ignore the individual rectangles completely, and simply do a complete repaint on the next cycle."	| r mergeRect |	totalRepaint ifTrue: [^ self].  "planning full repaint; don't bother collecting damage"	r _ (aRectangle topLeft truncated) corner: (aRectangle right ceiling@aRectangle bottom ceiling).	invalidRects do: [:rect |		(rect intersects: r) ifTrue: [			"merge rectangle in place (see note below) if there is any overlap"			rect setOrigin: (rect origin min: r origin) truncated				corner: (rect corner max: r corner) truncated.			^ self]].	invalidRects size >= 15 ifTrue: [		"if there are too many separate areas, just repaint all"		"totalRepaint _ true.""Note:  The totalRepaint policy has poor behavior when many local rectangles (such as parts of a text selection) force repaint of the entire screen.  As an alternative, this code performs a simple merge of all rects whenever there are more than 10."		mergeRect _ Rectangle merging: invalidRects.		self reset.		invalidRects addLast: mergeRect].	"add the new damage rectangle to the damage list"	"Note: All rectangles added to the damage list should be copies,	 since rectangles in this list may be extended in place."	invalidRects addLast: r.! !Refactored to use Julian Day Numbers internally.Julian Day Numbers are the number of days which have elapsed since 24 November -4713 Gregorian.The algorithm was published in the Communications of the ACM, volume 11, Number 10, October 1968.See also: http://www.magnet.ch/serendipity/hermetic/cal_stud/jdn.htmhttp://www.cs.ubc.ca/spider/flinn/docs/scham/primitives/time.html!!Date methodsFor: 'accessing' stamp: 'BP 5/21/2000 19:17'!day	"Answer the day of the year represented by the receiver."	^self dayOfYear! !!Date methodsFor: 'accessing' stamp: 'BP 5/18/2000 18:28'!julianDayNumber	"Answer the number of days (or part of a day) elapsed since noon GMT on January 1st, 4713 B.C."	^julianDayNumber! !!Date methodsFor: 'accessing' stamp: 'BP 5/18/2000 18:29'!julianDayNumber: anInteger	"Set the number of days (or part of a day) elapsed since noon GMT on January 1st, 4713 B.C."	julianDayNumber _ anInteger.! !!Date methodsFor: 'accessing' stamp: 'BP 5/21/2000 16:39'!leap	"Answer whether the receiver's year is a leap year."	^Date leapYear: self year! !!Date methodsFor: 'accessing' stamp: 'jm 5/23/2003 21:19'!monthIndex	"Answer the index of the month in which the receiver falls."	^ self asGregorian second! !!Date methodsFor: 'accessing' stamp: 'BP 5/18/2000 18:05'!monthName	"Answer the name of the month in which the receiver falls."	^MonthNames at: self monthIndex! !!Date methodsFor: 'accessing' stamp: 'BP 5/18/2000 18:05'!weekday	"Answer the name of the day of the week on which the receiver falls."	^WeekDayNames at: self weekdayIndex! !!Date methodsFor: 'accessing' stamp: 'rca 6/15/2000 14:51'!weekdayIndex	"Monday=1, ... , Sunday=7"	^ (self julianDayNumber rem: 7) + 1! !!Date methodsFor: 'accessing' stamp: 'BP 5/18/2000 19:34'!year	"Answer the year in which the receiver falls."	^self asGregorian last! !!Date methodsFor: 'arithmetic' stamp: 'BP 5/18/2000 18:46'!addDays: dayCount 	"Answer a Date that is dayCount days after the receiver."	^self class fromJulianDayNumber: self julianDayNumber + dayCount.! !!Date methodsFor: 'arithmetic' stamp: 'RAH 5/23/2000 11:32'!subtractDate: aDate 	"Answer the number of days between the receiver and aDate."	^self julianDayNumber - aDate asJulianDayNumber! !!Date methodsFor: 'arithmetic' stamp: 'BP 5/18/2000 18:48'!subtractDays: dayCount 	"Answer a Date that is dayCount days before the receiver."	^self addDays: dayCount negated.! !!Date methodsFor: 'comparing' stamp: 'RAH 5/23/2000 11:04'!< aDate 	"Answer whether aDate precedes the date of the receiver." 	^julianDayNumber < aDate asJulianDayNumber! !!Date methodsFor: 'comparing' stamp: 'BP 5/18/2000 18:31'!= aDate 	"Answer whether aDate is the same day as the receiver."	^julianDayNumber = aDate asJulianDayNumber.! !!Date methodsFor: 'comparing' stamp: 'BP 5/18/2000 19:09'!hash	"Hash is reimplemented because = is implemented."	^julianDayNumber hash! !!Date methodsFor: 'inquiries' stamp: 'BP 5/21/2000 19:18'!dayOfMonth	"Answer which day of the month is represented by the receiver."	^self asGregorian first! !!Date methodsFor: 'inquiries' stamp: 'BP 5/21/2000 19:18'!dayOfYear	^self firstDayOfMonth + self dayOfMonth - 1! !!Date methodsFor: 'inquiries' stamp: 'BP 5/18/2000 18:05'!daysInMonth	"Answer the number of days in the month represented by the receiver."	^(DaysInMonth at: self monthIndex)		+ (self monthIndex = 2				ifTrue: [self leap]				ifFalse: [0])! !!Date methodsFor: 'inquiries' stamp: 'BP 5/21/2000 16:40'!daysInYear	"Answer the number of days in the year represented by the receiver."	^Date daysInYear: self year! !!Date methodsFor: 'inquiries' stamp: 'BP 5/21/2000 17:28'!daysLeftInYear	"Answer the number of days in the year after the date of the receiver."	^self daysInYear - self dayOfYear! !!Date methodsFor: 'inquiries' stamp: 'BP 5/21/2000 17:31'!firstDayOfMonth	"Answer the index of the day of the year that is the first day of the receiver's month."	^(FirstDayOfMonth at: self monthIndex)		+ (self monthIndex > 2				ifTrue: [self leap]				ifFalse: [0])! !!Date methodsFor: 'inquiries' stamp: 'BP 5/18/2000 19:10'!previous: dayName 	"Answer the previous date whose weekday name is dayName."	^self subtractDays: 7 + self weekdayIndex - (self class dayOfWeek: dayName) \\ 7! !!Date methodsFor: 'converting' stamp: 'BP 5/18/2000 18:21'!asDate	^self! !!Date methodsFor: 'converting' stamp: 'BP 5/21/2000 17:32'!asGregorian	"Return an array of integers #(dd mm yyyy)"	| l n i j dd mm yyyy |	l _ self julianDayNumber + 68569.	n _ (4 * l) // 146097.	l _ l - ( (146097 * n + 3) // 4 ).	i _ (4000 * (l + 1) ) // 1461001.	l _ l - ( (1461 * i) // 4 ) + 31.	j _ (80 *l) // 2447.	dd _ l - ( (2447 * j) // 80 ).	l _ j // 11.	mm _ j + 2 - (12 * l).	yyyy _ 100 * (n -49) + i + l.	^Array with: dd with: mm with: yyyy.! !!Date methodsFor: 'converting' stamp: 'BP 5/21/2000 19:19'!asJulianDayNumber	^self julianDayNumber! !!Date methodsFor: 'converting' stamp: 'BP 5/18/2000 18:05'!asSeconds	"Answer the seconds between a time on 1 January 1901 and the same 	time in the receiver's day."	^SecondsInDay * (self subtractDate: (Date newDay: 1 year: 1901))! !!Date methodsFor: 'converting' stamp: 'BP 5/18/2000 18:05'!month	^ Month fromDate: self! !!Date methodsFor: 'converting' stamp: 'BP 5/18/2000 18:05'!week	^ Week fromDate: self! !!Date methodsFor: 'printing' stamp: 'BP 5/18/2000 18:05'!mmddyyyy	"Answer the receiver rendered in standard fmt mm/dd/yyyy.  Good for avoiding year 2000 bugs.  Note that the name here is slightly misleading -- the month and day numbers don't show leading zeros, so that for example feb 1 1996 is 2/1/96"	"Date today mmddyyyy"	^ self printFormat: #(2 1 3 $/ 1 1)! !!Date methodsFor: 'printing' stamp: 'BP 5/18/2000 18:22'!printFormat: formatArray 	"Answer a String describing the receiver using the argument formatArray."	| aStream |	aStream _ WriteStream on: (String new: 16).	self printOn: aStream format: formatArray.	^aStream contents! !!Date methodsFor: 'printing' stamp: 'BP 5/18/2000 18:05'!printOn: aStream	self printOn: aStream format: #(1 2 3 $  3 1 )! !!Date methodsFor: 'printing' stamp: 'jm 5/23/2003 21:20'!printOn: aStream format: formatArray 	"Print a description of the receiver on aStream using the format denoted the argument, formatArray:		#(item item item sep monthfmt yearfmt twoDigits)		items:  1=day  2=month  3=year  will appear in the order given,		separated by sep which is eaither an ascii code or character.		monthFmt:  1=09  2=Sep  3=September		yearFmt:  1=1996  2=96		digits:  (missing or)1=9  2=09.	See the examples in printOn: and mmddyy"	| gregorian twoDigits element monthFormat  |	gregorian _ self asGregorian.	twoDigits _ formatArray size > 6 and: [ (formatArray at: 7) > 1 ].	1 to: 3 do: 	[ :i | 		element _ formatArray at: i.		element = 1 ifTrue:		[ 			twoDigits 				ifTrue: [ aStream nextPutAll: (gregorian first asString padded: #left to: 2 with: $0) ]				ifFalse: [ gregorian first printOn: aStream ]		].		element = 2 ifTrue: 		[			monthFormat _ formatArray at: 5.			monthFormat = 1 ifTrue:			[				twoDigits 					ifTrue: [ aStream nextPutAll: (gregorian second asString padded: #left to: 2 with: $0) ]					ifFalse: [ gregorian second printOn: aStream ].			].			monthFormat = 2 ifTrue:			[				aStream nextPutAll: ((MonthNames at: gregorian second) copyFrom: 1 to: 3)			].			monthFormat = 3 ifTrue:			[				aStream nextPutAll: (MonthNames at: gregorian second)			].		].		element = 3 ifTrue: 		[			(formatArray at: 6) = 1				ifTrue: [ gregorian last printOn: aStream ]				ifFalse: [ aStream nextPutAll: ((gregorian last \\ 100) asString padded: #left to: 2 with: $0) ].		].		i < 3 ifTrue: 		[			(formatArray at: 4) ~= 0 				ifTrue: [ aStream nextPut: (formatArray at: 4) asCharacter ] 		].	].! !!Date methodsFor: 'printing' stamp: 'BP 5/18/2000 18:05'!storeOn: aStream	aStream nextPutAll: '(', self class name, ' readFromString: ';		print: self printString;		nextPut: $)! !!Date methodsFor: 'obsolete' stamp: 'BP 5/21/2000 17:24'!day: dayInteger year: yearInteger	self error: 'obsolete'! !!Date methodsFor: 'obsolete' stamp: 'BP 5/21/2000 17:30'!firstDayOfMonthIndex: monthIndex 	"Answer the day of the year (an Integer) that is the first day of my month"	self error: 'obsolete'! !!Date methodsFor: 'obsolete' stamp: 'BP 5/18/2000 18:23'!mmddyy	"Please use mmddyyyy instead, so dates in 2000 will be unambiguous"	^ self printFormat: #(2 1 3 $/ 1 2)! !!Date class methodsFor: 'class initialization' stamp: 'BP 5/18/2000 18:59'!initialize	"Initialize class variables representing the names of the months and days and	the number of seconds, days in each month, and first day of each month."	MonthNames _		#(January February March April May June July August September October November December ).	SecondsInDay _ 24 * 60 * 60.	DaysInMonth _ #(31 28 31 30 31 30 31 31 30 31 30 31 ).	FirstDayOfMonth _ #(1 32 60 91 121 152 182 213 244 274 305 335 ).	WeekDayNames _ #(Monday Tuesday Wednesday Thursday Friday Saturday Sunday ).	"Date initialize."! !!Date class methodsFor: 'instance creation' stamp: 'BP 5/21/2000 17:36'!fromDays: dayCount	"Answer an instance of me which is dayCount days after January 1, 1901.  Works for negative days before 1901.  Works over a huge range, both BC and AD."	^self fromJulianDayNumber: dayCount +  2415386 "Julian Day Number of 1 Jan 1901" ! !!Date class methodsFor: 'instance creation' stamp: 'BP 5/18/2000 18:38'!fromJulianDayNumber: aJulianDayNumber	^self new julianDayNumber: aJulianDayNumber.! !!Date class methodsFor: 'instance creation' stamp: 'BP 5/21/2000 19:26'!fromSeconds: seconds	"Answer an instance of me which is 'seconds' seconds after January 1, 1901."	^self fromDays: seconds // SecondsInDay! !!Date class methodsFor: 'instance creation' stamp: 'BP 5/18/2000 18:57'!fromString: aString	"Answer an instance of created from a string with format DD.MM.YYYY."	^self readFrom: (ReadStream on: aString).! !!Date class methodsFor: 'instance creation' stamp: 'BP 5/18/2000 19:02'!newDay: day month: month year: year 	"Arguments day, month and year are all integers, except month may be a string	 Two digit dates are always from 1900. 1/1/01 will NOT mean 2001."	| monthIndex daysInMonth p q r s |	year < 100 ifTrue: [ ^self newDay: day month: month year: 1900 + year].	monthIndex _ month isInteger ifTrue: [month] ifFalse: [self indexOfMonth: month].	monthIndex = 2		ifTrue: [ daysInMonth _ (DaysInMonth at: monthIndex) + (self leapYear: year) ]		ifFalse: [ daysInMonth _ DaysInMonth at: monthIndex ].	(day < 1 or: [day > daysInMonth]) ifTrue: [ self error: 'illegal day in month' ].	p _ (monthIndex - 14) quo: 12.	q _ year + 4800 + p.	r _ monthIndex - 2 - (12 * p).	s _ (year + 4900 + p) quo: 100. 	^self fromJulianDayNumber: 		( (1461 * q) quo: 4 ) + 			( (367 * r) quo: 12 ) - 				( (3 * s) quo: 4 ) + 					( day - 32075 ).	! !!Date class methodsFor: 'instance creation' stamp: 'BP 5/22/2000 16:46'!newDay: dayCount year: referenceYear 	"Answer an instance of me which is dayCount days after the beginning of the year referenceYear."	| day year daysInYear date |	day _ dayCount.	year _ referenceYear.	[ day > (daysInYear _ self daysInYear: year) ] whileTrue: 	[		year _ year + 1.		day _ day - daysInYear	].	[ day <= 0 ] whileTrue: 	[		year _ year - 1.		day _ day + (self daysInYear: year)	].		date _ self newDay: 1 month: 1 year: year.	^date addDays: (day - 1).! !!Date class methodsFor: 'instance creation' stamp: 'BP 5/21/2000 16:48'!readFrom: aStream	"Read a Date from the stream in any of the forms:		<day> <monthName> <year>		(5 April 1982; 5-APR-82)		<monthName> <day> <year>		(April 5, 1982)		<monthNumber> <day> <year>	(4/5/82)"	| day month |	aStream peek isDigit ifTrue: [day _ Integer readFrom: aStream].	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].	aStream peek isLetter		ifTrue:		"number/name... or name..."			[month _ WriteStream on: (String new: 10).			[aStream peek isLetter] whileTrue: [month nextPut: aStream next].			month _ month contents.			day isNil ifTrue:		"name/number..."				[[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].				day _ Integer readFrom: aStream]]		ifFalse:		"number/number..."			[month _ Date nameOfMonth: day.			day _ Integer readFrom: aStream].	[aStream peek isAlphaNumeric] whileFalse: [aStream skip: 1].	^self newDay: day month: month year: (Integer readFrom: aStream)	"Date readFrom: (ReadStream on: '5APR82')"! !!Date class methodsFor: 'instance creation' stamp: 'BP 5/21/2000 19:26'!today	"Answer an instance of me representing the day and year right now."	^self dateAndTimeNow first! !!Date class methodsFor: 'general inquiries' stamp: 'BP 5/18/2000 18:05'!dateAndTimeNow	"Answer an Array whose first element is Date today and second element 	is Time now."	^Time dateAndTimeNow! !!Date class methodsFor: 'general inquiries' stamp: 'BP 5/18/2000 18:59'!dayOfWeek: dayName 	"Answer the index in a week, 1-7, of the day named dayName. Create an 	error notification if no such day exists."	1 to: 7 do: [ :index | (WeekDayNames at: index) = dayName ifTrue: [^index] ].	self error: dayName asString , ' is not a day of the week'! !!Date class methodsFor: 'general inquiries' stamp: 'BP 5/18/2000 19:00'!daysInMonth: monthName forYear: yearInteger 	"Answer the number of days in the month named monthName in the year yearInteger."	^(self newDay: 1 month: monthName year: yearInteger) daysInMonth! !!Date class methodsFor: 'general inquiries' stamp: 'BP 5/18/2000 18:05'!daysInYear: yearInteger 	"Answer the number of days in the year, yearInteger."	^365 + (self leapYear: yearInteger)! !!Date class methodsFor: 'general inquiries' stamp: 'BP 5/18/2000 18:05'!firstWeekdayOfMonth: mn year: yr	"Answer the weekday index (Sunday=1, etc) of the first day in the month named mn in the year yr."	^(self newDay: 1 month: mn year: yr) weekdayIndex + 7 \\ 7 + 1! !!Date class methodsFor: 'general inquiries' stamp: 'BP 5/18/2000 18:05'!indexOfMonth: monthName 	"Answer the index, 1-12, of the month monthName. Create an error 	notification if no such month exists."	1 to: 12 do: 		[ :index | 			(monthName , '*' match: (MonthNames at: index))						ifTrue: [^index]].	self error: monthName , ' is not a recognized month name'! !!Date class methodsFor: 'general inquiries' stamp: 'BP 5/18/2000 18:05'!leapYear: yearInteger "Answer 1 if the year yearInteger is a leap year; answer 0 if it is not."    | adjustedYear |    adjustedYear := yearInteger > 0        ifTrue: [yearInteger]        ifFalse: [(yearInteger + 1) negated "There is no year 0!!!!"].     (adjustedYear \\ 4 ~= 0 or: [adjustedYear \\ 100 = 0 and: [adjustedYear \\ 400 ~= 0]])        ifTrue: [^0]        ifFalse: [^1]! !!Date class methodsFor: 'general inquiries' stamp: 'BP 5/18/2000 19:01'!nameOfDay: dayIndex 	"Answer a symbol representing the name of the day indexed by dayIndex, 1-7."	^WeekDayNames at: dayIndex! !!Date class methodsFor: 'general inquiries' stamp: 'BP 5/18/2000 19:01'!nameOfMonth: monthIndex 	"Answer a String representing the name of the month indexed by monthIndex, 1-12."	^MonthNames at: monthIndex! !!Date class methodsFor: 'obsolete' stamp: 'BP 5/18/2000 18:05'!absoluteDaysToYear: gregorianYear	"Computes the number of days from (or until) January 1 of the year 1 A.D. upto (or since) January 1 of a given year. [Alan Lovejoy]"	| days yearDelta quadCenturies centuries quadYears years isInADEra |	days := 0.	isInADEra := gregorianYear > 0.	gregorianYear = 0 ifTrue: [gregorianYear = -1]. "There is no year 0"	isInADEra		ifTrue: [yearDelta := gregorianYear - 1]		ifFalse: [yearDelta := (gregorianYear + 1) negated].	quadCenturies := yearDelta // 400.	yearDelta := yearDelta rem: 400.	centuries := yearDelta // 100.	yearDelta := yearDelta rem: 100.	quadYears := yearDelta // 4.	years := yearDelta rem: 4.	days := (quadCenturies * 146097 "days per quad century") +		(centuries * 36524 "days per century")  +		(quadYears * 1461 "days per quad year") +		(years * 365).	isInADEra ifFalse:			[days := days + 366.  "1 B.C. is a leap year"			days := days negated].	^ days! !!Date class methodsFor: 'obsolete' stamp: 'BP 5/18/2000 18:05'!yearAndDaysFromDays: days into: aTwoArgBlock	"Compute the Gregorian year, and the day of the year, from the number of days since (or until) January 1 of the year 1 A.D. Return the values in a block.  [Alan Lovejoy]"	| quadCentury year dayInYear isInADEra century quadYear |	dayInYear := days.	isInADEra := days >= 0.	isInADEra		ifTrue: [year := 0]		ifFalse: [dayInYear := dayInYear abs.			dayInYear >= 366 "days per leap year" 				ifTrue: [year := 1.						dayInYear := dayInYear - 366]	"Subtract the year 1 B.C."				ifFalse: [year := 0]].	quadCentury := dayInYear // 146097 "days per quad century".	dayInYear := dayInYear \\ 146097 "days per quad century".	century := dayInYear // 36524 "days per century".	dayInYear := dayInYear \\ 36524 "days per century".	quadYear := dayInYear // 1461 "days per quad year".	dayInYear := dayInYear \\ 1461 "days per quad year".	dayInYear >= 365 "days per standard year" ifTrue: ["e.g., 1 AD or 2 BC"		dayInYear := dayInYear - 365 "days per standard year".		year := year + 1.		dayInYear >= 365 "days per standard year" ifTrue: ["e.g., 2 AD or 3 BC"			dayInYear := dayInYear - 365 "days per standard year".			year := year + 1.			dayInYear >= 365 "days per standard year" ifTrue: ["e.g., 3 AD or 4 BC"				dayInYear := dayInYear - 365 "days per standard year".				year := year + 1.				dayInYear >= 366 "days per leap year" ifTrue: [					"e.g., 4 AD or 5 BC (although this won't occur in the AD case)"					dayInYear := dayInYear - 366 "days per leap year".					year := year + 1]]]].	year := year + (quadCentury * 400) + (century * 100) + (quadYear * 4) + 1.	isInADEra ifFalse: [		year := year negated.		dayInYear > 0 ifTrue: [			(Date leapYear: year) = 1				ifTrue: [dayInYear := 366 "days per leap year" - dayInYear]				ifFalse: [dayInYear := 365 "days per standard year" - dayInYear]]].	^ aTwoArgBlock value: year value: dayInYear+1 "the way Dates do it"! !I represent the machine state at the time of an interrupted process. I also represent a query path into the state of the process. The debugger is typically viewed through a window that views the stack of suspended contexts, the code for, and execution point in, the currently selected message, and inspectors on both the receiver of the currently selected message, and the variables in the current context.Special note on recursive errors:Some errors affect Squeak's ability to present a debugger.  This is normally an unrecoverable situation.  However, if such an error occurs in an isolation layer, Squeak will attempt to exit from the isolation layer and then present a debugger.  Here is the chain of events in such a recovery.	* A recursive error is detected.	* The current project is queried for an isolationHead	* Changes in the isolationHead are revoked	* The parent project of isolated project is returned to	* The debugger is opened there and execution resumes.If the user closes that debugger, execution continues in the outer project and layer.  If, after repairing some damage, the user proceeds from the debugger, then the isolationHead is re-invoked, the failed project is re-entered, and execution resumes in that world. !!Debugger methodsFor: 'initialize' stamp: 'sbw 12/23/1999 10:00'!buildMVCDebuggerViewLabel: aString minSize: aPoint	| topView stackListView stackCodeView rcvrVarView rcvrValView ctxtVarView ctxtValView deltaY underPane annotationPane buttonsView |	self expandStack.	topView _ StandardSystemView new model: self.	topView borderWidth: 1.	stackListView _ PluggableListView on: self			list: #contextStackList			selected: #contextStackIndex			changeSelected: #toggleContextStackIndex:			menu: #contextStackMenu:shifted:			keystroke: #contextStackKey:from:.		stackListView menuTitleSelector: #messageListSelectorTitle.		stackListView window: (0 @ 0 extent: 150 @ 50).		topView addSubView: stackListView.	deltaY _ 0.	Preferences useAnnotationPanes		ifTrue:			[annotationPane _ PluggableTextView on: self				text: #annotation accept: nil readSelection: nil menu: nil.			annotationPane window: (0@0 extent: 150@self optionalAnnotationHeight).			topView addSubView: annotationPane below: stackListView.			deltaY _ deltaY + self optionalAnnotationHeight.			underPane _ annotationPane]		ifFalse:			[underPane _ stackListView].	Preferences optionalButtons ifTrue:			[buttonsView _ self buildMVCOptionalButtonsButtonsView.			buttonsView borderWidth: 1.			topView addSubView: buttonsView below: underPane.			underPane _ buttonsView.			deltaY _ deltaY + self optionalButtonHeight].	stackCodeView _ PluggableTextView on: self			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		stackCodeView window: (0 @ 0 extent: 150 @ (75 - deltaY)).		topView addSubView: stackCodeView below: underPane.	rcvrVarView _ PluggableListView on: self receiverInspector			list: #fieldList			selected: #selectionIndex			changeSelected: #toggleIndex:			menu: #fieldListMenu:			keystroke: #inspectorKey:from:.		rcvrVarView window: (0 @ 0 extent: 25 @ (50 - deltaY)).		topView addSubView: rcvrVarView below: stackCodeView.	rcvrValView _ PluggableTextView on: self receiverInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		rcvrValView window: (0 @ 0 extent: 50 @ (50 - deltaY)).		topView addSubView: rcvrValView toRightOf: rcvrVarView.	ctxtVarView _ PluggableListView on: self contextVariablesInspector			list: #fieldList			selected: #selectionIndex			changeSelected: #toggleIndex:			menu: #fieldListMenu:			keystroke: #inspectorKey:from:.		ctxtVarView window: (0 @ 0 extent: 25 @ (50 - deltaY)).		topView addSubView: ctxtVarView toRightOf: rcvrValView.	ctxtValView _ PluggableTextView on: self contextVariablesInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		ctxtValView window: (0 @ 0 extent: 50 @ (50 - deltaY)).		topView addSubView: ctxtValView toRightOf: ctxtVarView.	topView label: aString.	topView minimumSize: aPoint.	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'sw 12/28/1999 13:12'!buildMVCNotifierButtonView	| aView bHeight priorButton buttonView |	aView _ View new model: self.	bHeight _ self notifierButtonHeight.	aView window: (0@0 extent: 350@bHeight).	priorButton _ nil.	self preDebugButtonQuads do:		[:aSpec |			buttonView _ PluggableButtonView				on: self				getState: nil				action: aSpec second..			buttonView				label: aSpec first;				insideColor: (Color perform: aSpec third) muchLighter lighter;				borderWidthLeft: 1 right: 1 top: 0 bottom: 0;				window: (0@0 extent: 117@bHeight).			priorButton				ifNil:					[aView addSubView: buttonView]				ifNotNil:					[aView addSubView: buttonView toRightOf: priorButton].			priorButton _ buttonView].	^ aView! !!Debugger methodsFor: 'initialize' stamp: 'sbw 12/23/1999 08:36'!buildMVCNotifierViewLabel: aString message: messageString minSize: aPoint	| topView aStringHolderView buttonView x y bHeight |	topView _ StandardSystemView new model: self.	topView borderWidth: 1.	buttonView _ self buildMVCNotifierButtonView.	topView addSubView: buttonView.	aStringHolderView _ PluggableTextView on: self		text: #contents		accept: #doNothing:		readSelection: #contentsSelection		menu: #debugProceedMenu:.	aStringHolderView		editString: messageString;		askBeforeDiscardingEdits: false.	x _ 350 max: (aPoint x).	y _ ((4 * 15) + 16) max: (aPoint y - 16 - self optionalButtonHeight).	bHeight _ self optionalButtonHeight.	y _ y - bHeight.	aStringHolderView window: (0@0 extent: x@y).	topView		addSubView: aStringHolderView below: buttonView;		label: aString;		minimumSize: aPoint.	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'sbw 12/28/1999 11:38'!buildMVCOptionalButtonsButtonsView	| aView bHeight offset aButtonView wid pairs windowWidth previousView |	aView _ View new model: self.	bHeight _ self optionalButtonHeight.	windowWidth _ 150.	aView window: (0@0 extent: windowWidth@bHeight).	offset _ 0.	pairs _ self optionalButtonPairs.	previousView _ nil.	pairs do: [:pair |		aButtonView _ PluggableButtonView on: self getState: nil action: pair last.		pair last = pairs last last			ifTrue:				[wid _ windowWidth - offset]			ifFalse:				[aButtonView borderWidthLeft: 0 right: 1 top: 0 bottom: 0.				wid _ windowWidth // (pairs size)].		aButtonView			label: pair first asParagraph;			insideColor: Color red muchLighter lighter;			window: (offset@0 extent: wid@bHeight).		offset _ offset + wid.		pair last = pairs first last			ifTrue: [aView addSubView: aButtonView]			ifFalse: [aView addSubView: aButtonView toRightOf: previousView].		previousView _ aButtonView].	^ aView! !!Debugger methodsFor: 'initialize' stamp: 'tk 1/3/2000 12:57'!buildMorphicNotifierLabelled: label message: messageString	| notifyPane window contentTop extentV |	window _ (PreDebugWindow labelled: label) model: self.	"Preferences optionalMorphicButtons" true		ifTrue:			[contentTop _ 0.2.			window addMorph: (self buttonRowForPreDebugWindow: window)				frame: (0@0 corner: 1 @ contentTop).			extentV _ 156]		ifFalse:			[extentV _ 116.			contentTop _ 0].	notifyPane _ PluggableTextMorph on: self text: nil accept: nil		readSelection: nil menu: #debugProceedMenu:.	notifyPane editString: messageString; askBeforeDiscardingEdits: false.	window addMorph: notifyPane frame: (0@contentTop corner: 1@1).	^ window openInWorldExtent: 450 @ extentV! !!Debugger methodsFor: 'initialize' stamp: 'jm 6/5/2003 18:27'!buttonRowForPreDebugWindow: aDebugWindow	| aRow aButton |	aRow _ AlignmentMorph newRow hResizing: #spaceFill.	aRow isSticky: true.	aButton _ SimpleButtonMorph new target: aDebugWindow.	aButton color: Color transparent; borderWidth: 1.	aRow addMorphBack: (AlignmentMorph newSpacer: self defaultBackgroundColor).	self preDebugButtonQuads do:			[:quad |				aButton _ aButton fullCopy.				aButton actionSelector: quad second.				aButton label: quad first.				aButton submorphs first color: (Color colorFrom: quad third).				aButton setBalloonText: quad fourth.				aRow addMorphBack: aButton.				aRow addMorphBack: (AlignmentMorph newSpacer: self defaultBackgroundColor)].	^ aRow! !!Debugger methodsFor: 'initialize' stamp: 'sw 12/28/1999 13:07'!notifierButtonHeight	^ 18! !!Debugger methodsFor: 'initialize' stamp: 'sw 1/12/2000 16:47'!openFullMorphicLabel: labelString	| window aListMorph codeTop aTextMorph |	self expandStack.	window _ (SystemWindow labelled: labelString) model: self.	aListMorph _ PluggableListMorph on: self list: #contextStackList			selected: #contextStackIndex changeSelected: #toggleContextStackIndex:			menu: #contextStackMenu:shifted: keystroke: #contextStackKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph		frame: (0@0 corner: 1@0.3).	Preferences useAnnotationPanes		ifFalse:			[codeTop _ 0.3]		ifTrue:			[aTextMorph _ PluggableTextMorph on: self					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.3 corner: 1@0.35).			codeTop _ 0.35].	Preferences optionalButtons ifTrue:		[window addMorph: self optionalButtonRow frame: ((0@codeTop corner: 1 @ (codeTop + 0.1))).		codeTop _ codeTop + 0.1].	window addMorph: (PluggableTextMorph on: self			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0 @ codeTop corner: 1 @ 0.7).	window addMorph: ((PluggableListMorph on: self receiverInspector list: #fieldList			selected: #selectionIndex changeSelected: #toggleIndex:			menu: #fieldListMenu: keystroke: #inspectorKey:from:) doubleClickSelector: #inspectSelection)		frame: (0@0.7 corner: 0.2@1).	window addMorph: (PluggableTextMorph on: self receiverInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0.2@0.7 corner: 0.5@1).	window addMorph: ((PluggableListMorph on: self contextVariablesInspector list: #fieldList			selected: #selectionIndex changeSelected: #toggleIndex:			menu: #fieldListMenu: keystroke: #inspectorKey:from:) doubleClickSelector: #inspectSelection)		frame: (0.5@0.7 corner: 0.7@1).	window addMorph: (PluggableTextMorph on: self contextVariablesInspector			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0.7@0.7 corner: 1@1).	^ window openInWorld! !!Debugger methodsFor: 'initialize' stamp: 'ls 3/5/2000 14:20'!openFullNoSuspendLabel: aString	"Create and schedule a full debugger with the given label. Do not terminate the current active process."	| topView |	Smalltalk isMorphic ifTrue:		[self openFullMorphicLabel: aString.		^ Project current spawnNewProcessIfThisIsUI: interruptedProcess].	topView _ self buildMVCDebuggerViewLabel: aString minSize: 300@200.	topView controller openNoTerminate.	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'jm 10/7/2002 05:54'!openNotifierContents: msgString label: label	"Create and schedule a notifier view with the given label and message. A notifier view shows just the message or the first several lines of the stack, with a menu that allows the user to open a full debugger if so desired."	"NOTE: When this method returns, a new process has been scheduled to run the windows, and thus this notifier, but the previous active porcess has not been suspended.  The sender will do this."	| msg topView p |	Sensor flushKeyboard.	savedCursor _ Sensor currentCursor.	Sensor currentCursor: Cursor normal.	msg _ msgString.	(label beginsWith: 'Space is low') ifTrue: [msg _ self lowSpaceChoices, msgString].	Smalltalk isMorphic		ifTrue:			[self buildMorphicNotifierLabelled: label message: msg.			^ Project current spawnNewProcessIfThisIsUI: interruptedProcess].	Display fullScreen.	topView _ self buildMVCNotifierViewLabel: label message: msg minSize: 350@((14 * 5) + 16 + self optionalButtonHeight).	ScheduledControllers activeController		ifNil: [p _ Display boundingBox center]		ifNotNil: [p _ ScheduledControllers activeController view displayBox center].	topView controller openNoTerminateDisplayAt: (p max: (200@60)).	^ topView! !!Debugger methodsFor: 'initialize' stamp: 'sbw 12/23/1999 09:50'!optionalAnnotationHeight	^ 10! !!Debugger methodsFor: 'initialize' stamp: 'sbw 12/23/1999 08:31'!optionalButtonHeight	^ 10! !!Debugger methodsFor: 'initialize' stamp: 'sbw 12/23/1999 09:28'!optionalButtonPairs	^ #(('Proceed'		proceed)		('Restart'		restart)		('Send'			send)		('Step'			doStep)		('Full Stack'		fullStack)		('Where'		where)		('Browse'		browseMethodFull))! !!Debugger methodsFor: 'initialize' stamp: 'jm 10/13/2002 18:05'!optionalButtonRow	| aRow aButton |	aRow _ AlignmentMorph newRow.	aRow isSticky: true.	aRow setProperty: #clipToOwnerWidth toValue: true.	aButton _ SimpleButtonMorph new target: self.	aButton color: Color lightRed; borderWidth: 1; borderColor: Color red darker.	aRow addTransparentSpacerOfSize: (5@0).	self optionalButtonPairs do:		[:pair |				aButton _ PluggableButtonMorph					on: self					getState: nil					action: pair second.				aButton useRoundedCorners;					label: pair first asString;					askBeforeChanging: true;					onColor: Color transparent offColor: Color transparent.				aRow addMorphBack: aButton.				aRow addTransparentSpacerOfSize: (3 @ 0)].	^ aRow! !!Debugger methodsFor: 'initialize' stamp: 'sbw 12/22/1999 16:20'!preDebugButtonQuads	^ #(('Proceed'		proceed 	blue 	'continue execution' )		('Abandon'		abandon 	black 	'close this window')		('Debug'		debug 		red 		'bring up a debugger'))! !!Debugger methodsFor: 'initialize' stamp: 'jm 8/20/1998 18:31'!release	self windowIsClosing.	super release.! !!Debugger methodsFor: 'initialize' stamp: 'jm 8/20/1998 18:30'!windowIsClosing	"My window is being closed; clean up. Restart the low space watcher."	interruptedProcess == nil ifTrue: [^ self].	interruptedProcess terminate.	interruptedProcess _ nil.	interruptedController _ nil.	contextStack _ nil.	contextStackTop _ nil.	receiverInspector _ nil.	contextVariablesInspector _ nil.	Smalltalk installLowSpaceWatcher.  "restart low space handler"! !!Debugger methodsFor: 'accessing' stamp: 'di 10/9/1998 17:15'!contents 	"Depending on the current selection, different information is retrieved.	Answer a string description of that information.  This information is the	method in the currently selected context."	contents == nil ifTrue: [^ String new].	^ contents copy! !!Debugger methodsFor: 'notifier menu' stamp: 'sma 4/30/2000 09:24'!debug	"Open a full DebuggerView."	| topView |	topView _ self topView.	topView model: nil.  "so close won't release me."	Smalltalk isMorphic		ifTrue:			[self breakDependents.			self openFullMorphicLabel: topView label.			^ topView delete].	topView controller controlTerminate.	topView deEmphasizeView; erase.	self openFullNoSuspendLabel: topView label.	topView controller closeAndUnscheduleNoErase.	Processor terminateActive.! !!Debugger methodsFor: 'context stack (message list)' stamp: 'sw 11/6/1999 22:58'!selectedMessage	"Answer the source code of the currently selected context."	contents _ [self selectedContext sourceCode] ifError: [ :err :rcvr |		'ERROR"',(err reject: [ :each | each == $"]),'"'	].	Preferences browseWithPrettyPrint ifTrue: [contents _ self selectedClass compilerClass new					format: contents					in: self selectedClass					notifying: nil					decorated: Preferences colorWhenPrettyPrinting].	^ contents _ contents asText makeSelectorBoldIn: self selectedClass! !!Debugger methodsFor: 'context stack menu' stamp: 'sw 12/28/1999 13:04'!abandon	"abandon the debugger from its pre-debug notifier"	self abandon: self topView! !!Debugger methodsFor: 'context stack menu' stamp: 'sw 12/28/1999 13:05'!abandon: aTopView 	"abandon the notifier represented by aTopView"	aTopView controller close! !!Debugger methodsFor: 'context stack menu' stamp: 'sw 10/12/1999 17:41'!browseVersions	"Create and schedule a message set browser on all versions of the 	currently selected message selector."	| class selector |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	VersionsBrowser		browseVersionsOf: (class compiledMethodAt: selector)		class: self selectedClass		meta: self selectedClass isMeta		category: self selectedMessageCategoryName		selector: selector! !!Debugger methodsFor: 'context stack menu' stamp: 'sw 5/8/2000 03:02'!contextStackMenu: aMenu shifted: shifted	^ shifted ifFalse: [aMenu labels: 'fullStack (f)restart (r)proceed (p)step (t)send (e)where (w)peel to first like thissenders of... (n)implementors of... (m)inheritance (i)versions (v)inst var refs...inst var defs...class var refs...class variablesclass refs (N)browse full (b)file out more...'	lines: #(7 11 13 16 18)	selections: #(fullStack restart proceed doStep send where peelToFirstbrowseSendersOfMessages browseMessages methodHierarchy browseVersionsbrowseInstVarRefs browseInstVarDefsbrowseClassVarRefs browseClassVariables browseClassRefsbrowseMethodFull fileOutMessageshiftedYellowButtonActivity)]	ifTrue: [aMenu labels: 'browse class hierarchybrowse classbrowse method (O)implementors of sent messageschange sets with this methodinspect instancesinspect subinstancesrevert to previous versionremove from current change setrevert and forgetmore...' 	lines: #(5 7 10)	selections: #(classHierarchy browseClass 		openSingleMessageBrowser browseAllMessages findMethodInChangeSets 		inspectInstances inspectSubInstances		revertToPreviousVersion 		removeFromCurrentChanges revertAndForget		unshiftedYellowButtonActivity)]! !!Debugger methodsFor: 'context stack menu' stamp: 'di 1/14/1999 09:18'!doStep	"Send the selected message in the accessed method, and regain control 	after the invoked method returns."		| currentContext oldMethod |	self okToChange ifFalse: [^ self].	self checkContextSelection.	externalInterrupt ifFalse: [contextStackTop push: proceedValue].	externalInterrupt _ true. "simulation leaves same state as interrupting"	currentContext _ self selectedContext.	self contextStackIndex > 1		ifTrue: 			[currentContext completeCallee: contextStackTop.			self resetContext: currentContext]		ifFalse: 			[currentContext stepToSendOrReturn.			currentContext willReturn				ifTrue: 					[oldMethod _ currentContext method.					currentContext _ currentContext step.					currentContext stepToSendOrReturn.					self resetContext: currentContext.					oldMethod == currentContext method "didnt used to update pc here"						ifTrue: [self changed: #contentsSelection]]				ifFalse: 					[currentContext completeCallee: currentContext step.					self changed: #contentsSelection.					self updateInspectors]]! !!Debugger methodsFor: 'context stack menu' stamp: 'tk 7/18/1999 23:01'!peelToFirst	"Peel the stack back to the second occurance of the currently selected message.  Very useful for an infinite recursion.  Gets back to the second call so you can see one complete recursion cycle, and how it was called at the beginning.  Also frees a lot of space!!"	| upperGuy meth second |	contextStackIndex = 0 ifTrue: [^ self beep].	"self okToChange ifFalse: [^ self]."	upperGuy _ contextStack at: contextStackIndex.	meth _ upperGuy method.	contextStackIndex+1 to: contextStack size do: [:ind |		(contextStack at: ind) method == meth ifTrue: [			second _ upperGuy.			upperGuy _ contextStack at: ind]].	second ifNil: [second _ upperGuy].	self resetContext: second.	interruptedProcess popTo: self selectedContext.! !!Debugger methodsFor: 'code pane' stamp: 'di 9/22/1998 00:21'!pcRange	"Answer the indices in the source code for the method corresponding to 	the selected context's program counter value."	| i methodNode pc end |	(selectingPC and: [contextStackIndex ~= 0])		ifFalse: [^1 to: 0].	sourceMap == nil ifTrue:		[methodNode _ self selectedClass compilerClass new			parse: contents			in: self selectedClass			notifying: nil.		sourceMap _ methodNode sourceMap.		tempNames _ methodNode tempNames.		self selectedContext method cacheTempNames: tempNames].	sourceMap size = 0 ifTrue: [^1 to: 0].	pc_ self selectedContext pc -		((externalInterrupt and: [contextStackIndex=1])			ifTrue: [1]			ifFalse: [2]).	i _ sourceMap indexForInserting: (Association key: pc value: nil).	i < 1 ifTrue: [^1 to: 0].	i > sourceMap size		ifTrue:			[end _ sourceMap inject: 0 into:				[:prev :this | prev max: this value last].			^ end+1 to: end].	^(sourceMap at: i) value! !!Debugger methodsFor: 'dependents access' stamp: 'di 1/14/1999 09:28'!step 	"Update the inspectors."	receiverInspector ifNotNil: [receiverInspector step].	contextVariablesInspector ifNotNil: [contextVariablesInspector step].! !!Debugger methodsFor: 'dependents access' stamp: 'di 1/14/1999 09:25'!wantsSteps 	^ true! !!Debugger methodsFor: 'private' stamp: 'sw 9/23/1999 15:58'!contextStackIndex: anInteger oldContextWas: oldContext	| newMethod |	contextStackIndex _ anInteger.	anInteger = 0		ifTrue:			[tempNames _ sourceMap _ contents _ nil.			self changed: #contextStackIndex.			self contentsChanged.			contextVariablesInspector object: nil.			receiverInspector object: self receiver.			^self].	(newMethod _ oldContext == nil or:		[oldContext method ~~ self selectedContext method])		ifTrue:			[tempNames _ sourceMap _ nil.			contents _ self selectedMessage.			self contentsChanged.			self pcRange "will compute tempNamesunless noFrills"].	self changed: #contextStackIndex.	tempNames == nil		ifTrue: [tempNames _ 					self selectedClassOrMetaClass parserClass new parseArgsAndTemps: contents notifying: nil].	contextVariablesInspector object: self selectedContext.	receiverInspector object: self receiver.	newMethod ifFalse: [self changed: #contentsSelection]! !!Debugger methodsFor: 'private' stamp: 'jm 10/7/2002 05:53'!process: aProcess controller: aController context: aContext	super initialize.	Smalltalk at: #MessageTally ifPresent: [:c | c new close].	contents _ nil. 	interruptedProcess _ aProcess.	interruptedController _ aController.	contextStackTop _ aContext.	self newStack: (contextStackTop stackOfSize: 1).	contextStackIndex _ 1.	externalInterrupt _ false.	selectingPC _ true.! !!Debugger methodsFor: 'private' stamp: 'jm 10/7/2002 05:52'!resumeProcess: aTopView	Smalltalk isMorphic ifFalse: [aTopView erase].	savedCursor ifNotNil: [Sensor currentCursor: savedCursor].	interruptedProcess suspendedContext method			== (Process compiledMethodAt: #terminate)		ifFalse:		[contextStackIndex > 1			ifTrue: [interruptedProcess popTo: self selectedContext]			ifFalse: [interruptedProcess install: self selectedContext].		Smalltalk isMorphic			ifTrue: [Project current resumeProcess: interruptedProcess]			ifFalse: [ScheduledControllers						activeControllerNoTerminate: interruptedController						andProcess: interruptedProcess]].	"if old process was terminated, just terminate current one"	interruptedProcess _ nil. "Before delete, so release doesn't terminate it"	Smalltalk isMorphic		ifTrue: [aTopView delete. World displayWorld]		ifFalse: [aTopView controller closeAndUnscheduleNoErase].	Smalltalk installLowSpaceWatcher.  "restart low space handler"	Processor terminateActive! !!Debugger class methodsFor: 'class initialization' stamp: 'di 1/14/1999 09:17'!initialize	ErrorRecursion _ false.	ContextStackKeystrokes _ Dictionary new		at: $e put: #send;		at: $t put: #doStep;		at: $p put: #proceed;		at: $r put: #restart;		at: $f put: #fullStack;		at: $w put: #where;		yourself.	"Debugger initialize"! !!Debugger class methodsFor: 'instance creation' stamp: 'jm 10/7/2002 05:55'!context: aContext	"Answer an instance of me for debugging the active process starting with the given context."	^ self new		process: Processor activeProcess		controller:			((Smalltalk isMorphic not and: [ScheduledControllers inActiveControllerProcess])				ifTrue: [ScheduledControllers activeController]				ifFalse: [nil])		context: aContext! !!Debugger class methodsFor: 'opening' stamp: 'jm 10/7/2002 05:56'!openContext: aContext label: aString contents: contentsString	"Open a notifier in response to an error, halt, or notify. A notifier view just shows a short view of the sender stack and provides a menu that lets the user open a full debugger."	<primitive: 19> "Simulation guard"	ErrorRecursion not & Preferences logDebuggerStackToFile ifTrue:		[Smalltalk logError: aString inContext: aContext to: 'SqueakDebug.log'].	ErrorRecursion ifTrue:		[ErrorRecursion _ false.		self primitiveError: aString].	ErrorRecursion _ true.	(Debugger context: aContext)		openNotifierContents: contentsString		label: aString.	ErrorRecursion _ false.	Processor activeProcess suspend.! !!Debugger class methodsFor: 'opening' stamp: 'ar 5/1/1999 09:25'!openInterrupt: aString onProcess: interruptedProcess	"Open a notifier in response to an interrupt. An interrupt occurs when the user types the interrupt key (cmd-. on Macs, ctrl-c or alt-. on other systems) or when the low-space watcher detects that memory is low."	| debugger |	<primitive: 19> "Simulation guard"	debugger _ self new.	debugger		process: interruptedProcess		controller: ((Smalltalk isMorphic not					and: [ScheduledControllers activeControllerProcess == interruptedProcess])						ifTrue: [ScheduledControllers activeController])		context: interruptedProcess suspendedContext.	debugger externalInterrupt: true.Preferences logDebuggerStackToFile ifTrue:	[(aString includesSubString: 'Space') & 		(aString includesSubString: 'low') ifTrue: [			Smalltalk logError: aString inContext: debugger interruptedContext to:'LowSpaceDebug.log']].	^ debugger		openNotifierContents: debugger interruptedContext shortStack		label: aString! !I decompile a method in three phases:	Reverser: postfix byte codes -> prefix symbolic codes (nodes and atoms)	Parser: prefix symbolic codes -> node tree (same as the compiler)	Printer: node tree -> text (done by the nodes)!!Decompiler methodsFor: 'instruction decoding' stamp: 'di 2/5/2000 09:34'!doPop	stack isEmpty ifTrue:		["Ignore pop in first leg of ifNil for value"		^ self].	stack last == CaseFlag		ifTrue: [stack removeLast]		ifFalse: [statements addLast: stack removeLast].! !!Decompiler methodsFor: 'instruction decoding' stamp: 'di 2/6/2000 08:46'!jump: dist if: condition	| savePc elseDist sign elsePc elseStart end cond ifExpr thenBlock elseBlock thenJump		elseJump condHasValue b isIfNil saveStack |	stack last == CascadeFlag ifTrue: [^ self case: dist].	elsePc _ lastPc.	elseStart _ pc + dist.	end _ limit.	"Check for bfp-jmp to invert condition.	Don't be fooled by a loop with a null body."	sign _ condition.	savePc _ pc.	((elseDist _ self interpretJump) notNil and: [elseDist >= 0 and: [elseStart = pc]])		ifTrue: [sign _ sign not.  elseStart _ pc + elseDist].	pc _ savePc.	ifExpr _ stack removeLast.	(stack size > 0 and: [stack last == IfNilFlag])		ifTrue: [stack removeLast.  isIfNil _ true]		ifFalse: [isIfNil _ false].	saveStack _ stack.	stack _ OrderedCollection new.	thenBlock _ self blockTo: elseStart.	condHasValue _ hasValue or: [isIfNil].	"ensure jump is within block (in case thenExpr returns)"	thenJump _ exit <= end ifTrue: [exit] ifFalse: [elseStart].	"if jump goes back, then it's a loop"	thenJump < elseStart		ifTrue:			["Must be a while loop...			thenJump will jump to the beginning of the while expr.  In the case of			while's with a block in the condition, the while expr			should include more than just the last expression: find all the			statements needed by re-decompiling."			stack _ saveStack.			pc _ thenJump.			b _ self statementsTo: elsePc.			"discard unwanted statements from block"			b size - 1 timesRepeat: [statements removeLast].			statements addLast: (constructor					codeMessage: (constructor codeBlock: b returns: false)					selector: (constructor codeSelector: (sign ifTrue: [#whileFalse:] ifFalse: [#whileTrue:]) code: #macro)					arguments: (Array with: thenBlock)).			pc _ elseStart.			self convertToDoLoop]		ifFalse:			["Must be a conditional..."			elseBlock _ self blockTo: thenJump.			elseJump _ exit.			"if elseJump is backwards, it is not part of the elseExpr"			elseJump < elsePc				ifTrue: [pc _ lastPc].			isIfNil			ifTrue: [cond _ constructor						codeMessage: ifExpr ifNilReceiver						selector: (sign							ifTrue: [constructor codeSelector: #ifNotNil: code: #macro]							ifFalse: [constructor codeSelector: #ifNil: code: #macro])						arguments: (Array with: thenBlock)]			ifFalse: [cond _ constructor						codeMessage: ifExpr						selector: (constructor codeSelector: #ifTrue:ifFalse: code: #macro)						arguments:							(sign								ifTrue: [Array with: elseBlock with: thenBlock]								ifFalse: [Array with: thenBlock with: elseBlock])].			stack _ saveStack.			condHasValue				ifTrue: [stack addLast: cond]				ifFalse: [statements addLast: cond]]! !!Decompiler methodsFor: 'instruction decoding' stamp: 'th 3/17/2000 20:48'!methodReturnTop	| last |	last _ stack removeLast "test test" asReturnNode.	stack size > blockStackBase  "get effect of elided pop before return"		ifTrue: [statements addLast: stack removeLast].	exit _ method size + 1.	lastJumpPc _ lastReturnPc _ lastPc.	statements addLast: last! !!Decompiler methodsFor: 'instruction decoding' stamp: 'di 1/29/2000 08:38'!send: selector super: superFlag numArgs: numArgs	| args rcvr selNode msgNode messages |	args _ Array new: numArgs.	(numArgs to: 1 by: -1) do:		[:i | args at: i put: stack removeLast].	rcvr _ stack removeLast.	superFlag ifTrue: [rcvr _ constructor codeSuper].	(selector == #blockCopy: and: [self checkForBlock: rcvr])		ifFalse:			[selNode _ constructor codeAnySelector: selector.			rcvr == CascadeFlag				ifTrue:					["May actually be a cascade or an ifNil: for value."					self willJumpIfFalse						ifTrue: "= generated by a case macro"							[selector == #= ifTrue:								[" = signals a case statement..."								statements addLast: args first.								stack addLast: rcvr. "restore CascadeFlag"								^ self].							selector == #== ifTrue:								[" == signals an ifNil: for value..."								stack removeLast; removeLast.								rcvr _ stack removeLast.								stack addLast: IfNilFlag;									addLast: (constructor										codeMessage: rcvr										selector: selNode										arguments: args).								^ self].							self error: 'bad case: ', selector]						ifFalse:							[(self willJumpIfTrue and: [selector == #==]) ifTrue:								[" == signals an ifNotNil: for value..."								stack removeLast; removeLast.								rcvr _ stack removeLast.								stack addLast: IfNilFlag;									addLast: (constructor										codeMessage: rcvr										selector: selNode										arguments: args).								^ self].							msgNode _ constructor codeCascadedMessage: selNode											arguments: args].					stack last == CascadeFlag						ifFalse:							["Last message of a cascade"							statements addLast: msgNode.							messages _ self popTo: stack removeLast.  "Depth saved by first dup"							msgNode _ constructor								codeCascade: stack removeLast								messages: messages]]				ifFalse:					[msgNode _ constructor								codeMessage: rcvr								selector: selNode								arguments: args].			stack addLast: msgNode]! !!Decompiler methodsFor: 'private' stamp: 'di 2/6/2000 11:06'!convertToDoLoop	"If statements contains the pattern		var _ startExpr.		[var <= limit] whileTrue: [...statements... var _ var + incConst]	then replace this by		startExpr to: limit by: incConst do: [:var | ...statements...]"	| initStmt toDoStmt limitStmt |	statements size < 2 ifTrue: [^ self].	initStmt _ statements at: statements size-1.	(toDoStmt _ statements last toDoFromWhileWithInit: initStmt)		== nil ifTrue: [^ self].	initStmt variable scope: -1.  "Flag arg as block temp"	statements removeLast; removeLast; addLast: toDoStmt.	"Attempt further conversion of the pattern		limitVar _ limitExpr.		startExpr to: limitVar by: incConst do: [:var | ...statements...]	to		startExpr to: limitExpr by: incConst do: [:var | ...statements...]"	statements size < 2 ifTrue: [^ self].	limitStmt _ statements at: statements size-1.	((limitStmt isMemberOf: AssignmentNode)		and: [limitStmt variable isTemp		and: [limitStmt variable == toDoStmt arguments first		and: [self methodRefersOnlyOnceToTemp: limitStmt variable fieldOffset]]])		ifFalse: [^ self].	toDoStmt arguments at: 1 put: limitStmt value.	limitStmt variable scope: -2.  "Flag limit var so it won't print"	statements removeLast; removeLast; addLast: toDoStmt.! !!Decompiler methodsFor: 'private' stamp: 'di 2/6/2000 08:49'!interpretNextInstructionFor: client	| code varNames |"Change false here will trace all state in Transcript."true ifTrue: [^ super interpretNextInstructionFor: client].	varNames _ Decompiler allInstVarNames.	code _ (self method at: pc) radix: 16.	Transcript cr; cr; print: pc; space;		nextPutAll: '<' , (code copyFrom: 4 to: code size) , '>'.	8 to: varNames size do:		[:i | i <= 10 ifTrue: [Transcript cr]				ifFalse: [Transcript space; space].		Transcript nextPutAll: (varNames at: i);				nextPutAll: ': '; print: (self instVarAt: i)].	Transcript endEntry.	^ super interpretNextInstructionFor: client! !!Decompiler methodsFor: 'private' stamp: 'di 2/6/2000 10:55'!methodRefersOnlyOnceToTemp: offset	| nRefs byteCode extension scanner |	nRefs _ 0.	offset <= 15		ifTrue:			[byteCode _ 16 + offset.			(InstructionStream on: method) scanFor:				[:instr | instr = byteCode ifTrue: [nRefs _ nRefs + 1].				nRefs > 1]]		ifFalse:			[extension _ 64 + offset.			scanner _ InstructionStream on: method.			scanner scanFor:				[:instr | (instr = 128 and: [scanner followingByte = extension])							ifTrue: [nRefs _ nRefs + 1].				nRefs > 1]].	^ nRefs = 1! !!Decompiler methodsFor: 'private' stamp: 'di 12/26/1998 21:29'!quickMethod	| |	method isReturnSpecial		ifTrue: [^ constructor codeBlock:				(Array with: (constTable at: method primitive - 255)) returns: true].	method isReturnField		ifTrue: [^ constructor codeBlock:				(Array with: (constructor codeInst: method returnField)) returns: true].	self error: 'improper short method'! !!Decompiler class methodsFor: 'class initialization' stamp: 'di 1/28/2000 22:21'!initialize	CascadeFlag _ 'cascade'.  "A unique object"	CaseFlag _ 'case'. "Ditto"	ArgumentFlag _ 'argument'.  "Ditto"	IfNilFlag _ 'ifNil'.  "Ditto"	"Decompiler initialize"! !I construct the node tree for a Decompiler.!!DecompilerConstructor methodsFor: 'constructor' stamp: 'sma 3/3/2000 13:34'!codeBlock: statements returns: returns	^ BlockNode statements: statements returns: returns! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'di 11/19/1999 11:06'!codeCascade: receiver messages: messages	^ (BraceNode new matchBraceStreamReceiver: receiver messages: messages)		ifNil: [CascadeNode new receiver: receiver messages: messages]! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'sma 3/3/2000 13:35'!codeEmptyBlock	^ BlockNode withJust: NodeNil! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'sma 2/5/2000 12:37'!codeMessage: receiver selector: selector arguments: arguments	| symbol node |	symbol _ selector key.	(node _ BraceNode new			matchBraceWithReceiver: receiver			selector: symbol			arguments: arguments) ifNotNil: [^ node].	(node _ self decodeIfNilWithReceiver: receiver			selector: symbol			arguments: arguments) ifNotNil: [^ node].	^ MessageNode new			receiver: receiver selector: selector			arguments: arguments			precedence: symbol precedence! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'sma 2/5/2000 12:37'!codeMethod: selector block: block tempVars: vars primitive: primitive class: class	| node |	node _ self codeSelector: selector code: nil.	tempVars _ vars.	^MethodNode new		selector: node		arguments: (tempVars copyFrom: 1 to: nArgs)		precedence: selector precedence		temporaries: (tempVars copyFrom: nArgs + 1 to: tempVars size)		block: block		encoder: (Encoder new initScopeAndLiteralTables					nTemps: tempVars size					literals: literalValues					class: class)		primitive: primitive! !!DecompilerConstructor methodsFor: 'constructor' stamp: 'di 1/28/2000 21:23'!decodeIfNilWithReceiver: receiver selector: selector arguments: arguments	selector == #ifTrue:ifFalse:		ifFalse: [^ nil].	(receiver isMessage: #==				receiver: nil				arguments: [:argNode | argNode == NodeNil])		ifFalse: [^ nil].	^ (MessageNode new			receiver: receiver			selector: (SelectorNode new key: #ifTrue:ifFalse: code: #macro)			arguments: arguments			precedence: 3)		noteSpecialSelector: #ifNil:ifNotNil:! !!DeflateStream methodsFor: 'initialize-release' stamp: 'ar 12/29/1999 17:30'!flush	"Force compression"	self deflateBlock.! !!DeflateStream methodsFor: 'initialize-release' stamp: 'ar 12/31/1999 18:00'!initialize	blockStart _ nil.	blockPosition _ 0.	hashValue _ 0.	self initializeHashTables.! !!DeflateStream methodsFor: 'initialize-release' stamp: 'ar 12/29/1999 17:32'!initializeHashTables	hashHead _ WordArray new: 1 << HashBits.	hashTail _ WordArray new: WindowSize.! !!DeflateStream methodsFor: 'initialize-release' stamp: 'ar 12/29/1999 17:33'!on: aCollection	self initialize.	super on: (aCollection species new: WindowSize * 2).! !!DeflateStream methodsFor: 'initialize-release' stamp: 'ar 12/28/1999 17:34'!on: aCollection from: firstIndex to: lastIndex	"Not for DeflateStreams please"	^self shouldNotImplement! !!DeflateStream methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:00'!goodMatchLength	"Return the length that is considered to be a 'good' match.	Higher values will result in better compression but take more time."	^MaxMatch "Best compression"! !!DeflateStream methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:00'!hashChainLength	"Return the max. number of hash chains to traverse.	Higher values will result in better compression but take more time."	^4096 "Best compression"! !!DeflateStream methodsFor: 'accessing' stamp: 'ar 12/29/1999 17:33'!nextPutAll: aCollection	| start count max |	aCollection species = collection species		ifFalse:[			aCollection do:[:ch| self nextPut: ch].			^aCollection].	start _ 1.	count _ aCollection size.	[count = 0] whileFalse:[		position = writeLimit ifTrue:[self deflateBlock].		max _ writeLimit - position.		max > count ifTrue:[max _ count].		collection replaceFrom: position+1			to: position+max			with: aCollection			startingAt: start.		start _ start + max.		count _ count - max.		position _ position + max].	^aCollection! !!DeflateStream methodsFor: 'accessing' stamp: 'ar 12/28/1999 17:35'!pastEndPut: anObject	self deflateBlock.	^self nextPut: anObject! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 20:24'!compare: here with: matchPos min: minLength	"Compare the two strings and return the length of matching characters.	minLength is a lower bound for match lengths that will be accepted.	Note: here and matchPos are zero based."	| length |	"First test if we can actually get longer than minLength"	(collection at: here+minLength+1) = (collection at: matchPos+minLength+1)		ifFalse:[^0].	(collection at: here+minLength) = (collection at: matchPos+minLength)		ifFalse:[^0].	"Then test if we have an initial match at all"	(collection at: here+1) = (collection at: matchPos+1)		ifFalse:[^0].	(collection at: here+2) = (collection at: matchPos+2)		ifFalse:[^1].	"Finally do the real comparison"	length _ 3.	[length <= MaxMatch and:[		(collection at: here+length) = (collection at: matchPos+length)]]			whileTrue:[length _ length + 1].	^length - 1! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/31/1999 18:00'!deflateBlock	"Deflate the current contents of the stream"	| flushNeeded lastIndex |	(blockStart == nil) ifTrue:[		"One time initialization for the first block"		1 to: MinMatch-1 do:[:i| self updateHashAt: i].		blockStart _ 0].	[blockPosition < position] whileTrue:[		(position + MaxMatch > writeLimit)			ifTrue:[lastIndex _ writeLimit - MaxMatch]			ifFalse:[lastIndex _ position].		flushNeeded _ self deflateBlock: lastIndex-1							chainLength: self hashChainLength							goodMatch: self goodMatchLength.		flushNeeded ifTrue:[			self flushBlock.			blockStart _ blockPosition].		"Make room for more data"		self moveContentsToFront].! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 18:05'!deflateBlock: lastIndex chainLength: chainLength goodMatch: goodMatch	"Continue deflating the receiver's collection from blockPosition to lastIndex.	Note that lastIndex must be at least MaxMatch away from the end of collection"	| here matchResult flushNeeded hereMatch hereLength newMatch newLength hasMatch |	blockPosition > lastIndex ifTrue:[^false]. "Nothing to deflate"	hasMatch _ false.	here _ blockPosition.	[here <= lastIndex] whileTrue:[		hasMatch ifFalse:[			"Find the first match"			matchResult _ self findMatch: here								lastLength: MinMatch-1								lastMatch: here								chainLength: chainLength								goodMatch: goodMatch.			self insertStringAt: here. "update hash table"			hereMatch _ matchResult bitAnd: 16rFFFF.			hereLength _ matchResult bitShift: -16].		"Look ahead if there is a better match at the next position"		matchResult _ self findMatch: here+1							lastLength: hereLength							lastMatch: hereMatch							chainLength: chainLength							goodMatch: goodMatch.		newMatch _ matchResult bitAnd: 16rFFFF.		newLength _ matchResult bitShift: -16.		"Now check if the next match is better than the current one.		If not, output the current match (provided that the current match		is at least MinMatch long)"		(hereLength >= newLength and:[hereLength >= MinMatch]) ifTrue:[			self assert:[self validateMatchAt: here							from: hereMatch to: hereMatch + hereLength - 1].			"Encode the current match"			flushNeeded _ self				encodeMatch: hereLength				distance: here - hereMatch.			"Insert all strings up to the end of the current match.			Note: The first string has already been inserted."			1 to: hereLength-1 do:[:i| self insertStringAt: (here _ here + 1)].			hasMatch _ false.			here _ here + 1.		] ifFalse:[			"Either the next match is better than the current one or we didn't			have a good match after all (e.g., current match length < MinMatch).			Output a single literal."			flushNeeded _ self encodeLiteral: (collection byteAt: (here + 1)).			here _ here + 1.			(here <= lastIndex and:[flushNeeded not]) ifTrue:[				"Cache the results for the next round"				self insertStringAt: here.				hasMatch _ true.				hereMatch _ newMatch.				hereLength _ newLength].		].		flushNeeded ifTrue:[blockPosition _ here. ^true].	].	blockPosition _ here.	^false! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 17:45'!findMatch: here lastLength: lastLength lastMatch: lastMatch chainLength: maxChainLength goodMatch: goodMatch	"Find the longest match for the string starting at here.	If there is no match longer than lastLength return lastMatch/lastLength.	Traverse at most maxChainLength entries in the hash table.	Stop if a match of at least goodMatch size has been found."	| matchResult matchPos distance chainLength limit bestLength length |	"Compute the default match result"	matchResult _ (lastLength bitShift: 16) bitOr: lastMatch.	"There is no way to find a better match than MaxMatch"	lastLength >= MaxMatch ifTrue:[^matchResult].	"Start position for searches"	matchPos _ hashHead at: (self updateHashAt: here + MinMatch) + 1.	"Compute the distance to the (possible) match"	distance _ here - matchPos.	"Note: It is required that 0 < distance < MaxDistance"	(distance > 0 and:[distance < MaxDistance]) ifFalse:[^matchResult].	chainLength _ maxChainLength.	"Max. nr of match chain to search"	here > MaxDistance	"Limit for matches that are too old"		ifTrue:[limit _ here - MaxDistance]		ifFalse:[limit _ 0].	"Best match length so far (current match must be larger to take effect)"	bestLength _ lastLength.	["Compare the current string with the string at match position"	length _ self compare: here with: matchPos min: bestLength.	"Truncate accidental matches beyound stream position"	(here + length > position) ifTrue:[length _ position - here].	"Ignore very small matches if they are too far away"	(length = MinMatch and:[(here - matchPos) > (MaxDistance // 4)])		ifTrue:[length _ MinMatch - 1].	length > bestLength ifTrue:["We have a new (better) match than before"		"Compute the new match result"		matchResult _ (length bitShift: 16) bitOr: matchPos.		bestLength _ length.		"There is no way to find a better match than MaxMatch"		bestLength >= MaxMatch ifTrue:[^matchResult].		"But we may have a good, fast match"		bestLength > goodMatch ifTrue:[^matchResult].	].	(chainLength _ chainLength - 1) > 0] whileTrue:[		"Compare with previous entry in hash chain"		matchPos _ hashTail at: (matchPos bitAnd: WindowMask) + 1.		matchPos <= limit ifTrue:[^matchResult]. "Match position is too old"	].	^matchResult! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/28/1999 17:37'!flushBlock	"Flush a deflated block"! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 17:46'!insertStringAt: here	"Insert the string at the given start position into the hash table.	Note: The hash value is updated starting at MinMatch-1 since	all strings before have already been inserted into the hash table	(and the hash value is updated as well)."	| prevEntry |	hashValue _ self updateHashAt: (here + MinMatch).	prevEntry _ hashHead at: hashValue+1.	hashHead at: hashValue+1 put: here.	hashTail at: (here bitAnd: WindowMask)+1 put: prevEntry.! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 17:48'!updateHash: nextValue	"Update the running hash value based on the next input byte.	Return the new updated hash value."	^((hashValue bitShift: HashShift) bitXor: nextValue) bitAnd: HashMask.! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/29/1999 17:47'!updateHashAt: here	"Update the hash value at position here (one based)"	^self updateHash: (collection byteAt: here)! !!DeflateStream methodsFor: 'deflating' stamp: 'ar 12/28/1999 17:43'!validateMatchAt: pos from: startPos to: endPos	| here |	here _ pos.	startPos+1 to: endPos+1 do:[:i|		(collection at: i) = (collection at: (here _ here + 1))			ifFalse:[^self error:'Not a match']].	^true! !!DeflateStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:04'!encodeLiteral: literal	"Encode the given literal.	Return true if the current block needs to be flushed."	^false! !!DeflateStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:04'!encodeMatch: matchLength distance: matchDistance	"Encode a match of the given length and distance.	Return true if the current block should be flushed."	^false! !!DeflateStream methodsFor: 'private' stamp: 'ar 12/29/1999 17:50'!moveContentsToFront	"Move the contents of the receiver to the front"	| delta |	delta _ (blockPosition - WindowSize).	delta <= 0 ifTrue:[^self].	"Move collection"	collection 		replaceFrom: 1 		to: collection size - delta 		with: collection 		startingAt: delta+1.	position _ position - delta.	"Move hash table entries"	blockPosition _ blockPosition - delta.	blockStart _ blockStart - delta.	self updateHashTable: hashHead delta: delta.	self updateHashTable: hashTail delta: delta.! !!DeflateStream methodsFor: 'private' stamp: 'ar 12/29/1999 20:15'!updateHashTable: table delta: delta	| pos |	<primitive:'primitiveDeflateUpdateHashTable'>	1 to: table size do:[:i|		"Discard entries that are out of range"		(pos _ table at: i) >= delta			ifTrue:[table at: i put: pos - delta]			ifFalse:[table at: i put: 0]].! !!DeflateStream class methodsFor: 'class initialization' stamp: 'ar 12/30/1999 00:24'!initialize	"DeflateStream initialize"	#(	WindowSize WindowMask 		MaxDistance MinMatch MaxMatch		HashBits HashMask HashShift	) do:[:sym|			ZipConstants declare: sym from: Undeclared.		].	WindowSize _ 16r8000.	WindowMask _ WindowSize - 1.	MaxDistance _ WindowSize.	MinMatch _ 3.	MaxMatch _ 258.	HashBits _ 15.	HashMask _ (1 << HashBits) - 1.	HashShift _ (HashBits + MinMatch - 1) // MinMatch.! !!Delay class methodsFor: 'instance creation' stamp: 'di 6/16/1999 23:04'!forSeconds: aNumber	"Return a new Delay for the given number of seconds. Sending 'wait' to this Delay will cause the sender's process to be suspended for approximately that length of time."	aNumber < 0 ifTrue: [self error: 'delay times cannot be negative'].	^ self new		setDelay: (aNumber * 1000) asInteger		forSemaphore: Semaphore new! !!Delay class methodsFor: 'utilities' stamp: 'jm 6/22/2003 08:17'!waitMSecs: mSecs	"Delay for the given number of milliseconds. For convenience."	(Delay forMilliseconds: mSecs) wait.! !!Delay class methodsFor: 'testing' stamp: 'ar 9/6/1999 17:05'!anyActive	"Return true if there is any delay currently active"	^ActiveDelay notNil! !I am a DialogBox for presenting messages to the user and asking them simple yes/no/okay/cancel questions. I am a subclass of ImageFrameMorph so I have my own frame and image buttons.Examples:	DialogBoxMorph ask: 'Time for lunch?'	DialogBoxMorph askWithCancel: 'Save project before quitting?'	DialogBoxMorph inform: 'Operation complete.'	DialogBoxMorph informWithCancel: 'This operation may take a while...'	DialogBoxMorph warn: 'File not found'I can show a different image on the top left corner of my window to show Question, Information or Attention messages based on the type parameter to my initialization message:	type: 1 = Question (question mark)	type: 2 = Attention (exclamation point)	type: 3 = Information (information symbol)For string input, see InputDialogBoxMorph.!!DialogBoxMorph methodsFor: 'initialization' stamp: 'jm 12/8/2003 07:45'!buttonLabel: labelString action: actionSelector	"Answer a new button with the given label and selector. The button target will be me and it will use my button forms."	"(DialogBoxMorph new buttonLabel: 'Yes' action: #beep) openInWorld"	| skin onForm offForm overForm |	skin _ ScratchFrameMorph defaultSkin.	onForm _ skin at: #dialogButtonPressed.	offForm _ skin at: #dialogButton.	overForm _ skin at: #dialogButtonOver.	^ ToggleButton new		isMomentary: true;		onForm: onForm offForm: offForm overForm: overForm;		label: labelString font: (StrikeFont familyName: 'New York' size: 18 emphasized: 1);		target: self;		actionSelector: actionSelector! !!DialogBoxMorph methodsFor: 'initialization' stamp: 'jm 12/8/2003 07:45'!initForms	"Set the forms used for my edges, corners, buttons, etc."	| skin |	skin _ ScratchFrameMorph defaultSkin.	topLeftForm _ skin at: #dialogTopLeft.	topRightForm _ skin at: #dialogTopRight.	bottomLeftForm _ skin at: #dialogBottomLeft.	bottomRightForm _ skin at: #dialogBottomRight.	topEdgeForm _ skin at: #dialogTopEdge.	leftEdgeForm _ skin at: #dialogLeftEdge.	rightEdgeForm _ skin at: #dialogRightEdge.	bottomEdgeForm _ skin at: #dialogBottomEdge.! !!DialogBoxMorph methodsFor: 'initialization' stamp: 'jm 12/7/2003 17:25'!initialize	"Set the forms for all my UI elements. Create a morph for my message text and a row to hold my buttons and install them in a column."	| col |	super initialize.	self initForms.	messageMorph _ TextMorph new   "morph to display the message"		contents: 'Question/message text not yet set'.	messageMorph beAllFont:		((StrikeFont familyName: 'New York' size: 12) emphasis: 1).  "bold"	buttonRow _ AlignmentMorph new  "row for yes/no/okay/cancel buttons"		orientation: #horizontal;		hResizing: #spacefill;		centering: #center;		vResizing: #shrinkWrap;		color: Color white.	col _ AlignmentMorph newColumn		color: Color white;		inset: 5;		hResizing: #rigid;		position: 5@24.	col addMorphBack: messageMorph.	col addMorphBack: (AlignmentMorph newSpacer: Color transparent).	col addMorphBack: buttonRow.	self addMorphBack: col.	self extent: 180@130.  "fix layout"! !!DialogBoxMorph methodsFor: 'initialization' stamp: 'jm 12/8/2003 07:45'!type: typeIndex withButtonsForYes: yesFlag no: noFlag okay: okayFlag cancel: cancelFlag	"Set my dialog box type and replace my current buttons with the ones specified."	"Note: The button row morph was created by initialize; I just replace its contents with a new collection of buttons. Spacers are added at both ends to provide centering."	| formName |	formName _ #(dialogTopLeft dialogTopLeftAttention dialogTopLeftInfo) at: typeIndex.	topLeftForm _ ScratchFrameMorph defaultSkin at: formName.	buttonRow removeAllMorphs.	buttonRow addMorphBack: (AlignmentMorph newSpacer: Color transparent).	yesFlag ifTrue: [buttonRow addMorphBack: (self buttonLabel: 'Yes' action: #yes)].	noFlag ifTrue: [buttonRow addMorphBack: (self buttonLabel: 'No' action: #no)].	okayFlag ifTrue: [buttonRow addMorphBack: (self buttonLabel: 'Okay' action: #yes)].	cancelFlag ifTrue: [buttonRow addMorphBack: (self buttonLabel: 'Cancel' action: #cancelled)].	buttonRow addMorphBack: (AlignmentMorph newSpacer: Color transparent).! !!DialogBoxMorph methodsFor: 'accessing' stamp: 'jm 12/6/2003 07:19'!message	^ messageMorph contents asString! !!DialogBoxMorph methodsFor: 'accessing' stamp: 'jm 12/7/2003 17:04'!message: aMessage	"Set my message/question text."	messageMorph contents: aMessage.	messageMorph beAllFont:		((StrikeFont familyName: 'New York' size: 15) emphasized: 1).  "bold 14-point"! !!DialogBoxMorph methodsFor: 'geometry' stamp: 'jm 12/7/2003 17:26'!extent: aPoint	"Resize my submorphs correctly whenever I get resized."	| minExtent col |	submorphs size = 0 ifTrue: [^ super extent: aPoint].  "no submorphs to resize; happens during initialization"	minExtent _ 100@100.	buttonRow ifNotNil: [minExtent _ (buttonRow minWidth @ buttonRow minHeight) + (10@60)].	super extent: (aPoint max: minExtent).	col _ self firstSubmorph.	col extent: self extent - (10@28).  "resize the column"	col submorphs do: [:m |		(m isKindOf: TextMorph) ifTrue: [ 			m contents: m contents wrappedTo: col width - (2 * col inset)]]! !!DialogBoxMorph methodsFor: 'interaction' stamp: 'jm 12/6/2003 07:52'!cancelled	"Cancel button was pressed."	response _ #cancelled.	done _ true.! !!DialogBoxMorph methodsFor: 'interaction' stamp: 'jm 12/7/2003 17:30'!getUserResponse	"Wait for the user to respond, then report their response. The symbol #cancel is returned if the user wishes to cancel the operation. True/false is returned if they respond yes/no, and a string is returned if this this a string input dialog and they don't cancel."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."	| w |	self openInWorld.	w _ self world.	self position: w center - (self extent // 2).  "center on screen"	self extent: self extent.  "force layout"	response _ #cancelled.  "default response"	done _ false.	[done] whileFalse: [w doOneCycle].  "wait for user to press a button"	self delete.	w doOneCycle.  "erase myself from the screen"	^ response! !!DialogBoxMorph methodsFor: 'interaction' stamp: 'jm 12/5/2003 20:19'!no	"No button was pressed."	response _ false.	done _ true.! !!DialogBoxMorph methodsFor: 'interaction' stamp: 'jm 12/5/2003 20:19'!yes	"Yes button was pressed."	response _ true.	done _ true.! !!DialogBoxMorph class methodsFor: 'instance creation' stamp: 'jm 12/6/2003 08:22'!ask: questionString	"Put up an instance of me to ask a yes/no question. Answer true or false depending on which button the user presses."	"DialogBoxMorph ask: 'Time for lunch?'"	| dialogBox |	dialogBox _ self new		type: 1 withButtonsForYes: true no: true okay: false cancel: false;		message: questionString.	^ dialogBox getUserResponse! !!DialogBoxMorph class methodsFor: 'instance creation' stamp: 'jm 12/6/2003 08:24'!askWithCancel: questionString	"Put up an instance of me to ask a yes/no question but include a cancel button as well. Answer either a boolean or the symbol #cancelled."	"DialogBoxMorph askWithCancel: 'Save project before quitting?'"	| dialogBox |	dialogBox _ self new		type: 1 withButtonsForYes: true no: true okay: false cancel: true;		message: questionString.	^ dialogBox getUserResponse! !!DialogBoxMorph class methodsFor: 'instance creation' stamp: 'jm 12/6/2003 08:21'!inform: informationString	"Put up an instance of me to give the user an informational message and wait until they click the 'ok' button before proceeding."	"DialogBoxMorph inform: 'Operation complete.'"	| dialogBox |	dialogBox _ self new		type: 3 withButtonsForYes: false no: false okay: true cancel: false;		message: informationString.	^ dialogBox getUserResponse! !!DialogBoxMorph class methodsFor: 'instance creation' stamp: 'jm 12/6/2003 08:18'!informWithCancel: informationString	"Put up an instance of me to give the user an informational message and wait until they click the 'ok' button before proceeding."	"DialogBoxMorph informWithCancel: 'This operation may take a while...'"	| dialogBox |	dialogBox _ self new		type: 3 withButtonsForYes: false no: false okay: true cancel: true;		message: informationString.	^ dialogBox getUserResponse! !!DialogBoxMorph class methodsFor: 'instance creation' stamp: 'jm 12/6/2003 08:16'!warn: informationString	"Put up an instance of me to give the user a warning message and wait until they click the 'ok' button before proceeding."	"DialogBoxMorph warn: 'File not found'"	| dialogBox |	dialogBox _ self new		type: 2 withButtonsForYes: false no: false okay: true cancel: false;		message: informationString.	^ dialogBox getUserResponse! !I represent a set of elements that can be viewed from one of two perspectives: a set of associations, or a set of values that are externally named where the name can be any object that responds to =. The external name is referred to as the key.!!Dictionary methodsFor: 'accessing' stamp: 'tk 4/9/1999 10:22'!associationDeclareAt: aKey	"Return an existing association, or create and return a new one.  Needed as a single message by ImageSegment.prepareToBeSaved."	| existing |	^ self associationAt: aKey ifAbsent: [		(Undeclared includesKey: aKey)			ifTrue: 				[existing _ Undeclared associationAt: aKey.				Undeclared removeKey: aKey.				self add: existing]			ifFalse: 				[self add: aKey -> false]]! !!Dictionary methodsFor: 'accessing' stamp: 'sma 5/12/2000 14:59'!at: key ifAbsent: aBlock 	"Answer the value associated with the key or, if key isn't found,	answer the result of evaluating aBlock."	| assoc |	assoc _ array at: (self findElementOrNil: key).	assoc ifNil: [^ aBlock value].	^ assoc value! !!Dictionary methodsFor: 'accessing' stamp: 'sma 5/12/2000 15:01'!at: key ifAbsentPut: aBlock 	"Return the value at the given key. 	If key is not included in the receiver store the result 	of evaluating aBlock as new value."	^ self at: key ifAbsent: [self at: key put: aBlock value]! !!Dictionary methodsFor: 'accessing' stamp: 'sma 5/12/2000 15:00'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a	new entry for key and set is value to anObject. Answer anObject."	| index assoc |	index _ self findElementOrNil: key.	assoc _ array at: index.	assoc		ifNil: [self atNewIndex: index put: (Association key: key value: anObject)]		ifNotNil: [assoc value: anObject].	^ anObject! !!Dictionary methodsFor: 'accessing' stamp: 'ar 2/13/1999 21:16'!keyAtIdentityValue: value 	"Answer the key that is the external name for the argument, value. If 	there is none, answer nil.	Note: There can be multiple keys with the same value. Only one is returned."	^self keyAtIdentityValue: value ifAbsent: [self errorValueNotFound]! !!Dictionary methodsFor: 'accessing' stamp: 'ar 2/13/1999 21:16'!keyAtIdentityValue: value ifAbsent: exceptionBlock	"Answer the key that is the external name for the argument, value. If 	there is none, answer the result of evaluating exceptionBlock.	Note: There can be multiple keys with the same value. Only one is returned." 	self associationsDo: 		[:association | value == association value ifTrue: [^association key]].	^exceptionBlock value! !!Dictionary methodsFor: 'accessing' stamp: 'di 3/8/2000 09:12'!keysSortedSafely	"Answer a SortedCollection containing the receiver's keys."	| sortedKeys |	sortedKeys _ SortedCollection new: self size.	sortedKeys sortBlock:		[ :x :y |  "Should really be use <obj, string, num> compareSafely..."		(((x isKindOf: String) & (y isKindOf: String))		or: [(x isKindOf: Number) & (y isKindOf: Number)])			ifTrue: [ x < y]			ifFalse: [ (x class = y class)				ifTrue: [ x printString < y printString]				ifFalse: [ x class name < y class name ] ] ].	self keysDo:		[ :aKey | sortedKeys add: aKey. ].	^ sortedKeys! !!Dictionary methodsFor: 'accessing' stamp: 'ar 7/11/1999 07:28'!values	"Answer a Collection containing the receiver's values."	| out |	out _ WriteStream on: (Array new: self size).	self valuesDo: [:value | out nextPut: value].	^ out contents! !!Dictionary methodsFor: 'removing' stamp: 'di 4/4/2000 11:47'!keysAndValuesRemove: keyValueBlock	"Removes all entries for which keyValueBlock returns true."	"When removing many items, you must not do it while iterating over the dictionary, since it may be changing.  This method takes care of tallying the removals in a first pass, and then performing all the deletions afterward.  Many places in the sytem could be simplified by using this method."	| removals |	removals _ OrderedCollection new.	self associationsDo:		[:assoc | (keyValueBlock value: assoc key value: assoc value)			ifTrue: [removals add: assoc key]]. 	removals do:		[:aKey | self removeKey: aKey]! !!Dictionary methodsFor: 'enumerating' stamp: 'ar 7/11/1999 08:04'!keysAndValuesDo: aBlock	^self associationsDo:[:assoc|		aBlock value: assoc key value: assoc value].! !!Dictionary methodsFor: 'enumerating' stamp: 'ar 7/11/1999 07:29'!valuesDo: aBlock 	"Evaluate aBlock for each of the receiver's keys."	self associationsDo: [:association | aBlock value: association value]! !!Dictionary methodsFor: 'printing' stamp: 'sma 6/1/2000 09:52'!printElementsOn: aStream	aStream nextPut: $(.	self keysSortedSafely do:		[:key | aStream print: key; nextPutAll: '->'; print: (self at: key); space].	aStream nextPut: $)! !!DictionaryInspector methodsFor: 'selecting' stamp: 'di 3/8/2000 09:14'!calculateKeyArray	"Recalculate the KeyArray from the object being inspected"	keyArray _ object keysSortedSafely asArray.	selectionIndex _ 0.! !!DictionaryInspector methodsFor: 'selecting' stamp: 'di 9/22/1998 21:25'!contentsIsString	"Hacked so contents empty when deselected"	^ (selectionIndex = 0)! !!DictionaryInspector methodsFor: 'selecting' stamp: 'ar 12/7/1999 18:12'!selection	selectionIndex = 0 ifTrue: [^ ''].	^ object at: (keyArray at: selectionIndex) ifAbsent:[nil]! !!DictionaryInspector methodsFor: 'menu' stamp: 'di 4/28/1999 11:32'!copyName	"Copy the name of the current variable, so the user can paste it into the window below and work with is.  If collection, do (xxx at: 1). "	| sel |	sel _ '(self at: ', 		(String streamContents: [:strm | (keyArray at: selectionIndex) storeOn: strm]) ,		')'.	ParagraphEditor clipboardTextPut: sel asText.	"no undo allowed"! !I represent an entry in a directory for either a file or a subdirectory.!!DirectoryEntry methodsFor: 'accessing' stamp: 'jm 11/18/2003 10:31'!creationTime	"Answer the time this file or directory was created (seconds since epoch)."	^ creationTime! !!DirectoryEntry methodsFor: 'accessing' stamp: 'jm 11/18/2003 10:32'!fileSize	"Answer the size of this entry if it's a file. Answer zero if it's a directory."	^ fileSize! !!DirectoryEntry methodsFor: 'accessing' stamp: 'jm 11/18/2003 10:33'!isDirectory	"Answer true if this entry represents a directory (versus a file)."	^ dirFlag! !!DirectoryEntry methodsFor: 'accessing' stamp: 'jm 11/18/2003 10:31'!modificationTime	"Answer the time this file or directory was last changed (seconds since epoch)."	^ modificationTime! !!DirectoryEntry methodsFor: 'accessing' stamp: 'jm 11/18/2003 10:32'!name	"Answer the name of this file or directory"	^ name! !!DirectoryEntry methodsFor: 'private' stamp: 'jm 11/18/2003 10:34'!privateName: aString creationTime: cTime modificationTime: mTime isDirectory: isDir fileSize: fSize	"Private!! Initialize my fields."	name _ aString.	creationTime _ cTime.	modificationTime _ mTime.	dirFlag _ isDir.	fileSize _ fSize.! !!DirectoryEntry class methodsFor: 'instance creation' stamp: 'jm 11/18/2003 10:35'!fromArray: anArray	"Create a new instance of me from the five-element array returned by the directory enumeration primitive."	^ self new		privateName: (anArray at: 1)		creationTime: (anArray at: 2)		modificationTime: (anArray at: 3)		isDirectory: (anArray at: 4)		fileSize: (anArray at: 5)! !The abstract protocol for most display primitives that are used by Views for presenting information on the screen.!!DisplayObject methodsFor: 'display box access' stamp: 'jm 6/15/2003 18:24'!boundingBox	"Answer the rectangular area that represents the boundaries of the receiver's display area."	^ self computeBoundingBox! !!DisplayObject methodsFor: 'display box access' stamp: 'jm 6/15/2003 18:23'!computeBoundingBox	"Answer the rectangular area that represents the boundaries of the receiver's area for displaying information. Clients generally send 'boundingBox' instead of this message."	self subclassResponsibility! !!DisplayObject methodsFor: 'displaying' stamp: 'jm 11/25/2002 16:18'!display	"Display the receiver on the Display at 0@0 using the paint rule."	self displayOn: Display at: 0@0 rule: Form paint.! !!DisplayObject methodsFor: 'displaying' stamp: 'jm 5/25/2003 12:04'!displayAt: aDisplayPoint 	"Display the receiver located at aDisplayPoint with default settings for 	the displayMedium, rule and halftone."	self displayOn: Display at: aDisplayPoint.! !!DisplayObject methodsFor: 'animation' stamp: 'jm 5/29/2003 17:58'!follow: locationBlock while: durationBlock bitsBehind: initialBitsBehind startingLoc: loc   "Move an image around on the Display. Restore the background continuously without causing flashing. The argument, locationBlock, supplies each new location, and the argument, durationBlock, supplies true to continue or false to stop. This variant takes the bitsBehind as an input argument, and returns the final saved saved bits as method value."   | location rect1 save1 save1Blt buffer bufferBlt newLoc rect2 bothRects |   location _ loc.   rect1 _ location extent: self extent.   save1 _ initialBitsBehind.   save1Blt _ BitBlt toForm: save1.   buffer _ Form extent: self extent*2 depth: Display depth.  "Holds overlapping region"   bufferBlt _ BitBlt toForm: buffer.   Display deferUpdates: true.   self displayOn: Display at: location rule: Form paint.   Display deferUpdates: false; forceToScreen: (location extent: self extent).   [durationBlock value] whileTrue: [		newLoc _ locationBlock value.		newLoc ~= location ifTrue: [			rect2 _ newLoc extent: self extent.			bothRects _ rect1 merge: rect2.			(rect1 intersects: rect2)				ifTrue: [  "when overlap, buffer background for both rectangles"					bufferBlt copyFrom: bothRects in: Display to: 0@0.					bufferBlt copyFrom: save1 boundingBox in: save1 to: rect1 origin - bothRects origin.					"now buffer is clean background; get new bits for save1"					save1Blt copy: (0@0 extent: self extent) from: rect2 origin - bothRects origin in: buffer.					bufferBlt copyForm: self to: rect2 origin - bothRects origin rule: Form paint.					Display deferUpdates: true.					Display copy: bothRects from: 0@0 in: buffer rule: Form over.					Display deferUpdates: false; forceToScreen: bothRects]				ifFalse: [  "when no overlap, do the simple thing (both rects might be too big)"					Display deferUpdates: true.					Display copy: (location extent: save1 extent) from: 0@0 in: save1 rule: Form over.					save1Blt copyFrom: rect2 in: Display to: 0@0.					self displayOn: Display at: newLoc rule: Form paint.					Display deferUpdates: false; 						forceToScreen: (location extent: save1 extent); 						forceToScreen: (newLoc extent: self extent)].			location _ newLoc.			rect1 _ rect2]].	^ save1 displayOn: Display at: location! !My instances are used to scan text and display it on the screen or in a hidden form.!!DisplayScanner methodsFor: 'scanning' stamp: 'jm 7/23/2003 01:50'!displayLine: textLine offset: offset leftInRun: leftInRun	"The call on the primitive (scanCharactersFrom:to:in:rightX:) will be interrupted according to an array of stop conditions passed to the scanner at which time the code to handle the stop condition is run and the call on the primitive continued until a stop condition returns true (which means the line has terminated).  leftInRun is the # of characters left to scan in the current run; when 0, it is time to call setStopConditions."	| done stopCondition nowLeftInRun startIndex string lastPos |	line _ textLine.	morphicOffset _ offset.	leftMargin _ (line leftMarginForAlignment: textStyle alignment) + offset x.	destX _ runX _ leftMargin.	rightMargin _ line rightMargin + offset x.	lineY _ line top + offset y.	lineHeight _ line lineHeight.	fillBlt == nil ifFalse:		["Not right"		fillBlt destX: line left destY: lineY			width: leftMargin - line left height: lineHeight; copyBits].	lastIndex _ line first.	leftInRun <= 0		ifTrue: [self setStopConditions.  "also sets the font"				nowLeftInRun _ text runLengthFor: lastIndex]		ifFalse: [nowLeftInRun _ leftInRun].	destY _ lineY + line baseline - font ascent.	runStopIndex _ lastIndex + (nowLeftInRun - 1) min: line last.	spaceCount _ 0.	self handleIndentation.	done _ false.	string _ text string.	[done] whileFalse:[		startIndex _ lastIndex.		lastPos _ destX@destY.		stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.		lastIndex >= startIndex ifTrue:[			font displayString: string on: bitBlt 				from: startIndex to: lastIndex at: lastPos kern: kern].		"see setStopConditions for stopping conditions for displaying."		done _ self perform: stopCondition].	fillBlt == nil ifFalse:		[fillBlt destX: destX destY: lineY width: line right-destX height: lineHeight;				copyBits].	^ runStopIndex - lastIndex   "Number of characters remaining in the current run"! !!DisplayScanner methodsFor: 'scanning' stamp: 'jm 7/22/2003 20:49'!displayLines: linesInterval in: aParagraph clippedBy: visibleRectangle	"The central display routine. The call on the primitive 	(scanCharactersFrom:to:in:rightX:) will be interrupted according to an 	array of stop conditions passed to the scanner at which time the code to 	handle the stop condition is run and the call on the primitive continued 	until a stop condition returns true (which means the line has 	terminated)."	| runLength done stopCondition leftInRun startIndex string lastPos |	"leftInRun is the # of characters left to scan in the current run;		when 0, it is time to call 'self setStopConditions'"	leftInRun _ 0.	self initializeFromParagraph: aParagraph clippedBy: visibleRectangle.	ignoreColorChanges _ false.	paragraph _ aParagraph.	foregroundColor _ paragraphColor _ aParagraph foregroundColor.	backgroundColor _ aParagraph backgroundColor.	aParagraph backgroundColor isTransparent		ifTrue: [fillBlt _ nil]		ifFalse: [fillBlt _ bitBlt copy.  "Blt to fill spaces, tabs, margins"				fillBlt sourceForm: nil; sourceOrigin: 0@0.				fillBlt fillColor: aParagraph backgroundColor].	rightMargin _ aParagraph rightMarginForDisplay.	lineY _ aParagraph topAtLineIndex: linesInterval first.	linesInterval do: 		[:lineIndex | 		leftMargin _ aParagraph leftMarginForDisplayForLine: lineIndex.		destX _ (runX _ leftMargin).		line _ aParagraph lines at: lineIndex.		lineHeight _ line lineHeight.		fillBlt == nil ifFalse:			[fillBlt destX: visibleRectangle left destY: lineY				width: leftMargin - visibleRectangle left height: lineHeight; copyBits].		lastIndex _ line first.		leftInRun <= 0			ifTrue: [self setStopConditions.  "also sets the font"					leftInRun _ text runLengthFor: line first].		destY _ lineY + line baseline - font ascent.  "Should have happened in setFont"		runLength _ leftInRun.		runStopIndex _ lastIndex + (runLength - 1) min: line last.		leftInRun _ leftInRun - (runStopIndex - lastIndex + 1).		spaceCount _ 0.		done _ false.		string _ text string.		self handleIndentation.		[done] whileFalse:[			startIndex _ lastIndex.			lastPos _ destX@destY.			stopCondition _ self scanCharactersFrom: lastIndex to: runStopIndex						in: string rightX: rightMargin stopConditions: stopConditions						kern: kern.			lastIndex >= startIndex ifTrue:[				font displayString: string on: bitBlt 					from: startIndex to: lastIndex at: lastPos kern: kern].		"see setStopConditions for stopping conditions for displaying."		done _ self perform: stopCondition].		fillBlt == nil ifFalse:			[fillBlt destX: destX destY: lineY width: visibleRectangle right-destX height: lineHeight; copyBits].		lineY _ lineY + lineHeight]! !!DisplayScanner methodsFor: 'scanning' stamp: 'ar 5/17/2000 17:36'!placeEmbeddedObject: anchoredMorph	(super placeEmbeddedObject: anchoredMorph) ifFalse: [^ false].	anchoredMorph isMorph 		ifTrue: [anchoredMorph position: ((destX - anchoredMorph width)@lineY) - morphicOffset]		ifFalse: [destY _ lineY.				runX _ destX.				anchoredMorph displayOn: bitBlt destForm at: destX - anchoredMorph width @ destY].	^ true! !!DisplayScanner methodsFor: 'private' stamp: 'ar 5/17/2000 17:36'!fillLeading	"At the end of every run (really only needed when font size changes),	fill any extra leading above and below the font in the larger line height"	fillBlt == nil ifTrue: [^ self].  "No fill requested"	"Fill space above the font"	fillBlt destX: runX destY: lineY width: destX - runX height: destY - lineY;		copyBits.	"Fill space below the font"	fillBlt destY: (destY + font height); height: (lineY + lineHeight) - (destY + font height);		copyBits.! !!DisplayScanner methodsFor: 'private' stamp: 'jm 5/29/2003 17:58'!initializeFromParagraph: aParagraph clippedBy: clippingRectangle	super initializeFromParagraph: aParagraph clippedBy: clippingRectangle.	bitBlt _ BitBlt toForm: aParagraph destinationForm.	bitBlt fillColor: aParagraph fillColor.	"sets halftoneForm"	bitBlt combinationRule: aParagraph rule.	bitBlt clipRect: clippingRectangle.! !!DisplayScanner methodsFor: 'private' stamp: 'ar 5/17/2000 19:26'!setDestForm: df	bitBlt setDestForm: df.! !!DisplayScanner methodsFor: 'private' stamp: 'ar 5/17/2000 18:57'!setFont 	foregroundColor _ paragraphColor.	super setFont.  "Sets font and emphasis bits, and maybe foregroundColor"	font installOn: bitBlt foregroundColor: foregroundColor backgroundColor: backgroundColor.	text ifNotNil:[destY _ lineY + line baseline - font ascent]! !!DisplayScanner methodsFor: 'private' stamp: 'ar 5/17/2000 20:25'!setPort: aBitBlt	"Install the BitBlt to use"	bitBlt _ aBitBlt.	bitBlt sourceForm: nil. "Make sure font installation won't be confused"! !!DisplayScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:51'!text: t textStyle: ts foreground: foreColor background: backColor fillBlt: blt ignoreColorChanges: shadowMode	text _ t.	textStyle _ ts. 	foregroundColor _ paragraphColor _ foreColor.	(backgroundColor _ backColor) isTransparent ifFalse:		[fillBlt _ blt.		fillBlt fillColor: backgroundColor].	ignoreColorChanges _ shadowMode! !!DisplayScanner methodsFor: 'private' stamp: 'ar 1/8/2000 14:51'!textColor: textColor	ignoreColorChanges ifTrue: [^ self].	foregroundColor _ textColor! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'ar 5/19/2000 14:46'!characterNotInFont	"See the note in CharacterScanner>>characterNotInFont.	All fonts have an illegal character to be used when a character is not 	within the font's legal range. When characters out of ranged are 	encountered in scanning text, then this special character indicates the 	appropriate behavior. The character is usually treated as a unary 	message understood by a subclass of CharacterScanner."	| illegalAsciiString saveIndex stopCondition lastPos |	saveIndex _ lastIndex.	lastPos _ destX @ destY.	illegalAsciiString _ String with: (font maxAscii + 1) asCharacter.	stopCondition _ self scanCharactersFrom: 1 to: 1			in: illegalAsciiString			rightX: rightMargin stopConditions: stopConditions			kern: kern.	font displayString: illegalAsciiString 			on: bitBlt from: 1 to: 1 at: lastPos kern: kern.	lastIndex _ saveIndex + 1.	stopCondition ~= (stopConditions at: EndOfRun)		ifTrue:	[^self perform: stopCondition]		ifFalse: [lastIndex = runStopIndex					ifTrue:	[^self perform: (stopConditions at: EndOfRun)].				^false]! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'ar 1/8/2000 14:42'!cr	"When a carriage return is encountered, simply increment the pointer 	into the paragraph."	lastIndex_ lastIndex + 1.	^false! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'ar 1/8/2000 14:42'!crossedX	"This condition will sometimes be reached 'legally' during display, when, 	for instance the space that caused the line to wrap actually extends over 	the right boundary. This character is allowed to display, even though it 	is technically outside or straddling the clipping ectangle since it is in 	the normal case not visible and is in any case appropriately clipped by 	the scanner."	self fillLeading.	^ true ! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'ar 1/9/2000 13:56'!endOfRun	"The end of a run in the display case either means that there is actually 	a change in the style (run code) to be associated with the string or the 	end of this line has been reached."	| runLength |	self fillLeading.  "Fill any leading above or below the font"	lastIndex = line last ifTrue: [^true].	runX _ destX.	runLength _ text runLengthFor: (lastIndex _ lastIndex + 1).	runStopIndex _ lastIndex + (runLength - 1) min: line last.	self setStopConditions.	^ false! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'ar 5/17/2000 17:36'!paddedSpace	"Each space is a stop condition when the alignment is right justified. 	Padding must be added to the base width of the space according to 	which space in the line this space is and according to the amount of 	space that remained at the end of the line when it was composed."	| oldX |	spaceCount _ spaceCount + 1.	oldX _ destX.	destX _ oldX + spaceWidth + (line justifiedPadFor: spaceCount).	fillBlt == nil ifFalse:		[fillBlt destX: oldX destY: destY width: destX - oldX height: font height; copyBits].	lastIndex _ lastIndex + 1.	^ false! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'jm 7/23/2003 16:20'!plainTab	| oldX |	oldX _ destX.	super plainTab.	fillBlt ifNotNil: [		fillBlt destX: oldX destY: destY width: destX - oldX height: font height; copyBits].! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'ar 5/18/2000 16:47'!setStopConditions	"Set the font and the stop conditions for the current run."		self setFont.	textStyle alignment = Justified ifTrue:[		"Make a local copy of stop conditions so we don't modify the default"		stopConditions == DefaultStopConditions 			ifTrue:[stopConditions _ stopConditions copy].		stopConditions at: Space asciiValue + 1 put: #paddedSpace]! !!DisplayScanner methodsFor: 'stop conditions' stamp: 'ar 5/17/2000 17:36'!tab	| oldX |	oldX _ destX.	destX _ (textStyle alignment == Justified and: [self leadingTab not])		ifTrue:		"imbedded tabs in justified text are weird"			[destX + (textStyle tabWidth - (line justifiedTabDeltaFor: spaceCount)) max: destX]		ifFalse: 			[textStyle nextTabXFrom: destX				leftMargin: leftMargin				rightMargin: rightMargin].	fillBlt == nil ifFalse:		[fillBlt destX: oldX destY: destY width: destX - oldX height: font height; copyBits].	lastIndex _ lastIndex + 1.	^ false! !!DisplayScanner methodsFor: 'quick print' stamp: 'ar 5/18/2000 18:00'!drawString: aString at: aPoint	"Draw the given string."	destX _ aPoint x asInteger.	destY _ aPoint y asInteger.	self primScanCharactersFrom: 1 to: aString size in: aString		rightX: bitBlt clipX + bitBlt clipWidth + font maxWidth		stopConditions: stopConditions kern: kern.	font displayString: aString on: bitBlt from: 1 to: lastIndex at: aPoint kern: kern.! !!DisplayScanner methodsFor: 'quick print' stamp: 'ar 5/17/2000 17:41'!lineHeight	"Answer the height of the font used by QuickPrint."	^ font height! !!DisplayScanner methodsFor: 'quick print' stamp: 'jm 5/29/2003 17:58'!quickPrintOn: aForm box: aRectangle font: aStrikeFont color: textColor	"Initialize myself."	bitBlt _ BitBlt toForm: aForm.	backgroundColor _ Color transparent.	paragraphColor _ textColor.	font _ aStrikeFont ifNil: [TextStyle defaultFont].	emphasisCode _ 0.	kern _ 0.	indentationLevel _ 0.	self setFont.	"Override cbrule and map"	bitBlt combinationRule: Form paint.	bitBlt colorMap: (Bitmap with: 0      "Assumes 1-bit deep fonts"						with: (textColor pixelValueForDepth: bitBlt destForm depth)).	bitBlt clipRect: aRectangle.! !!DisplayScanner methodsFor: 'quick print' stamp: 'ar 5/18/2000 18:00'!stringWidth: aString	"Answer the width of the given string."	destX _ destY _ 0.	aString ifNil: [^ 0].	self primScanCharactersFrom: 1 to: aString size in: aString		rightX: 99999	"virtual infinity"		stopConditions: stopConditions		kern: kern.	^ destX"	(1 to: 10) collect: [:i | QuickPrint new stringWidth: (String new: i withAll: $A)]"! !!DisplayScanner methodsFor: 'quick print' stamp: 'jm 8/30/2003 21:47'!stringWidth: aString from: startIndex to: endIndex	"Answer the width of the given string between the given indices."	destX _ destY _ 0.	aString ifNil: [^ 0].	self primScanCharactersFrom: startIndex to: endIndex in: aString		rightX: 99999	"virtual infinity"		stopConditions: stopConditions		kern: kern.	^ destX! !!DisplayScanner class methodsFor: 'queries' stamp: 'ar 5/17/2000 17:39'!defaultFont	^ TextStyle defaultFont! !!DisplayScanner class methodsFor: 'queries' stamp: 'ar 5/17/2000 17:40'!quickPrintOn: aForm	"Create an instance to print on the given form in the given rectangle."	^(super new) quickPrintOn: aForm box: aForm boundingBox font: self defaultFont color: Color black! !!DisplayScanner class methodsFor: 'queries' stamp: 'ar 5/17/2000 17:39'!quickPrintOn: aForm box: aRectangle	"Create an instance to print on the given form in the given rectangle."	^(super new) quickPrintOn: aForm box: aRectangle font: self defaultFont color: Color black! !!DisplayScanner class methodsFor: 'queries' stamp: 'ar 5/17/2000 17:40'!quickPrintOn: aForm box: aRectangle font: aStrikeFont	"Create an instance to print on the given form in the given rectangle."	^(super new) quickPrintOn: aForm box: aRectangle font: aStrikeFont color: Color black! !!DisplayScanner class methodsFor: 'queries' stamp: 'ar 5/17/2000 17:40'!quickPrintOn: aForm box: aRectangle font: aStrikeFont color: textColor	"Create an instance to print on the given form in the given rectangle."	^ (super new) quickPrintOn: aForm box: aRectangle font: aStrikeFont color: textColor! !!DisplayScanner class methodsFor: 'queries' stamp: 'jm 8/30/2003 21:48'!quickPrintOn: aForm font: aStrikeFont	"Create an instance to print on the given form in the given rectangle."	^ super new quickPrintOn: aForm box: aForm boundingBox font: aStrikeFont color: Color black! !!DisplayScanner class methodsFor: 'examples' stamp: 'ar 5/17/2000 17:41'!example	"This will quickly print all the numbers from 1 to 100 on the display,	and then answer the default width and height of the string 'hello world'."	"NewDisplayScanner example"	| scanner |	scanner _ self quickPrintOn: Display.	0 to: 99 do: [: i | scanner drawString: i printString at: (i//10*20) @ (i\\10*12) ].	^ (scanner stringWidth: 'hello world') @ (scanner lineHeight)! !There is only one instance of me, Display. It is a global and is used to handle general user requests to deal with the whole display screen. 	Although I offer no protocol, my name provides a way to distinguish this special instance from all other Forms. This is useful, for example, in dealing with saving and restoring the system.	To change the depth of your Display...		Display newDepth: 16.		Display newDepth: 8.		Display newDepth: 1.Valid display depths are 1, 2, 4, 8, 16 and 32.  It is suggested that you run with your monitors setting the same, for better speed and color fidelity.  Note that this can add up to 4Mb for the Display form.  Finally, note that newDepth: ends by executing a 'ControlManager restore' which currently terminates the active process, so nothing that follows in the doit will get executed.Depths 1, 2, 4 and 8 bits go through a color map to put color on the screen, but 16 and 32-bit color use the pixel values directly for RGB color (5 and 8 bits per, respectivlely).  The color choice an be observed by executing Color fromUser in whatever depth you are using.!!DisplayScreen methodsFor: 'displaying' stamp: 'jm 5/25/2003 11:48'!copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aColor 	"Copy the given rectangular area from sourceForm into myself at the given destination point using the given combination rule and fill color."	(BitBlt		destForm: self		sourceForm: sourceForm		fillColor: aColor		combinationRule: rule		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: (clipRect intersect: clippingBox)) copyBits.! !!DisplayScreen methodsFor: 'displaying' stamp: 'jm 5/29/2003 17:58'!copyBits: rect from: sf at: destOrigin clippingBox: clipRect rule: cr fillColor: hf map: map	((BitBlt		destForm: self		sourceForm: sf		fillColor: hf		combinationRule: cr		destOrigin: destOrigin		sourceOrigin: rect origin		extent: rect extent		clipRect: (clipRect intersect: clippingBox)) colorMap: map) copyBits! !!DisplayScreen methodsFor: 'other' stamp: 'RAA 11/27/1999 15:48'!displayChangeSignature	^DisplayChangeSignature! !!DisplayScreen methodsFor: 'other' stamp: 'ar 5/5/1999 23:44'!newDepth: pixelSize"	Display newDepth: 8.	Display newDepth: 1."	(self supportsDisplayDepth: pixelSize)		ifFalse:[^self inform:'Display depth ', pixelSize printString, ' is not supported on this system'].	self newDepthNoRestore: pixelSize.	self restore.! !!DisplayScreen methodsFor: 'other' stamp: 'ar 5/1/1999 11:03'!restore	Smalltalk isMorphic		ifTrue: [World fullRepaintNeeded]		ifFalse: [ScheduledControllers unCacheWindows; restore].! !!DisplayScreen methodsFor: 'other' stamp: 'sma 4/30/2000 09:27'!restoreAfter: aBlock	"Evaluate the block, wait for a mouse click, and then restore the screen."	aBlock value.	Sensor waitButton.	Smalltalk isMorphic		ifTrue: [World fullRepaintNeeded]		ifFalse: [(ScheduledControllers restore; activeController) view emphasize]! !!DisplayScreen methodsFor: 'other' stamp: 'bf 9/18/1999 19:46'!supportedDisplayDepths	"Return all pixel depths supported on the current host platform."	^#(1 2 4 8 16 32) select: [:d | self supportsDisplayDepth: d]! !!DisplayScreen methodsFor: 'other' stamp: 'ar 5/5/1999 23:45'!supportsDisplayDepth: pixelDepth	"Return true if this pixel depth is supported on the current host platform.	Primitive. Optional."	<primitive: 91>	^#(1 2 4 8 16 32) includes: pixelDepth! !!DisplayScreen methodsFor: 'private' stamp: 'di 3/3/1999 10:00'!copyFrom: aForm	"Take on all state of aForm, with complete sharing"	super copyFrom: aForm.	clippingBox _ super boundingBox! !!DisplayScreen methodsFor: 'private' stamp: 'ar 5/25/2000 23:43'!findAnyDisplayDepth	"Return any display depth that is supported on this system."	^self findAnyDisplayDepthIfNone:[		"Ugh .... now this is a biggie - a system that does not support		any of the Squeak display depths at all."		Smalltalk			logError:'Fatal error: This system has no support for any display depth at all.'			inContext: thisContext			to: 'SqueakDebug.log'.		Smalltalk quitPrimitive. "There is no way to continue from here"	].! !!DisplayScreen methodsFor: 'private' stamp: 'ar 5/25/2000 23:44'!findAnyDisplayDepthIfNone: aBlock	"Return any display depth that is supported on this system.	If there is none, evaluate aBlock."	#(1 2 4 8 16 32) do:[:bpp|		(self supportsDisplayDepth: bpp) ifTrue:[^bpp].	].	^aBlock value! !!DisplayScreen methodsFor: 'private' stamp: 'di 4/15/1999 10:58'!newDepthNoRestore: pixelSize	"Change depths.  Check if there is enough space!!  , di"	| area need |	pixelSize = depth ifTrue: [^ self  "no change"].	pixelSize < depth ifFalse:		["Make sure there is enough space"		area _ Display boundingBox area. "pixels"		Smalltalk isMorphic ifFalse:			[ScheduledControllers scheduledWindowControllers do:				[:aController | "This should be refined..."				aController view cacheBitsAsTwoTone ifFalse:					[area _ area + aController view windowBox area]]].		need _ (area * (pixelSize-depth) // 8)  "new bytes needed"				+ Smalltalk lowSpaceThreshold.		(Smalltalk garbageCollectMost <= need			and: [Smalltalk garbageCollect <= need])			ifTrue: [self error: 'Insufficient free space']].	self setExtent: self extent depth: pixelSize.	Smalltalk isMorphic ifFalse: [ScheduledControllers updateGray].	DisplayScreen startUp! !!DisplayScreen methodsFor: 'private' stamp: 'jm 6/3/1998 13:00'!primRetryShowRectLeft: l right: r top: t bottom: b	"Copy the given rectangular section of the Display to to the screen. This primitive is not implemented on all platforms. Do nothing if it fails. "	<primitive: 127>	"do nothing if primitive fails"! !!DisplayScreen methodsFor: 'private' stamp: 'jm 6/3/1998 13:02'!primShowRectLeft: l right: r top: t bottom: b	"Copy the given rectangular section of the Display to to the screen. This primitive is not implemented on all platforms. If this fails, retry integer coordinates."	<primitive: 127>	"if this fails, coerce coordinates to integers and try again"	self primRetryShowRectLeft: l truncated		right: r rounded		top: t truncated		bottom: b rounded.! !!DisplayScreen methodsFor: 'private' stamp: 'RAA 11/27/1999 15:48'!setExtent: aPoint depth: bitsPerPixel  "DisplayScreen startUp"	"This method is critical.  If the setExtent fails, there will be no	proper display on which to show the error condition..."	"ar 5/1/1999: ... and that is exactly why we check for the available display depths first."	"RAA 27 Nov 99 - if depth and extent are the same and acceptable, why go through this.	also - record when we change so worlds can tell if it is time to repaint"	(depth == bitsPerPixel and: [aPoint = self extent and: 					[self supportsDisplayDepth: bitsPerPixel]]) ifFalse: [		bits _ nil.  "Free up old bitmap in case space is low"		DisplayChangeSignature _ (DisplayChangeSignature ifNil: [0]) + 1.		(self supportsDisplayDepth: bitsPerPixel)			ifTrue:[super setExtent: aPoint depth: bitsPerPixel]			ifFalse:["Search for a suitable depth"					super setExtent: aPoint depth: self findAnyDisplayDepth].	].	clippingBox _ super boundingBox! !!DisplayScreen methodsFor: 'initialize-release' stamp: 'ar 5/26/2000 00:07'!release	"I am no longer Display. Release any resources if necessary"! !!DisplayScreen class methodsFor: 'display box access' stamp: 'sma 4/30/2000 09:25'!checkForNewScreenSize	Display extent = DisplayScreen actualScreenSize ifTrue: [^ self].	DisplayScreen startUp.	Smalltalk isMorphic		ifTrue: [World restoreDisplay]		ifFalse: [ScheduledControllers restore; searchForActiveController]! !!DisplayScreen class methodsFor: 'snapshots' stamp: 'jm 1/1/2004 11:07'!shutDown 	"Minimize Display size to save space in snapshots."	Display setExtent: 160@120 depth: Display depth.! !!DisplayScreen class methodsFor: 'snapshots' stamp: 'jm 1/1/2004 11:17'!startUp	"Install Display as the current display."	"DisplayScreen startUp"	Display setExtent: self actualScreenSize depth: Display depth.	Display beDisplay.! !I represent Text whose emphasis changes are mapped to a set of fonts. My instances have an offset used in determining screen placement for displaying. They get used two different ways in the system. In the user interface, they mainly hold onto some text which is viewed by some form of ParagraphEditor. However, as a DisplayObject, they may need to display efficiently, so my instances have a cache for the bits.!!DisplayText methodsFor: 'displaying' stamp: 'di 2/2/1999 17:12'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm 	"Refer to the comment in 	DisplayObject|displayOn:at:clippingBox:rule:mask:."	self form		displayOn: aDisplayMedium		at: aDisplayPoint + offset		clippingBox: clipRectangle		rule: ((ruleInteger = Form over and: [backColor isTransparent])				ifTrue: [Form paint]				ifFalse: [ruleInteger])		fillColor: aForm! !!DisplayText methodsFor: 'display box access' stamp: 'jm 6/15/2003 18:22'!computeBoundingBox 	"Compute minimum enclosing rectangle around characters."	| character font width carriageReturn lineWidth lineHeight |	carriageReturn _ Character cr.	width _ lineWidth _ 0.	font _ textStyle defaultFont.	lineHeight _ textStyle lineGrid.	1 to: text size do: [:i | 		character _ text at: i.		character = carriageReturn			ifTrue: [				lineWidth _ lineWidth max: width.				lineHeight _ lineHeight + textStyle lineGrid.				width _ 0]			ifFalse: [width _ width + (font widthOf: character)]].	lineWidth _ lineWidth max: width.	^ offset extent: lineWidth @ lineHeight! !!DisplayText methodsFor: 'private' stamp: 'jm 7/4/2003 10:40'!composeForm	| m form1 |	Smalltalk isMorphic		ifTrue: [			m _ TextMorph new contentsAsIs: text.			form1 _ m imageForm: 1 forRectangle: m fullBounds.			form _ (ColorForm extent: form1 extent)				offset: offset;				colors: (Array					with: (backColor == nil ifTrue: [Color transparent] ifFalse: [backColor])					with: (foreColor == nil ifTrue: [Color black] ifFalse: [foreColor])).			form1 displayOn: form]		ifFalse: [			form _ self asParagraph asForm].! !!DisplayText class methodsFor: 'examples' stamp: 'mjg 4/28/2000 14:31'!example	"Continually prints two lines of text wherever you point with the cursor	and press any mouse button.  Terminate by pressing any button on the	mouse."	| tx |	tx _ 'this is a line of characters andthis is the second line.' asDisplayText.	tx foregroundColor: Color black backgroundColor: Color transparent.	tx _ tx alignedTo: #center.	[Sensor anyButtonPressed]		whileFalse:			[tx displayOn: Display at: Sensor cursorPoint]	"DisplayText example."! !I represent a view of an instance of DisplayText.!This class represents a base for generic transformations of 2D points between different coordinate systems (including scaling and rotation). The transformations map objects between one coordinate system and another where it is assumed that a nested hierarchy of transformations can be defined.It is assumed that transformations deal with Integer points. All transformations should return Integer coordinates (even though float points may be passed in as argument).Compositions of transformations MUST work in the following order. A 'global' transformation (the argument in #composedWithGlobal:) is defined as a transformation that takes place between the receiver (the 'local') transformation and any 'global' point computations, whereas a 'local' transformation (e.g., the argument in #composedWithLocal:) takes place between the receiver ('global') and any 'local' points. For the transformation methods this means that combining a global and a local transformation will result in the following order:		globalPointToLocal: globalPoint			"globalPoint -> globalTransform -> localTransform -> locaPoint"			^localTransform globalPointToLocal:				(globalTransform globalPointToLocal: globalPoint)		localPointToGlobal: localPoint			"localPoint -> localTransform -> globalTransform -> globalPoint"			^globalTransform localPointToGlobal:				(localTransform localPointToGlobal: localPoint)!!DisplayTransform methodsFor: 'initialize' stamp: 'ar 11/2/1998 23:18'!setIdentity	"Initialize the receiver to the identity transformation (e.g., not affecting points)"	^self subclassResponsibility! !!DisplayTransform methodsFor: 'accessing' stamp: 'ar 11/2/1998 19:43'!inverseTransformation	"Return the inverse transformation of the receiver"	^self subclassResponsibility! !!DisplayTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 22:47'!isCompositeTransform	"Return true if the receiver is a composite transformation.	Composite transformations may have impact on the accuracy."	^false! !!DisplayTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 16:17'!isIdentity	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."	^self subclassResponsibility! !!DisplayTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 22:48'!isMatrixTransform2x3	"Return true if the receiver is 2x3 matrix transformation"	^false! !!DisplayTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 22:48'!isMorphicTransform	"Return true if the receiver is a MorphicTransform, that is specifies the transformation values explicitly."	^false! !!DisplayTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 16:16'!isPureTranslation	"Return true if the receiver specifies no rotation or scaling."	^self subclassResponsibility! !!DisplayTransform methodsFor: 'composing' stamp: 'ar 11/2/1998 16:15'!composedWithGlobal: aTransformation	"Return the composition of the receiver and the global transformation passed in.	A 'global' transformation is defined as a transformation that takes place	between the receiver (the 'local') transformation and any 'global' point	computations, e.g., for the methods		globalPointToLocal: globalPoint			globalPoint -> globalTransform -> localTransform -> locaPoint		localPointToGlobal: localPoint			localPoint -> localTransform -> globalTransform -> globalPoint		"	^aTransformation composedWithLocal: self! !!DisplayTransform methodsFor: 'composing' stamp: 'ar 11/2/1998 16:41'!composedWithLocal: aTransformation	"Return the composition of the receiver and the local transformation passed in.	A 'local' transformation is defined as a transformation that takes place	between the receiver (the 'global') transformation and any 'local' point	computations, e.g., for the methods		globalPointToLocal: globalPoint			globalPoint -> globalTransform -> localTransform -> locaPoint		localPointToGlobal: localPoint			localPoint -> localTransform -> globalTransform -> globalPoint		"	self isIdentity ifTrue:[^ aTransformation].	aTransformation isIdentity ifTrue:[^ self].	^ CompositeTransform new globalTransform: self							localTransform: aTransformation! !!DisplayTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:17'!globalPointToLocal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^self subclassResponsibility! !!DisplayTransform methodsFor: 'transforming points' stamp: 'ar 11/9/1998 14:35'!globalPointsToLocal: inArray	"Transform all the points of inArray from global into local coordinates"	^inArray collect:[:pt| self globalPointToLocal: pt]! !!DisplayTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:18'!localPointToGlobal: aPoint	"Transform aPoint from local coordinates into global coordinates"	^self subclassResponsibility! !!DisplayTransform methodsFor: 'transforming points' stamp: 'ar 11/9/1998 14:35'!localPointsToGlobal: inArray	"Transform all the points of inArray from local into global coordinates"	^inArray collect:[:pt| self localPointToGlobal: pt]! !!DisplayTransform methodsFor: 'transforming rects' stamp: 'ar 11/2/1998 16:19'!globalBoundsToLocal: aRectangle	"Transform aRectangle from global coordinates into local coordinates"	^Rectangle encompassing: (self globalPointsToLocal: aRectangle corners)! !!DisplayTransform methodsFor: 'transforming rects' stamp: 'ar 11/2/1998 16:19'!localBoundsToGlobal: aRectangle	"Transform aRectangle from local coordinates into global coordinates"	^Rectangle encompassing: (self localPointsToGlobal: aRectangle corners)! !!DisplayTransform methodsFor: 'transforming rects' stamp: 'di 10/25/1999 12:49'!sourceQuadFor: aRectangle	^ aRectangle innerCorners collect: 		[:p | self globalPointToLocal: p]! !!DisplayTransform methodsFor: 'converting' stamp: 'ar 11/2/1998 19:59'!asCompositeTransform	"Represent the receiver as a composite transformation"	^CompositeTransform new		globalTransform: self		localTransform: self species identity! !!DisplayTransform methodsFor: 'converting' stamp: 'ar 11/2/1998 20:01'!asMatrixTransform2x3	"Represent the receiver as a 2x3 matrix transformation"	^self subclassResponsibility! !!DisplayTransform methodsFor: 'encoding' stamp: 'ls 10/9/1999 18:56'!encodeForRemoteCanvas	"encode this transform into a string for use by a RemoteCanvas"	^self subclassResponsibility! !!DisplayTransform class methodsFor: 'instance creation' stamp: 'ls 3/19/2000 16:44'!fromRemoteCanvasEncoding: encoded	| type |	"decode a transform from the given encoded string"	type _ (ReadStream on: encoded) upTo: $,.	type = 'Morphic' ifTrue: [		^MorphicTransform fromRemoteCanvasEncoding: encoded ].	type = 'Matrix' ifTrue: [		^MatrixTransform2x3 fromRemoteCanvasEncoding: encoded ].	type = 'Composite' ifTrue: [		^CompositeTransform fromRemoteCanvasEncoding: encoded ].	^self error: 'invalid transform encoding'! !!DisplayTransform class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 20:55'!identity	^self new setIdentity! !!DosFileDirectory methodsFor: 'as yet unclassified' stamp: 'di 6/18/1998 08:57'!checkName: aFileName fixErrors: fixing	"Check if the file name contains any invalid characters"	| fName badChars hasBadChars |	fName _ super checkName: aFileName fixErrors: fixing.	badChars _ #( $: $< $> $| $/ $\ $? $* $") asSet.	hasBadChars _ fName includesAnyOf: badChars.	(hasBadChars and:[fixing not]) ifTrue:[^self error:'Invalid file name'].	hasBadChars ifFalse:[^ fName].	^ fName collect:		[:char | (badChars includes: char) 				ifTrue:[$#] 				ifFalse:[char]]! !!DosFileDirectory methodsFor: 'as yet unclassified' stamp: 'ar 12/18/1999 00:52'!fullPathFor: path	"Return the fully-qualified path name for the given file."	path isEmpty ifTrue:[^pathName].	(path at: 1) = $\ ifTrue:[		(path size >= 2 and:[(path at: 2) = $\]) ifTrue:[^path]. "e.g., \\pipe\"		^(pathName copyFrom: 1 to: 2), path "e.g., \windows\"].	(path size >= 2 and:[(path at: 2) = $: and:[path first isLetter]])		ifTrue:[^path]. "e.g., c:"	^pathName, self slash, path! !!DosFileDirectory methodsFor: 'as yet unclassified' stamp: 'bf 3/21/2000 17:06'!setPathName: pathString	"Ensure pathString is absolute - relative directories aren't supported on all platforms."	(pathString isEmpty		or: [pathString first = $\			or: [pathString size >= 2 and: [pathString second = $: and: [pathString first isLetter]]]])				ifTrue: [^ super setPathName: pathString].	self error: 'Fully qualified path expected'! !!DosFileDirectory class methodsFor: 'platform specific' stamp: 'ar 5/1/1999 01:48'!isCaseSensitive	"Return true if file names are treated case sensitive"	^false! !!DosFileDirectory class methodsFor: 'platform specific' stamp: 'sma 3/24/2000 11:15'!isDrive: fullName	^ (fullName size = 2 and: [fullName first isLetter and: [fullName last = $:]])		or: [(fullName beginsWith: '\\') and: [(fullName occurrencesOf: $\) <= 3]]! !!DosFileDirectory class methodsFor: 'platform specific' stamp: 'sma 3/24/2000 11:15'!splitName: fullName to: pathAndNameBlock	(self isDrive: fullName)		ifTrue: [^ pathAndNameBlock value: fullName value: ''].	^ super splitName: fullName to: pathAndNameBlock! !I illustrate the click/drag/double-click capabilities of Morphic.To make a morph respond to a double-click or distinguish between a single click and a drag operation, it should:	(1)  Respond "true" to #handlesMouseDown:	(2)  In the mouseDown: method, send #waitForClicksOrDrag:event: to the hand.	(3)  Reimplement #click: to react to single-clicked mouse-down.	(4)  Reimplement #doubleClick: to make the appropriate response to a double-click.	(5)  Reimplement #drag: to react to non-clicks (i.e. dragging). This message is sent continuously until the button is released. You can check the event argument to react differently on the first, intermediate, and final calls.!!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'sw 9/28/1999 16:51'!balloonText	^ 'Double-click on me to change my color; single-click on me to change border color;hold mouse down within me to grow (if I''m red) or shrink (if I''m blue).'! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'sw 9/28/1999 16:46'!click: evt	self showBalloon: 'click'.	self borderColor: (self borderColor = Color black ifTrue: [Color yellow] ifFalse: [Color black])! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'bf 9/28/1999 20:55'!doubleClick: evt	self showBalloon: 'doubleClick'.	self color: ((color = Color blue) ifTrue: [Color red] ifFalse: [Color blue])! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'sw 9/14/1999 16:05'!handlesMouseDown: evt	^ true! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'sw 9/23/1999 17:55'!initialize	super initialize.	self color: Color red! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'bf 9/28/1999 17:20'!mouseDown: evt	"Do nothing upon mouse-down except inform the hand to watch for a double-click; wait until an ensuing click:, doubleClick:, or drag: message gets dispatched"	evt hand waitForClicksOrDrag: self event: evt! !!DoubleClickExample methodsFor: 'as yet unclassified' stamp: 'mir 6/12/2000 17:53'!startDrag: evt	"We'll get a mouseDown first, some mouseMoves, and a mouseUp event last"	| oldCenter |	evt isMouseDown ifTrue:		[self showBalloon: 'drag (mouse down)'.		self world displayWorld.		(Delay forMilliseconds: 750) wait].	evt isMouseUp ifTrue:		[self showBalloon: 'drag (mouse up)'].	(evt isMouseUp or: [evt isMouseDown]) ifFalse:		[self showBalloon: 'drag (mouse still down)'].	(self containsPoint: evt cursorPoint)		ifFalse: [^ self].	oldCenter _ self center.	color = Color red		ifTrue:			[self extent: self extent + (1@1)]		ifFalse:			[self extent: ((self extent - (1@1)) max: (16@16))].	self center: oldCenter! !A slider object with two sliders on each end, which can be moved closer together or farther apart, but which cannot cross each other.  Used in the sensor editor to set the range of the sensor inputs.!!DoubleSlider methodsFor: 'as yet unclassified' stamp: 'dh 9/20/2003 16:17'!computeSlider		"calculates the positions of the two slider bars, making sure they don't cross each other"	| r |	r _ self roomToMove.	self descending		ifFalse:			[slider position: (bounds isWide				ifTrue: [r topLeft + ((r width * value) asInteger @ 0)]				ifFalse: [r topLeft + (0 @ (r height * value)  asInteger)])]		ifTrue:			[slider position: (bounds isWide				ifTrue:	[r bottomRight - ((r width * value) asInteger @ 0)]				ifFalse:	[r bottomRight - ((0 @ (r height * value) asInteger))])].	slider extent: self sliderExtent.	self descending		ifFalse:			[slider2 position: (bounds isWide				ifTrue: [r topLeft + ((r width * value2) asInteger @ 0)]				ifFalse: [r topLeft + (0 @ (r height * value2)  asInteger)])]		ifTrue:			[slider2 position: (bounds isWide				ifTrue:	[r bottomRight - ((r width * value2) asInteger @ 0)]				ifFalse:	[r bottomRight - ((0 @ (r height * value2) asInteger))])].	slider2 extent: self sliderExtent.		highlight 		extent: (slider2 left - slider right)@(highlight height);		position: (slider right)@(self top + 1).	position1 position: (slider center x - 14)@(position1 top).	position2 position: (slider2 center x - 14)@(position2 top).	(position1 bounds intersects: position2 bounds) ifTrue: [		position1 position: 			(((slider2 left - slider right // 2) + slider right) - position1 width)@(position1 top).		position2 position: 			((slider2 left - slider right // 2) + slider right)@(position2 top).].! !!DoubleSlider methodsFor: 'as yet unclassified' stamp: 'dh 7/31/2003 12:30'!handlesMouseDown: evt	^ (slider containsPoint: evt cursorPoint) | (slider2 containsPoint: evt cursorPoint)! !!DoubleSlider methodsFor: 'as yet unclassified' stamp: 'dh 7/31/2003 13:01'!initialize	super initialize.	bounds := 0@0 corner: 16@100.	color := Color gray.	borderWidth := 1.	borderColor := #inset.	value _ 0.0.	value2 _ 1.0.	descending _ false.	self initializeSlider! !!DoubleSlider methodsFor: 'as yet unclassified' stamp: 'dh 9/20/2003 16:17'!initializeSlider	value _ 0.0.	value2 _ 1.0.	sliderColor _ Color darkGray.	slider _ BorderedMorph newBounds: self totalSliderArea color: sliderColor.	slider setBorderWidth: 1 borderColor: #raised.	self addMorph: slider.	slider2 _ BorderedMorph newBounds: self totalSliderArea color: sliderColor.	slider2 setBorderWidth: 1 borderColor: #raised.	slider2 extent: (slider width)@(slider2 height).	self addMorph: slider2.	position1 _ BorderedMorph new		borderRaised;		extent: 28@20;		position: (self left - 12)@(self bottom);		borderWidth: 1;		color: Color lightGray.	position2 _ BorderedMorph new		borderRaised;		extent: 28@20;		position: (self right - 12)@(self bottom);		borderWidth: 1;		color: Color lightGray.	self addMorph: position1.	self addMorph: position2.	position1Text _ UpdatingStringMorph new		getSelector: #slider1Val;		target: self;		contents: '0';		position: (position1 left + 3)@(position1 top + 4).	position1 addMorph: position1Text.	position1Text startStepping.	position2Text _ UpdatingStringMorph new		getSelector: #slider2Val;		target: self;		contents: '1024';		position: (position2 left + 3)@(position2 top + 4).	position2 addMorph: position2Text.		highlight _ Morph new		color: (Color r: 0.35 g: 0.45 b: 0.85);		extent: (self width - slider width - slider2 width)@(self height - 2).	self addMorph: highlight.	self computeSlider.! !!DoubleSlider methodsFor: 'as yet unclassified' stamp: 'dh 7/31/2003 12:54'!mouseDown: evt	(slider containsPoint: evt cursorPoint) ifTrue: [		heldSlider _ 1.		slider color: self sliderColor lighter lighter.		"sliderShadow bounds: slider bounds.		sliderShadow isHidden: false."		dragOffset _ slider position - evt cursorPoint].	(slider2 containsPoint: evt cursorPoint) ifTrue: [		heldSlider _ 2.		slider2 color: self sliderColor lighter lighter.	"	sliderShadow2 bounds: slider2 bounds.		sliderShadow2 isHidden: false."		dragOffset _ slider2 position - evt cursorPoint].! !!DoubleSlider methodsFor: 'as yet unclassified' stamp: 'dh 7/31/2003 12:54'!mouseUp: evt	slider color: self sliderColor.	"sliderShadow isHidden: true."	slider2 color: self sliderColor.	"sliderShadow2 isHidden: true."! !!DoubleSlider methodsFor: 'as yet unclassified' stamp: 'dh 8/13/2003 17:17'!position1Text	^ position1Text.! !!DoubleSlider methodsFor: 'as yet unclassified' stamp: 'dh 8/13/2003 17:17'!position2Text	^ position2Text.! !!DoubleSlider methodsFor: 'as yet unclassified' stamp: 'dh 8/1/2003 14:03'!slider1Val	^ value * 1024.! !!DoubleSlider methodsFor: 'as yet unclassified' stamp: 'dh 8/1/2003 15:50'!slider1Val: num	value _ num / 1024.! !!DoubleSlider methodsFor: 'as yet unclassified' stamp: 'dh 8/1/2003 12:29'!slider2Val	^ value2 * 1024.! !!DoubleSlider methodsFor: 'as yet unclassified' stamp: 'dh 8/1/2003 15:50'!slider2Val: num	value2 _ num / 1024.! !!DoubleSlider methodsFor: 'as yet unclassified' stamp: 'dh 7/31/2003 15:06'!sliderThickness	^ 5.! !!DoubleSlider methodsFor: 'as yet unclassified' stamp: 'dh 8/8/2003 15:22'!value: newValue	"Drive the slider position externally..."	heldSlider = 1 		ifTrue: [			value _ newValue min: 1.0 - 0.02 max: 0.0. 			value > (value2 - 0.02) ifTrue: [value2 _ value + 0.04]]		ifFalse: [			value2 _ newValue min: 1.0 max: 0.02.			value2 < (value + 0.02) ifTrue: [value _ value2 - 0.04]].	self computeSlider! !I provide a drop-down menu of selections. If my target object is not nil, I update my display string, get a menu of possible choices, and inform the target of a menu selection by sending customizable selectors.!!DropDownSelectionMorph methodsFor: 'initialization' stamp: 'jm 6/28/2003 12:43'!initialize	| m |	super initialize.	self extent: 72@20.	self borderWidth: 1.	self color: Color transparent.	self useRoundedCorners.	fitToLabel _ true.	target _ nil.	getLabelSelector _ getMenuSelector _ menuChoiceSelector _ nil.	m _ ImageMorph new form: DropDownForm.	m position: (self position + (5@5)).	self addMorph: m.	labelMorph _ StringMorph new contents: 'January'.	labelMorph position: (self position + (15@3)).	self addMorph: labelMorph.! !!DropDownSelectionMorph methodsFor: 'accessing' stamp: 'jm 6/28/2003 12:06'!fitToLabel: aBoolean	fitToLabel _ aBoolean.! !!DropDownSelectionMorph methodsFor: 'accessing' stamp: 'jm 6/28/2003 13:31'!fixedExtent: aPoint	"Turn off label fitting and set my (now fixed) dimensions."	fitToLabel _ false.	self extent: aPoint.! !!DropDownSelectionMorph methodsFor: 'accessing' stamp: 'jm 6/28/2003 12:38'!getLabelSelector: aSymbolOrNil	getLabelSelector _ aSymbolOrNil.! !!DropDownSelectionMorph methodsFor: 'accessing' stamp: 'jm 6/28/2003 12:38'!getMenuSelector: aSymbolOrNil	getMenuSelector _ aSymbolOrNil.! !!DropDownSelectionMorph methodsFor: 'accessing' stamp: 'jm 6/28/2003 12:24'!labelString: aString	labelMorph contents: aString.	fitToLabel ifTrue: [		self extent: (labelMorph bottomRight - self topLeft) + (7@5)].! !!DropDownSelectionMorph methodsFor: 'accessing' stamp: 'jm 6/28/2003 12:43'!menuChoiceSelector: aSymbolOrNil	menuChoiceSelector _ aSymbolOrNil.! !!DropDownSelectionMorph methodsFor: 'accessing' stamp: 'jm 6/28/2003 12:39'!target: anObjectOrNil	target _ anObjectOrNil.! !!DropDownSelectionMorph methodsFor: 'events' stamp: 'jm 6/28/2003 12:47'!handlesMouseDown: evt	^ true! !!DropDownSelectionMorph methodsFor: 'events' stamp: 'jm 6/28/2003 22:15'!mouseDown: evt	| menu choice |	(menu _ self getMenuFromTarget) ifNil: [^ self beep].	choice _ menu build; startUpWithCaption: nil at: (evt cursorPoint x + 2)@(self top + 8).	choice notNil & menuChoiceSelector notNil ifTrue: [		target perform: menuChoiceSelector with: choice.		self step].! !!DropDownSelectionMorph methodsFor: 'stepping' stamp: 'jm 6/28/2003 12:39'!step	| newLabel |	((target == nil) or: [getLabelSelector == nil]) ifTrue: [^ nil].	newLabel _ target perform: getLabelSelector.	newLabel ifNil: [^ self].	newLabel _ newLabel asString.	newLabel = labelMorph contents ifFalse:		[self labelString: newLabel].! !!DropDownSelectionMorph methodsFor: 'private' stamp: 'jm 6/28/2003 12:14'!getMenuFromTarget	((target == nil) or: [getMenuSelector == nil]) ifTrue: [^ nil].	^ target perform: getMenuSelector! !!DropDownSelectionMorph class methodsFor: 'as yet unclassified' stamp: 'jm 6/28/2003 09:28'!initialize	"self initialize"	DropDownForm _ Form		extent: 7@4		depth: 1		fromArray: #(4261412864 2080374784 939524096 268435456)		offset: 0@0.! !!DualChangeSorter methodsFor: 'as yet unclassified' stamp: 'sw 3/6/1999 09:34'!morphicWindow		| window |	leftCngSorter _ ChangeSorter new myChangeSet: Smalltalk changes.	leftCngSorter parent: self.	rightCngSorter _ ChangeSorter new myChangeSet: 			ChangeSorter secondaryChangeSet.	rightCngSorter parent: self.	window _ (SystemWindow labelled: leftCngSorter label) model: self.	"topView minimumSize: 300 @ 200."	leftCngSorter openAsMorphIn: window rect: (0@0 extent: 0.5@1).	rightCngSorter openAsMorphIn: window rect: (0.5@0 extent: 0.5@1).	^ window! !!DualChangeSorter methodsFor: 'as yet unclassified' stamp: 'sma 4/30/2000 09:29'!open	| topView |	Smalltalk isMorphic | Sensor leftShiftDown ifTrue: [^ self openAsMorph].	leftCngSorter _ ChangeSorter new myChangeSet: Smalltalk changes.	leftCngSorter parent: self.	rightCngSorter _ ChangeSorter new myChangeSet: 			ChangeSorter secondaryChangeSet.	rightCngSorter parent: self.	topView _ (StandardSystemView new) model: self; borderWidth: 1.	topView label: leftCngSorter label.	topView minimumSize: 300 @ 200.	leftCngSorter openView: topView offsetBy: 0@0.	rightCngSorter openView: topView offsetBy: 360@0.	topView controller open.! !!DualChangeSorter methodsFor: 'as yet unclassified' stamp: 'sw 3/6/1999 09:34'!openAsMorph	^ self morphicWindow openInWorld! !I am used to compute the shape of circles and ellispes.!!EllipseMidpointTracer methodsFor: 'initialize' stamp: 'ar 6/28/1999 15:33'!on: aRectangle	rect _ aRectangle.	a _ rect width // 2.	b _ rect height // 2.	x _ 0.	y _ b.	aSquared _ a * a.	bSquared _ b * b.	d1 _ bSquared - (aSquared * b) + (0.25 * aSquared).	d2 _ nil.	inFirstRegion _ true.! !!EllipseMidpointTracer methodsFor: 'computing' stamp: 'ar 6/28/1999 15:35'!stepInY	"Step to the next y value"	inFirstRegion ifTrue:[		"In the upper region we must step until we reach the next y value"		[(aSquared * (y-0.5)) > (bSquared * (x+1))] whileTrue:[			d1 < 0.0				ifTrue:[d1 _ d1 + (bSquared * (2*x+3)).						x _ x + 1]				ifFalse:[d1 _ d1 + (bSquared * (2*x+3)) + (aSquared * (-2*y+2)).						y _ y - 1.						^x _ x + 1]].		"Stepping into second region"		d2 _ (bSquared * (x + 0.5) squared) + (aSquared * (y-1) squared) - (aSquared * bSquared).		inFirstRegion _ false.	].	"In the lower region each step is a y-step"	d2 < 0.0		ifTrue:[d2 _ d2 + (bSquared * (2*x+2)) + (aSquared * (-2*y+3)).				x _ x + 1]		ifFalse:[d2 _ d2 + (aSquared * (-2*y+3))].	y _ y - 1.	^x! !I draw myself as an ellipse or circle with a border.!!EllipseMorph methodsFor: 'initialization' stamp: 'jm 10/9/2002 05:53'!initialize	super initialize.	borderColor _ Color black.	borderWidth _ 1.	color _ Color yellow.! !!EllipseMorph methodsFor: 'accessing' stamp: 'jm 10/9/2002 06:02'!doesBevels	^ false! !!EllipseMorph methodsFor: 'accessing' stamp: 'jm 10/9/2002 07:31'!isRectangular	^ false! !!EllipseMorph methodsFor: 'drawing' stamp: 'jm 11/24/2002 11:02'!drawOn: aCanvas 	aCanvas fillOval: bounds color: color borderWidth: borderWidth borderColor: borderColor.! !!EllipseMorph class methodsFor: 'as yet unclassified' stamp: 'jm 5/31/2003 20:03'!includeInNewMorphMenu	^ true! !A selection menu in which individual selections are allowed to have different emphases.  Emphases allowed are: bold, italic, struckThrough, and plain.  Provide an emphasis array, with one element per selection, to use.  Refer to the class method #example.!!EmphasizedMenu methodsFor: 'emphasis' stamp: 'di 4/13/1999 16:27'!onlyBoldItem: itemNumber	"Set up emphasis such that all items are plain except for the given item number.  "	emphases _ (Array new: selections size) atAllPut: #plain.	emphases at: itemNumber put: #bold! !!EmphasizedMenu methodsFor: 'private' stamp: 'sw 4/5/1999 13:59'!setEmphasis	"Set up the receiver to reflect the emphases in the emphases array.  "	| selStart selEnd currEmphasis |	labelString _ labelString asText.	emphases isEmptyOrNil ifTrue: [^ self].	selStart _ 1.	1 to: selections size do:		[:line |			selEnd _ selStart + (selections at: line) size - 1.			((currEmphasis _ emphases at: line) size > 0 and: [currEmphasis ~~ #plain]) ifTrue:				[labelString addAttribute: (TextEmphasis perform: currEmphasis)					from: selStart to: selEnd].			selStart _ selEnd + 2]! !!EmphasizedMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:14'!selections: selList emphases: emphList	"Answer an instance of the receiver with the given selections and 	emphases."	^ (self selections: selList) emphases: emphList"Example:	(EmphasizedMenu		selections: #('how' 'well' 'does' 'this' 'work?') 		emphases: #(bold plain italic struckOut plain)) startUp"! !!EmphasizedMenu class methodsFor: 'examples' stamp: 'sma 5/28/2000 16:16'!example1	"EmphasizedMenu example1"	^ (self		selections: #('how' 'well' 'does' 'this' 'work?' ) 		emphases: #(#bold #plain #italic #struckOut #plain ))			startUpWithCaption: 'A Menu with Emphases'! !!EmphasizedMenu class methodsFor: 'examples' stamp: 'sma 5/28/2000 16:17'!example3	"EmphasizedMenu example3"	^ (self		selectionAndEmphasisPairs: #('how' #bold 'well' #plain 'does' #italic 'this' #struckOut 'work' #plain))		startUpWithCaption: 'A Menu with Emphases'! !I encode names and literals into tree nodes with byte codes for the compiler. Byte codes for literals are not assigned until the tree-sizing pass of the compiler, because only then is it known which literals are actually needed. I also keep track of sourceCode ranges during parsing and code generation so I can provide an inverse map for the debugger.!!Encoder methodsFor: 'initialize-release' stamp: 'di 12/4/1999 22:22'!init: aClass context: aContext notifying: req	| node n homeNode indexNode |	requestor _ req.	class _ aClass.	nTemps _ 0.	supered _ false.	self initScopeAndLiteralTables.	n _ -1.	class allInstVarNames do: 		[:variable | 		node _ VariableNode new					name: variable					index: (n _ n + 1)					type: LdInstType.		scopeTable at: variable put: node].	aContext == nil		ifFalse: 			[homeNode _ self bindTemp: 'homeContext'.			"first temp = aContext passed as arg"			n _ 0.			aContext tempNames do: 				[:variable | 				indexNode _ self encodeLiteral: (n _ n + 1).				node _ MessageAsTempNode new							receiver: homeNode							selector: #tempAt:							arguments: (Array with: indexNode)							precedence: 3							from: self.				scopeTable at: variable put: node]].	sourceRanges _ Dictionary new: 32.	globalSourceRanges _ OrderedCollection new: 32.! !!Encoder methodsFor: 'encoding' stamp: 'di 12/4/1999 20:09'!encodeVariable: name	^ self encodeVariable: name sourceRange: nil ifUnknown: [ self undeclared: name ]! !!Encoder methodsFor: 'encoding' stamp: 'sma 12/22/1999 11:28'!encodeVariable: name ifUnknown: action	| varNode |	varNode _ 		scopeTable 			at: name			ifAbsent: 				[self lookupInPools: name 					ifFound: [:assoc | ^self global: assoc name: name].				^action value].	(varNode isTemp and: [varNode scope < 0]) ifTrue: [^self notify: 'out of scope'].	^varNode! !!Encoder methodsFor: 'encoding' stamp: 'di 12/4/1999 22:39'!encodeVariable: name sourceRange: range ifUnknown: action	| varNode |	varNode _ scopeTable at: name			ifAbsent: 				[(self lookupInPools: name 					ifFound: [:assoc | varNode _ self global: assoc name: name])					ifTrue: [varNode]					ifFalse: [action value]].	name first isUppercase ifTrue:		[globalSourceRanges addLast: { name. range. false }].	^ varNode! !!Encoder methodsFor: 'encoding' stamp: 'di 1/7/2000 15:24'!sharableLitIndex: literal	"Special access prevents multiple entries for post-allocated super send special selectors"	| p |	p _ literalStream originalContents indexOf: literal.	p = 0 ifFalse: [^ p-1].	^ self litIndex: literal! !!Encoder methodsFor: 'encoding' stamp: 'jm 10/31/2002 08:14'!undeclared: name	| sym |	Transcript show: ' (' , name , ' is Undeclared) '.	sym _ name asSymbol.	Undeclared at: sym put: nil.	^ self global: (Undeclared associationAt: sym) name: sym! !!Encoder methodsFor: 'temps' stamp: 'di 10/12/1999 16:53'!bindAndJuggle: name	| node nodes first thisCode |	node _ self reallyBind: name.	"Declared temps must precede block temps for decompiler and debugger to work right"	nodes _ self tempNodes.	(first _ nodes findFirst: [:n | n scope > 0]) > 0 ifTrue:		[node == nodes last ifFalse: [self error: 'logic error'].		thisCode _ (nodes at: first) code.		first to: nodes size - 1 do:			[:i | (nodes at: i) key: (nodes at: i) key							code: (nodes at: i+1) code].		nodes last key: nodes last key code: thisCode].		^ node! !!Encoder methodsFor: 'temps' stamp: 'crl 2/26/1999 12:18'!bindBlockTemp: name 	"Declare a temporary block variable; complain if it's not a field or class variable."	| node |	node _ scopeTable at: name ifAbsent: [^self reallyBind: name].	node isTemp		ifTrue: [			node scope >= 0 ifTrue: [^ self notify: 'Name already used in this method'].			node scope: 0]		ifFalse: [^self notify: 'Name already used in this class'].	^node! !!Encoder methodsFor: 'temps' stamp: 'ar 7/12/1999 00:24'!bindTemp: name 	"Declare a temporary; error not if a field or class variable."	scopeTable at: name ifPresent:[:node|		"When non-interactive raise the error only if its a duplicate"		(node isTemp or:[requestor interactive])			ifTrue:[^self notify:'Name is already defined']			ifFalse:[Transcript show: '(', name, ' is shadowed)']].	^self reallyBind: name! !!Encoder methodsFor: 'results' stamp: 'ar 2/13/1999 21:18'!associationFor: aClass	| name |	name _ Smalltalk keyAtIdentityValue: aClass ifAbsent: [^Association new value: aClass].	^Smalltalk associationAt: name! !!Encoder methodsFor: 'results' stamp: 'di 10/12/1999 16:12'!tempNames 	^ self tempNodes collect:		[:node | (node isMemberOf: MessageAsTempNode)					ifTrue: [scopeTable keyAtValue: node]					ifFalse: [node key]]! !!Encoder methodsFor: 'results' stamp: 'di 10/12/1999 15:31'!tempNodes 	| tempNodes |	tempNodes _ SortedCollection sortBlock: [:n1 :n2 | n1 code <= n2 code].	scopeTable associationsDo:		[:assn | assn value isTemp ifTrue: [tempNodes add: assn value]].	^ tempNodes! !!Encoder methodsFor: 'results' stamp: 'di 10/12/1999 17:15'!unusedTempNames 	| unused name |	unused _ OrderedCollection new.	scopeTable associationsDo:		[:assn | (assn value isUnusedTemp)			ifTrue: [name _ assn value key.					name ~= 'homeContext' ifTrue: [unused add: name]]].	^ unused! !!Encoder methodsFor: 'source mapping' stamp: 'di 12/4/1999 22:27'!globalSourceRanges	^ globalSourceRanges! !!Encoder methodsFor: 'private' stamp: 'jm 10/30/2002 20:52'!lookupInPools: varName ifFound: assocBlock	Symbol hasInterned: varName ifTrue: [:sym |		(class scopeHas: sym ifTrue: assocBlock) ifTrue: [^ true].		^ false].	^ class scopeHas: varName ifTrue: assocBlock.  "Maybe a string in a pool  **Eliminate this**"! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/17/1998 15:20'!attackTime	"Return the time taken by the attack phase."	^ (points at: loopStartIndex) x! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:10'!centerPitch: aNumber	"Set the center pitch of a pitch-controlling envelope. This default implementation does nothing."! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/19/1998 09:07'!duration: seconds	"Set the note duration to the given number of seconds."	"Details: The duration is reduced by 19 mSec to ensure proper cutoffs even when the sound starts playing between doControl epochs."	"Note: This is a hack. With a little additional work on the envelope logic, it should be possible to reduce or eliminate this fudge factor. In particular, an envelope should use the time remaining, rather than time-since-start to determine when to enter its decay phase. In addition, an envelope must be able to cut off in minimum time (~5-10 msec) if there isn't enough time to do their normal decay. All of this is to allow instruments with leisurely decays to play very short notes if necessary (say, when fast-forwarding through a score)." 	| attack decay endTime |	endMSecs _ (seconds * 1000.0) asInteger - 19.	attack _ self attackTime.	decay _ self decayTime.	endMSecs > (attack + decay)		ifTrue: [endTime _ endMSecs - decay]		ifFalse: [			endMSecs >= attack				ifTrue: [endTime _ attack]				ifFalse: [endTime _ endMSecs]].	self sustainEnd: (endTime max: 0).! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 17:03'!name	^ self updateSelector allButLast! !!Envelope methodsFor: 'accessing' stamp: 'jm 8/13/1998 18:13'!volume: aNumber	"Set the maximum volume of a volume-controlling envelope. This default implementation does nothing."! !I represent a simple Smalltalk expression, typically a literal value such as a number or boolean.  Now you can edit me in place.!!ExpressionArgMorph methodsFor: 'initialization' stamp: 'jm 9/28/2003 16:23'!initialize	super initialize.	isEvaluated _ true.	self borderWidth: 1.	self borderInset.	self color: Color paleBlue.	self extent: 20@17.	"To allow for editing in place."	labelMorph _ UpdatingStringMorph new		contents: '10';		target: self;		getSelector: #expression;		putSelector: #expression:;		useStringFormat.	self addMorph: labelMorph.! !!ExpressionArgMorph methodsFor: 'accessing' stamp: 'jm 9/24/2003 18:23'!expression	^ labelMorph contents! !!ExpressionArgMorph methodsFor: 'accessing' stamp: 'jm 9/24/2003 18:23'!expression: aString	labelMorph contents: aString.	self fixArgLayout.! !!ExpressionArgMorph methodsFor: 'accessing' stamp: 'jm 9/28/2003 16:23'!numExpression: aNumber	isEvaluated _ true.	self expression: aNumber asString.! !!ExpressionArgMorph methodsFor: 'accessing' stamp: 'jm 9/28/2003 16:23'!stringExpression: aString	isEvaluated _ false.	self expression: aString.! !!ExpressionArgMorph methodsFor: 'event handling' stamp: 'jm 4/29/2003 16:30'!handlesMouseDown: evt	^ true! !!ExpressionArgMorph methodsFor: 'event handling' stamp: 'jm 6/30/2003 07:33'!wantsKeyboardFocusFor: aSubmorph	aSubmorph wouldAcceptKeyboardFocus ifTrue: [^ true].	^ super wantsKeyboardFocusFor: aSubmorph! !!ExpressionArgMorph methodsFor: 'evaluation' stamp: 'jm 9/28/2003 16:24'!evaluate	"Answer the result of evaluating my expression in the context of the given ScratchProcess."	| expr |	expr _ self expression.	isEvaluated ifFalse: [^ expr].  "string"	expr size = 0 ifTrue: [^ 0].	expr first = $. ifTrue: [expr _ '0', expr].  "supply a leading zero if necessary"	^ Compiler evaluate: expr! !!ExpressionArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:19'!fieldsVersion	^ 1! !!ExpressionArgMorph methodsFor: 'object i/o' stamp: 'jm 9/28/2003 16:34'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		isEvaluated	) from: anObjStream.! !!ExpressionArgMorph methodsFor: 'object i/o' stamp: 'jm 9/28/2003 16:34'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		isEvaluated	) on: anObjStream.! !!ExpressionArgMorph methodsFor: 'private' stamp: 'jm 8/24/2003 16:59'!fixArgLayout	self width: labelMorph width + 6.	labelMorph position: self position + (3@2).! !By John M McIntosh johnmci@smalltalkconsulting.comThis class was written to mange the external semaphore table. When I was writing a Socket test server I discovered various race conditions on the access to the externalSemaphore table. This new class uses class side methods to restrict access using a mutex semaphore. It seemed cleaner to deligate the reponsibility here versus adding more code and another class variable to SystemDictionary Note that in Smalltalk recreateSpecialObjectsArray we still directly play with the table.!!ExternalSemaphoreTable class methodsFor: 'accessing' stamp: 'JMM 6/6/2000 20:36'!clearExternalObjects	"Clear the array of objects that have been registered for use in non-Smalltalk code."	ProtectTable critical: [Smalltalk specialObjectsArray at: 39 put: Array new].! !!ExternalSemaphoreTable class methodsFor: 'accessing' stamp: 'JMM 6/6/2000 21:01'!externalObjects	^ProtectTable critical: [Smalltalk specialObjectsArray at: 39].! !!ExternalSemaphoreTable class methodsFor: 'accessing' stamp: 'JMM 6/6/2000 20:44'!registerExternalObject: anObject	^ ProtectTable critical: [self safelyRegisterExternalObject: anObject]! !!ExternalSemaphoreTable class methodsFor: 'accessing' stamp: 'JMM 6/6/2000 20:57'!safelyRegisterExternalObject: anObject	"Register the given object in the external objects array and return its index. If it is already there, just return its index."	| objects firstEmptyIndex obj sz newObjects |	objects _ Smalltalk specialObjectsArray at: 39.	"find the first empty slot"	firstEmptyIndex _ 0.	1 to: objects size do: [:i |		obj _ objects at: i.		obj == anObject ifTrue: [^ i].  "object already there, just return its index"		(obj == nil and: [firstEmptyIndex = 0]) ifTrue: [firstEmptyIndex _ i]].	"if no empty slots, expand the array"	firstEmptyIndex = 0 ifTrue: [		sz _ objects size.		newObjects _ objects species new: sz + 20.  "grow linearly"		newObjects replaceFrom: 1 to: sz with: objects startingAt: 1.		firstEmptyIndex _ sz + 1.		Smalltalk specialObjectsArray at: 39 put: newObjects.		objects _ newObjects].	objects at: firstEmptyIndex put: anObject.	^ firstEmptyIndex! !!ExternalSemaphoreTable class methodsFor: 'accessing' stamp: 'JMM 6/6/2000 20:59'!safelyUnregisterExternalObject: anObject	"Unregister the given object in the external objects array. Do nothing if it isn't registered.	JMM change to return if we clear the element, since it should only appear once in the array"	| objects |	anObject ifNil: [^ self].	objects _ Smalltalk specialObjectsArray at: 39.	1 to: objects size do: [:i |		(objects at: i) == anObject ifTrue: 		[objects at: i put: nil.		^self]].! !!ExternalSemaphoreTable class methodsFor: 'accessing' stamp: 'JMM 6/6/2000 20:45'!unregisterExternalObject: anObject	ProtectTable critical: [self safelyUnregisterExternalObject: anObject]! !!ExternalSemaphoreTable class methodsFor: 'initialize' stamp: 'JMM 6/6/2000 20:32'!initialize	ProtectTable _ Semaphore forMutualExclusion! !This class implements the Fast Fourier Transform roughly as described on page 367of "Theory and Application of Digital Signal Processing" by Rabiner and Gold.Each instance caches tables used for transforming a given size (n = 2^nu samples) of data.It would have been cleaner using complex numbers, but often the data is all real.!!FFT methodsFor: 'initialization' stamp: 'jm 8/25/1999 21:59'!n	^ n! !!FFT methodsFor: 'testing' stamp: 'jm 8/1/1998 13:08'!imagData	^ imagData! !!FFT methodsFor: 'testing' stamp: 'jm 8/1/1998 13:08'!realData	^ realData! !!FFT methodsFor: 'testing' stamp: 'jm 8/16/1998 17:36'!samplesPerCycleForIndex: i	"Answer the number of samples per cycle corresponding to a power peak at the given index. Answer zero if i = 1, since an index of 1 corresponds to the D.C. component."	| windowSize |	windowSize _ 2 raisedTo: nu.	(i < 1 or: [i > (windowSize // 2)]) ifTrue: [^ self error: 'index is out of range'].	i = 1 ifTrue: [^ 0].  "the D.C. component"	^ windowSize asFloat / (i - 1)! !!FFT methodsFor: 'plugin-testing' stamp: 'ar 10/10/1998 21:53'!pluginPrepareData	"The FFT plugin requires data to be represented in WordArrays or FloatArrays"	sinTable _ sinTable asFloatArray.	permTable _ permTable asWordArray.	realData _ realData asFloatArray.	imagData _ imagData asFloatArray.! !!FFT methodsFor: 'plugin-testing' stamp: 'ar 10/10/1998 21:53'!pluginTest  "Display restoreAfter: [(FFT new nu: 12) pluginTest]."	"Test on an array of 256 samples"	"Initialize to pure (co)Sine Wave, plot, transform, plot, invert and plot again"	self realData: ((1 to: n) collect: [:i | (Float pi * (i-1) / (n/8)) cos]).	self plot: realData in: (100@20 extent: 256@60).	self pluginPrepareData.	Transcript cr; print: (Time millisecondsToRun:[self pluginTransformData: true]); endEntry.	self plot: realData in: (100@100 extent: 256@60).	self plot: imagData in: (100@180 extent: 256@60).	Transcript cr; print: (Time millisecondsToRun:[self pluginTransformData: false]); endEntry.	self plot: realData in: (100@260 extent: 256@60)! !!FFT methodsFor: 'plugin-testing' stamp: 'jm 10/2/2002 13:50'!pluginTransformData: forward	"Do FFT transform in the given direction."	<primitive: 'primitiveFFTTransformData'>	self primitiveFailed.! !!FFT methodsFor: 'bulk processing' stamp: 'jm 9/8/1999 17:10'!initializeHammingWindow: alpha	"Initialize the windowing function to the generalized Hamming window. See F. Richard Moore, Elements of Computer Music, p. 100. An alpha of 0.54 gives the Hamming window, 0.5 gives the hanning window."	| v midPoint |	window _ FloatArray new: n.	midPoint _ (n + 1) / 2.0.	1 to: n do: [:i |		v _ alpha + ((1.0 - alpha) * (2.0 * Float pi * ((i - midPoint) / n)) cos).		window at: i put: v].! !!FFT methodsFor: 'bulk processing' stamp: 'jm 9/8/1999 16:42'!initializeTriangularWindow	"Initialize the windowing function to the triangular, or Parzen, window. See F. Richard Moore, Elements of Computer Music, p. 100."	| v |	window _ FloatArray new: n.	0 to: (n // 2) - 1 do: [:i |		v _ i / ((n // 2) - 1).		window at: (i + 1) put: v.		window at: (n - i) put: v].! !!FFT methodsFor: 'bulk processing' stamp: 'jm 9/8/1999 17:40'!setSize: anIntegerPowerOfTwo	"Initialize variables and tables for performing an FFT on the given number of samples. The number of samples must be an integral power of two (e.g. 1024). Prepare data for use with the fast primitive."	self nu: (anIntegerPowerOfTwo log: 2) asInteger.	n = anIntegerPowerOfTwo ifFalse: [self error: 'size must be a power of two'].	sinTable _ sinTable asFloatArray.	permTable _ permTable asWordArray.	realData _ FloatArray new: n.	imagData _ FloatArray new: n.	self initializeHammingWindow: 0.54.  "0.54 for Hamming, 0.5 for hanning"! !!FFT methodsFor: 'bulk processing' stamp: 'jm 9/8/1999 17:55'!transformDataFrom: anIndexableCollection startingAt: index	"Forward transform a block of real data taken from from the given indexable collection starting at the given index. Answer a block of values representing the normalized magnitudes of the frequency components."	| j real imag out |	j _ 0.	index to: index + n - 1 do: [:i |		realData at: (j _ j + 1) put: (anIndexableCollection at: i)].	realData *= window.	imagData _ FloatArray new: n.	self pluginTransformData: true.	"compute the magnitudes of the complex results"	"note: the results are in bottom half; the upper half is just its mirror image"	real _ realData copyFrom: 1 to: (n / 2).	imag _ imagData copyFrom: 1 to: (n / 2).	out _ (real * real) + (imag * imag).	1 to: out size do: [:i | out at: i put: (out at: i) sqrt].	^ out! !!FFT class methodsFor: 'instance creation' stamp: 'jm 8/25/1999 12:49'!new: anIntegerPowerOfTwo	"Answer a new FFT instance for transforming data packets of the given size."	^ self new setSize: anIntegerPowerOfTwo! !!FMBassoonSound methodsFor: 'as yet unclassified' stamp: 'jm 5/30/1999 21:17'!setPitch: pitchNameOrNumber dur: d loudness: l	"Select a modulation ratio and modulation envelope scale based on my pitch."	| p modScale |	p _ self nameOrNumberToPitch: pitchNameOrNumber.	modScale _ 9.4.	p > 100.0 ifTrue: [modScale _ 8.3].	p > 150.0 ifTrue: [modScale _ 6.4].	p > 200.0 ifTrue: [modScale _ 5.2].	p > 300.0 ifTrue: [modScale _ 3.9].	p > 400.0 ifTrue: [modScale _ 2.8].	p > 600.0 ifTrue: [modScale _ 1.7].	envelopes size > 0 ifTrue: [		envelopes do: [:e |			(e updateSelector = #modulation:)				ifTrue: [e scale: modScale]]].	super setPitch: p dur: d loudness: l.! !!FMClarinetSound methodsFor: 'initialization' stamp: 'jm 5/30/1999 10:10'!setPitch: pitchNameOrNumber dur: d loudness: l	"Select a modulation ratio and modulation envelope scale based on my pitch."	| p modScale |	p _ self nameOrNumberToPitch: pitchNameOrNumber.	p < 262.0		ifTrue: [modScale _ 25.0. self ratio: 4]		ifFalse: [modScale _ 20.0. self ratio: 2].	p > 524.0 ifTrue: [modScale _ 8.0].	envelopes size > 0 ifTrue: [		envelopes do: [:e |			(e updateSelector = #modulation:)				ifTrue: [e scale: modScale]]].	super setPitch: p dur: d loudness: l.! !!FMSound methodsFor: 'initialization' stamp: 'jm 7/5/1998 11:44'!initialize	super initialize.	waveTable _ SineTable.	scaledWaveTableSize _ waveTable size * ScaleFactor.	self setPitch: 440.0 dur: 1.0 loudness: 0.2.! !!FMSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:08'!setPitch: pitchNameOrNumber dur: d loudness: vol	"(FMSound pitch: 'a4' dur: 2.5 loudness: 0.4) play"	super setPitch: pitchNameOrNumber dur: d loudness: vol.	modulation ifNil: [modulation _ 0.0].	multiplier ifNil: [multiplier _ 0.0].	self pitch: (self nameOrNumberToPitch: pitchNameOrNumber).	self reset.! !!FMSound methodsFor: 'initialization' stamp: 'jm 9/20/1998 10:10'!setWavetable: anArray	"(AbstractSound lowMajorScaleOn: (FMSound new setWavetable: AA)) play"	| samples p dur vol |	"copy the array into a SoundBuffer if necessary"	anArray class isPointers		ifTrue: [samples _ SoundBuffer fromArray: anArray]		ifFalse: [samples _ anArray].	p _ self pitch.	dur _ self duration.	vol _ self loudness.	waveTable _ samples.	scaledWaveTableSize _ waveTable size * ScaleFactor.	self setPitch: p dur: dur loudness: vol.! !!FMSound methodsFor: 'accessing' stamp: 'jm 9/9/1998 07:49'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!FMSound methodsFor: 'accessing' stamp: 'jm 8/7/1998 15:45'!pitch	^ (self samplingRate asFloat * scaledIndexIncr / ScaleFactor) asFloat / waveTable size! !!FMSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:55'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!FMSound class methodsFor: 'class initialization' stamp: 'jm 7/6/1998 10:26'!initialize	"Build a sine wave table."	"FMSound initialize"	| tableSize radiansPerStep peak |	tableSize _ 4000.	SineTable _ SoundBuffer newMonoSampleCount: tableSize.	radiansPerStep _ (2.0 * Float pi) / tableSize asFloat.	peak _ ((1 bitShift: 15) - 1) asFloat.  "range is +/- (2^15 - 1)"	1 to: tableSize do: [:i |		SineTable at: i put: (peak * (radiansPerStep * (i - 1)) sin) rounded].! !!FMSound class methodsFor: 'class initialization' stamp: 'jm 7/5/1998 14:22'!sineTable	"Answer a SoundBuffer containing one complete cycle of a sine wave."	^ SineTable! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!bass1	"FMSound bass1 play"	"(FMSound lowMajorScaleOn: FMSound bass1) play"	| snd |	snd _ FMSound new modulation: 0 ratio: 0.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.95).	^ snd setPitch: 220 dur: 1.0 loudness: 0.3! !!FMSound class methodsFor: 'instruments' stamp: 'jm 5/30/1999 20:37'!bassoon1	"FMSound bassoon1 play"	"(FMSound lowMajorScaleOn: FMSound bassoon1) play"	| snd p env |	snd _ FMBassoonSound new ratio: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 40@0.45; add: 90@1.0; add: 180@0.9; add: 270@1.0; add: 320@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 5).	p _ OrderedCollection new.	p add: 0@0.2; add: 40@0.9; add: 90@0.6; add: 270@0.6; add: 320@0.5.	env _ Envelope points: p loopStart: 3 loopEnd: 4.	env updateSelector: #modulation:; scale: 5.05.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!brass1	"FMSound brass1 play"	"(FMSound lowMajorScaleOn: FMSound brass1) play"	| snd p env |	snd _ FMSound new modulation: 0 ratio: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 30@0.8; add: 90@1.0; add: 120@0.9; add: 220@0.7; add: 320@0.9; add: 360@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 4 loopEnd: 6).	p _ OrderedCollection new.	p add: 0@0.5; add: 60@1.0; add: 120@0.8; add: 220@0.65; add: 320@0.8; add: 360@0.0.	env _ Envelope points: p loopStart: 3 loopEnd: 5.	env target: snd; updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!brass2	"FMSound brass2 play"	"(FMSound lowMajorScaleOn: FMSound brass2) play"	| snd p env |	snd _ FMSound new modulation: 1 ratio: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 20@1.0; add: 40@0.9; add: 100@0.7; add: 160@0.9; add: 200@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 5).	p _ OrderedCollection new.	p add: 0@0.5; add: 30@1.0; add: 40@0.8; add: 100@0.7; add: 160@0.8; add: 200@0.0.	env _ Envelope points: p loopStart: 3 loopEnd: 5.	env updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:10'!clarinet	"FMSound clarinet play"	"(FMSound lowMajorScaleOn: FMSound clarinet) play"	| snd p env |	snd _ FMSound new modulation: 0 ratio: 2.	p _ OrderedCollection new.	p add: 0@0.0; add: 60@1.0; add: 310@1.0; add: 350@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	p _ OrderedCollection new.	p add: 0@0.0167; add: 60@0.106; add: 310@0.106; add: 350@0.0.	env _ Envelope points: p loopStart: 2 loopEnd: 3.	env updateSelector: #modulation:; scale: 10.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 5/30/1999 10:20'!clarinet2	"FMSound clarinet2 play"	"(FMSound lowMajorScaleOn: FMSound clarinet2) play"	| snd p env |	snd _ FMClarinetSound new modulation: 0 ratio: 2.	p _ OrderedCollection new.	p add: 0@0.0; add: 60@1.0; add: 310@1.0; add: 350@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	p _ OrderedCollection new.	p add: 0@0.0167; add: 60@0.106; add: 310@0.106; add: 350@0.0.	env _ Envelope points: p loopStart: 2 loopEnd: 3.	env updateSelector: #modulation:; scale: 10.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:02'!flute1	"FMSound flute1 play"	"(FMSound majorScaleOn: FMSound flute1) play"	| snd p |	snd _ FMSound new.	p _ OrderedCollection new.	p add: 0@0; add: 20@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!mellowBrass	"FMSound mellowBrass play"	"(FMSound lowMajorScaleOn: FMSound mellowBrass) play"	| snd p env |	snd _ FMSound new modulation: 0 ratio: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 70@0.325; add: 120@0.194; add: 200@0.194; add: 320@0.194; add: 380@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 3 loopEnd: 5).	p _ OrderedCollection new.	p add: 0@0.1; add: 70@0.68; add: 120@0.528; add: 200@0.519; add: 320@0.528; add: 380@0.0.	env _ Envelope points: p loopStart: 3 loopEnd: 5.	env updateSelector: #modulation:; scale: 5.0.	snd addEnvelope: env.	^ snd setPitch: 220.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:00'!oboe1	"FMSound oboe1 play"	"(FMSound majorScaleOn: FMSound oboe1) play"	| snd p |	snd _ FMSound new modulation: 1 ratio: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 1/14/1999 12:56'!organ1	"FMSound organ1 play"	"(FMSound majorScaleOn: FMSound organ1) play"	| snd p |	snd _ FMSound new.	p _ OrderedCollection new.	p add: 0@0; add: 60@1.0; add: 110@0.8; add: 200@1.0; add: 250@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 4).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 13:00'!randomWeird1	"FMSound randomWeird1 play"	| snd p |	snd _ FMSound new.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.96).	p _ Array with: 0@0 with: 100@1.0 with: 250@0.7 with: 400@1.0 with: 500@0.	snd addEnvelope: (PitchEnvelope points: p loopStart: 2 loopEnd: 4).	^ snd setPitch: (150 + 2000 atRandom) dur: 2.0 loudness: 0.5! !!FMSound class methodsFor: 'instruments' stamp: 'jm 8/14/1998 12:57'!randomWeird2	"FMSound randomWeird2 play"	| snd |	snd _ FMSound new.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.96).	snd addEnvelope: (PitchEnvelope exponentialDecay: 0.98).	^ snd setPitch: (150 + 2000 atRandom) dur: 2.0 loudness: 0.5! !A minimal FTP client program.  Could store all state in inst vars, and use an instance to represent the full state of a connection in progress.  But simpler to do all that in one method and have it be a complete transaction.Always operates in passive mode (PASV).  All connections are initiated from client in order to get through firewalls.See ServerDirectory openFTP, ServerDirectory getFileNamed:, ServerDirectory putFile:named: for examples of use.See TCP/IP, second edition, by Dr. Sidnie Feit, McGraw-Hill, 1997, Chapter 14, p311.!]style[(259 1 89 23 2 29 2 30 27 6 74)f1,f1-,f1,f1LServerDirectory openFTP;,f1,f1LServerDirectory getFileNamed:;,f1,f1LServerDirectory putFile:named:;,f1,f1b,f1!!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:13'!dataSocket	^ dataSocket! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:13'!dataSocket: dd	dataSocket _ dd! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 21:56'!getAllData	"Reel in all data until the server closes the connection.  Return a RWBinaryOrTextStream.  Don't know how much is coming."	| buf response bytesRead |	buf _ String new: 4000.	response _ RWBinaryOrTextStream on: (String new: 4000).	[(self dataAvailable | self isConnected)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | response nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	response reset.	"position: 0."	^ response! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 15:03'!getAllDataWhileWatching: otherSocket	"Reel in all data until the server closes the connection.  At the same time, watch for errors on otherSocket.  Return a RWBinaryOrTextStream.  Don't know how much is coming."	| buf response bytesRead |	buf _ String new: 4000.	response _ RWBinaryOrTextStream on: (String new: 4000).	[self isConnected | self dataAvailable] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			otherSocket responseError ifTrue: [self destroy. ^ #error:].			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | response nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	response reset.	"position: 0."	^ response! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 15:05'!getDataTo: dataStream whileWatching: otherSocket	"Reel in all data until the server closes the connection.  At the same time, watch for errors on otherSocket.  Don't know how much is coming.  Put the data on the stream."	| buf bytesRead |	buf _ String new: 4000.	[self isConnected | self dataAvailable] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			otherSocket responseError ifTrue: [self destroy. ^ #error:].			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: 1 count: buf size.		1 to: bytesRead do: [:ii | dataStream nextPut: (buf at: ii)].			"Any way to do this so we do not have to recopy?"		].	dataStream reset.	"position: 0."	^ dataStream! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 3/23/2000 22:10'!getOnlyBuffer: ubuffer whileWatching: otherSocket	"Reel in all data until the buffer is full.  At the same time, watch for errors on otherSocket.  Caller will break the connection after we have the data."	| bytesRead ind |	ind _ 1.	[self isConnected | self dataAvailable] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			otherSocket responseError ifTrue: [self destroy. ^ #error:].			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: ubuffer 			startingAt: ind count: ubuffer size - ind + 1.		(ind _ ind + bytesRead) > ubuffer size ifTrue: [^ ubuffer].		].	^ ubuffer	"file was shorter"! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'di 3/29/1999 17:18'!lookFor: beginning        "Get the response from the server.  If 1xx, in progress.  If 2xx, success.  If 3xx, intermediate point successful.  4xx, transient error.  5xx, true error.  If 4 or 5, put up dialog, kill the socket, and return the response string.  Return true the string in beginning is at the front of what came back.  Ignore any 2xx response that is not what we want, but print it."	| resp what all |	(readAhead ~~ nil and: [readAhead size > 0])		ifTrue: [resp _ readAhead removeFirst]  "response already came in"		ifFalse: [			all _ self getResponseUpTo: CrLf.			resp _ all at: 1.       "150 Opening binary mode data conn"			readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].	resp size > 0 		ifTrue: [			resp first isDigit ifFalse: [ ^self lookFor: beginning ].				"we're in the middle of a line, not the end." #XXX. "this should be fixed..."			(resp at: 4) == $- ifTrue: [^ self lookFor: beginning]. "is a comment"			(resp beginsWith: beginning) ifTrue: [^ true].  "exactly what we wanted"			]		ifFalse: [resp _ '[timeout]'].	what _ (PopUpMenu labels: 'OK\ debug ' withCRs) 		startUpWithCaption: 'Server reported this error:\' withCRs, resp.	what = 2 ifTrue: [self halt].	self destroy.	^ resp! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 7/8/1999 14:29'!lookSoftlyFor: beginning        "Get the response from the server.  Return true the string in beginning is at the front of what came back.  Don't kill the socket if we fail.  Users wants to try another password."	| resp what all |	(readAhead ~~ nil and: [readAhead size > 0])		ifTrue: [resp _ readAhead removeFirst]  "response already came in"		ifFalse: [			all _ self getResponseUpTo: CrLf.			resp _ all at: 1.       "150 Opening binary mode data conn"			readAhead _ (all at: 3) findBetweenSubStrs: (Array with: CrLf)].	resp size > 0 		ifTrue: [			resp first isDigit ifFalse: [ ^self lookFor: beginning ].				"we're in the middle of a line, not the end." #XXX. "this should be fixed..."			(resp at: 4) == $- ifTrue: [^ self lookFor: beginning]. "is a comment"			(resp beginsWith: beginning) ifTrue: [^ true].  "exactly what we wanted"			]		ifFalse: [resp _ '[timeout]'].	what _ (PopUpMenu labels: 'OK\ debug ' withCRs) 		startUpWithCaption: 'Server reported this error:\' withCRs, resp.	what = 2 ifTrue: [self halt].	^ resp! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:12'!portNum	^ portNum! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 12/26/97 22:12'!portNum: anInteger	portNum _ anInteger! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 11:59'!responseCheck	"If data is waiting, do a responseOK to catch any error reports."	self dataAvailable ifTrue: [^ self responseOK].	^ true	"all OK so far"! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 1/5/98 12:28'!responseError	"If data is waiting, Check it to catch any error reports.  Keep all responses in a queue for caller to examine later."	| all what |	self dataAvailable ifTrue: [		all _ self getResponseUpTo: CrLf.		readAhead ifNil: [readAhead _ OrderedCollection new].		readAhead addLast: (all at: 1).	"150 Opening binary mode data conn"		readAhead addAll: ((all at: 3) findBetweenSubStrs: (Array with: CrLf)).		readAhead do: [:resp |			((resp at: 1) == $5) | ((resp at: 1) == $4) ifTrue: [				what _ (PopUpMenu labels: 'OK\ debug ' withCRs) 					startUpWithCaption: 'Server reported this error:\' withCRs, resp.				what = 2 ifTrue: [self halt].				self sendCommand: 'QUIT'.				readAhead _ nil.	"clear queue"				self responseOK.		"221"				self destroy.				^ true]]].	^ false	"all OK so far"! !!FTPSocket methodsFor: 'as yet unclassified' stamp: 'mjg 5/7/1999 13:54'!responseOK	"Get the response from the server.  If 1xx, in progress.  If 2xx,success.  If 3xx, intermediate point successful.  4xx, transient error.5xx, true error.  If 4 or 5, put up dialog and kill the socket.  Returntrue if OK, the error string if not."	| resp what all |	readAhead isNil ifTrue: [readAhead _ ''].	readAhead size > 0		ifTrue: [resp _ readAhead removeFirst]	"response alreadycame in"		ifFalse: [			all _ self getResponseUpTo: CrLf.			resp _ all at: 1.	"150 Opening binary modedata conn"			readAhead _ (all at: 3) findBetweenSubStrs: (Arraywith: CrLf)].	"Transcript show: resp; cr."	resp size > 0		ifTrue: [((resp at: 1) == $5) | ((resp at: 1) == $4)ifFalse: [^ true]]  "All is well"		ifFalse: [resp _ '[timeout]'].	what _ (PopUpMenu labels: 'OK\ debug ' withCRs)		startUpWithCaption: 'Server reported this error:\' withCRs,resp.	what = 2 ifTrue: [self halt].	self destroy.	^ resp! !!FTPSocket methodsFor: 'finalization' stamp: 'ar 3/21/98 18:19'!actAsExecutor	super actAsExecutor.	dataSocket := nil.! !The sole purpose of this class is to allow the Browser code pane to evaluate the class variables of the class whose method it is showing.  It does this by stuffing a pointer to the classpool dictionary of the class being shown into its own classpool.  It does this just around a doIt in the code pane.  An instance of FakeClasspool is then used as the receiver of the doIt.!False defines the behavior of its single instance, false -- logical negation. Notice how the truth-value checks become direct message sends, without the need for explicit testing.Be aware however that most of these methods are not sent as real messages in normal use. Most are inline coded by the compiler as test and jump bytecodes - avoiding the overhead of the full message sends. So simply redefining these methods here will have no effect.!This class adds the following optimizations to the basic Inflate decompression:a) Bit reversed accessIf we want to fetch the bits efficiently then we have them in the wrong bit order (e.g., when we should fetch 2r100 we would get 2r001). But since the huffman tree lookup determines the efficiency of the decompression, reversing the bits before traversal is expensive. Therefore the entries in each table are stored in REVERSE BIT ORDER. This is achieved by a reverse increment of the current table index in the huffman table construction phase (see method increment:bits:). According to my measures this speeds up the implementation by about 30-40%.b) Inplace storage of code meanings and extra bitsRather than looking up the meaning for each code during decompression of blocks we store the appropriate values directly in the huffman tables, using a pre-defined mapping. Even though this does not make a big difference in speed, it cleans up the code and allows easier translation into primitive code (which is clearly one goal of this implementation).c) Precomputed huffman tables for fixed blocksSo we don't have to compute the huffman tables from scratch. The precomputed tables are not in our superclass to avoid double storage (and my superclass is more intended for documentation anyways).!!FastInflateStream methodsFor: 'inflating' stamp: 'ar 12/22/1999 01:30'!decompressBlock: llTable with: dTable	"Process the compressed data in the block.	llTable is the huffman table for literal/length codes	and dTable is the huffman table for distance codes."	| value extra length distance oldPos oldBits oldBitPos |	<primitive:'primitiveInflateDecompressBlock'>	[readLimit < collection size and:[sourcePos <= sourceLimit]] whileTrue:[		"Back up stuff if we're running out of space"		oldBits _ bitBuf.		oldBitPos _ bitPos.		oldPos _ sourcePos.		value _ self decodeValueFrom: llTable.		value < 256 ifTrue:[ "A literal"			collection byteAt: (readLimit _ readLimit + 1) put: value.		] ifFalse:["length/distance or end of block"			value = 256 ifTrue:["End of block"				state _ state bitAnd: StateNoMoreData.				^self].			"Compute the actual length value (including possible extra bits)"			extra _ (value bitShift: -16) - 1.			length _ value bitAnd: 16rFFFF.			extra > 0 ifTrue:[length _ length + (self nextBits: extra)].			"Compute the distance value"			value _ self decodeValueFrom: dTable.			extra _ (value bitShift: -16).			distance _ value bitAnd: 16rFFFF.			extra > 0 ifTrue:[distance _ distance + (self nextBits: extra)].			(readLimit + length >= collection size) ifTrue:[				bitBuf _ oldBits.				bitPos _ oldBitPos.				sourcePos _ oldPos.				^self].			collection 					replaceFrom: readLimit+1 					to: readLimit + length + 1 					with: collection 					startingAt: readLimit - distance + 1.			readLimit _ readLimit + length.		].	].! !!FastInflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 19:15'!processFixedBlock	litTable _ FixedLitTable.	distTable _ FixedDistTable.	state _ state bitOr: BlockProceedBit.	self proceedFixedBlock.! !!FastInflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:26'!distanceMap	^DistanceMap! !!FastInflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 01:48'!increment: value bits: nBits	"Increment value in reverse bit order, e.g. 	for a 3 bit value count as follows:		000 / 100 / 010 / 110		001 / 101 / 011 / 111	See the class comment why we need this."	| result bit |	result _ value.	"Test the lowest bit first"	bit _ 1 << (nBits - 1).	"If the currently tested bit is set then we need to	turn this bit off and test the next bit right to it"	[(result bitAnd: bit) = 0] whileFalse:[ 		"Turn off current bit"		result _ result bitXor: bit.		"And continue testing the next bit"		bit _ bit bitShift: -1].	"Turn on the right-most bit that we haven't touched in the loop above"	^result bitXor: bit! !!FastInflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:26'!literalLengthMap	^LiteralLengthMap! !!FastInflateStream methodsFor: 'bit access' stamp: 'ar 12/4/1998 02:02'!nextSingleBits: n	"Fetch the bits all at once"	^self nextBits: n.! !!FastInflateStream class methodsFor: 'class initialization' stamp: 'ar 12/21/1999 23:00'!initialize	"FastInflateStream initialize"	| low high |	"Init literal/length map"	low _ #(3 4 5 6 7 8 9 10 11 13 15 17 19 23 27 31 35 43 51 59 67 83 99 115 131 163 195 227 258 ).	high _ #(0 0 0 0 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 0 0).	LiteralLengthMap _ WordArray new: 256 + 32.	1 to: 257 do:[:i| LiteralLengthMap at: i put: i-1].	1 to: 29 do:[:i| LiteralLengthMap at: 257+i put: (low at:i) + ( (high at: i) + 1 << 16)].	"Init distance map"	high _ #(0 0 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13).	low _ #(1 2 3 4 5 7 9 13 17 25 33 49 65 97 129 193 257 385 513 769			1025 1537 2049 3073 4097 6145 8193 12289 16385 24577).	DistanceMap _ WordArray new: 32.	1 to: 30 do:[:i| DistanceMap at: i put: (low at: i) + ( (high at: i) << 16)].	"Init fixed block huffman tables"	FixedLitTable _ self basicNew				huffmanTableFrom: FixedLitCodes				mappedBy: LiteralLengthMap.	FixedDistTable _ self basicNew				huffmanTableFrom: FixedDistCodes				mappedBy: DistanceMap.! !I provide fast JPEG compression and decompression. I require the VM extension JPEGReadWriter2Plugin, which is usually installed in same directory as the Squeak virtual machine.JPEGReadWriter2Plugin is based on LIBJPEG library. This sentence applies to that library:   "This software is based in part on the work of the Independent JPEG Group".The LIBJPEG license allows it to be used free for any purpose so long as its origin and copyright are acknowledged. You can read more about LIBJPEG and get the complete source code at www.ijg.org.!!FastJPEG class methodsFor: 'image operations' stamp: 'jm 10/27/2002 11:04'!compress: aForm quality: quality	"Encode the given Form and answer the compressed ByteArray. Quality goes from 0 (low) to 100 (high)."	^ self compress: aForm quality: quality progressive: false! !!FastJPEG class methodsFor: 'image operations' stamp: 'jm 7/16/2003 13:57'!compress: aForm quality: quality progressive: progressiveFlag	"Encode the given Form and answer the compressed ByteArray. Quality goes from 0 (low) to 100 (high). If progressiveFlag is true, then create a progressive-scan JPEG which is a bit larger but causes a low-resolution version to appear in browsers while the rest of the data is being fetched."	| sourceForm jpegCompressStruct jpegErrorMgr2Struct buffer byteCount |	aForm unhibernate.	"Odd width images of depth 16 give problems; avoid them. Make sure depth is 16 or 32."	sourceForm _ (aForm depth = 32) | (aForm width even & (aForm depth = 16))		ifTrue: [aForm]		ifFalse: [aForm asFormOfDepth: 32].	jpegCompressStruct _ ByteArray new: self primJPEGCompressStructSize.	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.	buffer _ ByteArray new: 2 * sourceForm width * sourceForm height.  "larger than compressed size..."	byteCount _ self primJPEGWriteImage: jpegCompressStruct 		onByteArray: buffer		form: sourceForm		quality: quality		progressiveJPEG: progressiveFlag		errorMgr: jpegErrorMgr2Struct.	byteCount = 0 ifTrue: [self error: 'buffer too small for compressed data'].	^ buffer copyFrom: 1 to: byteCount! !!FastJPEG class methodsFor: 'image operations' stamp: 'jm 11/13/2002 10:22'!uncompress: aByteArray	"Uncompress an image from the given ByteArray and return the resulting 32-bit Form."	^ self uncompress: aByteArray doDithering: false! !!FastJPEG class methodsFor: 'image operations' stamp: 'jm 10/27/2002 08:26'!uncompress: aByteArray doDithering: ditherFlag	"Uncompress an image from the given ByteArray and return the resulting Form. If ditherFlag = true, do ordered dithering into a Form of depth 16. Otherwise, return a Form of depth 32."	| jpegDecompressStruct jpegErrorMgr2Struct w h result |	jpegDecompressStruct _ ByteArray new: self primJPEGDecompressStructSize.	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.	self 		primJPEGReadHeader: jpegDecompressStruct 		fromByteArray: aByteArray		errorMgr: jpegErrorMgr2Struct.	w _ self primImageWidth: jpegDecompressStruct.	h _ self primImageHeight: jpegDecompressStruct.	(ditherFlag and: [w odd not])  "odd width images of depth 16 do not work"		ifTrue: [result _ Form extent: w@h depth: 16]		ifFalse: [result _ Form extent: w@h depth: 32].	self primJPEGReadImage: jpegDecompressStruct		fromByteArray: aByteArray		onForm: result		doDithering: ditherFlag		errorMgr: jpegErrorMgr2Struct.	^ result! !!FastJPEG class methodsFor: 'image operations' stamp: 'jm 10/27/2002 11:05'!uncompress: aByteArray into: aForm	"Uncompress an image from the given ByteArray into the given Form. Fail if the given Form has the wrong dimensions or depth < 16. If aForm has depth 16, do ordered dithering."	self uncompress: aByteArray		into: aForm		doDithering: (aForm depth = 16).! !!FastJPEG class methodsFor: 'image operations' stamp: 'jm 10/27/2002 08:02'!uncompress: aByteArray into: aForm doDithering: ditherFlag	"Uncompress an image from the given ByteArray into the given Form. Fail if aForm has the wrong dimensions or depth < 16. If aForm has depth 16 and ditherFlag = true, do ordered dithering."	| jpegDecompressStruct jpegErrorMgr2Struct w h |	aForm unhibernate.	jpegDecompressStruct _ ByteArray new: self primJPEGDecompressStructSize.	jpegErrorMgr2Struct _ ByteArray new: self primJPEGErrorMgr2StructSize.	self 		primJPEGReadHeader: jpegDecompressStruct 		fromByteArray: aByteArray		errorMgr: jpegErrorMgr2Struct.	w _ self primImageWidth: jpegDecompressStruct.	h _ self primImageHeight: jpegDecompressStruct.	((aForm width = w) & (aForm height = h)) ifFalse: [		^ self error: 'form dimensions do not match'].	"odd width images of depth 16 give problems; avoid them"	w odd		ifTrue: [			aForm depth = 32 ifFalse: [^ self error: 'must use depth 32 with odd width']]		ifFalse: [			((aForm depth = 16) | (aForm depth = 32)) ifFalse: [^ self error: 'must use depth 16 or 32']].	self primJPEGReadImage: jpegDecompressStruct		fromByteArray: aByteArray		onForm: aForm		doDithering: ditherFlag		errorMgr: jpegErrorMgr2Struct.! !!FastJPEG class methodsFor: 'testing' stamp: 'jm 10/26/2002 22:24'!isPluginPresent	^ self primJPEGPluginIsPresent! !!FastJPEG class methodsFor: 'primitives' stamp: 'jm 10/30/2002 19:28'!primImageHeight: aJPEGCompressStruct	<primitive: 'primImageHeight' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!FastJPEG class methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!primImageWidth: aJPEGCompressStruct	<primitive: 'primImageWidth' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!FastJPEG class methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!primJPEGCompressStructSize	<primitive: 'primJPEGCompressStructSize' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!FastJPEG class methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!primJPEGDecompressStructSize	<primitive: 'primJPEGDecompressStructSize' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!FastJPEG class methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!primJPEGErrorMgr2StructSize	<primitive: 'primJPEGErrorMgr2StructSize' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!FastJPEG class methodsFor: 'primitives' stamp: 'jm 10/27/2002 07:53'!primJPEGPluginIsPresent	<primitive: 'primJPEGPluginIsPresent' module: 'JPEGReadWriter2Plugin'>	^ false! !!FastJPEG class methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!primJPEGReadHeader: aJPEGDecompressStruct fromByteArray: source errorMgr: aJPEGErrorMgr2Struct	<primitive: 'primJPEGReadHeaderfromByteArrayerrorMgr' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!FastJPEG class methodsFor: 'primitives' stamp: 'jmv 12/7/2001 13:45'!primJPEGReadImage: aJPEGDecompressStruct fromByteArray: source onForm: form doDithering: ditherFlag errorMgr: aJPEGErrorMgr2Struct	<primitive: 'primJPEGReadImagefromByteArrayonFormdoDitheringerrorMgr' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!FastJPEG class methodsFor: 'primitives' stamp: 'jm 11/20/2001 10:35'!primJPEGWriteImage: aJPEGCompressStruct onByteArray: destination form: form quality: quality progressiveJPEG: progressiveFlag errorMgr: aJPEGErrorMgr2Struct	<primitive: 'primJPEGWriteImageonByteArrayformqualityprogressiveJPEGerrorMgr' module: 'JPEGReadWriter2Plugin'>	self primitiveFailed! !!FileContentsBrowser methodsFor: 'accessing'!contents	self updateInfoView.	(editSelection == #newClass and:[self selectedPackage notNil])		ifTrue: [^self selectedPackage packageInfo].	editSelection == #editClass		ifTrue:[^self modifiedClassDefinition].	^super contents! !!FileContentsBrowser methodsFor: 'accessing'!contents: input notifying: aController 	"The retrieved information has changed and its source must now be 	updated. The information can be a variety of things, depending on the 	list selections (such as templates for class or message definition, methods) 	or the user menu commands (such as definition, comment, hierarchy). 	Answer the result of updating the source."	| aString aText theClass |	aString _ input asString.	aText _ input asText.	editSelection == #editComment 		ifTrue: [theClass _ self selectedClass.				theClass ifNil: [PopUpMenu notify: 'You must select a classbefore giving it a comment.'.				^ false].				theClass comment: aText. ^ true].	editSelection == #editMessageCategories 		ifTrue: [^ self changeMessageCategories: aString].	self inform:'You cannot change the current selection'.	^false! !!FileContentsBrowser methodsFor: 'accessing'!packages	^packages! !!FileContentsBrowser methodsFor: 'accessing'!packages: aDictionary	packages := aDictionary.! !!FileContentsBrowser methodsFor: 'accessing'!selectedPackage	| cat |	cat := self selectedSystemCategoryName.	cat isNil ifTrue:[^nil].	^self packages at: cat asString ifAbsent:[nil]! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:37'!removeClass	| class |	classListIndex = 0 ifTrue: [^ self].	class _ self selectedClass.	(self confirm:'Are you certain that youwant to delete the class ', class name, '?') ifFalse:[^self].	self selectedPackage removeClass: class.	self classListIndex: 0.	self changed: #classList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:46'!removeMessage	| messageName |	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageName _ self selectedMessageName.	(self selectedClassOrMetaClass confirmRemovalOf: messageName) ifFalse:[^false].	self selectedClassOrMetaClass removeMethod: self selectedMessageName.	self messageListIndex: 0.	self setClassOrganizer.  "In case organization not cached"	self changed: #messageList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:51'!removeMessageCategory	"If a message category is selected, create a Confirmer so the user can 	verify that the currently selected message category should be removed 	from the system. If so, remove it."	| messageCategoryName |	messageCategoryListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageCategoryName _ self selectedMessageCategoryName.	(self messageList size = 0		or: [self confirm: 'Are you sure you want toremove this method category and all its methods?']) ifFalse: [^ self].	self selectedClassOrMetaClass removeCategory: messageCategoryName.	self messageCategoryListIndex: 0.	self changed: #messageCategoryList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:52'!removePackage	systemCategoryListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(self confirm: 'Are you sure you want toremove this package and all its classes?') ifFalse:[^self].	(systemOrganizer listAtCategoryNamed: self selectedSystemCategoryName) do:[:el|		systemOrganizer removeElement: el].	self packages removeKey: self selectedPackage packageName.	systemOrganizer removeCategory: self selectedSystemCategoryName.	self systemCategoryListIndex: 0.	self changed: #systemCategoryList! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 2/3/1999 18:47'!removeUnmodifiedCategories	| theClass |	self okToChange ifFalse: [^self].	theClass _ self selectedClass.	theClass isNil ifTrue: [^self].	Cursor wait showWhile:		[theClass removeUnmodifiedMethods: theClass selectors.		theClass metaClass removeUnmodifiedMethods: theClass metaClass selectors].	self messageCategoryListIndex: 0.	self changed: #messageCategoryList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 5/24/1998 20:37'!removeUnmodifiedClasses	| packageList |	self okToChange ifFalse:[^self].	packageList := self selectedPackage isNil						ifTrue:[self packages] 						ifFalse:[Array with: self selectedPackage].	packageList do:[:package|		package classes copy do:[:theClass|			Cursor wait showWhile:[				theClass removeAllUnmodified.			].			theClass hasChanges ifFalse:[				package removeClass: theClass.			].		]].	self classListIndex: 0.	self changed: #classList.! !!FileContentsBrowser methodsFor: 'removing' stamp: 'wod 2/3/1999 18:47'!removeUnmodifiedMethods	| theClass cat |	self okToChange ifFalse:[^self].	theClass := self selectedClassOrMetaClass.	theClass isNil ifTrue:[^self].	cat := self selectedMessageCategoryName.	cat isNil ifTrue:[^self].	Cursor wait showWhile:[		theClass removeUnmodifiedMethods: (theClass organization listAtCategoryNamed: cat).	].	self messageListIndex: 0.	self changed: #messageList.! !!FileContentsBrowser methodsFor: 'class list' stamp: 'sma 5/6/2000 18:48'!browseMethodFull	| myClass |	(myClass _ self selectedClassOrMetaClass) ifNotNil:		[Browser fullOnClass: myClass realClass selector: self selectedMessageName]! !!FileContentsBrowser methodsFor: 'class list'!classList	"Answer an array of the class names of the selected category. Answer an 	empty array if no selection exists."	(systemCategoryListIndex = 0 or:[self selectedPackage isNil])		ifTrue: [^Array new]		ifFalse: [^self selectedPackage classes keys asSortedCollection].! !!FileContentsBrowser methodsFor: 'class list'!findClass	| pattern foundClass classNames index foundPackage |	self okToChange ifFalse: [^ self classNotFound].	pattern _ (FillInTheBlank request: 'Class Name?') asLowercase.	pattern isEmpty ifTrue: [^ self].	classNames := Set new.	self packages do:[:p| classNames addAll: p classes keys].	classNames := classNames asArray select: 		[:n | (n asLowercase indexOfSubCollection: pattern startingAt: 1) > 0].	classNames isEmpty ifTrue: [^ self].	index _ classNames size == 1				ifTrue:	[1]				ifFalse:	[(PopUpMenu labelArray: classNames lines: #()) startUp].	index = 0 ifTrue: [^ self].	foundPackage := nil.	foundClass := nil.	self packages do:[:p| 		(p classes includesKey: (classNames at: index)) ifTrue:[			foundClass := p classes at: (classNames at: index).			foundPackage := p]].	foundClass isNil ifTrue:[^self]. 	self systemCategoryListIndex: (self systemCategoryList indexOf: foundPackage packageName asSymbol).	self classListIndex: (self classList indexOf: foundClass name). ! !!FileContentsBrowser methodsFor: 'class list' stamp: 'wod 5/24/1998 20:37'!renameClass	| oldName newName |	classListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	oldName _ self selectedClass name.	newName _ (self request: 'Please type new class name'						initialAnswer: oldName) asSymbol.	(newName isEmpty or:[newName = oldName]) ifTrue: [^ self].	(self selectedPackage classes includesKey: newName)		ifTrue: [^ self error: newName , ' already exists in the package'].	systemOrganizer classify: newName under: self selectedSystemCategoryName.	systemOrganizer removeElement: oldName.	self selectedPackage renameClass: self selectedClass to: newName.	self changed: #classList.	self classListIndex: ((systemOrganizer listAtCategoryNamed: self selectedSystemCategoryName) indexOf: newName).! !!FileContentsBrowser methodsFor: 'class list'!selectedClass	"Answer the class that is currently selected. Answer nil if no selection 	exists."	self selectedClassName == nil ifTrue: [^nil].	^self selectedPackage classAt: self selectedClassName! !!FileContentsBrowser methodsFor: 'edit pane' stamp: 'sw 11/9/1999 19:26'!selectedMessage	"Answer a copy of the source code for the selected message selector."	| class selector |	class _ self selectedClassOrMetaClass.	selector _ self selectedMessageName.	contents _ class sourceCodeAt: selector.	Preferences browseWithPrettyPrint ifTrue: [contents _ Compiler new					format: contents					in: class					notifying: nil					decorated: Preferences colorWhenPrettyPrinting].	self showDiffs ifTrue:		[contents _ self			methodDiffFor: contents			class: self selectedClass			selector: self selectedMessageName			meta: self metaClassIndicated].	^ contents asText makeSelectorBoldIn: class! !!FileContentsBrowser methodsFor: 'diffs' stamp: 'sma 5/6/2000 18:08'!methodDiffFor: aString class: aPseudoClass selector: selector meta: meta 	| theClass source |	theClass _ Smalltalk at: aPseudoClass name ifAbsent: [^ aString copy].	meta ifTrue: [theClass _ theClass class].	(theClass includesSelector: selector)		ifFalse: [^ aString copy].	source _ theClass sourceCodeAt: selector.	^ Cursor wait showWhile: [TextDiffBuilder buildDisplayPatchFrom: source to: aString]! !!FileContentsBrowser methodsFor: 'diffs'!modifiedClassDefinition	| pClass rClass old new diff |	pClass := self selectedClassOrMetaClass.	pClass hasDefinition ifFalse:[^pClass definition].	rClass := Smalltalk at: self selectedClass name asSymbol ifAbsent:[nil].	rClass isNil ifTrue:[^pClass definition].	self metaClassIndicated ifTrue:[ rClass := rClass class].	old := rClass definition.	new := pClass definition.	Cursor wait showWhile:[		diff := ClassDiffBuilder buildDisplayPatchFrom: old to: new	].	^diff! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileInClass	Cursor read showWhile:[		self selectedClass fileIn.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 6/16/1998 17:14'!fileInMessage		self selectedMessageName ifNil: [^self].	Cursor read showWhile: [		self selectedClassOrMetaClass fileInMethod: self selectedMessageName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 2/3/1999 18:46'!fileInMessageCategories	Cursor read showWhile:[		self selectedClassOrMetaClass fileInCategory: self selectedMessageCategoryName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 5/13/1998 12:50'!fileInPackage	Cursor read showWhile:[		self selectedPackage fileIn.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'sma 4/22/2000 20:51'!fileIntoNewChangeSet	| p ff |	(p _ self selectedPackage) ifNil: [^ self beep].	ff _ StandardFileStream readOnlyFileNamed: p fullPackageName.	ChangeSorter newChangesFromStream: ff named: p packageName! !!FileContentsBrowser methodsFor: 'fileIn/fileOut'!fileOutClass	Cursor write showWhile:[		self selectedClass fileOut.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 6/16/1998 17:14'!fileOutMessage	self selectedMessageName ifNil: [^self].	Cursor write showWhile: [		self selectedClassOrMetaClass fileOutMethod: self selectedMessageName].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 2/3/1999 18:46'!fileOutMessageCategories	Cursor write showWhile:[		self selectedClassOrMetaClass fileOutCategory: self selectedMessageCategoryName.	].! !!FileContentsBrowser methodsFor: 'fileIn/fileOut' stamp: 'wod 5/13/1998 14:19'!fileOutPackage	Cursor write showWhile:[		self selectedPackage fileOut.	].! !!FileContentsBrowser methodsFor: 'infoView' stamp: 'sma 5/6/2000 19:19'!extraInfo	^ (self		methodDiffFor: (self selectedClassOrMetaClass sourceCodeAt: self selectedMessageName)		class: self selectedClass		selector: self selectedMessageName		meta: self metaClassIndicated) unembellished			ifTrue: [' - identical']			ifFalse: [' - modified']! !!FileContentsBrowser methodsFor: 'infoView'!infoString	^infoString isNil		ifTrue:[infoString := StringHolder new]		ifFalse:[infoString]! !!FileContentsBrowser methodsFor: 'infoView' stamp: 'sma 5/6/2000 18:26'!infoViewContents	| theClass |	editSelection == #newClass ifTrue: [^ self packageInfo: self selectedPackage].	self selectedClass isNil ifTrue: [^ ''].	theClass _ Smalltalk at: self selectedClass name asSymbol ifAbsent: [].	editSelection == #editClass ifTrue: [^ theClass notNil			ifTrue: ['Class exists already in the system']			ifFalse: ['New class']].	editSelection == #editMessage ifFalse: [^ ''].	(theClass notNil and: [self metaClassIndicated])		ifTrue: [theClass _ theClass class].	^ (theClass notNil and: [theClass includesSelector: self selectedMessageName])		ifTrue: ['Method already exists' , self extraInfo]		ifFalse: ['New method']! !!FileContentsBrowser methodsFor: 'infoView'!packageInfo: p	| nClasses newClasses oldClasses |	p isNil ifTrue:[^''].	nClasses := newClasses := oldClasses := 0.	p classes do:[:cls|		nClasses := nClasses + 1.		(Smalltalk includesKey: (cls name asSymbol))			ifTrue:[oldClasses := oldClasses + 1]			ifFalse:[newClasses := newClasses + 1]].	^nClasses printString,' classes (', newClasses printString, ' new / ', oldClasses printString, ' modified)'! !!FileContentsBrowser methodsFor: 'infoView' stamp: 'wod 5/19/1998 17:34'!updateInfoView	Smalltalk isMorphic 		ifTrue: [self changed: #infoViewContents]		ifFalse: [			self infoString contents: self infoViewContents.			self infoString changed].! !!FileContentsBrowser methodsFor: 'metaclass'!selectedClassOrMetaClass	"Answer the selected class or metaclass."	self metaClassIndicated		ifTrue: [^ self selectedClass metaClass]		ifFalse: [^ self selectedClass]! !!FileContentsBrowser methodsFor: 'metaclass'!setClassOrganizer	"Install whatever organization is appropriate"	| theClass |	classOrganizer _ nil.	metaClassOrganizer _ nil.	classListIndex = 0 ifTrue: [^ self].	classOrganizer _ (theClass _ self selectedClass) organization.	metaClassOrganizer _ theClass metaClass organization.! !!FileContentsBrowser methodsFor: 'other' stamp: 'wod 5/25/1998 00:46'!browseSenders	"Create and schedule a message set browser on all senders of the 	currently selected message selector. Do nothing if no message is selected."	messageListIndex ~= 0 		ifTrue: [Smalltalk browseAllCallsOn: self selectedMessageName]! !!FileContentsBrowser methodsFor: 'other' stamp: 'sw 10/12/1999 17:42'!browseVersions	"Create and schedule a message set browser on all versions of the 	currently selected message selector."	| class selector |	(selector _ self selectedMessageName) ifNotNil:		[class _ self selectedClassOrMetaClass.		(class exists and: [class realClass includesSelector: selector]) ifTrue:			[VersionsBrowser				browseVersionsOf: (class realClass compiledMethodAt: selector)				class: class realClass				meta: class realClass isMeta				category: self selectedMessageCategoryName				selector: selector]]! !!FileContentsBrowser methodsFor: 'other'!changeMessageCategories: aString 	"The characters in aString represent an edited version of the the message 	categories for the selected class. Update this information in the system 	and inform any dependents that the categories have been changed. This 	message is invoked because the user had issued the categories command 	and edited the message categories. Then the user issued the accept 	command."	self classOrMetaClassOrganizer changeFromString: aString.	self unlock.	self editClass.	self classListIndex: classListIndex.	^ true! !!FileContentsBrowser methodsFor: 'other' stamp: 'sma 2/6/2000 12:27'!methodHierarchy	(self selectedClassOrMetaClass isNil or:		[self selectedClassOrMetaClass hasDefinition])			ifFalse: [super methodHierarchy]! !!FileContentsBrowser methodsFor: 'creation' stamp: 'sma 2/6/2000 12:03'!createViews	"Create a pluggable version of all the views for a Browser, including views and controllers."	| hasSingleFile width topView packageListView classListView switchView messageCategoryListView messageListView browserCodeView infoView |	showDiffs _ true.	Smalltalk isMorphic ifTrue: [^ self openAsMorph].	(hasSingleFile _ self packages size = 1)		ifTrue: [width _ 150]		ifFalse: [width _ 200].	(topView _ StandardSystemView new) 		model: self;		borderWidth: 1.		"label and minSize taken care of by caller"		hasSingleFile 		ifTrue: [			self systemCategoryListIndex: 1.			packageListView _ PluggableListView on: self				list: #systemCategorySingleton				selected: #indexIsOne 				changeSelected: #indexIsOne:				menu: #packageListMenu:				keystroke: #packageListKey:from:.			packageListView window: (0 @ 0 extent: width @ 12)]		ifFalse: [			packageListView _ PluggableListView on: self				list: #systemCategoryList				selected: #systemCategoryListIndex				changeSelected: #systemCategoryListIndex:				menu: #packageListMenu:				keystroke: #packageListKey:from:.			packageListView window: (0 @ 0 extent: 50 @ 70)].	topView addSubView: packageListView.	classListView _ PluggableListView on: self		list: #classList		selected: #classListIndex		changeSelected: #classListIndex:		menu: #classListMenu:		keystroke: #classListKey:from:.	classListView window: (0 @ 0 extent: 50 @ 62).	hasSingleFile 		ifTrue: [topView addSubView: classListView below: packageListView]		ifFalse: [topView addSubView: classListView toRightOf: packageListView].	switchView _ self buildInstanceClassSwitchView.	switchView borderWidth: 1.	topView addSubView: switchView below: classListView.	messageCategoryListView _ PluggableListView on: self		list: #messageCategoryList		selected: #messageCategoryListIndex		changeSelected: #messageCategoryListIndex:		menu: #messageCategoryMenu:.	messageCategoryListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageCategoryListView toRightOf: classListView.	messageListView _ PluggableListView on: self		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:		keystroke: #messageListKey:from:.	messageListView window: (0 @ 0 extent: 50 @ 70).	topView addSubView: messageListView toRightOf: messageCategoryListView.	browserCodeView _ PluggableTextView on: self 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	browserCodeView window: (0@0 extent: width@110).	topView 		addSubView: browserCodeView 		below: (hasSingleFile 			ifTrue: [switchView]			ifFalse: [packageListView]).	infoView _ StringHolderView new		model: self infoString;		window: (0@0 extent: width@12);		borderWidth: 1.	topView addSubView: infoView below: browserCodeView.	^ topView! !!FileContentsBrowser methodsFor: 'creation' stamp: 'sma 2/6/2000 11:59'!openAsMorph	"Create a pluggable version of all the views for a Browser, including views and controllers."	| window aListExtent next |	window _ (SystemWindow labelled: 'later') model: self.	self packages size = 1		ifTrue: [			aListExtent _ 0.333333 @ 0.34.			self systemCategoryListIndex: 1.			window addMorph: (PluggableListMorph on: self list: #systemCategorySingleton					selected: #indexIsOne changeSelected: #indexIsOne:					menu: #packageListMenu:					keystroke: #packageListKey:from:)				frame: (0@0 extent: 1.0@0.06).			next := 0@0.06]		ifFalse: [			aListExtent _ 0.25 @ 0.4.			window addMorph: (PluggableListMorph on: self list: #systemCategoryList					selected: #systemCategoryListIndex changeSelected: #systemCategoryListIndex:					menu: #packageListMenu:					keystroke: #packageListKey:from:)				frame: (0@0 extent: aListExtent).			next := aListExtent x @ 0].	window addMorph: (PluggableListMorph on: self list: #classList			selected: #classListIndex changeSelected: #classListIndex:			menu: #classListMenu:			keystroke: #classListKey:from:)		frame: (next extent: aListExtent - (0.0 @ 0.05)).	window addMorph: self buildMorphicSwitches		frame: (next + (0 @ (aListExtent y - 0.05)) extent: aListExtent x @ 0.05).	next := next + (aListExtent x @ 0).	window addMorph: (PluggableListMorph on: self list: #messageCategoryList			selected: #messageCategoryListIndex changeSelected: #messageCategoryListIndex:			menu: #messageCategoryMenu:)		frame: (next extent: aListExtent).	next := next + (aListExtent x @ 0).	window addMorph: (PluggableListMorph on: self list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:			keystroke: #messageListKey:from:)		frame: (next extent: aListExtent).	window addMorph: (PluggableTextMorph on: self text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@0.4 corner: 1@0.94).	window addMorph: (PluggableTextMorph on: self text: #infoViewContents accept: nil			readSelection: nil menu: nil)		frame: (0@0.94 corner: 1@1).	^ window! !!FileContentsBrowser methodsFor: 'menus' stamp: 'sw 11/9/1999 18:26'!addModelItemsToWindowMenu: aMenu	aMenu addLine.	aMenu add: 		(self showDiffs ifTrue: ['stop showing diffs'] ifFalse: ['start showing diffs'])			  target: self action: #toggleDiffing ! !!FileContentsBrowser methodsFor: 'menus' stamp: 'sma 5/6/2000 18:36'!classListMenu: aMenu	^ aMenu 		labels:'definitioncommentbrowse full (b)class refs (N)fileInfileOutrename...removeremove existing'		lines: #(2 4 6 8)		selections: #(editClass editComment browseMethodFull browseClassRefs fileInClass fileOutClass renameClass removeClass removeUnmodifiedCategories) ! !!FileContentsBrowser methodsFor: 'menus' stamp: 'wod 5/13/1998 17:39'!messageCategoryMenu: aMenu	^ aMenu 		labels:'fileInfileOutreorganizeadd item...rename...removeremove existing'		lines: #(2 3 6)		selections: #(fileInMessageCategories fileOutMessageCategories editMessageCategories addCategory renameCategory removeMessageCategory removeUnmodifiedMethods)! !!FileContentsBrowser methodsFor: 'menus' stamp: 'sma 2/6/2000 12:28'!messageListMenu: aMenu	^ aMenu 		labels:'fileInfileOutsenders (n)implementors (m)method inheritance (h)versions (v)remove'		lines: #(2 6)		selections: #(fileInMessage fileOutMessagebrowseSenders browseImplementors methodHierarchy browseVersionsremoveMessage).! !!FileContentsBrowser methodsFor: 'menus' stamp: 'sma 4/22/2000 20:52'!packageListMenu: aMenu	^ aMenu 		labels:'find class... (f)fileInfile into new changesetfileOutremoveremove existing'		lines: #(1 4 5)		selections: #(findClass fileInPackage fileIntoNewChangeSet fileOutPackage removePackage removeUnmodifiedClasses)! !!FileContentsBrowser methodsFor: 'keys' stamp: 'sma 5/6/2000 18:48'!classListKey: aChar from: view	aChar == $b ifTrue: [^ self browseMethodFull].	aChar == $N ifTrue: [^ self browseClassRefs].	self packageListKey: aChar from: view! !!FileContentsBrowser methodsFor: 'keys' stamp: 'sma 5/6/2000 18:50'!messageListKey: aChar from: view	aChar == $b ifTrue: [^ self browseMethodFull].	super messageListKey: aChar from: view! !!FileContentsBrowser methodsFor: 'keys' stamp: 'sma 2/6/2000 12:05'!packageListKey: aChar from: view	aChar == $f ifTrue: [^ self findClass].	self arrowKey: aChar from: view! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'wod 5/13/1998 18:17'!browseFile: aFilename	self browseFiles: (Array with: aFilename).! !!FileContentsBrowser class methodsFor: 'instance creation' stamp: 'wod 5/14/1998 23:40'!browseFiles: fileList	| package organizer packageDict browser |	Cursor wait showWhile: [		packageDict _ Dictionary new.		organizer _ SystemOrganizer defaultList: Array new.		fileList do: [:fileName |			package _ FilePackage fromFileNamed: fileName.			packageDict 				at: package packageName 				put: package.			organizer 				classifyAll: package classes keys 				under: package packageName].		(browser := self new)			systemOrganizer: organizer;			packages: packageDict].	self		openBrowserView: browser createViews		label: 'Package Browser'.! !!FileDirectory methodsFor: 'path access' stamp: 'ar 12/18/1999 01:01'!fullPathFor: path	^path isEmpty ifTrue:[pathName] ifFalse:[path]! !!FileDirectory methodsFor: 'path access' stamp: 'ar 12/18/1999 00:36'!slash	^self class slash! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 12/4/2003 12:51'!allFileNamesDo: aBlock	"Evaluate the given block with the full file name of every file in this entire directory tree. Answer an array with the total number of directories and files visited."	| dirs files todo p fullName |	dirs _ files _ 0.	todo _ OrderedCollection with: pathName.	[todo isEmpty] whileFalse: [		p _ todo removeFirst.		(self directoryEntriesFor: p) do: [:entry |			fullName _ p, self pathNameDelimiter asString, entry name.			entry isDirectory				ifTrue: [					todo addLast: fullName.					dirs _ dirs + 1]				ifFalse: [					aBlock value: fullName.					files _ files + 1]]].	^ Array with: dirs with: files! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 11/18/2003 09:13'!directoryNames	"Return a collection of names for the subdirectories of this directory."	"FileDirectory default directoryNames"	^ (self entries select: [:entry | entry isDirectory])		collect: [:entry | entry name]! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 11/18/2003 09:49'!entries	"Answer an array of DirectoryEntry objects for the files and directories in this directory."	"FileDirectory default entries"	^ self directoryEntriesFor: pathName! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 11/18/2003 09:13'!fileAndDirectoryNames	"FileDirectory default fileAndDirectoryNames"	^ self entries collect: [:entry | entry name]! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 11/18/2003 09:14'!fileNames	"Return a collection of names for the files (but not directories) in this directory."	"FileDirectory default fileNames"	^ (self entries select: [:entry | entry isDirectory not])		collect: [:entry | entry name]! !!FileDirectory methodsFor: 'enumeration' stamp: 'jm 11/18/2003 10:08'!statsForDirectoryTree: rootedPathName	"Return the size statistics for the entire directory tree starting at the given root. The result is a three element array of the form: (<number of folders><number of files><total bytes in all files>). This method also serves as an example of how recursively enumerate a directory tree."	"Note: The total file bytes does not include the storage space required for the directories in the tree."	"FileDirectory default statsForDirectoryTree: FileDirectory default pathName"	| dirs files bytes todo p |	Cursor wait showWhile: [		dirs _ files _ bytes _ 0.		todo _ OrderedCollection with: rootedPathName.		[todo isEmpty] whileFalse: [			p _ todo removeFirst.			(self directoryEntriesFor: p) do: [:entry |				entry isDirectory					ifTrue: [						todo addLast: (p, self pathNameDelimiter asString, entry name).						dirs _ dirs + 1]					ifFalse: [						bytes _ bytes + entry fileSize.						files _ files + 1]]]].	^ Array with: dirs with: files with: bytes! !!FileDirectory methodsFor: 'testing' stamp: 'di 11/21/1999 20:16'!directoryExists: filenameOrPath	"Answer true if a directory of the given name exists. The given name may be either a full path name or a local directory within this directory."	"FileDirectory default directoryExists: FileDirectory default pathName"	| fName dir |	FileDirectory splitName: filenameOrPath to:		[:filePath :name |			fName _ name.			filePath isEmpty				ifTrue: [dir _ self]				ifFalse: [dir _ FileDirectory on: filePath]].	self isCaseSensitive 		ifTrue:[^dir directoryNames includes: fName]		ifFalse:[^dir directoryNames anySatisfy: [:name| name sameAs: fName]].! !!FileDirectory methodsFor: 'testing' stamp: 'di 11/21/1999 20:17'!fileExists: filenameOrPath	"Answer true if a file of the given name exists. The given name may be either a full path name or a local file within this directory."	"FileDirectory default fileExists: Smalltalk sourcesName"	| fName dir |	FileDirectory splitName: filenameOrPath to:		[:filePath :name |			fName _ name.			filePath isEmpty				ifTrue: [dir _ self]				ifFalse: [dir _ FileDirectory on: filePath]].	self isCaseSensitive 		ifTrue:[^dir fileNames includes: fName]		ifFalse:[^dir fileNames anySatisfy: [:name| name sameAs: fName]].	! !!FileDirectory methodsFor: 'testing' stamp: 'jm 4/9/1999 17:48'!fileOrDirectoryExists: filenameOrPath	"Answer true if either a file or a directory file of the given name exists. The given name may be either a full path name or a local name within this directory."	"FileDirectory default fileOrDirectoryExists: Smalltalk sourcesName"	| fName dir |	FileDirectory splitName: filenameOrPath to:		[:filePath :name |			fName _ name.			filePath isEmpty				ifTrue: [dir _ self]				ifFalse: [dir _ FileDirectory on: filePath]].	^ dir includesKey: fName! !!FileDirectory methodsFor: 'testing' stamp: 'di 11/21/1999 20:17'!includesKey: localName	"Answer true if this directory includes a file or directory of the given name. Note that the name should be a local file name, in contrast with fileExists:, which takes either local or full-qualified file names."	"(FileDirectory on: Smalltalk vmPath) includesKey: 'SqueakV2.sources'"	self isCaseSensitive		ifTrue:[^ self fileAndDirectoryNames includes: localName]		ifFalse:[^ self fileAndDirectoryNames anySatisfy: [:str| str sameAs: localName]].! !!FileDirectory methodsFor: 'testing' stamp: 'ar 5/1/1999 01:51'!isCaseSensitive	"Return true if file names are treated case sensitive"	^self class isCaseSensitive! !!FileDirectory methodsFor: 'file operations' stamp: 'wod 11/5/1998 18:41'!copyFileNamed: fileName1 toFileNamed: fileName2	"Copy the contents of the existing file with the first name into a new file with the second name. Both files are assumed to be in this directory."	"FileDirectory default copyFileNamed: 'todo.txt' toFileNamed: 'todocopy.txt'"	| file1 file2 buffer |	file1 _ (self readOnlyFileNamed: fileName1) binary.	file2 _ (self newFileNamed: fileName2) binary.	buffer _ String new: 50000.	[file1 atEnd] whileFalse:		[file2 nextPutAll: (file1 nextInto: buffer)].	file1 close.	file2 close.! !!FileDirectory methodsFor: 'file operations' stamp: 'jm 4/9/1999 18:02'!deleteDirectory: localDirName	"Delete the directory with the given name in this directory. Fail if the path is bad or if a directory by that name does not exist." 	self primDeleteDirectory: (self fullNameFor: localDirName).! !!FileDirectory methodsFor: 'file operations' stamp: 'ar 3/21/98 18:08'!deleteFileNamed: localFileName ifAbsent: failBlock	"Delete the file of the given name if it exists, else evaluate failBlock.	If the first deletion attempt fails do a GC to force finalization of any lost references. ar 3/21/98 17:53"	(self 		retryWithGC:[self primDeleteFileNamed: (self fullNameFor: localFileName)]		until:[:result| result notNil]) == nil			ifTrue: [^failBlock value].! !!FileDirectory methodsFor: 'file operations' stamp: 'tk 2/25/2000 15:30'!putFile: file1 named: destinationFileName	"Copy the contents of the existing fileStream into the file destinationFileName in this directory.  fileStream can be anywhere in the fileSystem."	| file2 buffer |	file1 binary.	(file2 _ self newFileNamed: destinationFileName) ifNil: [^ false].	file2 binary.	buffer _ String new: 50000.	[file1 atEnd] whileFalse:		[file2 nextPutAll: (file1 nextInto: buffer)].	file1 close.	file2 close.	^ true! !!FileDirectory methodsFor: 'file operations' stamp: 'tk 3/31/2000 21:09'!rename: oldFileName toBe: newFileName	| selection |	"Rename the file of the given name to the new name. Fail if there is no file of the old name or if there is an existing file with the new name."	"Modified for retry after GC ar 3/21/98 18:09"	(self retryWithGC:[self primRename: (self fullNameFor: oldFileName)						to: (self fullNameFor: newFileName)]		until:[:result| result notNil]) ~~ nil ifTrue:[^self].	(self fileExists: oldFileName) ifFalse:[		^self error:'Attempt to rename a non-existent file'.	].	(self fileExists: newFileName) ifTrue:[		selection _ (PopUpMenu labels:'delete old versioncancel')				startUpWithCaption: 'Trying to rename a file to be', newFileName , 'and it already exists.'.		selection = 1 ifTrue:			[self deleteFileNamed: newFileName.			^ self rename: oldFileName toBe: newFileName]].	^self error:'Failed to rename file'.! !!FileDirectory methodsFor: 'file name utilities' stamp: 'acg 1/7/2000 08:00'!fullNameFor: fileName	"Return a corrected, fully-qualified name for the given file name. If the given name is already a full path (i.e., it contains a delimiter character), assume it is already a fully-qualified name. Otherwise, prefix it with the path to this directory. In either case, correct the local part of the file name."	"Details: Note that path relative to a directory, such as '../../foo' are disallowed by this algorithm."	| correctedLocalName prefix |	self class splitName: fileName to:		[:filePath :localName |			correctedLocalName _ localName isEmpty 				ifFalse: [self checkName: localName fixErrors: true]				ifTrue: [localName].			prefix _ self fullPathFor: filePath].	prefix isEmpty		ifTrue: [^correctedLocalName].	prefix last = self pathNameDelimiter		ifTrue:[^ prefix, correctedLocalName]		ifFalse:[^ prefix, self slash, correctedLocalName]! !!FileDirectory methodsFor: 'file name utilities' stamp: 'jm 11/21/2003 19:03'!fullToRelativePath: fullPathString	"Answer the path relative to this directory for the file or directory with the given full path. See the comment in relativeToFullPath: for a description of the relative path syntax."	| currentPath fullPath minSize indexOfDiff result |	currentPath _ self pathParts.	fullPath _ fullPathString findTokens: self pathNameDelimiter asString.	minSize _ currentPath size min: fullPath size.	indexOfDiff _ (1 to: minSize)		detect: [:i | (currentPath at: i) ~= (fullPath at: i)]		ifNone: [minSize + 1].	result _ WriteStream on: (String new: 100).	currentPath size - (indexOfDiff - 1) timesRepeat: [result nextPutAll: '../'].	indexOfDiff to: fullPath size do: [:i |		result nextPutAll: (fullPath at: i), '/'].	result position > 0 ifTrue: [result skip: -1].	^ result contents! !!FileDirectory methodsFor: 'file name utilities' stamp: 'jm 5/29/2003 19:22'!nextNameFor: baseFileName extension: extension	"Assumes a file name includes a version number encoded as '.' followed by digits 	preceding the file extension.  Increment the version number and answer the new file name.	If a version number is not found, set the version to 1 and answer a new file name"	| files splits version |	files _ self fileNamesMatching: (baseFileName,'*', self class dot, extension).	splits _ (files collect: [:file | self splitNameVersionExtensionFor: file])				select: [:split | (split at: 1) = baseFileName].	splits _ splits asSortedCollection: [:a :b | (a at: 2) < (b at: 2)].	splits isEmpty 			ifTrue: [version _ 1]			ifFalse: [version _ (splits last at: 2) + 1].	^ (baseFileName, '.', version asString, self class dot, extension) asFileName! !!FileDirectory methodsFor: 'file name utilities' stamp: 'jm 11/21/2003 18:13'!relativeToFullPath: relativePath	"Answer the full path name for the file or directory with the given path relative to this directory. The relative path is in Unix/URL format: the delimitor is a slash (/), a single period (.) means the current directory, and a double period (..) means the parent directory. A relative path is *always* begins with the current directory, so a leading './' is inferred."	| currentPath relParts result |	currentPath _ self pathParts.	relParts _ relativePath findTokens: '/'.	relParts do: [:s |		(s = '.' or: [s = '..'])			ifTrue: [				s = '..' ifTrue: [					currentPath size > 0 ifTrue: [						currentPath _ currentPath copyFrom: 1 to: currentPath size - 1]]]			ifFalse: [				currentPath _ currentPath copyWith: s]].	result _ WriteStream on: (String new: 100).	currentPath do: [:s | result nextPutAll: s; nextPut: self pathNameDelimiter].	result position > 0 ifTrue: [result skip: -1].	^ result contents! !!FileDirectory methodsFor: 'file name utilities' stamp: 'djp 10/27/1999 08:58'!splitNameVersionExtensionFor: fileName	" answer an array with the root name, version # and extension.	See comment in nextSequentialNameFor: for more details"	| baseName version extension i j |	baseName _ self class baseNameFor: fileName.	extension _ self class extensionFor: fileName.	i _ j _ baseName findLast: [:c | c isDigit not].	i = 0		ifTrue: [version _ 0]		ifFalse:			[(baseName at: i) = $.				ifTrue:					[version _ (baseName copyFrom: i+1 to: baseName size) asNumber.					j _ j - 1]				ifFalse: [version _ 0].			baseName _ baseName copyFrom: 1 to: j].	^ Array with: baseName with: version with: extension! !!FileDirectory methodsFor: 'file name utilities' stamp: 'jm 12/1/2003 17:58'!unusedNameStartingWith: prefix	"Answer an unused file or directory name in this directory starting with the given prefix and ending with one or more digits."	"FileDirectory default unusedNameStartingWith: 'tmp'"	| usedNames i result |	usedNames _ self fileAndDirectoryNames asSet.	i _ 0.	result _ prefix, '0'.	[usedNames includes: result] whileTrue: [		result _ prefix, (i _ i + 1) printString].	^ pathName, self slash, result! !!FileDirectory methodsFor: 'private' stamp: 'jm 11/18/2003 09:55'!directoryEntriesFor: fullPath	"Answer an array of DirectoryEntry objects for the files and directories in the directory with the given path. If the given path is not a directory, answer an empty array. See primLookupEntryIn:index: for further details."	"FileDirectory default directoryEntriesFor: ''"	| entries index done entryArray |	entries _ OrderedCollection new: 200.	index _ 1.	done _ false.	[done] whileFalse: [		entryArray _ self primLookupEntryIn: fullPath index: index.		#badDirectoryPath = entryArray ifTrue: [^ #()].		entryArray			ifNil: [done _ true]			ifNotNil: [entries addLast: (DirectoryEntry fromArray: entryArray)].		index _ index + 1].	^ entries asArray! !!FileDirectory methodsFor: 'private' stamp: 'jm 4/9/1999 17:59'!primDeleteDirectory: fullPath	"Delete the directory named by the given path. Fail if the path is bad or if a directory by that name does not exist." 	<primitive: 163>	self primitiveFailed! !!FileDirectory methodsFor: 'private' stamp: 'jm 11/18/2003 09:58'!primLookupEntryIn: fullPath index: index	"Look up the index-th entry of the directory with the given fully-qualified path (i.e., starting from the root of the file hierarchy) and return an array containing:	<name> <creationTime> <modificationTime> <dirFlag> <fileSize>	The empty string enumerates the top-level directories, mounted volumes, or disk drives. (For example, on Unix, the empty path enumerates the root directory '/'. On Macs and PCs, it enumerates the mounted volumes/drives.)	The creation and modification times are in seconds since the start of the Smalltalk time epoch. DirFlag is true if the entry is a directory. FileSize the file size in bytes or zero for directories. The primitive returns nil when index is past the end of the directory. It fails if the given path is bad." 	<primitive: 162>	^ #badDirectoryPath! !!FileDirectory methodsFor: 'private' stamp: 'ar 3/21/98 18:04'!primRename: oldFileFullName to: newFileFullName 	"Rename the file of the given name to the new name. Fail if there is no file of the old name or if there is an existing file with the new name.	Changed to return nil instead of failing ar 3/21/98 18:04"	<primitive: 159>	^nil! !!FileDirectory methodsFor: 'searching' stamp: 'sw 6/2/2000 21:55'!filesContaining: searchString caseSensitive: aBoolean	| aList |	"Search the contents of all files in the receiver and its subdirectories for the search string.  Return a list of paths found.  Make the search case sensitive if aBoolean is true."	aList _ OrderedCollection new.	self withAllFilesDo: [:stream |			(stream contentsOfEntireFile includesSubstring: searchString caseSensitive: aBoolean)				ifTrue:	[aList add: stream name]]		andDirectoriesDo: [:d | d pathName].	^ aList"FileDirectory default filesContaining: 'includesSubstring:'  caseSensitive: true"! !!FileDirectory methodsFor: 'searching' stamp: 'SIM 5/22/2000 13:33'!withAllFilesDo: fileStreamBlock andDirectoriesDo: directoryBlock	"For the receiver and all it's subdirectories evaluate directoryBlock.	For a read only file stream on each file within the receiver 	and it's subdirectories evaluate fileStreamBlock."	| todo dir |	todo _ OrderedCollection with: self.	[todo size > 0] whileTrue: [		dir _ todo removeFirst.		directoryBlock value: dir.		dir fileNames do: [: n | 			fileStreamBlock value: 				(FileStream readOnlyFileNamed: (dir fullNameFor: n))].		dir directoryNames do: [: n | 			todo add: (dir directoryNamed: n)]]! !!FileDirectory class methodsFor: 'instance creation' stamp: 'ls 9/10/1998 00:59'!forFileName: aString	| path |	path _ self dirPathFor: aString.	path isEmpty ifTrue: [^ self default].	^ self on: path! !!FileDirectory class methodsFor: 'name utilities' stamp: 'jm 11/14/2003 10:44'!baseNameFor: fileName	"Answer the given file name without its extension, if any."	| i |	i _ fileName findLast: [:c | c = $.].	i = 0		ifTrue: [^ fileName]		ifFalse: [^ fileName copyFrom: 1 to: i - 1].! !!FileDirectory class methodsFor: 'name utilities' stamp: 'jm 11/14/2003 10:45'!extensionFor: fileName	"Answer the extension of given file name, if any."	| i |	i _ fileName findLast: [:c | c = $.].	i = 0		ifTrue: [^ '']		ifFalse: [^ fileName copyFrom: i + 1 to: fileName size].! !!FileDirectory class methodsFor: 'name utilities' stamp: 'jm 12/8/2003 15:01'!searchAllFilesForAString	"Prompt the user for a search string and a starting directory. Search the contents of all files in the starting directory and its subdirectories for the search string (case-insensitive) and answer a collection of file paths."	"FileDirectory searchAllFilesForAString"	| searchString dir |	searchString _ FillInTheBlankMorph request: 'Search string?'.	searchString isEmpty ifTrue: [^ nil].	dir _ StandardFileMenu getFolder.	dir ifNil: [^ self].	^ dir filesContaining: searchString caseSensitive: false! !!FileDirectory class methodsFor: 'name utilities' stamp: 'bf 3/22/2000 18:04'!splitName: fullName to: pathAndNameBlock	"Take the file name and convert it to the path name of a directory and a local file name within that directory. FileName must be of the form: <dirPath><delimiter><localName>, where <dirPath><delimiter> is optional. The <dirPath> part may contain delimiters."	| delimiter i dirName localName |	delimiter _ self pathNameDelimiter.	(i _ fullName findLast: [:c | c = delimiter]) = 0		ifTrue:			[dirName _ String new.			localName _ fullName]		ifFalse:			[dirName _ fullName copyFrom: 1 to: (i - 1 max: 1).			localName _ fullName copyFrom: i + 1 to: fullName size].	^ pathAndNameBlock value: dirName value: localName! !!FileDirectory class methodsFor: 'system start up' stamp: 'jbc 5/12/2000 17:09'!openSources: sourcesName andChanges: changesName forImage: imageName 	"Initialize the default directory to the image directory and open the  	sources and changes files, if possible. Look for the changes file in  	image directory. Look for the system sources (or an alias to it) first in  	the VM directory, then in the image directory. Open the changes and  	sources files and install them in SourceFiles."	"Note: SourcesName and imageName are full paths; changesName is a  	local name."	| sources changes sourceAlias msg wmsg localSourcesName |	msg _ 'Squeak cannot locate &fileRef.Please check that the file is named properly and is in thesame directory as this image.  Further explanation can foundin the startup window, ''How Squeak Finds Source Code''.'.	wmsg _ 'Squeak cannot write to &fileRef.Please check that you have write permission for this file.You won''t be able to save this image correctly until you fix this.'.	self setDefaultDirectoryFrom: imageName.	sources _ changes _ nil.	"look for the sources file or an alias to it in the VM's directory"	(DefaultDirectory fileExists: sourcesName)		ifTrue: [sources _ DefaultDirectory readOnlyFileNamed: sourcesName]		ifFalse: 			["look for an un-renamed Macintosh alias to the sources file"			sourceAlias _ sourcesName , ' alias'.			(DefaultDirectory fileExists: sourceAlias)				ifTrue: [sources _ DefaultDirectory readOnlyFileNamed: sourceAlias]].	sources		ifNil: 			["look for the sources file or an alias to it in the image directory"			localSourcesName _ FileDirectory localNameFor: sourcesName.			(DefaultDirectory fileExists: localSourcesName)				ifTrue: [sources _ DefaultDirectory readOnlyFileNamed: localSourcesName]				ifFalse: 					["look for an un-renamed Macintosh alias to the sources  					file"					sourceAlias _ localSourcesName , ' alias'.					(DefaultDirectory fileExists: sourceAlias)						ifTrue: [sources _ DefaultDirectory readOnlyFileNamed: sourceAlias]]].	(DefaultDirectory fileExists: changesName)		ifTrue: 			[changes _ DefaultDirectory oldFileNamed: changesName.			changes isNil				ifTrue: 					[PopUpMenu notify: (wmsg copyReplaceAll: '&fileRef' with: 'the changes file named ' , changesName).					changes _ DefaultDirectory readOnlyFileNamed: changesName]].	((sources == nil or: [sources atEnd])		and: [Preferences valueOfFlag: #warnIfNoSourcesFile])		ifTrue: 			[PopUpMenu notify: (msg copyReplaceAll: '&fileRef' with: 'the sources file named ' , sourcesName).			(Smalltalk getSystemAttribute: 1001)				= 'Mac OS' ifTrue: [PopUpMenu notify: 'Make sure the sources file is not an Alias.']].	(changes == nil and: [Preferences valueOfFlag: #warnIfNoChangesFile])		ifTrue: [PopUpMenu notify: (msg copyReplaceAll: '&fileRef' with: 'the changes file named ' , changesName)].	SourceFiles _ Array with: sources with: changes! !!FileDirectory class methodsFor: 'system start up' stamp: 'di 2/4/1999 15:27'!shutDown	Smalltalk closeSourceFiles.! !!FileDirectory class methodsFor: 'system start up' stamp: 'di 2/4/1999 08:50'!startUp	"Establish the platform-specific FileDirectory subclass. Do any platform-specific startup."	self setDefaultDirectoryFrom: Smalltalk imageName.	Smalltalk openSourceFiles.! !!FileDirectory class methodsFor: 'platform specific' stamp: 'jm 11/14/2003 10:44'!dot	"Answer a one-character string containing a period character."	^ '.'! !!FileDirectory class methodsFor: 'platform specific' stamp: 'ar 5/1/1999 01:48'!isCaseSensitive	"Return true if file names are treated case sensitive"	^true! !!FileDirectory class methodsFor: 'platform specific' stamp: 'jm 11/14/2003 10:50'!pathNameDelimiter	"Answer the active directory class's directory separator character (e.g., '/' on Unix, ':' on Macintosh)."	^ DirectoryClass pathNameDelimiter! !!FileDirectory class methodsFor: 'platform specific' stamp: 'ar 4/18/1999 18:18'!slash	^ self pathNameDelimiter asString! !!FileDirectory class methodsFor: 'private' stamp: 'TPR 5/10/1998 21:47'!activeDirectoryClass	"Return the concrete FileDirectory subclass for the platform on which we are currently running."	FileDirectory allSubclasses do: [:class |		class isActiveDirectoryClass ifTrue: [^ class]].	"no responding subclass; use FileDirectory"	^ FileDirectory! !!FileDirectory class methodsFor: 'private' stamp: 'TPR 5/10/1998 21:40'!isActiveDirectoryClass	"Does this class claim to be that properly active subclass of FileDirectory for this platform?	Default test is whether the primPathNameDelimiter matches the one for this class. Other tests are possible"	^self pathNameDelimiter = self primPathNameDelimiter! !I am model that can be used to navigate the host file system. By omitting the volume list, file list, and template panes from the view, I can also be used as the model for an editor on an individual file.FileLists can now see FTP servers anywhere on the net.  In the volume list menu: fill in server info...		Gives you a form to register a new ftp server you want to use.open server...		Choose a server to connect to.local disk			Go back to looking at your local volume.Still undone (you can contribute code):[ ] Using a Proxy server to get out through a firewall.  What is the convention for proxy servers with FTP?[ ] Fill in the date and size info in the list of remote files.  Allow sorting by it.  New smarts needed in (ServerDirectory fileNameFormattedFrom:sizePad:sortMode:).[ ] Currently the FileList has no way to delete a directory.  Since you can't select a directory without going into it, it would have to be deleting the current directory.  Which would usually be empty.!!FileList methodsFor: 'initialization' stamp: 'di 5/16/2000 09:42'!directory: dir	"Set the path of the volume to be displayed."	self okToChange ifFalse: [^ self].	self modelSleep.	directory _ dir.	self modelWakeUp.	sortMode == nil ifTrue: [sortMode _ #date].	volList _ ((Array with: '[]'), directory pathParts)  "Nesting suggestion from RvL"			withIndexCollect: [:each :i | ( String new: i-1 withAll: $ ), each].	self changed: #relabel.	self changed: #volumeList.	self pattern: pattern! !!FileList methodsFor: 'initialization' stamp: 'jm 7/17/2003 22:30'!modelSleep	"User has exited or collapsed the window--close any remote connections."! !!FileList methodsFor: 'initialization' stamp: 'sbw 12/30/1999 15:53'!optionalButtonHeight	^ 15! !!FileList methodsFor: 'initialization' stamp: 'jm 10/13/2002 18:06'!optionalButtonRow	| aRow aButton |	aRow _ AlignmentMorph newRow.	aRow isSticky: true.	aRow setProperty: #clipToOwnerWidth toValue: true.	aRow addTransparentSpacerOfSize: (5@0).	self optionalButtonSpecs do:			[:spec |				aButton _ PluggableButtonMorph					on: self					getState: nil					action: spec second.				aButton useRoundedCorners;					label: spec first asString;					askBeforeChanging: true;					onColor: Color transparent offColor: Color transparent.				aRow addMorphBack: aButton.				aRow addTransparentSpacerOfSize: (3 @ 0).				aButton setBalloonText: spec fourth.				aRow addTransparentSpacerOfSize: (3 @ 0).				(spec second == #sortBySize)					ifTrue:						[aRow addTransparentSpacerOfSize: (4@0)]].	^ aRow! !!FileList methodsFor: 'initialization' stamp: 'sw 1/7/2000 15:55'!optionalButtonSpecs	^ #(			('Name' 		sortByName				sortingByName	'sort entries by name')		('Date'			sortByDate				sortingByDate	'sort entries by date')		('Size'			sortBySize				sortingBySize	'sort entries by size')		('Changes'		browseChanges			none			'open a changelist browser on selected file')		('File-in'		fileInSelection			none			'fileIn the selected file')		('File-in to New'	fileIntoNewChangeSet	none			'fileIn the selected file into a new change set')		('Delete'			deleteFile				none			'delete the seleted item'))! !!FileList methodsFor: 'initialization' stamp: 'sw 1/7/2000 15:56'!optionalButtonView	| aView bHeight windowWidth offset previousView aButtonView wid specs |	aView _ View new model: self.	bHeight _ self optionalButtonHeight.	windowWidth _ 120.	aView window: (0@0 extent: windowWidth@bHeight).	offset _ 0.	specs _ self optionalButtonSpecs copyFrom: 1 to: 6.  "Too cramped for the seventh!!"	previousView _ nil.	specs do: [:quad |		aButtonView _ PluggableButtonView on: self getState: (quad third == #none ifTrue: [nil] ifFalse: [quad third]) action: quad second.		quad second = specs last second			ifTrue:				[wid _ windowWidth - offset]			ifFalse:				[aButtonView borderWidthLeft: 0 right: 1 top: 0 bottom: 0.				wid _ (windowWidth // (specs size)) - 2].		aButtonView			label: quad first asParagraph;			window: (offset@0 extent: wid@bHeight).		offset _ offset + wid.		quad second = specs first second			ifTrue: [aView addSubView: aButtonView]			ifFalse: [aView addSubView: aButtonView toRightOf: previousView].		previousView _ aButtonView].	^aView! !!FileList methodsFor: 'initialization' stamp: 'di 5/11/1999 22:25'!release	self modelSleep! !!FileList methodsFor: 'volume list and pattern' stamp: 'jm 11/18/2003 09:16'!deleteDirectory	"Remove the currently selected directory."	| localDir |	directory entries size = 0 ifFalse:[^ self inform: 'Directory must be empty'].	localDir _ directory pathParts last.	(self confirm: 'Really delete ' , localDir printString, '?') ifFalse: [^ self].	self volumeListIndex: self volumeListIndex - 1.	directory deleteDirectory: localDir.	self updateFileList.! !!FileList methodsFor: 'volume list and pattern' stamp: 'jm 11/18/2003 10:25'!fileNameFormattedFrom: entry sizePad: sizePad	"Answer a formated file description string for the given DirectoryEntry."	| dateStr sizeStr nameStr |	dateStr _		((Date fromSeconds: entry modificationTime) printFormat: #(3 2 1 $. 1 1 2)), ' ',		(String streamContents: [:s | (Time fromSeconds: entry modificationTime \\ 86400) print24: true on: s]).	sizeStr _ entry fileSize asStringWithCommas.	entry isDirectory		ifTrue: [			nameStr _ entry name, self folderString.			sortMode = #date ifTrue: [^ '(', dateStr, ') ', nameStr].			^ nameStr, ' (', dateStr, ')']		ifFalse: [			nameStr _ entry name.			sortMode = #name ifTrue: [^ nameStr, '    (', dateStr, ' ', sizeStr, ')'].			sortMode = #date ifTrue: [^ '(', dateStr, ' ', sizeStr, ') ', nameStr].			sortMode = #size ifTrue: [^ '(', ((sizeStr size to: sizePad) collect: [:i | $ ]), sizeStr, ' ', dateStr, ') ', nameStr]].! !!FileList methodsFor: 'volume list and pattern' stamp: 'jm 11/18/2003 09:37'!listForPattern: pat	"Make the list be only those file names that match the pattern."	| sortBlock entries sizePad |	"create a sort block to decide what order to display the entries"	sortBlock _ [:x :y |		x isDirectory = y isDirectory			ifTrue: [				"sort by user-specified criterion"				sortMode = #name					ifTrue: [  "sort by name"						(x name compare: y name) <= 2]					ifFalse: [						sortMode = #date							ifTrue: [  "sort by time, then name"								x modificationTime = y modificationTime									ifTrue: [(x name compare: y name) <= 2]									ifFalse: [x modificationTime > y modificationTime]]							ifFalse: [  "sort by size, then name"								x fileSize = y fileSize									ifTrue: [(x name compare: y name) <= 2]									ifFalse: [x fileSize > y fileSize]]]]			ifFalse: [  "directories always follow files"				x isDirectory not]].	entries _ directory entries.	pat = '*' ifFalse: [  "filter file names"		entries _ entries select: [:e |e isDirectory or: [pat match: e name]]].	entries sort: sortBlock.	sizePad _ (entries inject: 0 into: [:mx :entry | mx max: entry fileSize])					asStringWithCommas size - 1.	^ entries collect: [:e | self fileNameFormattedFrom: e sizePad: sizePad]! !!FileList methodsFor: 'volume list and pattern' stamp: 'stp 12/11/1999 19:37'!volumeListIndex: index	"Select the volume name having the given index."	| delim path |	volListIndex := index.	index = 1 		ifTrue: [self directory: (FileDirectory on: '')]		ifFalse: [delim := directory pathNameDelimiter.				path := String streamContents: [:strm |					2 to: index do: [:i |						strm nextPutAll: (volList at: i) withBlanksTrimmed.						i < index ifTrue: [strm nextPut: delim]]].				self directory: (directory on: path)].	brevityState := #FileList.	self addPath: path.	self changed: #fileList.	self changed: #contents! !!FileList methodsFor: 'volume list and pattern' stamp: 'jm 5/23/2003 13:22'!volumeMenu: aMenu	^ aMenu labels:'recent...delete directory...'		lines: # (1)		selections: #(recentDirs deleteDirectory)! !!FileList methodsFor: 'file list' stamp: 'jm 5/23/2003 13:19'!fileListIndex: anInteger	"Select the file name having the given index, and display its contents."	| item name |	self okToChange ifFalse: [^ self].	listIndex := anInteger.	listIndex = 0 		ifTrue: [fileName := nil]		ifFalse:			[item := self fileNameFromFormattedItem: (list atPin: anInteger).			(item endsWith: self folderString)				ifTrue:					["remove [...] folder string and open the folder"					name := item copyFrom: 1 to: item size - self folderString size.					listIndex := 0.					brevityState := #FileList.					self addPath: name.					name first = $^						ifTrue: [self error: 'remote directories not supported']						ifFalse: [volListIndex = 1 ifTrue: [name _ name, directory slash].							self directory: (directory directoryNamed: name)]]				ifFalse: [fileName := item]].  "open the file selected"	brevityState := #needToGetBrief.	self changed: #fileListIndex.	self changed: #contents! !!FileList methodsFor: 'file list menu' stamp: 'sge 11/28/1999 09:03'!addNew: aString byEvaluating: aBlock	"A parameterization of earlier versions of #addNewDirectory and	#addNewFile.  Fixes the bug in each that pushing the cancel button	in the FillInTheBlank dialog gave a walkback."	| response newName index ending |	self okToChange ifFalse: [^ self].	(response _ FillInTheBlank request: 'New ',aString,' Name?' 					initialAnswer: aString,'Name')		isEmpty ifTrue: [^ self].	newName _ response asFileName.	Cursor wait showWhile: [		aBlock value: newName].	self updateFileList.	index _ list indexOf: newName.	index = 0 ifTrue: [ending _ ') ',newName.		index _ list findFirst: [:line | line endsWith: ending]].	self fileListIndex: index.! !!FileList methodsFor: 'file list menu' stamp: 'sge 11/28/1999 09:04'!addNewDirectory	self 		addNew: 'Directory'		byEvaluating: [:newName | directory createDirectory: newName]! !!FileList methodsFor: 'file list menu' stamp: 'sge 11/28/1999 09:04'!addNewFile	self 		addNew: 'File'		byEvaluating: [:newName | (directory newFileNamed: newName) close]! !!FileList methodsFor: 'file list menu' stamp: 'sw 7/8/1999 16:05'!browseChanges	"Browse the selected file in fileIn format."	fileName		ifNotNil:			[ChangeList browseStream: (directory oldFileNamed: fileName)]		ifNil:			[self beep].! !!FileList methodsFor: 'file list menu' stamp: 'tk 3/15/2000 10:32'!compressFile	"Compress the currently selected file"	(directory readOnlyFileNamed: self fullName) compressFile.	self updateFileList! !!FileList methodsFor: 'file list menu' stamp: 'di 4/28/1999 11:33'!copyName	listIndex = 0 ifTrue: [^ self].	ParagraphEditor clipboardTextPut: self fullName asText.! !!FileList methodsFor: 'file list menu' stamp: 'di 8/16/1998 12:22'!deleteFile	"Delete the currently selected file"	listIndex = 0 ifTrue: [^ self].	(self confirm: 'Really delete ' , fileName , '?') ifFalse: [^ self].	directory deleteFileNamed: fileName.	self updateFileList.	brevityState _ #FileList.	self get! !!FileList methodsFor: 'file list menu' stamp: 'sma 5/20/2000 18:30'!fileAllIn	"File in all of the currently selected file, if any."	"wod 5/24/1998: open the file read only."	| fn ff |	listIndex = 0 ifTrue: [^ self].	ff _ directory readOnlyFileNamed: (fn _ self uncompressedFileName).	((self getSuffix: fn) sameAs: 'html') ifTrue: [ff _ ff asHtml].	ff fileIn! !!FileList methodsFor: 'file list menu' stamp: 'di 4/26/2000 20:33'!fileContentsMenu: aMenu shifted: shifted| shiftMenu |^ shifted 	ifFalse: [aMenu 		labels: 'get entire fileview as hexbrowse changesfind...(f)find again (g)set search string (h)do again (j)undo (z)copy (c)cut (x)paste (v)paste...do it (d)print it (p)inspect it (i)fileIn selectionaccept (s)cancel (l)more...' 		lines: #(3 6 8 12 16 18)		selections: #(get getHex browseChangesfind findAgain setSearchStringagain undocopySelection cut paste pasteRecentdoIt printIt inspectIt fileItInaccept cancelshiftedYellowButtonActivity)]	ifTrue: [shiftMenu _ ParagraphEditor shiftedYellowButtonMenu.		aMenu 			labels: shiftMenu labelString 			lines: shiftMenu lineArray			selections: shiftMenu selections]! !!FileList methodsFor: 'file list menu' stamp: 'jwh 5/24/2000 12:35'!fileIntoNewChangeSet	"File in all of the contents of the currently selected file,	if any, into a new change set." 	| fn ff |	listIndex = 0 ifTrue: [^ self].	ff _ directory readOnlyFileNamed: (fn _ self uncompressedFileName).	((self getSuffix: fn) sameAs: 'html') ifTrue: [ff _ ff asHtml].	ChangeSorter newChangesFromStream: ff named: (FileDirectory localNameFor: fn)! !!FileList methodsFor: 'file list menu' stamp: 'sma 5/20/2000 18:29'!fileNameSuffix	^ self getSuffix: self fullName! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 16:06'!fileSelectedMenu: aMenu	| firstItems secondItems thirdItems n1 n2 n3 |	firstItems _ self itemsForFileEnding: self fileNameSuffix asLowercase.	secondItems _ self itemsForAnyFile.	thirdItems _ self itemsForNoFile.	n1 _ firstItems first size.	n2 _ n1 + secondItems first size.	n3 _ n2 + thirdItems first size.	^ aMenu		labels: firstItems first , secondItems first , thirdItems first , #('more...')		lines: firstItems second				, (Array with: n1 with: n2)				, (thirdItems second collect: [:n | n + n2])				, (Array with: n3)		selections: firstItems third , secondItems third , thirdItems third , #(offerAllFileOptions)! !!FileList methodsFor: 'file list menu' stamp: 'ar 1/2/2000 15:30'!itemsForAnyFile	^ #(('copy name to clipboard' 'rename' 'delete' 'compress')		()		(copyName renameFile deleteFile compressFile)		)! !!FileList methodsFor: 'file list menu' stamp: 'jm 5/23/2003 13:17'!itemsForFileEnding: suffix	| labels lines selectors |	labels _ OrderedCollection new.	lines _ OrderedCollection new.	selectors _ OrderedCollection new.	(#('bmp' 'gif' 'jpg' 'jpeg' 'form' 'png' '*') includes: suffix) ifTrue: [		labels addAll: #('open image in a window').		selectors addAll: #(openImageInWindow)].	(#('mid' 'midi' '*') includes: suffix) ifTrue: [		labels add: 'play midi file'.		selectors add: #playMidiFile].	(#('st' 'cs' '*') includes: suffix) ifTrue: [		suffix = '*' ifTrue: [lines add: labels size].		labels addAll: #('fileIn' 'file into new change set' 'browse changes' 'browse code' 'remove line feeds').		lines add: labels size - 1.		selectors addAll: #(fileInSelection fileIntoNewChangeSet browseChanges browseFile removeLinefeeds)].	(#('gz' '*') includes: suffix) ifTrue: [		labels addAll: #('view decompressed' 'decompress to file').		selectors addAll: #(viewGZipContents saveGZipContents)].	^ Array with: labels with: lines with: selectors! !!FileList methodsFor: 'file list menu' stamp: 'di 11/19/1998 14:25'!itemsForNoFile	^ #(		('sort by name' 'sort by size' 'sort by date'		'browse code files'		'add new file' 'add new directory')		(3 4)		(sortByName sortBySize sortByDate		browseFiles		addNewFile addNewDirectory)		)! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 09:34'!noFileSelectedMenu: aMenu	| items |	items _ self itemsForNoFile.	^ aMenu		labels: items first		lines: items second		selections: items third! !!FileList methodsFor: 'file list menu' stamp: 'di 8/20/1998 16:05'!offerAllFileOptions	| items action |	items _ self itemsForFileEnding: '*'.	action _ (SelectionMenu labels: items first lines: items second selections: items third)			startUp.	action ifNotNil: [self perform: action]! !!FileList methodsFor: 'file list menu' stamp: 'sma 4/30/2000 09:38'!openImageInWindow	"Handle five file formats: GIF, JPG, PNG, Form stoteOn: (run coded), and BMP.	Fail if file format is not recognized."	| image |	image _ Form fromFileNamed: self fullName.	Smalltalk isMorphic		ifTrue: [World addMorph: (SketchMorph withForm: image)]		ifFalse: [FormView open: image named: fileName]! !!FileList methodsFor: 'file list menu' stamp: 'jm 5/23/2003 13:18'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, then perform it on myself.  If not, send it to otherTarget, presumably the editPane from which the menu was invoked." 	(#(get getHex browseChangessortByDate sortBySize sortByNamefileInSelection fileIntoNewChangeSet browseChanges copyNameopenImageInWindow playMidiFilerenameFile deleteFile addNewFile) includes: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ super perform: selector orSendTo: otherTarget]! !!FileList methodsFor: 'file list menu' stamp: 'jm 5/29/1998 17:09'!playMidiFile	"Play a MIDI file." 	| f score |	Smalltalk at: #MIDIFileReader ifPresent: [:midiReader |		Smalltalk at: #ScorePlayerMorph ifPresent: [:scorePlayer |			f _ (directory oldFileNamed: self fullName) binary.			score _ (midiReader new readMIDIFrom: f) asScore.			f close.			scorePlayer openOn: score title: fileName]].! !!FileList methodsFor: 'file list menu' stamp: 'ar 9/3/1999 13:05'!removeLinefeeds	"Remove any line feeds by converting to CRs instead"	| fileContents |	fileContents _ (CrLfFileStream readOnlyFileNamed: self fullName) contentsOfEntireFile.	(StandardFileStream newFileNamed: self fullName) 		nextPutAll: fileContents;		close.! !!FileList methodsFor: 'file list menu' stamp: 'sge 2/13/2000 04:36'!renameFile	"Rename the currently selected file"	| newName response |	listIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	(response _ FillInTheBlank request: 'NewFileName?' 					initialAnswer: fileName)		isEmpty ifTrue: [^ self].	newName _ response asFileName.	newName = fileName ifTrue: [^ self].	directory rename: fileName toBe: newName.	self updateFileList.	listIndex _ list findFirst: [:item | (self fileNameFromFormattedItem: item) = newName].	listIndex > 0 ifTrue: [fileName _ newName].	self changed: #fileListIndex.! !!FileList methodsFor: 'file list menu' stamp: 'jm 6/20/2003 09:51'!saveGZipContents	"Save the contents of a gzipped file."	| newName unzipped zipped buffer |	newName _ FileDirectory baseNameFor: fileName.	unzipped _ directory newFileNamed: newName.	zipped _ GZipReadStream on: (directory readOnlyFileNamed: self fullName).	buffer _ String new: 50000.	'Extracting ' , self fullName		displayProgressAt: Sensor cursorPoint		from: 0		to: zipped sourceStream size		during: 			[:bar | 			[zipped atEnd]				whileFalse: 					[bar value: zipped sourceStream position.					unzipped nextPutAll: (zipped nextInto: buffer)].			zipped close.			unzipped close].	self updateFileList.	^ newName! !!FileList methodsFor: 'file list menu' stamp: 'mjg 9/1/1998 14:10'!templateFile	^'<head><title><?request name?></title></head><body><?request formatted?></body>'! !!FileList methodsFor: 'file list menu' stamp: 'ar 1/2/2000 15:31'!viewGZipContents	"View the contents of a gzipped file"	| f |	f _ (directory readOnlyFileNamed: self fullName).	contents _ f contentsOfEntireFile.	Cursor wait showWhile:[contents _ (GZipReadStream on: contents) upToEnd].	contents replaceAll: Character lf with: Character cr.	(StringHolder new)		contents: contents;		openLabel:'Contents of ', fileName printString! !!FileList methodsFor: 'private' stamp: 'stp 12/11/1999 20:05'!addPath: aString	"Add the given string to the list of recently visited directories."	| full |	aString ifNil: [^self].	full := String streamContents: 		[ :strm | 2 to: volList size do: 			[ :i | strm nextPutAll: (volList at: i) withBlanksTrimmed.			strm nextPut: FileDirectory pathNameDelimiter]].	full := full, aString."Remove and super-directories of aString from the collection."	RecentDirs removeAllSuchThat: [ :aDir | ((aDir, '*') match: full)]."If a sub-directory is in the list, do nothing."	(RecentDirs detect: [ :aDir | ((full, '*') match: aDir)] ifNone: [nil])		ifNotNil: [^self].	[RecentDirs size >= 10]		whileTrue: [RecentDirs removeFirst].	RecentDirs addLast: full! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:26'!contents	"Answer the contents of the file, reading it first if needed."	"Possible brevityState values:		FileList,		fullFile, briefFile, needToGetFull, needToGetBrief,		fullHex, briefHex, needToGetFullHex, needToGetBriefHex"	(listIndex = 0) | (brevityState == #FileList) ifTrue: [^ self defaultContents].  "no file selected"	brevityState == #fullFile ifTrue: [^ contents].	brevityState == #fullHex ifTrue: [^ contents].	brevityState == #briefFile ifTrue: [^ contents].	brevityState == #briefHex ifTrue: [^ contents].	brevityState == #needToGetFullHex ifTrue: [^ self readContentsHex: false].	brevityState == #needToGetBriefHex ifTrue: [^ self readContentsHex: true].	brevityState == #needToGetFull ifTrue: [^ self readContentsBrief: false].	brevityState == #needToGetBrief ifTrue: [^ self readContentsBrief: true].  "default"	self halt: 'unknown state ' , brevityState printString! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:25'!defaultContents	contents _ list == nil		ifTrue: [String new]		ifFalse: [String streamContents:					[:s | s nextPutAll: 'NO FILE SELECTED'; cr.					s nextPutAll: '  -- Folder Summary --'; cr.					list do: [:item | s nextPutAll: item; cr]]].	brevityState _ #FileList.	^ contents! !!FileList methodsFor: 'private' stamp: 'sma 4/30/2000 09:41'!errorMustBeMorph	self inform: 'Can only load a single morphinto an mvc project via this mechanism.'! !!FileList methodsFor: 'private'!fileNameFromFormattedItem: item	"Extract fileName and folderString from a formatted fileList item string"	| i |	(i _ item indexOf: $( ifAbsent: [0]) = 0 ifTrue: [^ item withBlanksTrimmed].	^ (item copyReplaceFrom: i to: (item findFirst: [:c | c = $)]) with: '') withBlanksTrimmed! !!FileList methodsFor: 'private' stamp: 'jm 11/18/2003 10:16'!folderString	^ ' []'! !!FileList methodsFor: 'private' stamp: 'sma 5/20/2000 18:29'!getSuffix: aString	| i |	i _ aString findLast: [:each | $. = each].	^ i = 0		ifTrue: ['']		ifFalse: [aString copyFrom: i + 1 to: aString size]! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:46'!put: aText	| ff type |	brevityState == #fullFile ifTrue:		[ff _ directory newFileNamed: self fullName.		Cursor write showWhile: [ff nextPutAll: aText asString; close].		fileName = ff localName 			ifTrue: [contents _ aText asString]			ifFalse: [self updateFileList].		"user renamed the file"		^ true  "accepted"].	listIndex = 0 ifTrue:		[PopUpMenu notify: 'No fileName is selected'.		^ false  "failed"].	type _ 'These'.	brevityState = #briefFile ifTrue: [type _ 'Abbreviated'].	brevityState = #briefHex ifTrue: [type _ 'Abbreviated'].	brevityState = #fullHex ifTrue: [type _ 'Hexadecimal'].	brevityState = #FileList ifTrue: [type _ 'Directory'].	PopUpMenu notify: type , ' contents cannotmeaningfully be saved at present.'.	^ false  "failed"! !!FileList methodsFor: 'private' stamp: 'jm 5/23/2003 13:21'!readContentsBrief: brevityFlag	"Read the contents of the receiver's selected file, unless it is too long, in which case show just the first 5000 characters. Don't create a file if it doesn't already exist."	| f fileSize first5000 |	f _ directory oldFileOrNoneNamed: self fullName.	f ifNil: [^ 'For some reason, this file cannot be read'].	(brevityFlag not or: [(fileSize _ f size) <= 100000]) ifTrue:		[contents _ f contentsOfEntireFile.		brevityState _ #fullFile.   "don't change till actually read"		^ contents].	"if brevityFlag is true, don't display long files when first selected"	first5000 _ f next: 5000.	f close.	contents _ 'File ''', fileName, ''' is ', fileSize printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------', first5000 , '------------------------------------------... end of the first 5000 characters.'.	brevityState _ #briefFile.   "don't change till actually read"	^ contents.! !!FileList methodsFor: 'private' stamp: 'di 8/16/1998 09:20'!readContentsHex: brevity	"retrieve the contents from the external file unless it is too long.	  Don't create a file here.  Check if exists."	| f size data hexData s |	f _ directory oldFileOrNoneNamed: self fullName. 	f == nil ifTrue: [^ 'For some reason, this file cannot be read'].	((size _ f size)) > 5000 & brevity		ifTrue: [data _ f next: 10000. f close. brevityState _ #briefHex]		ifFalse: [data _ f contentsOfEntireFile. brevityState _ #fullHex].	s _ WriteStream on: (String new: data size*4).	0 to: data size-1 by: 16 do:		[:loc | s nextPutAll: loc hex; space;			nextPut: $(; print: loc; nextPut: $); space; tab.		loc+1 to: (loc+16 min: data size) do: [:i | s nextPutAll: (data at: i) hex; space].		s cr].	hexData _ s contents.	^ contents _ ((size > 5000) & brevity		ifTrue: ['File ''', fileName, ''' is ', size printString, ' bytes long.You may use the ''get'' command to read the entire file.Here are the first 5000 characters...------------------------------------------', hexData , '------------------------------------------... end of the first 5000 characters.']		ifFalse: [hexData]).! !!FileList methodsFor: 'private' stamp: 'stp 12/11/1999 20:03'!recentDirs	"Put up a menu and let the user select from the list of recently visited directories."	| dirName |	RecentDirs isEmpty ifTrue: [^self].	dirName := (SelectionMenu selections: RecentDirs) startUp.	dirName == nil ifTrue: [^self].	self directory: (FileDirectory on: dirName)! !!FileList methodsFor: 'private' stamp: 'ls 9/11/1998 04:15'!resort: newMode	"Re-sort the list of files."	| name |	listIndex > 0		ifTrue: [name _ self fileNameFromFormattedItem: (list at: listIndex)].	sortMode _ newMode.	self pattern: pattern.	name ifNotNil: [		fileName _ name.		listIndex _ list findFirst: [:item | (self fileNameFromFormattedItem: item) = name. ].		self changed: #fileListIndex].	listIndex = 0 ifTrue: [self changed: #contents]! !!FileList methodsFor: 'private' stamp: 'sw 1/7/2000 15:58'!sortingByDate	^ sortMode == #date! !!FileList methodsFor: 'private' stamp: 'sw 1/7/2000 15:57'!sortingByName	^ sortMode == #name! !!FileList methodsFor: 'private' stamp: 'sw 1/7/2000 15:58'!sortingBySize	^ sortMode == #size! !!FileList methodsFor: 'private' stamp: 'sma 5/20/2000 18:31'!uncompressedFileName	| f |	f _ self fullName.	((f endsWith: '.gz') and: [self confirm: f , 'appears to be a compressed file.Do you want to uncompress it?'])		ifFalse: [^ f].	^ self saveGZipContents! !!FileList methodsFor: 'private' stamp: 'wod 5/27/1998 17:47'!updateFileList	"Update my files list with file names in the current directory that match the pattern."	"wod 5/27/1998: nil out the fileName."	Cursor execute showWhile:		[list _ (pattern includes: $*) | (pattern includes: $#)			ifTrue: [self listForPattern: pattern]			ifFalse: [				pattern isEmpty					ifTrue: [self listForPattern: '*']					ifFalse: [self listForPattern: '*', pattern, '*']].		listIndex _ 0.		volListIndex _ volList size.		fileName _ nil.		contents _ ''.		self changed: #volumeListIndex.		self changed: #fileList].! !!FileList methodsFor: 'menu messages' stamp: 'wod 5/13/1998 04:10'!browseFile	FileContentsBrowser browseFile: self fullName.! !!FileList methodsFor: 'menu messages' stamp: 'wod 5/13/1998 04:10'!browseFiles	| selectionPattern fileList |	selectionPattern := FillInTheBlank request:'What files?' initialAnswer: self pattern.	fileList _ (directory fileNamesMatching: selectionPattern) 		collect: [:each | directory fullNameFor: each].	FileContentsBrowser browseFiles: fileList.! !!FileList class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 09:30'!open	"Open a view of an instance of me on the default directory."	"FileList open"	| dir aFileList topView volListView templateView fileListView fileContentsView underPane pHeight |	Smalltalk isMorphic ifTrue: [^ self openAsMorph].	dir _ FileDirectory default.	aFileList _ self new directory: dir.	topView _ StandardSystemView new.	topView		model: aFileList;		label: dir pathName;		minimumSize: 200@200.	topView borderWidth: 1.	volListView _ PluggableListView on: aFileList		list: #volumeList		selected: #volumeListIndex		changeSelected: #volumeListIndex:		menu: #volumeMenu:.	volListView autoDeselect: false.	volListView window: (0@0 extent: 80@45).	topView addSubView: volListView.	templateView _ PluggableTextView on: aFileList		text: #pattern		accept: #pattern:.	templateView askBeforeDiscardingEdits: false.	templateView window: (0@0 extent: 80@15).	topView addSubView: templateView below: volListView.	Preferences optionalButtons		ifTrue: [			underPane _ aFileList optionalButtonView.			underPane isNil				ifTrue: [pHeight _ 60]				ifFalse: [					topView addSubView: underPane toRightOf: volListView.					pHeight _ 60 - aFileList optionalButtonHeight]]		ifFalse: [			underPane _ nil.			pHeight _ 60].	fileListView _ PluggableListView on: aFileList		list: #fileList		selected: #fileListIndex		changeSelected: #fileListIndex:		menu: #fileListMenu:.	fileListView window: (0@0 extent: 120@pHeight).	underPane isNil		ifTrue: [topView addSubView: fileListView toRightOf: volListView]		ifFalse: [topView addSubView: fileListView below: underPane].	fileListView controller terminateDuringSelect: true.  "Pane to left may change under scrollbar"	fileContentsView _ PluggableTextView on: aFileList		text: #contents accept: #put:		readSelection: #contentsSelection menu: #fileContentsMenu:shifted:.	fileContentsView window: (0@0 extent: 200@140).	topView addSubView: fileContentsView below: templateView.	topView controller open.! !!FileList class methodsFor: 'instance creation' stamp: 'sw 12/13/1999 10:26'!openAsMorph	"Open a morphic view of a FileList on the default directory."	| dir aFileList window fileListTop |	dir _ FileDirectory default.	aFileList _ self new directory: dir.	window _ (SystemWindow labelled: dir pathName) model: aFileList.	window addMorph: ((PluggableListMorph on: aFileList list: #volumeList selected: #volumeListIndex				changeSelected: #volumeListIndex: menu: #volumeMenu:) autoDeselect: false)		frame: (0@0 corner: 0.3@0.2).	window addMorph: (PluggableTextMorph on: aFileList text: #pattern accept: #pattern:)		frame: (0@0.2 corner: 0.3@0.3).	Preferences optionalButtons		ifTrue:			[window addMorph: aFileList optionalButtonRow frame: (0.3 @ 0 corner: 1 @ 0.08).			fileListTop _ 0.08]		ifFalse:			[fileListTop _ 0].	window addMorph: (PluggableListMorph on: aFileList list: #fileList selected: #fileListIndex				changeSelected: #fileListIndex: menu: #fileListMenu:)		frame: (0.3 @ fileListTop corner: 1@0.3).	window addMorph: (PluggableTextMorph on: aFileList text: #contents accept: #put:			readSelection: #contentsSelection menu: #fileContentsMenu:shifted:)		frame: (0@0.3 corner: 1@1).	^ window! !!FileList class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 09:31'!openEditorOn: aFileStream editString: editString	"Open an editor on the given FileStream."	| fileModel topView fileContentsView |	Smalltalk isMorphic ifTrue: [^ (self openMorphOn: aFileStream editString: editString) openInWorld].	fileModel _ FileList new setFileStream: aFileStream.	"closes the stream"	topView _ StandardSystemView new.	topView		model: fileModel;		label: aFileStream fullName;		minimumSize: 180@120.	topView borderWidth: 1.	fileContentsView _ PluggableTextView on: fileModel 		text: #contents accept: #put:		readSelection: #contentsSelection menu: #fileContentsMenu:shifted:.	fileContentsView window: (0@0 extent: 180@120).	topView addSubView: fileContentsView.	editString ifNotNil: [fileContentsView editString: editString.			fileContentsView hasUnacceptedEdits: true].	topView controller open.! !!FileList class methodsFor: 'instance creation' stamp: 'di 10/18/1999 22:34'!openMorphOn: aFileStream editString: editString 	"Open a morphic view of a FileList on the given file."	| fileModel window fileContentsView |	fileModel _ FileList new setFileStream: aFileStream.	"closes the stream"	window _ (SystemWindow labelled: aFileStream fullName) model: fileModel.	window addMorph: (fileContentsView _ PluggableTextMorph on: fileModel 			text: #contents accept: #put:			readSelection: #contentsSelection 			menu: #fileContentsMenu:shifted:)		frame: (0@0 corner: 1@1).	editString ifNotNil: [fileContentsView editString: editString.			fileContentsView hasUnacceptedEdits: true].	^ window! !!FileList class methodsFor: 'class initialization' stamp: 'stp 12/11/1999 19:47'!initialize	"FileList initialize"	RecentDirs := OrderedCollection new! !!FilePackage methodsFor: 'accessing'!classAt: className	^self classes at: className! !!FilePackage methodsFor: 'accessing'!classes	^classes! !!FilePackage methodsFor: 'accessing'!fullPackageName	^fullName! !!FilePackage methodsFor: 'accessing'!packageInfo	^String streamContents:[:s|		s nextPutAll:'Package: '.		s nextPutAll: self fullPackageName; cr; cr.		sourceSystem isEmpty ifFalse:[			s nextPutAll: sourceSystem; cr; cr].		doIts isEmpty ifFalse:[			s nextPutAll:'Unresolvable doIts:'; cr; cr.			doIts do:[:chgRec|				s nextPut:$!!; nextPutAll: chgRec string; nextPut: $!!; cr]]].! !!FilePackage methodsFor: 'accessing'!packageName	^packageName! !!FilePackage methodsFor: 'accessing'!removeClass: aPseudoClass	(self classes removeKey: aPseudoClass name).	classOrder copy do:[:cls|		cls name = aPseudoClass name ifTrue:[ classOrder remove: cls].	].! !!FilePackage methodsFor: 'accessing'!renameClass: aPseudoClass to: newName	| oldName |	oldName := aPseudoClass name.	self classes removeKey: oldName.	self classes at: newName put: aPseudoClass.	aPseudoClass renameTo: newName.! !!FilePackage methodsFor: 'initialize'!fromFileNamed: aName	| stream |	fullName := aName.	packageName := FileDirectory localNameFor: fullName.	stream := FileStream readOnlyFileNamed: aName.	doIts := OrderedCollection new.	classOrder := OrderedCollection new.	sourceSystem := ''.	self fileInFrom: stream.! !!FilePackage methodsFor: 'private'!classDefinition: string with: chgRec	| tokens theClass |	tokens := Scanner new scanTokens: string.	tokens size = 11 ifFalse:[^doIts add: chgRec].	theClass := self getClass: (tokens at: 3).	theClass definition: string.	classOrder add: theClass.! !!FilePackage methodsFor: 'private'!getClass: className	| pseudoClass |	(classes includesKey: className) ifTrue:[		^classes at: className.	].	pseudoClass := PseudoClass new.	pseudoClass name: className.	classes at: className put: pseudoClass.	^pseudoClass.! !!FilePackage methodsFor: 'private'!metaClassDefinition: string with: chgRec	| tokens theClass |	tokens := Scanner new scanTokens: string.	theClass := self getClass: (tokens at: 1).	theClass metaClass definition: string.	classOrder add: theClass metaClass.! !!FilePackage methodsFor: 'private'!msgClassComment: string with: chgRec	| tokens theClass |	tokens := Scanner new scanTokens: string.	(tokens size = 3 and:[(tokens at: 3) class == String]) ifTrue:[		theClass := self getClass: tokens first.		^theClass commentString: tokens last].	(tokens size = 4 and:[(tokens at: 3) asString = 'class' and:[(tokens at: 4) class == String]]) ifTrue:[		theClass := self getClass: tokens first.		theClass metaClass commentString: tokens last].! !!FilePackage methodsFor: 'private'!possibleSystemSource: chgRec	| tokens |	sourceSystem isEmpty ifTrue:[		tokens := Scanner new scanTokens: chgRec string.		(tokens size = 1 and:[tokens first class == String]) ifTrue:[			sourceSystem := tokens first.			^self]].	doIts add: chgRec.! !!FilePackage methodsFor: 'private'!removedMethod: string with: chgRec	| class tokens |	tokens := Scanner new scanTokens: string.	(tokens size = 3 and:[(tokens at: 2) == #removeSelector: ]) ifTrue:[		class := self getClass: (tokens at: 1).		^class removeSelector: (tokens at: 3).	].	(tokens size = 4 and:[(tokens at: 2) == #class and:[(tokens at: 3) == #removeSelector:]]) ifTrue:[		class := self getClass: (tokens at: 1).		^class metaClass removeSelector: (tokens at: 4).	].	doIts add: chgRec! !!FilePackage methodsFor: 'private'!sampleMethod"	In an existing method there are always a number of changes.	Other stuff		will be deleted	Or even better,		some things may be just modified."! !!FilePackage methodsFor: 'change record types'!classComment: chgRec	(self getClass: chgRec methodClassName) classComment: chgRec! !!FilePackage methodsFor: 'change record types'!doIt: chgRec	| string |	string := chgRec string.	('*ubclass:*instanceVariableNames:*classVariableNames:*poolDictionaries:*category:*'		match: string) ifTrue:[^self classDefinition: string with: chgRec].	('* class*instanceVariableNames:*'		match: string) ifTrue:[^self metaClassDefinition: string with: chgRec].	('* removeSelector: *'		match: string) ifTrue:[^self removedMethod: string with: chgRec].	('* comment:*'		match: string) ifTrue:[^self msgClassComment: string with: chgRec].	('* initialize'		match: string) ifTrue:[^self]. "Initialization is done based on class>>initialize"	('''From *'		match: string) ifTrue:[^self possibleSystemSource: chgRec].	doIts add: chgRec.! !!FilePackage methodsFor: 'change record types'!method: chgRec	(self getClass: chgRec methodClassName) methodChange: chgRec! !!FilePackage methodsFor: 'change record types'!preamble: chgRec	self doIt: chgRec! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'wod 4/15/98 15:57'!askForDoits	| menu choice choices |	choices := #('do not process' 'at the beginning' 'at the end' 'cancel').	menu _ SelectionMenu selections: choices.	choice := nil.	[choices includes: choice] whileFalse: [		choice _ menu startUpWithCaption: 'The package contains unprocessed doIts.When would like to process those?'].	^choices indexOf: choice! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'wod 4/15/98 16:00'!fileIn	| doitsMark |	doitsMark := 1.	doIts isEmpty ifFalse:[doitsMark := self askForDoits].	doitsMark = 4 ifTrue: [^nil].	doitsMark = 2 ifTrue:[self fileInDoits].	classOrder do:[:cls|		cls fileInDefinition.	].	classes do:[:cls|		Transcript cr; show:'Filing in ', cls name.		cls fileInMethods.		cls hasMetaclass ifTrue:[cls metaClass fileInMethods].	].	doitsMark = 3 ifTrue:[self fileInDoits].! !!FilePackage methodsFor: 'fileIn/fileOut'!fileInDoits	doIts do:[:chgRec| chgRec fileIn].! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'jm 10/7/2002 06:57'!fileOut	| fileName stream |	fileName := FillInTheBlank request: 'Enter the file name' initialAnswer:''.	stream := FileStream newFileNamed: fileName.	sourceSystem isEmpty ifFalse:[		stream nextChunkPut: sourceSystem printString;cr ].	self fileOutOn: stream.	stream cr; cr.	self classes do:[:cls|		cls needsInitialize ifTrue:[			stream cr; nextChunkPut: cls name,' initialize']].	stream cr.	stream close.! !!FilePackage methodsFor: 'fileIn/fileOut'!fileOutDoits: aStream	doIts do:[:chgRec| chgRec fileOutOn: aStream].! !!FilePackage methodsFor: 'fileIn/fileOut' stamp: 'wod 4/15/98 15:59'!fileOutOn: aStream	| doitsMark |	doitsMark := 1.	doIts isEmpty ifFalse:[doitsMark := self askForDoits].	doitsMark = 4 ifTrue: [^nil].	doitsMark = 2 ifTrue:[self fileOutDoits: aStream].	classOrder do:[:cls|		cls fileOutDefinitionOn: aStream.	].	classes do:[:cls|		cls fileOutMethodsOn: aStream.		cls hasMetaclass ifTrue:[cls metaClass fileOutMethodsOn: aStream].	].	doitsMark = 3 ifTrue:[self fileOutDoits: aStream].! !!FilePackage methodsFor: 'reading'!fileInFrom: aStream	| chgRec changes |	changes := (ChangeList new scanFile: aStream from: 0 to: aStream size) changeList.	aStream close.	classes := Dictionary new.	('Processing ', self packageName) 		displayProgressAt: Sensor cursorPoint		from: 1		to: changes size		during:[:bar|			1 to: changes size do:[:i|				bar value: i.				chgRec := changes at: i.				self perform: (chgRec type copyWith: $:) asSymbol with: chgRec.			].		].! !!FilePackage class methodsFor: 'instance creation'!fromFileNamed: aName	^self new fromFileNamed: aName! !I am an example server that can receive and save large files using the MsgServer framework. My only operation is:	1 -- receive a filewhose arguments are the file name and file size in bytes.To try this server, copy the remainder of this comment into a workspace and follow the step-by-step directions.First start the server:  server _ FileReceiverServerTest new.  server forkServerProcess.Next, create a client socket and connect it to the server:  Socket initializeNetwork.  sock _ MessageSocket new.  sock	connectTo: NetNameResolver localHostAddress	port: FileReceiverServerTest portNumber	waitSecs: 10.  sock isConnected ifFalse: [self error: 'could not connect'].You can now send a file to the server:  fileName _ 'Gromit.jmv'.  file _ (FileStream readOnlyFileNamed: fileName) binary.  request _ WriteStream on: ByteArray new.  request nextPut: 1.  request string: fileName.  request int32: file size.  sock request: request contents withStream: file.When you are done sending files, you can close the client socket stop the server:  sock destroy.  server stopServer.!!FileReceiverServerTest methodsFor: 'request handling' stamp: 'jm 4/23/2003 09:57'!createFileBasedOnName: fileName	"Find an unused file name based on the given file name. Create a new file of that name and answer a stream on that file."	| ext root n newFileName |	(FileDirectory default fileExists: fileName) ifFalse: [^ FileStream newFileNamed: fileName].	ext _ FileDirectory extensionFor: fileName.	root _ fileName copyFrom: 1 to: fileName size - ext size.	ext size > 0 ifTrue: [ext _ '.', ext].	n _ 1.	[true] whileTrue: [		newFileName _ root, n printString, ext.		(FileDirectory default fileExists: newFileName) ifFalse: [			^ FileStream newFileNamed: newFileName].		n _ n + 1].! !!FileReceiverServerTest methodsFor: 'request handling' stamp: 'jm 4/23/2003 18:32'!processMessage: aByteArray requestSocket: aSocket	"This server receives and saves files."	| s op fName byteCount file bytesLeft buf n |	"parse the request"	s _ ReadStream on: aByteArray.	op _ s next.	op = 1 ifFalse: [^ 'bad op'].	fName _ s string.	byteCount _ s int32.	"receive the file"	file _ self createFileBasedOnName: fName.	bytesLeft _ byteCount.	buf _ ByteArray new: 10000.	[aSocket isConnected and: [bytesLeft > 0]] whileTrue: [		buf size > bytesLeft ifTrue: [buf _ ByteArray new: bytesLeft].		aSocket waitForData.		n _ aSocket socket readInto: buf startingAt: 1.		n > 0 ifTrue: [			file nextPutAll: (buf copyFrom: 1 to: n).			bytesLeft _ bytesLeft - n]].	file close.	^ 'ok'! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:02'!close	"Close this file."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:02'!closed	"Answer true if this file is closed."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:03'!flush	"When writing, flush the current buffer out to disk."	self subclassResponsibility! !!FileStream methodsFor: 'file open/close' stamp: 'jm 9/21/1998 13:04'!reopen	"Ensure that the receiver is open, re-open it if necessary."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 13:01'!ascii	"Set this file to ascii (text) mode."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 12:59'!binary	"Set this file to binary mode."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 12:59'!readOnly	"Set this file's mode to read-only."	self subclassResponsibility! !!FileStream methodsFor: 'file modes' stamp: 'jm 9/21/1998 13:01'!text	"Set this file to text (ascii) mode."	self ascii.! !!FileStream methodsFor: 'fileIn/Out' stamp: 'sw 11/19/1998 16:42'!fileIn	"Guarantee that the receiver is readOnly before fileIn for efficiency and	to eliminate remote sharing conflicts."	self readOnly.	self fileInAnnouncing: 'Loading ', self localName! !!FileStream class methodsFor: 'instance creation' stamp: 'jm 5/8/2003 19:14'!droppedFiles	"Poll for a dropped file event. If there is such an event, answer an array containing the drop point followed by one or more FileStream's for the dropped files. Otherwise, answer the empty array."	"Note: File dropping does not work on versions of the Squeak VM before the DropPlugin and event primitive. This method can still be called, but it will always answer an empty array."	| p result i f evtBuf |	"check for a file drop event?"	p _ Sensor fileDropPoint.	p ifNil: [^ #()].  "no file drop event"	"get streams on all dropped files"	result _ OrderedCollection with: p.	i _ 1.	[(f _ StandardFileStream new requestDropStream: i) notNil] whileTrue: [		result addLast: f.		i _ i + 1].	"flush remaining file drop events"	evtBuf _ Array new: 8.	[(evtBuf at: 1) = 3] whileTrue: [		evtBuf at: 1 put: 0.		Sensor primGetNextEvent: evtBuf].	^ result asArray! !!FileStream class methodsFor: 'instance creation' stamp: 'TPR 8/26/1999 10:49'!isAFileNamed: fName	"return whether a file exists with the given name"	^self concreteStream isAFileNamed: (self fullName: fName)! !!FileStream class methodsFor: 'concrete classes' stamp: 'ls 7/11/1998 02:58'!concreteStream	"Who should we really direct class queries to?  "	^ StandardFileStream  "may change this to CrLfFileStream"! !!FillInTheBlank methodsFor: 'initialize-release' stamp: 'sw 1/31/2000 14:42'!initialize	super initialize.	acceptOnCR _ false.	done _ false.	responseUponCancel _ ''! !!FillInTheBlank methodsFor: 'accessing' stamp: 'sw 1/31/2000 14:45'!responseUponCancel: resp	responseUponCancel _ resp! !!FillInTheBlank methodsFor: 'accessing' stamp: 'sw 1/31/2000 14:47'!setResponseForCancel	self contents: responseUponCancel! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 09:43'!multiLineRequest: queryString centerAt: aPoint initialAnswer: defaultAnswer answerHeight: answerHeight	"Create a multi-line instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.  Answer nil if the user cancels.  An empty string returned means that the ussr cleared the editing area and then hit 'accept'.  Because multiple lines are invited, we ask that the user use the ENTER key, or (in morphic anyway) hit the 'accept' button, to submit; that way, the return key can be typed to move to the next line."	"FillInTheBlank		multiLineRequest:'Enter several lines; end input by acceptingor canceling or typing the enter key'		centerAt: Display boundingBox center		initialAnswer: 'bozo!!'		answerHeight: 100"	| model fillInView savedArea |	Smalltalk isMorphic		ifTrue:			[^ FillInTheBlankMorph				request: queryString				initialAnswer: defaultAnswer				centerAt: aPoint				inWorld: self currentWorld				onCancelReturn: nil				acceptOnCR: false].	model _ self new initialize.	model contents: defaultAnswer.	model responseUponCancel: nil.	model acceptOnCR: false.	fillInView _		(Smalltalk at: #FillInTheBlankView)			multiLineOn: model			message: queryString			centerAt: aPoint			answerHeight: answerHeight.	savedArea _ Form fromDisplay: fillInView displayBox.	fillInView display.	defaultAnswer isEmpty		ifFalse: [fillInView lastSubView controller selectFrom: 1 to: defaultAnswer size].	(fillInView lastSubView containsPoint: Sensor cursorPoint)		ifFalse: [fillInView lastSubView controller centerCursorInView].	fillInView controller startUp.	fillInView release.	savedArea displayOn: Display at: fillInView viewport topLeft.	^ model contents! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'di 9/11/1998 15:01'!request: queryString	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlankMorph request: queryString"	^ self request: queryString		initialAnswer: ''		centerAt: Sensor cursorPoint.! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'di 9/11/1998 15:02'!request: queryString initialAnswer: defaultAnswer 	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlank		request: 'What is your favorite color?'		initialAnswer: 'red, no blue. Ahhh!!'"	^ self request: queryString		initialAnswer: defaultAnswer		centerAt: Sensor cursorPoint.! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 09:43'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlank request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	| model fillInView savedArea |	Smalltalk isMorphic		ifTrue:			[^ FillInTheBlankMorph				request: queryString				initialAnswer: defaultAnswer				centerAt: aPoint].	model _ self new initialize.	model contents: defaultAnswer.	fillInView _		FillInTheBlankView			on: model			message: queryString			centerAt: aPoint.	savedArea _ Form fromDisplay: fillInView displayBox.	fillInView display.	defaultAnswer isEmpty		ifFalse: [fillInView lastSubView controller selectFrom: 1 to: defaultAnswer size].	(fillInView lastSubView containsPoint: Sensor cursorPoint)		ifFalse: [fillInView lastSubView controller centerCursorInView].	fillInView controller startUp.	fillInView release.	savedArea displayOn: Display at: fillInView viewport topLeft.	^ model contents! !!FillInTheBlank class methodsFor: 'instance creation' stamp: 'jdr 6/4/2000 15:04'!requestPassword: queryString	| model fillInView savedArea defaultAnswer |	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."	"FillInTheBlank requestPassword: 'POP password'"	Smalltalk isMorphic		ifTrue:			[^ FillInTheBlankMorph requestPassword: queryString].	defaultAnswer _ ''.	model _ self new initialize.	model contents: defaultAnswer.	fillInView _		FillInTheBlankView			requestPassword: model			message: queryString			centerAt: Sensor cursorPoint			answerHeight: 40.	savedArea _ Form fromDisplay: fillInView displayBox.	fillInView display.	defaultAnswer isEmpty		ifFalse: [fillInView lastSubView controller selectFrom: 1 to: defaultAnswer size].	(fillInView lastSubView containsPoint: Sensor cursorPoint)		ifFalse: [fillInView lastSubView controller centerCursorInView].	fillInView controller startUp.	fillInView release.	savedArea displayOn: Display at: fillInView viewport topLeft.	^ model contents	! !!FillInTheBlankController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 14:45'!isControlActive	^ self isControlWanted! !!FillInTheBlankController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 14:45'!isControlWanted	^ model done not! !!FillInTheBlankController methodsFor: 'other' stamp: 'sw 1/31/2000 14:47'!cancel	model setResponseForCancel.	super cancel.	model done: true.! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'di 4/12/1999 16:19'!delete	self breakDependents.	^ super delete! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'jm 11/24/2002 10:24'!initialize	super initialize.	self color: Color white.	Preferences roundedWindowCorners ifTrue: [self useRoundedCorners].	borderWidth _ 2.	self extent: 200@70.	responseUponCancel _ ''.  "Caller can reset this to return something else, e.g. nil, upon cancel"! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'sw 1/31/2000 11:01'!responseUponCancel: anObject	responseUponCancel _ anObject! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'bolot 5/18/2000 13:52'!setPasswordQuery: queryString initialAnswer: initialAnswer answerHeight: answerHeight acceptOnCR: acceptBoolean	response _ initialAnswer.	done _ false.	self removeAllMorphs.	self extent: 200@70.	self addQuery: queryString.	self width: (self width max: self firstSubmorph width + (2 * borderWidth)).	self addLine.	textPane _ PluggableTextMorph on: self		text: #response		accept: #response:		readSelection: #selectionInterval		menu: #codePaneMenu:shifted:.	textPane hasUnacceptedEdits: true.	textPane acceptOnCR: acceptBoolean.	textPane extent: self innerBounds width@answerHeight.	textPane position: self innerBounds left@self lastSubmorph bottom.	textPane font: (StrikeFont passwordFontSize: 12).	self addMorphBack: textPane.	self addLine.	self addButtonRow.	self height: (self height max: (self lastSubmorph bottom - self top) + borderWidth).! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'sw 2/2/2000 22:41'!setQuery: queryString initialAnswer: initialAnswer answerHeight: answerHeight	self setQuery: queryString initialAnswer: initialAnswer answerHeight: answerHeight acceptOnCR: true! !!FillInTheBlankMorph methodsFor: 'initialization' stamp: 'ssa 2/14/2000 13:20'!setQuery: queryString initialAnswer: initialAnswer answerHeight: answerHeight acceptOnCR: acceptBoolean	response _ initialAnswer.	done _ false.	self removeAllMorphs.	self extent: 200@70.	self addQuery: queryString.	self width: (self width max: self firstSubmorph width + (2 * borderWidth)).	self addLine.	textPane _ PluggableTextMorph on: self		text: #response		accept: #response:		readSelection: #selectionInterval		menu: #codePaneMenu:shifted:.	textPane hasUnacceptedEdits: true.	textPane acceptOnCR: acceptBoolean.	textPane extent: self innerBounds width@answerHeight.	textPane position: self innerBounds left@self lastSubmorph bottom.	self addMorphBack: textPane.	self addLine.	self addButtonRow.	self height: (self height max: (self lastSubmorph bottom - self top) + borderWidth).! !!FillInTheBlankMorph methodsFor: 'menu' stamp: 'sw 1/31/2000 11:11'!cancel	"Sent by the cancel button."	response _ responseUponCancel.	done _ true.! !!FillInTheBlankMorph methodsFor: 'invoking' stamp: 'di 12/6/1999 19:42'!getUserResponse	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."	| w |	w _ self world.	w ifNil: [^ response].	done _ false.	[done] whileFalse: [w doOneCycle].	self delete.	w doOneCycle.	^ response! !!FillInTheBlankMorph methodsFor: 'private' stamp: 'jm 6/15/2003 10:28'!addLine	| line |	line _ BorderedMorph new color: Color black;		extent: self width@borderWidth;		position: self left@self lastSubmorph bottom.	self addMorphBack: line.! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'sw 12/21/1998 13:21'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts. Answer the empty string if the user cancels.	This variant is only for calling from within a Morphic project."	"FillInTheBlankMorph		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	 ^ self request: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: World! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'sw 1/31/2000 11:03'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.  Answer the empty string if the user cancels."	"FillInTheBlankMorph		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	^ self request: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld onCancelReturn: ''! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'sw 2/2/2000 22:43'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld onCancelReturn: returnOnCancel	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel.  If user hits cr, treat it as a normal accept."	"FillInTheBlankMorph		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	^ self request: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld onCancelReturn: returnOnCancel acceptOnCR: true! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'sw 2/2/2000 22:34'!request: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel."	"FillInTheBlankMorph		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	| aFillInTheBlankMorph |	aFillInTheBlankMorph _ self new		setQuery: queryString		initialAnswer: defaultAnswer		answerHeight: 50		acceptOnCR: acceptBoolean.	aFillInTheBlankMorph responseUponCancel: returnOnCancel.	aWorld addMorph: aFillInTheBlankMorph centeredNear: aPoint.	^ aFillInTheBlankMorph getUserResponse! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'bolot 5/18/2000 13:57'!requestPassword: queryString	"Create an instance of me whose question is queryString. Invoke it centered at the cursor, and answer the string the user accepts. Answer the empty string if the user cancels."	"use password font"	"FillInTheBlankMorph requestPassword: 'Password?'"	^ self		requestPassword: queryString		initialAnswer: ''		centerAt: Sensor cursorPoint		inWorld: World		onCancelReturn: ''		acceptOnCR: true! !!FillInTheBlankMorph class methodsFor: 'instance creation' stamp: 'bolot 5/18/2000 13:53'!requestPassword: queryString initialAnswer: defaultAnswer centerAt: aPoint inWorld: aWorld onCancelReturn: returnOnCancel acceptOnCR: acceptBoolean	"Create an instance of me whose question is queryString with the given initial answer. Invoke it centered at the given point, and answer the string the user accepts.   If the user cancels, answer returnOnCancel."	"FillInTheBlankMorph		request: 'Type something, then type CR.'		initialAnswer: 'yo ho ho!!'		centerAt: Display center"	| aFillInTheBlankMorph |	aFillInTheBlankMorph _ self new		setPasswordQuery: queryString		initialAnswer: defaultAnswer		answerHeight: 50		acceptOnCR: acceptBoolean.	aFillInTheBlankMorph responseUponCancel: returnOnCancel.	aWorld addMorph: aFillInTheBlankMorph centeredNear: aPoint.	^ aFillInTheBlankMorph getUserResponse! !!FillInTheBlankView class methodsFor: 'instance creation' stamp: 'jdr 6/4/2000 15:03'!requestPassword: aFillInTheBlank message: queryString centerAt: aPoint answerHeight: answerHeight	"Answer an instance of me on aFillInTheBlank asking the question queryString. Allow the reply to be multiple lines, and make the user input view the given height."	| messageView answerView topView myPar pwdFont myArray myStyle |	aFillInTheBlank acceptOnCR: true.	messageView _ DisplayTextView new		model: queryString asDisplayText;		borderWidthLeft: 2 right: 2 top: 2 bottom: 0;		controller: NoController new.	messageView		window: (0@0 extent: (messageView window extent max: 200@30));		centered.	answerView _ self new		model: aFillInTheBlank;		window: (0@0 extent: (messageView window width@answerHeight));		borderWidth: 2.	" now answerView to use the password font"	myPar _ answerView displayContents.	pwdFont _ (StrikeFont passwordFontSize: 12).	myArray _ Array new: 1.	myArray at: 1 put: pwdFont.	myStyle _ TextStyle fontArray: myArray.	myPar setWithText: (myPar text) style: myStyle.	topView _ View new model: aFillInTheBlank.	topView controller: ModalController new.	topView addSubView: messageView.	topView addSubView: answerView below: messageView.	topView align: topView viewport center with: aPoint.	topView window:		(0 @ 0 extent:			(messageView window width) @			  (messageView window height + answerView window height)).	topView translateBy:		(topView displayBox amountToTranslateWithin: Display boundingBox).	^ topView! !I demonstrate how to used the step mechanism to provide a flashing ellipse.!!FlasherMorph methodsFor: 'accessing' stamp: 'jm 6/15/2003 11:54'!color: aColor	"Record my on color."	super color: aColor.	onColor _ aColor.! !!FlasherMorph methodsFor: 'stepping' stamp: 'jm 6/15/2003 11:58'!step	super step.	color = onColor		ifTrue: [super color: (onColor mixed: 0.5 with: Color black)]		ifFalse: [super color: onColor].! !!FlasherMorph methodsFor: 'stepping' stamp: 'jm 6/15/2003 11:57'!stepTime	"Answer the desired time between steps in milliseconds."	^ 500! !!FlasherMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:05'!includeInNewMorphMenu	^ true! !My instances represent IEEE-754 floating-point double-precision numbers.  They have about 16 digits of accuracy and their range is between plus and minus 10^307. Some valid examples are:		8.0 13.3 0.3 2.5e6 1.27e-30 1.27e-31 -12.987654e12Mainly: no embedded blanks, little e for tens power, and a digit on both sides of the decimal point.  It is actually possible to specify a radix for Squeak Float constants.  This is great for teaching about numbers, but may be confusing to the average reader:	3r20.2 --> 6.66666666666667	8r20.2 --> 16.25If you don't have access to the definition of IEEE-754, you can figure out what is going on by printing various simple values in Float hex.  It may help you to know that the basic format is...	sign		1 bit	exponent	11 bits with bias of 1023 (16r3FF) to produce an exponent						in the range -1023 .. +1024				- 16r000:					significand = 0: Float zero					significand ~= 0: Denormalized number (exp = -1024, no hidden '1' bit)				- 16r7FF:					significand = 0: Infinity					significand ~= 0: Not A Number (NaN) representation	mantissa	53 bits, but only 52 are stored (20 in the first word, 32 in the second).  This is because a normalized mantissa, by definition, has a 1 to the right of its floating point, and IEEE-754 omits this redundant bit to gain an extra bit of precision instead.  People talk about the mantissa without its leading one as the FRACTION, and with its leading 1 as the SIGNFICAND.The single-precision format is...	sign		1 bit	exponent	8 bits, with bias of 127, to represent -126 to +127                    - 0x0 and 0xFF reserved for Float zero (mantissa is ignored)                    - 16r7F reserved for Float underflow/overflow (mantissa is ignored)	mantissa	24 bits, but only 23 are storedThis format is used in FloatArray (qv), and much can be learned from the conversion routines, Float asIEEE32BitWord, and Float class fromIEEE32Bit:.Thanks to Rich Harmon for asking many questions and to Tim Olson, Bruce Cohen, Rick Zaccone and others for the answers that I have collected here.!]style[(680 9 1189 21 6 26 149)f1,f1LFloat hex;,f1,f1LFloat asIEEE32BitWord;,f1,f1LFloat class fromIEEE32Bit:;,f1!!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:54'!* aNumber 	"Primitive. Answer the result of multiplying the receiver by aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 49>	^ aNumber adaptToFloat: self andSend: #*! !!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:22'!+ aNumber 	"Primitive. Answer the sum of the receiver and aNumber. Essential.	Fail if the argument is not a Float. See Object documentation	whatIsAPrimitive."	<primitive: 41>	^ aNumber adaptToFloat: self andSend: #+! !!Float methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:55'!- aNumber 	"Primitive. Answer the difference between the receiver and aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 42>	^ aNumber adaptToFloat: self andSend: #-! !!Float methodsFor: 'arithmetic' stamp: 'jm 5/22/2003 19:58'!/ aNumber 	"Primitive. Answer the result of dividing receiver by aNumber.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 50>	aNumber = 0 ifTrue: [^ self error: 'division by 0'].	^ aNumber adaptToFloat: self andSend: #/! !!Float methodsFor: 'mathematical functions' stamp: 'jsp 2/25/1999 11:15'!arcSin	"Answer the angle in radians."	((self < -1.0) or: [self > 1.0]) ifTrue: [self error: 'Value out of range'].	((self = -1.0) or: [self = 1.0])		ifTrue: [^ Halfpi * self]		ifFalse: [^ (self / (1.0 - (self * self)) sqrt) arcTan]! !!Float methodsFor: 'mathematical functions' stamp: 'jsp 3/30/1999 12:38'!arcTan: denominator	"Answer the angle in radians.	 Optional. See Object documentation whatIsAPrimitive."	| result |	(self = 0.0) ifTrue: [ (denominator > 0.0) ifTrue: [ result _ 0 ]										    ifFalse: [ result _ Pi ]						]			    ifFalse: [(denominator = 0.0)					ifTrue: [ (self > 0.0) ifTrue: [ result _ Halfpi ]												ifFalse: [ result _ Halfpi negated ]							]					ifFalse: [ (denominator > 0) ifTrue: [ result _ (self / denominator) arcTan ]								 ifFalse: [ result _ ((self / denominator) arcTan) + Pi ]							].						].		^ result.! !!Float methodsFor: 'mathematical functions' stamp: 'RJ 3/15/1999 19:35'!raisedTo: aNumber	"Answer the receiver raised to aNumber."	aNumber isInteger ifTrue:		["Do the special case of integer power"		^ self raisedToInteger: aNumber].	self < 0.0 ifTrue:		[ self error: self printString, ' raised to a non-integer power' ].	0.0 = aNumber ifTrue: [^ 1.0].				"special case for exponent = 0.0"	(self= 0.0) | (aNumber = 1.0) ifTrue: [^ self].	"special case for self = 1.0"	^ (self ln * aNumber asFloat) exp			"otherwise use logarithms"! !!Float methodsFor: 'mathematical functions' stamp: 'laza 12/21/1999 12:15'!safeArcCos	"Answer the angle in radians."	(self between: -1.0 and: 1.0)		ifTrue: [^ self arcCos]		ifFalse: [^ self sign arcCos]! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:55'!< aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is less than the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 43>	^ aNumber adaptToFloat: self andSend: #<! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:55'!<= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is less than or equal to the argument. Otherwise return	false. Fail if the argument is not a Float. Optional. See Object	documentation whatIsAPrimitive."	<primitive: 45>	^ aNumber adaptToFloat: self andSend: #<=! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:56'!= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is equal to the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 47>	aNumber isNumber ifFalse: [^ false].	^ aNumber adaptToFloat: self andSend: #=! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:57'!> aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is greater than the argument. Otherwise return false.	Fail if the argument is not a Float. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 44>	^ aNumber adaptToFloat: self andSend: #>! !!Float methodsFor: 'comparing' stamp: 'di 11/6/1998 13:57'!>= aNumber 	"Primitive. Compare the receiver with the argument and return true	if the receiver is greater than or equal to the argument. Otherwise return	false. Fail if the argument is not a Float. Optional. See Object documentation 	whatIsAPrimitive. "	<primitive: 46>	^ aNumber adaptToFloat: self andSend: #>! !!Float methodsFor: 'testing' stamp: 'ar 6/9/2000 18:56'!isPowerOfTwo	"Return true if the receiver is an integral power of two.	Floats never return true here."	^false! !!Float methodsFor: 'testing'!isZero	^self = 0.0! !!Float methodsFor: 'truncation and round off' stamp: 'di 7/1/1998 23:01'!truncated	"Answer with a SmallInteger equal to the value of the receiver without 	its fractional part. The primitive fails if the truncated value cannot be 	represented as a SmallInteger. In that case, the code below will compute 	a LargeInteger truncated value.	Essential. See Object documentation whatIsAPrimitive. "	<primitive: 51>	(self isInfinite or: [self isNaN]) ifTrue: [self error: 'Cannot truncate this number'].	self abs < 2.0e16		ifTrue: ["Fastest way when it may not be an integer"				^ (self quo: 1073741823.0) * 1073741823 + (self rem: 1073741823.0) truncated]		ifFalse: [^ self asTrueFraction.  "Extract all bits of the mantissa and shift if necess"]! !!Float methodsFor: 'converting' stamp: 'di 11/6/1998 13:38'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert it to a Float."	^ rcvr asFloat perform: selector with: self! !!Float methodsFor: 'converting' stamp: 'di 11/6/1998 13:07'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Float."	^ rcvr asFloat perform: selector with: self! !!Float methodsFor: 'converting' stamp: 'sma 5/3/2000 21:46'!asFraction	^ self asTrueFraction ! !!Float methodsFor: 'converting' stamp: 'di 2/8/1999 12:51'!asIEEE32BitWord	"Convert the receiver into a 32 bit Integer value representing the same number in IEEE 32 bit format. Used for conversion in FloatArrays only."	| word1 word2 sign mantissa exponent destWord |	self = 0.0 ifTrue:[^0].	word1 _ self basicAt: 1.	word2 _ self basicAt: 2.	mantissa _ (word2 bitShift: -29) + ((word1 bitAnd:  16rFFFFF) bitShift: 3).	exponent _ ((word1 bitShift: -20) bitAnd: 16r7FF) - 1023 + 127.	exponent < 0 ifTrue:[^0]. "Underflow"	exponent > 254 ifTrue:["Overflow"		exponent _ 255.		mantissa _ 0].	sign _ word1 bitAnd: 16r80000000.	destWord _ (sign bitOr: (exponent bitShift: 23)) bitOr: mantissa.	^ destWord! !!Float methodsFor: 'converting' stamp: 'di 7/1/1998 22:20'!asTrueFraction	" Answer a fraction that EXACTLY represents self,	  a double precision IEEE floating point number.	  Floats are stored in the same form on all platforms.	  (Does not handle gradual underflow or NANs.)	  By David N. Smith with significant performance	  improvements by Luciano Esteban Notarfrancesco.	  (Version of 11April97)"	| shifty sign expPart exp fraction fractionPart result zeroBitsCount |	self isInfinite ifTrue: [self error: 'Cannot represent infinity as a fraction'].	self isNaN ifTrue: [self error: 'Cannot represent Not-a-Number as a fraction'].	" Extract the bits of an IEEE double float "	shifty := ((self basicAt: 1) bitShift: 32) + (self basicAt: 2).	" Extract the sign and the biased exponent "	sign := (shifty bitShift: -63) = 0 ifTrue: [1] ifFalse: [-1].	expPart := (shifty bitShift: -52) bitAnd: 16r7FF.	" Extract fractional part; answer 0 if this is a true 0.0 value "	fractionPart := shifty bitAnd:  16r000FFFFFFFFFFFFF.	( expPart=0 and: [ fractionPart=0 ] ) ifTrue: [ ^ 0  ].	" Replace omitted leading 1 in fraction "	fraction := fractionPart bitOr: 16r0010000000000000.	"Unbias exponent: 16r3FF is bias; 52 is fraction width"	exp := 16r3FF + 52 - expPart.	" Form the result. When exp>52, the exponent is adjusted by	  the number of trailing zero bits in the fraction to minimize	  the (huge) time otherwise spent in #gcd:. "	exp negative		ifTrue: [			result := sign * fraction bitShift: exp negated ]		ifFalse:	[			zeroBitsCount _ fraction lowBit - 1.			exp := exp - zeroBitsCount.			exp <= 0				ifTrue: [					zeroBitsCount := zeroBitsCount + exp.					"exp := 0."   " Not needed; exp notrefernced again "					result := sign * fraction bitShift:zeroBitsCount negated ]				ifFalse: [					result := Fraction						numerator: (sign * fractionbitShift: zeroBitsCount negated)						denominator: (1 bitShift:exp) ] ].	"Low cost validation omitted after extensive testing"	"(result asFloat = self) ifFalse: [self error: 'asTrueFraction validation failed']."	^ result ! !!Float methodsFor: 'private' stamp: 'ls 10/10/1999 11:55'!absPrintOn: aStream base: base digitCount: digitCount 	"Print me in the given base, using digitCount significant figures."	| fuzz x exp q fBase scale logScale xi |	self isInf ifTrue: [^ aStream nextPutAll: 'Inf'].	fBase _ base asFloat.	"x is myself normalized to [1.0, fBase), exp is my exponent"	exp _ 		self < 1.0			ifTrue: [self reciprocalFloorLog: fBase]			ifFalse: [self floorLog: fBase].	scale _ 1.0.	logScale _ 0.	[(x _ fBase raisedTo: (exp + logScale)) = 0]		whileTrue:			[scale _ scale * fBase.			logScale _ logScale + 1].	x _ self * scale / x.	fuzz _ fBase raisedTo: 1 - digitCount.	"round the last digit to be printed"	x _ 0.5 * fuzz + x.	x >= fBase		ifTrue: 			["check if rounding has unnormalized x"			x _ x / fBase.			exp _ exp + 1].	(exp < 6 and: [exp > -4])		ifTrue: 			["decimal notation"			q _ 0.			exp < 0 ifTrue: [1 to: 1 - exp do: [:i | aStream nextPut: ('0.0000'at: i)]]]		ifFalse: 			["scientific notation"			q _ exp.			exp _ 0].	[x >= fuzz]		whileTrue: 			["use fuzz to track significance"			xi _ x asInteger.			aStream nextPut: (Character digitValue: xi).			x _ x - xi asFloat * fBase.			fuzz _ fuzz * fBase.			exp _ exp - 1.			exp = -1 ifTrue: [aStream nextPut: $.]].	[exp >= -1]		whileTrue: 			[aStream nextPut: $0.			exp _ exp - 1.			exp = -1 ifTrue: [aStream nextPut: $.]].	q ~= 0		ifTrue: 			[aStream nextPut: $e.			q printOn: aStream]! !!Float class methodsFor: 'instance creation' stamp: 'di 2/8/1999 12:58'!fromIEEE32Bit: word	"Convert the given 32 bit word (which is supposed to be a positive 32bit value) from a 32bit IEEE floating point representation into an actual Squeak float object (being 64bit wide). Should only be used for conversion in FloatArrays or likewise objects."	| sign mantissa exponent newFloat |	word negative ifTrue: [^ self error:'Cannot deal with negative numbers'].	word = 0 ifTrue:[^ 0.0].	mantissa _ word bitAnd:  16r7FFFFF.	exponent _ ((word bitShift: -23) bitAnd: 16rFF) - 127.	sign _ word bitAnd: 16r80000000.	exponent = 128 ifTrue:["Either NAN or INF"		mantissa = 0 ifFalse:[^ Float nan].		sign = 0 			ifTrue:[^ Float infinity]			ifFalse:[^ Float infinity negated]].	"Create new float"	newFloat _ self new: 2.	newFloat basicAt: 1 put: ((sign bitOr: (1023 + exponent bitShift: 20)) bitOr: (mantissa bitShift: -3)).	newFloat basicAt: 2 put: ((mantissa bitAnd: 7) bitShift: 29).	^newFloat! !!Float class methodsFor: 'constants' stamp: 'sw 10/8/1999 22:59'!halfPi	^ Halfpi! !FloatArrays store 32bit IEEE floating point numbers.!!FloatArray methodsFor: 'accessing' stamp: 'ar 1/22/1999 19:52'!at: index	<primitive: 'primitiveFloatArrayAt'>	^Float fromIEEE32Bit: (self basicAt: index)! !!FloatArray methodsFor: 'accessing' stamp: 'ar 2/4/1999 17:05'!at: index put: value	<primitive: 'primitiveFloatArrayAtPut'>	value isFloat 		ifTrue:[self basicAt: index put: value asIEEE32BitWord]		ifFalse:[self at: index put: value asFloat].	^value! !!FloatArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0.0! !!FloatArray methodsFor: 'accessing' stamp: 'laza 3/24/2000 13:08'!length	"Return the length of the receiver"	^self squaredLength sqrt! !!FloatArray methodsFor: 'accessing' stamp: 'laza 3/24/2000 13:08'!squaredLength	"Return the squared length of the receiver"	^self dot: self! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:33'!* anObject	^self clone *= anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:49'!*= anObject	^anObject isNumber		ifTrue:[self primMulScalar: anObject asFloat]		ifFalse:[self primMulArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:33'!+ anObject	^self clone += anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:48'!+= anObject	^anObject isNumber		ifTrue:[self primAddScalar: anObject asFloat]		ifFalse:[self primAddArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:33'!- anObject	^self clone -= anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:49'!-= anObject	^anObject isNumber		ifTrue:[self primSubScalar: anObject asFloat]		ifFalse:[self primSubArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 9/14/1998 22:34'!/ anObject	^self clone /= anObject! !!FloatArray methodsFor: 'arithmetic' stamp: 'ar 10/7/1998 19:58'!/= anObject	^anObject isNumber		ifTrue:[self primDivScalar: anObject asFloat]		ifFalse:[self primDivArray: anObject]! !!FloatArray methodsFor: 'arithmetic' stamp: 'laza 3/24/2000 13:07'!dot: aFloatVector	"Primitive. Return the dot product of the receiver and the argument.	Fail if the argument is not of the same size as the receiver."	| result |	"<primitive:'primitiveFloatArrayDotProduct'>"	self size = aFloatVector size ifFalse:[^self error:'Must be equal size'].	result _ 0.0.	1 to: self size do:[:i|		result _ result + ((self at: i) * (aFloatVector at: i)).	].	^result! !!FloatArray methodsFor: 'comparing' stamp: 'bf 8/20/1999 12:49'!= aFloatArray 	| length |	<primitive: 'primitiveFloatArrayEqual'>	aFloatArray class = self class ifFalse: [^ false].	length _ self size.	length = aFloatArray size ifFalse: [^ false].	1 to: self size do: [:i | (self at: i)			= (aFloatArray at: i) ifFalse: [^ false]].	^ true! !!FloatArray methodsFor: 'comparing' stamp: 'ar 9/15/1998 01:14'!hash	| result |	<primitive:'primitiveFloatArrayHash'>	result _ 0.	1 to: self size do:[:i| result _ result + (self basicAt: i) ].	^result bitAnd: 16r1FFFFFFF! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/11/1998 03:10'!primAddArray: floatArray	<primitive: 'primitiveFloatArrayAddFloatArray'>	1 to: self size do:[:i| self at: i put: (self at: i) + (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/10/1998 21:46'!primAddScalar: scalarValue	<primitive: 'primitiveFloatArrayAddScalar'>	1 to: self size do:[:i| self at: i put: (self at: i) + scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/7/1998 20:00'!primDivArray: floatArray	<primitive: 'primitiveFloatArrayDivFloatArray'>	1 to: self size do:[:i| self at: i put: (self at: i) / (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/10/1998 21:46'!primDivScalar: scalarValue	<primitive: 'primitiveFloatArrayDivScalar'>	1 to: self size do:[:i| self at: i put: (self at: i) / scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/7/1998 20:00'!primMulArray: floatArray	<primitive: 'primitiveFloatArrayMulFloatArray'>	1 to: self size do:[:i| self at: i put: (self at: i) * (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/10/1998 21:47'!primMulScalar: scalarValue	<primitive: 'primitiveFloatArrayMulScalar'>	1 to: self size do:[:i| self at: i put: (self at: i) * scalarValue].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/7/1998 20:01'!primSubArray: floatArray	<primitive: 'primitiveFloatArraySubFloatArray'>	1 to: self size do:[:i| self at: i put: (self at: i) - (floatArray at: i)].! !!FloatArray methodsFor: 'primitives-plugin' stamp: 'ar 10/10/1998 21:47'!primSubScalar: scalarValue	<primitive: 'primitiveFloatArraySubScalar'>	1 to: self size do:[:i| self at: i put: (self at: i) - scalarValue].! !!FloatArray methodsFor: 'converting' stamp: 'ar 9/14/1998 23:46'!asFloatArray	^self! !!FloatArray methodsFor: 'private' stamp: 'ar 10/9/1998 11:27'!replaceFrom: start to: stop with: replacement startingAt: repStart 	"Primitive. This destructively replaces elements from start to stop in the receiver starting at index, repStart, in the collection, replacement. Answer the receiver. Range checks are performed in the primitive only. Optional. See Object documentation whatIsAPrimitive."	<primitive: 105>	super replaceFrom: start to: stop with: replacement startingAt: repStart! !!FloatArray methodsFor: 'user interface' stamp: 'ar 2/13/1999 21:33'!inspect	"Open a OrderedCollectionInspector on the receiver.  Use basicInspect to get a normal (less useful) type of inspector."	OrderedCollectionInspector openOn: self withEvalPane: true! !!FloatArray methodsFor: 'user interface' stamp: 'ar 2/13/1999 21:33'!inspectWithLabel: aLabel	"Open a OrderedCollectionInspector on the receiver. Use basicInspect to get a normal (less useful) type of inspector."	OrderedCollectionInspector openOn: self withEvalPane: true withLabel: aLabel! !This class allows you to extract any font from a screen shot of it.Here's the process:For best results, turn off font anti-aliasing or set your Display depth to one-bit. Then create the text file 'strike.txt' by doing:	FontExtractor writeStrikeFileOpen that file in text editor that allows you to set the font and set the font to the desired font, style, and size. Make a screen shot of this file and store it in a graphics format readable by Squeak, such as BMP, PNG, or GIF (but NOT JPEG). Now process that font by doing:	font _ FontExtractor extractFontFrom: 'yourFileName'You will be prompted to select the rectangle containing the letters of the font. Leave a bit of white space around the letters, but don't select the window borders or anything outside of the window containing the font. Once you've done this, Squeak will do the rest.You may want to add the font to the TextStyles dictionary by doing:!!FontExtractor methodsFor: 'as yet unclassified' stamp: 'jm 5/12/2003 15:35'!ascentFromPixCounts: pixCountArray	"Answer the ascent of a font line from the given array of (<y>, <pixCount>) pairs. The ascent is the number of pixel lines from the top of the tallest glyph to the baseline, inclusive. The descent can be computed by subtracting the height from pixCountArray size."	"Details: The baseline is detected by scanning up from the bottom to find the first horizontal line with at least half the number of black pixels as the maximum number of pixels. While this heuristic usually works for alphanumeric fonts, it wouldn't necessarily work for fonts of symbols or icons."	| totalH maxPixPerLine |	totalH _ pixCountArray size.	maxPixPerLine _ pixCountArray inject: 0 into: [:m :pair | m max: pair last].	^ (totalH to: 1 by: -1)		detect: [:i | (pixCountArray at: i) last > (maxPixPerLine // 2)]		ifNone: [totalH // 2]! !!FontExtractor methodsFor: 'as yet unclassified' stamp: 'jm 5/10/2003 09:48'!computeMetricsFrom: aForm	"Compute the width of a space character. Also compute the pixel offset from the right edge of a period to the edge of the next character from the given line form (typically the first line of the strike file). These metrics are used to extract the characters from subsequent lines."	"Details: The first line contains four printing characters intermixed with space characters:		.<space>.<space><space>.<space>x	The difference in spacing between the first/second and second/third periods gives the width of a space character. The space between the last period and the start of the 'x' is the character start offset."	| glyphPairs d1 |	spaceWidth _ 0.	glyphPairs _ self glyphStartsAndStopsFrom: aForm.	glyphPairs size = 4 ifFalse: [self error: 'implementation problem'].	d1 _ (glyphPairs at: 2) first - ((glyphPairs at: 1) last + 1).	basePix _ (glyphPairs at: 3) first - ((glyphPairs at: 2) last + 1).	spaceWidth _ basePix - d1.	charOffset _ (glyphPairs at: 4) first - ((glyphPairs at: 3) last + 1).! !!FontExtractor methodsFor: 'as yet unclassified' stamp: 'jm 5/12/2003 15:55'!extractFontFrom: aForm	"Answer a StrikeFont for the font extracted from the given Form."	"FontExtractor new extractFontFrom: (Form fromFileNamed: 'Palatino24.gif')"	strikeForm _ Form extent: aForm extent depth: 1.	strikeForm copy: strikeForm boundingBox from: 0@0 in: aForm rule: Form over.	self extractLines.	self computeMetricsFrom: lineForms first.	^ (2 to: lineForms size) collect: [:i | self letterWidthsForLine: i]! !!FontExtractor methodsFor: 'as yet unclassified' stamp: 'jm 5/4/2003 17:17'!extractLettersFromLine: aForm	| w h tallies letters inRun startX |	w _ aForm width.	h _ aForm height.	tallies _ Bitmap new: 2.	letters _ OrderedCollection new.	inRun _ false.	startX _ 0.	0 to: w - 1 do: [:x |		tallies at: 2 put: 0.		aForm tallyPixelValuesInRect: (x@0 extent: 1@h) into: tallies.		inRun			ifTrue: [				(tallies at: 2) = 0 ifTrue: [					letters addLast: (aForm copy: (startX@0 corner: x@h)).					inRun _ false]]			ifFalse: [				(tallies at: 2) > 0 ifTrue: [					startX _ x.					inRun _ true]]].	inRun ifTrue: [		letters addLast: (aForm copy: (startX@0 corner: w@h))].	^ letters asArray! !!FontExtractor methodsFor: 'as yet unclassified' stamp: 'jm 5/12/2003 15:48'!extractLines	"Set my lineForms to an array of Forms, one for each line of characters in my strikeForm."	| linePixCounts ascents descents startY |	linePixCounts _ self extractPixCountsForLines.	ascents _ linePixCounts collect: [:line | self ascentFromPixCounts: line].	descents _ linePixCounts collect: [:line | line size - (self ascentFromPixCounts: line)].	fontAscent _ ascents max.	fontHeight _ fontAscent + descents max.	lineForms _ (1 to: linePixCounts size) collect: [:i |		startY _ (linePixCounts at: i) first first - (fontAscent - (ascents at: i)).		strikeForm copy: (0@startY extent: strikeForm width@fontHeight)]! !!FontExtractor methodsFor: 'as yet unclassified' stamp: 'jm 5/12/2003 15:39'!extractPixCountsForLines	"Answer an array line arrays. Each line array is a sequence of (y, pixCount) pairs for one pixel row within the line of characters."	"Details: Several scan lines containing only white pixels is taken to be an inter-line space. Small fonts may need to be double-spaced to ensure there are is enough white space between lines."	| w h tallies lines inRun pixCount thisLine endOfLastLine |	w _ strikeForm width.	h _ strikeForm height.	tallies _ Bitmap new: 2.	lines _ OrderedCollection new.	endOfLastLine _ -100.	inRun _ false.	0 to: h - 1 do: [:y |		tallies at: 2 put: 0.		strikeForm tallyPixelValuesInRect: (0@y extent: w@1) into: tallies.		pixCount _ tallies at: 2.		inRun ifFalse: [			pixCount > 0 ifTrue: [				(y - endOfLastLine) <= 3  "in large fonts, there can be a few pixels between capital letters and their accents"					ifTrue: [thisLine _ lines removeLast asOrderedCollection]					ifFalse: [thisLine _ OrderedCollection new].				inRun _ true]].		inRun ifTrue: [				pixCount = 0					ifTrue: [						endOfLastLine _ y.						lines addLast: thisLine asArray.						inRun _ false]					ifFalse: [						thisLine addLast: (Array with: y with: pixCount)]]].	inRun ifTrue: [self error: 'final line must be all white space'].	^ lines asArray! !!FontExtractor methodsFor: 'as yet unclassified' stamp: 'jm 5/10/2003 09:48'!glyphStartsAndStopsFrom: lineForm	"Answer an array of (startX, endX) runs for the glyphs in the given Form."	| w h tallies runs endOfLastGlyph inRun pixCount thisRun |	w _ lineForm width.	h _ lineForm height.	tallies _ Bitmap new: 2.	runs _ OrderedCollection new.	endOfLastGlyph _ -100.	inRun _ false.	0 to: w - 1 do: [:x |		tallies at: 2 put: 0.		lineForm tallyPixelValuesInRect: (x@0 extent: 1@h) into: tallies.		pixCount _ tallies at: 2.		(inRun not and: [pixCount > 0]) ifTrue: [ "start a new run or extend the last run"			(x - endOfLastGlyph) < spaceWidth  "some chars, such as double-quote, include a gap of a few pixels"				ifTrue: [thisRun _ runs removeLast]  "extend the last run"				ifFalse: [thisRun _ Array with: x with: 0].			inRun _ true].		(inRun and: [pixCount = 0]) ifTrue: [  "end the current run"			thisRun at: 2 put: x - 1.			endOfLastGlyph _ x - 1.			runs addLast: thisRun.			inRun _ false]].	inRun ifTrue: [self error: 'line must end with white space'].	^ runs asArray! !!FontExtractor methodsFor: 'as yet unclassified' stamp: 'jm 5/10/2003 10:00'!letterWidthsForLine: lineIndex	| startsAndStops totalW |	startsAndStops _ self glyphStartsAndStopsFrom: (lineForms at: lineIndex).	^ (1 to: startsAndStops size - 2 by: 2) collect: [:i |		totalW _ (startsAndStops at: i + 2) first - ((startsAndStops at: i) + 1) first.		totalW - basePix]! !!FontExtractor class methodsFor: 'as yet unclassified' stamp: 'jm 5/7/2003 09:47'!writeStrikeFile	"FontExtractor writeStrikeFile"	| f |	f _ (FileStream newFileNamed: 'strike.txt') binary.	f nextPutAll: ' . .  . x', String crlf, String crlf.	33 to: 255 do: [:ch |		(ch \\ 16) = 0 ifTrue: [f nextPutAll: ' . ', String crlf, String crlf].		f nextPutAll: ' . '.		f nextPut: ch].	f nextPutAll: ' . ', String crlf, String crlf.	f close.! !A rectangular array of pixels, used for holding images.  All pictures, including character images are Forms.  The depth of a Form is how many bits are used to specify the color at each pixel.  The actual bits are held in a Bitmap, whose internal structure is different at each depth.  Class Color allows you to deal with colors without knowing how they are actually encoded inside a Bitmap.	  The supported depths (in bits) are 1, 2, 4, 8, 16, and 32.  The number of actual colors at these depths are: 2, 4, 16, 256, 32768, and 16 million.	Forms are combined using BitBlt.  See the comment in class BitBlt.  Forms that are have both transparent and opapue areas are MaskedForms.  Forms that repeat many times to fill a large destination are InfiniteForms.	colorAt: x@y		Returns the abstract color at this location	displayAt: x@y		shows this form on the screen	displayOn: aMedium at: x@y	shows this form in a Window, a Form, or other DisplayMedium	fillColor: aColor		Set all the pixels to the color.	edit		launch an editor to change the bits of this form.	pixelValueAt: x@y	The encoded color.  Depends on the depth.!!Form methodsFor: 'initialize-release' stamp: 'ar 5/28/2000 16:00'!allocateForm: extentPoint	"Allocate a new form which is similar to the receiver and can be used for accelerated blts"	^Form extent: extentPoint depth: self depth! !!Form methodsFor: 'accessing' stamp: 'jm 6/15/2003 18:26'!boundingBox	^ Rectangle origin: 0@0 corner: width@height! !!Form methodsFor: 'accessing' stamp: 'jm 6/15/2003 18:47'!computeBoundingBox	"Note: Clients usually send boundingBox rather than this message."	^ Rectangle origin: 0@0 corner: width@height! !!Form methodsFor: 'accessing' stamp: 'jm 11/24/2002 10:48'!getCanvas	"Return a Canvas for drawing on the receiver."	^ FormCanvas on: self! !!Form methodsFor: 'accessing' stamp: 'ar 2/16/2000 22:00'!offset	^offset ifNil:[0@0]! !!Form methodsFor: 'copying' stamp: 'jm 5/29/2003 17:58'!copy: destRectangle from: sourcePt in: sourceForm rule: rule 	"Make up a BitBlt table and copy the bits."	(BitBlt toForm: self)		copy: destRectangle		from: sourcePt in: sourceForm		fillColor: nil rule: rule! !!Form methodsFor: 'displaying' stamp: 'jm 6/15/2003 18:29'!copyBits: sourceForm at: destOrigin translucent: factor	"Make up a BitBlt table and copy the bits with the given colorMap."	(BitBlt 		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: 30		destOrigin: destOrigin		sourceOrigin: 0@0		extent: sourceForm extent		clipRect: self boundingBox)		copyBitsTranslucent: ((0 max: (factor*255.0) asInteger) min: 255)" | f f2 f3 | f _ Form fromUser. f2 _ Form fromDisplay: (0@0 extent: f extent). f3 _ f2 deepCopy.0.0 to: 1.0 by: 1.0/32 do:	[:t | f3 _ f2 deepCopy. f3 copyBits: f at: 0@0 translucent: t.	f3 displayAt: 0@0. (Delay forMilliseconds: 50) wait]."! !!Form methodsFor: 'displaying' stamp: 'jm 5/25/2003 11:48'!copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aColor 	"Copy the given rectangular area from sourceForm into myself at the given destination point using the given combination rule and fill color."	(BitBlt 		destForm: self		sourceForm: sourceForm		fillColor: aColor		combinationRule: rule		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: clipRect) copyBits.! !!Form methodsFor: 'displaying' stamp: 'jm 5/29/2003 17:58'!copyBits: sourceRect from: sourceForm at: destOrigin clippingBox: clipRect rule: rule fillColor: aForm map: map	"Make up a BitBlt table and copy the bits.  Use a colorMap."	((BitBlt 		destForm: self		sourceForm: sourceForm		fillColor: aForm		combinationRule: rule		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: clipRect) colorMap: map) copyBits! !!Form methodsFor: 'displaying' stamp: 'jm 5/29/2003 17:58'!copyBits: sourceRect from: sourceForm at: destOrigin colorMap: map 	"Make up a BitBlt table and copy the bits with the given colorMap."	((BitBlt 		destForm: self		sourceForm: sourceForm		halftoneForm: nil		combinationRule: Form over		destOrigin: destOrigin		sourceOrigin: sourceRect origin		extent: sourceRect extent		clipRect: self boundingBox) colorMap: map) copyBits! !!Form methodsFor: 'bordering'!border: aRectangle width: borderWidth	"Paint a border whose rectangular area is defined by aRectangle. The	width of the border of each side is borderWidth. Uses black for	drawing the border."	self border: aRectangle width: borderWidth fillColor: Color black.! !!Form methodsFor: 'bordering'!border: aRectangle width: borderWidth fillColor: aColor	"Paint a border whose rectangular area is defined by aRectangle. The width of the border of each side is borderWidth. Uses aColor for drawing the border."	self border: aRectangle		widthRectangle:			(Rectangle				left: borderWidth				right: borderWidth				top: borderWidth				bottom: borderWidth)		rule: Form over		fillColor: aColor.! !!Form methodsFor: 'bordering' stamp: 'jm 5/29/2003 17:58'!border: rect width: borderWidth rule: rule fillColor: fillColor        "Paint a fillColor colored border whose rectangular area is defined by rect. The width of the border of each side is borderWidth."	| blt |	blt _ (BitBlt toForm: self)		combinationRule: rule;		fillColor: fillColor;		sourceOrigin: 0@0;		destOrigin: rect origin.	blt width: rect width; height: borderWidth; copyBits.	blt destY: rect corner y - borderWidth; copyBits.	blt		destY: rect origin y + borderWidth;		width: borderWidth;		height: rect height - borderWidth - borderWidth;		copyBits.	blt destX: rect corner x - borderWidth; copyBits.! !!Form methodsFor: 'bordering'!border: aRectangle widthRectangle: insets rule: combinationRule fillColor: aColor	"Paint a border whose rectangular area is defined by aRectangle. The width of each edge of the border is determined by the four coordinates of insets. Uses aColor and combinationRule for drawing the border."	(aRectangle areasOutside: (aRectangle insetBy: insets)) do:		[:edgeStrip | self fill: edgeStrip rule: combinationRule fillColor: aColor].! !!Form methodsFor: 'bordering' stamp: 'jm 5/29/2003 18:06'!borderFormOfWidth: borderWidth sharpCorners: sharpen	"Smear this form around and then subtract the original to produce	an outline.  If sharpen is true, then cause right angles to be outlined	by right angles (takes an additional diagonal smears ANDed with both	horizontal and vertical smears)."	| smearForm bigForm smearPort all cornerForm cornerPort nbrs |	depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	bigForm _ self deepCopy.	all _ bigForm boundingBox.	smearForm _ Form extent: self extent.	smearPort _ BitBlt toForm: smearForm.	sharpen ifTrue:		[cornerForm _ Form extent: self extent.		cornerPort _ BitBlt toForm: cornerForm].	nbrs _ (0@0) fourNeighbors.	1 to: borderWidth do:		[:i |  "Iterate to get several layers of 'skin'"		nbrs do:			[:d |  "Smear the self in 4 directions to grow each layer of skin"			smearPort copyForm: bigForm to: d rule: Form under].		sharpen ifTrue:			["Special treatment to smear sharp corners"			nbrs with: ((2 to: 5) collect: [:i2 | nbrs atWrap: i2]) do:				[:d1 :d2 |				"Copy corner points diagonally"				cornerPort copyForm: bigForm to: d1+d2 rule: Form over.				"But only preserve if there were dots on either side"				cornerPort copyForm: bigForm to: d1+d1+d2 rule: Form and.				cornerPort copyForm: bigForm to: d1+d2+d2 rule: Form and.				smearPort copyForm: cornerForm to: 0@0 rule: Form under].			].		bigForm copy: all from: 0@0 in: smearForm rule: Form over.		].	"Now erase the original shape to obtain the outline"	bigForm copy: all from: 0@0 in: self rule: Form erase.	^ bigForm! !!Form methodsFor: 'filling' stamp: 'di 2/19/1999 07:07'!anyShapeFill	"Fill the interior of the outermost outlined region in the receiver, a 1-bit deep form.  Typically the resulting form is used with fillShape:fillColor: to paint a solid color.  See also convexShapeFill:"	| shape |	"Draw a seed line around the edge and fill inward from the outside."	shape _ self findShapeAroundSeedBlock: [:f | f borderWidth: 1].	"Reverse so that this becomes solid in the middle"	shape _ shape reverse.	"Finally erase any bits from the original so the fill is only elsewhere"	shape copy: shape boundingBox from: self to: 0@0 rule: Form erase.	^ shape! !!Form methodsFor: 'filling' stamp: 'di 9/11/1998 16:25'!convexShapeFill: aMask 	"Fill the interior of the outtermost outlined region in the receiver.  The outlined region must not be concave by more than 90 degrees.  Typically aMask is Color black, to produce a solid fill. then the resulting form is used with fillShape: to paint a solid color.  See also anyShapeFill"	| destForm tempForm |	destForm _ Form extent: self extent.  destForm fillBlack.	tempForm _ Form extent: self extent.	(0@0) fourNeighbors do:		[:dir |  "Smear self in all 4 directions, and AND the result"		self displayOn: tempForm at: (0@0) - self offset.		tempForm smear: dir distance: (dir dotProduct: tempForm extent) abs.		tempForm displayOn: destForm at: 0@0			clippingBox: destForm boundingBox			rule: Form and fillColor: nil].	destForm displayOn: self at: 0@0		clippingBox: self boundingBox		rule: Form over fillColor: aMask! !!Form methodsFor: 'filling'!fill: aRectangle fillColor: aColor	"Fill the given rectangular area of the receiver with the given color."	self fill: aRectangle rule: Form over fillColor: aColor.! !!Form methodsFor: 'filling' stamp: 'jm 5/25/2003 11:47'!fill: aRectangle rule: anInteger fillColor: aForm 	"Fill a rectangular area of the receiver with the given color and combination rule."	(BitBlt toForm: self)		copy: aRectangle		from: 0@0 in: nil		fillColor: aForm rule: anInteger.! !!Form methodsFor: 'filling'!fillBlack	"Fill the entire receiver with black."	self fill: self boundingBox rule: Form over fillColor: Color black.! !!Form methodsFor: 'filling'!fillBlack: aRectangle	"Fill the given rectangular area of the receiver with black."	self fill: aRectangle rule: Form over fillColor: Color black.! !!Form methodsFor: 'filling'!fillColor: aColor	"Fill the entire receiver with the given color."	self fill: self boundingBox rule: Form over fillColor: aColor.! !!Form methodsFor: 'filling' stamp: 'jm 5/29/2003 17:59'!fillFromXYColorBlock: colorBlock	"General Gradient Fill.	Supply relative x and y in [0.0 ... 1.0] to colorBlock,	and paint each pixel with the color that comes back"	| poker yRel xRel |	poker _ BitBlt bitPokerToForm: self.	0 to: height-1 do:		[:y | yRel _ y asFloat / (height-1) asFloat.		0 to: width-1 do:			[:x |  xRel _ x asFloat / (width-1) asFloat.			poker pixelAt: x@y				put: ((colorBlock value: xRel value: yRel) pixelWordForDepth: depth)]]" | d |((Form extent: 100@20 depth: Display depth)	fillFromXYColorBlock:	[:x :y | d _ 1.0 - (x - 0.5) abs - (y - 0.5) abs.	Color r: d g: 0 b: 1.0-d]) display"! !!Form methodsFor: 'filling' stamp: 'ee 10/25/2003 13:41'!fillFromYColorBlock: colorBlock	"Vertical Gradient Fill. Supply relative y in [0.0 ... 1.0] to colorBlock, and paint each pixel with the color that comes back."	| yRel |	0 to: height-1 do: [:y |		height = 1			ifTrue: [yRel _ y asFloat / 1 asFloat]			ifFalse: [yRel _ y asFloat / (height-1) asFloat].		self fill: (0@y extent: width@1) 			fillColor: (colorBlock value: yRel)]"((Form extent: 100@100 depth: Display depth)	fillFromYColorBlock: [:y | Color r: y g: 0.0 b: 0.5]) display"! !!Form methodsFor: 'filling' stamp: 'ee 7/28/2003 15:02'!fillRadialFromXColorBlock: colorBlock center: aPoint	"Horizontal Gradient Fill.	Supply relative x in [0.0 ... 1.0] to colorBlock,	and paint each pixel with the color that comes back"	| canvas t xRel m |	m _ (width max: height).	canvas _ self getCanvas.	self fill: (self boundingBox) fillColor: (colorBlock value: 1).	((m-1) negated) to: 0 do:		[:x |		t _ x abs.  		xRel _ t asFloat / (m-1) asFloat.		canvas frameOval: (Rectangle center: aPoint extent: (t@t))		color: (colorBlock value: xRel)].! !!Form methodsFor: 'filling'!fillShape: aShapeForm fillColor: aColor	"Fill a region corresponding to 1 bits in aShapeForm with the given color."	^ self fillShape: aShapeForm fillColor: aColor at: 0@0.! !!Form methodsFor: 'filling' stamp: 'jm 5/29/2003 17:59'!fillShape: aShapeForm fillColor: aColor at: location	"Fill a region corresponding to 1 bits in aShapeForm with the given color."	((BitBlt destForm: self sourceForm: aShapeForm fillColor: aColor		combinationRule: Form paint		destOrigin: location + aShapeForm offset sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))		copyBits.! !!Form methodsFor: 'filling'!fillWhite	"Fill the entire receiver with white."	self fill: self boundingBox fillColor: Color white.! !!Form methodsFor: 'filling'!fillWhite: aRectangle	"Fill the given rectangular area of the receiver with white."	self fill: aRectangle rule: Form over fillColor: Color white.! !!Form methodsFor: 'filling' stamp: 'jm 5/29/2003 17:59'!findShapeAroundSeedBlock: seedBlock	"Build a shape that is black in any region marked by seedBlock. 	SeedBlock will be supplied a form, in which to blacken various	pixels as 'seeds'.  Then the seeds are smeared until 	there is no change in the smear when it fills the region, ie,	when smearing hits a black border and thus goes no further."	| smearForm previousSmear all count smearPort |	depth > 1 ifTrue: [self halt]. "Only meaningful for B/W forms."	all _ self boundingBox.	smearForm _ Form extent: self extent.	smearPort _ BitBlt toForm: smearForm.	seedBlock value: smearForm.		"Blacken seeds to be smeared"	smearPort copyForm: self to: 0@0 rule: Form erase.  "Clear any in black"	previousSmear _ smearForm deepCopy.	count _ 1.	[count = 10 and:   "check for no change every 10 smears"		[count _ 1.		previousSmear copy: all from: 0@0 in: smearForm rule: Form reverse.		previousSmear isAllWhite]]		whileFalse: 			[smearPort copyForm: smearForm to: 1@0 rule: Form under.			smearPort copyForm: smearForm to: -1@0 rule: Form under.			"After horiz smear, trim around the region border"			smearPort copyForm: self to: 0@0 rule: Form erase.			smearPort copyForm: smearForm to: 0@1 rule: Form under.			smearPort copyForm: smearForm to: 0@-1 rule: Form under.			"After vert smear, trim around the region border"			smearPort copyForm: self to: 0@0 rule: Form erase.			count _ count+1.			count = 9 ifTrue: "Save penultimate smear for comparison"				[previousSmear copy: all from: 0@0 in: smearForm rule: Form over]].	"Now paint the filled region in me with aHalftone"	^ smearForm! !!Form methodsFor: 'filling' stamp: 'jm 5/29/2003 18:00'!pixelValueAt: aPoint 	"Return the raw pixel value at the given point. This pixel value depends on the receiver's depth. Typical clients use colorAt: to get a Color.  "	^ (BitBlt bitPeekerFromForm: self) pixelAt: aPoint! !!Form methodsFor: 'filling' stamp: 'jm 5/29/2003 18:00'!pixelValueAt: aPoint put: pixelValue	"Store the given raw pixel value at the given point. Typical clients use colorAt:put: to store a color. "	(BitBlt bitPokerToForm: self) pixelAt: aPoint put: pixelValue.! !!Form methodsFor: 'filling' stamp: 'jm 6/18/1999 19:01'!reverse	"Invert the colors of the receiver."	self fill: self boundingBox rule: Form reverse fillColor: (Color quickHighLight: self depth).! !!Form methodsFor: 'filling' stamp: 'jm 6/18/1999 19:00'!reverse: aRectangle	"Invert the colors of the receiver in the given rectangular area."	self fill: aRectangle rule: Form reverse fillColor: (Color quickHighLight: self depth).! !!Form methodsFor: 'filling' stamp: 'jm 5/29/2003 18:00'!shapeFill: aColor interiorPoint: interiorPoint	"Identify the shape (region of identical color) at interiorPoint,	and then fill that shape with the new color, aColor	: modified di's original method such that it returns the bwForm, for potential use by the caller"	| bwForm interiorPixVal map ppd color ind |	depth = 1 ifTrue:		[^ self shapeFill: aColor			seedBlock: [:form | form pixelValueAt: interiorPoint put: 1]].	"First map this form into a B/W form with 0's in the interior region."	interiorPixVal _ self pixelValueAt: interiorPoint.	bwForm _ Form extent: self extent.	map _ Bitmap new: (1 bitShift: (depth min: 12)).  "Not calling newColorMap.  All 			non-foreground go to 0.  Length is 2 to 4096."	ppd _ depth.	"256 long color map in depth 8 is not one of the following cases"	3 to: 5 do: [:bitsPerColor | 		(2 raisedTo: bitsPerColor*3) = map size 			ifTrue: [ppd _ bitsPerColor*3]].	"ready for longer maps than 512"	ppd <= 8		ifTrue: [map at: interiorPixVal+1 put: 1]		ifFalse: [interiorPixVal = 0 			ifFalse: [color _ Color colorFromPixelValue: interiorPixVal depth: depth.				ind _ color pixelValueForDepth: ppd.				map at: ind+1 put: 1]			ifTrue: [map at: 1 put: 1]].	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.		"bwForm _ self makeBWForm: interiorColor."	"not work for two whites"	bwForm reverse.  "Make interior region be 0's"	"Now fill the interior region and return that shape"	bwForm _ bwForm findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	"Finally use that shape as a mask to flood the region with color"	((BitBlt destForm: self sourceForm: bwForm 		fillColor: nil		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"		destOrigin: bwForm offset 		sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 0 with: 16rFFFFFFFF))		copyBits.	self fillShape: bwForm fillColor: aColor.	^ bwForm! !!Form methodsFor: 'filling' stamp: 'ee 7/18/2003 13:22'!shapeGradientFill: aColor altColor: aColor2 interiorPoint: interiorPoint	"Identify the shape (region of identical color) at interiorPoint,	and then fill that shape with the new color, aColor	: modified di's original method such that it returns the bwForm, for potential use by the caller"	| bwForm interiorPixVal map ppd color ind newForm newBounds |	depth = 1 ifTrue:		[^ self shapeFill: aColor			seedBlock: [:form | form pixelValueAt: interiorPoint put: 1]].	"First map this form into a B/W form with 0's in the interior region."	interiorPixVal _ self pixelValueAt: interiorPoint.	bwForm _ Form extent: self extent.	map _ Bitmap new: (1 bitShift: (depth min: 12)).  "Not calling newColorMap.  All 			non-foreground go to 0.  Length is 2 to 4096."	ppd _ depth.	"256 long color map in depth 8 is not one of the following cases"	3 to: 5 do: [:bitsPerColor | 		(2 raisedTo: bitsPerColor*3) = map size 			ifTrue: [ppd _ bitsPerColor*3]].	"ready for longer maps than 512"	ppd <= 8		ifTrue: [map at: interiorPixVal+1 put: 1]		ifFalse: [interiorPixVal = 0 			ifFalse: [color _ Color colorFromPixelValue: interiorPixVal depth: depth.				ind _ color pixelValueForDepth: ppd.				map at: ind+1 put: 1]			ifTrue: [map at: 1 put: 1]].	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.	"bwForm _ self makeBWForm: (Color white)."	"not work for two whites"	bwForm reverse.  "Make interior region be 0's"	"Now fill the interior region and return that shape"	bwForm _ bwForm findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	newBounds _ (bwForm rectangleEnclosingPixelsNotOfColor: (Color white)).		newForm _ Form extent: (newBounds extent) depth: 16.	newForm offset: bwForm offset.	newForm fillFromXColorBlock: [:x | 				aColor mixed: x with: aColor2].		"Finally use that shape as a mask to flood the region with color"	((BitBlt destForm: newForm sourceForm: bwForm		fillColor: nil		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"		destOrigin: bwForm offset 		sourceOrigin: (newBounds origin)		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 16rFFFFFFFF with: 0))		copyBits.	self copy: (newForm boundingBox) from: newForm to: (newBounds origin) rule: (Form paint).		^ self.! !!Form methodsFor: 'filling' stamp: 'ee 7/28/2003 14:59'!shapeGradientRFill: aColor altColor: aColor2 interiorPoint: interiorPoint	"Identify the shape (region of identical color) at interiorPoint,	and then fill that shape with the new color, aColor	: modified di's original method such that it returns the bwForm, for potential use by the caller"	| bwForm interiorPixVal map ppd color ind newForm newBounds |	depth = 1 ifTrue:		[^ self shapeFill: aColor			seedBlock: [:form | form pixelValueAt: interiorPoint put: 1]].	"First map this form into a B/W form with 0's in the interior region."	interiorPixVal _ self pixelValueAt: interiorPoint.	bwForm _ Form extent: self extent.	map _ Bitmap new: (1 bitShift: (depth min: 12)).  "Not calling newColorMap.  All 			non-foreground go to 0.  Length is 2 to 4096."	ppd _ depth.	"256 long color map in depth 8 is not one of the following cases"	3 to: 5 do: [:bitsPerColor | 		(2 raisedTo: bitsPerColor*3) = map size 			ifTrue: [ppd _ bitsPerColor*3]].	"ready for longer maps than 512"	ppd <= 8		ifTrue: [map at: interiorPixVal+1 put: 1]		ifFalse: [interiorPixVal = 0 			ifFalse: [color _ Color colorFromPixelValue: interiorPixVal depth: depth.				ind _ color pixelValueForDepth: ppd.				map at: ind+1 put: 1]			ifTrue: [map at: 1 put: 1]].	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.	"bwForm _ self makeBWForm: (Color white)."	"not work for two whites"	bwForm reverse.  "Make interior region be 0's"	"Now fill the interior region and return that shape"	bwForm _ bwForm findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	newBounds _ (bwForm rectangleEnclosingPixelsNotOfColor: (Color white)).		newForm _ Form extent: (newBounds extent) depth: 16.	newForm offset: bwForm offset.	newForm fillRadialFromXColorBlock: [:x | 				aColor mixed: x with: aColor2]			  center: (interiorPoint - newBounds origin).		"Finally use that shape as a mask to flood the region with color"	((BitBlt destForm: newForm sourceForm: bwForm		fillColor: nil		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"		destOrigin: bwForm offset 		sourceOrigin: (newBounds origin)		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 16rFFFFFFFF with: 0))		copyBits.	self copy: (newForm boundingBox) from: newForm to: (newBounds origin) rule: (Form paint).		^ self.! !!Form methodsFor: 'filling' stamp: 'ee 7/25/2003 15:04'!shapeGradientVFill: aColor altColor: aColor2 interiorPoint: interiorPoint	"Identify the shape (region of identical color) at interiorPoint,	and then fill that shape with the new color, aColor	: modified di's original method such that it returns the bwForm, for potential use by the caller"	| bwForm interiorPixVal map ppd color ind newForm newBounds |	depth = 1 ifTrue:		[^ self shapeFill: aColor			seedBlock: [:form | form pixelValueAt: interiorPoint put: 1]].	"First map this form into a B/W form with 0's in the interior region."	interiorPixVal _ self pixelValueAt: interiorPoint.	bwForm _ Form extent: self extent.	map _ Bitmap new: (1 bitShift: (depth min: 12)).  "Not calling newColorMap.  All 			non-foreground go to 0.  Length is 2 to 4096."	ppd _ depth.	"256 long color map in depth 8 is not one of the following cases"	3 to: 5 do: [:bitsPerColor | 		(2 raisedTo: bitsPerColor*3) = map size 			ifTrue: [ppd _ bitsPerColor*3]].	"ready for longer maps than 512"	ppd <= 8		ifTrue: [map at: interiorPixVal+1 put: 1]		ifFalse: [interiorPixVal = 0 			ifFalse: [color _ Color colorFromPixelValue: interiorPixVal depth: depth.				ind _ color pixelValueForDepth: ppd.				map at: ind+1 put: 1]			ifTrue: [map at: 1 put: 1]].	bwForm copyBits: self boundingBox from: self at: 0@0 colorMap: map.	"bwForm _ self makeBWForm: (Color white)."	"not work for two whites"	bwForm reverse.  "Make interior region be 0's"	"Now fill the interior region and return that shape"	bwForm _ bwForm findShapeAroundSeedBlock:					[:form | form pixelValueAt: interiorPoint put: 1].	newBounds _ (bwForm rectangleEnclosingPixelsNotOfColor: (Color white)).		newForm _ Form extent: (newBounds extent) depth: 16.	newForm offset: bwForm offset.	newForm fillFromYColorBlock: [:x | 				aColor mixed: x with: aColor2].		"Finally use that shape as a mask to flood the region with color"	((BitBlt destForm: newForm sourceForm: bwForm		fillColor: nil		combinationRule: Form erase1bitShape	"Cut a hole in the picture with my mask"		destOrigin: bwForm offset 		sourceOrigin: (newBounds origin)		extent: self extent clipRect: self boundingBox)		colorMap: (Bitmap with: 16rFFFFFFFF with: 0))		copyBits.	self copy: (newForm boundingBox) from: newForm to: (newBounds origin) rule: (Form paint).		^ self.! !!Form methodsFor: 'scaling, rotation' stamp: 'jm 5/29/2003 17:59'!flipBy: direction centerAt: aPoint	"Return a copy of the receiver flipped either #vertical or #horizontal."	| newForm quad |	newForm _ self class extent: self extent depth: depth.	quad _ self boundingBox innerCorners.	quad _ (direction = #vertical ifTrue: [#(2 1 4 3)] ifFalse: [#(4 3 2 1)])		collect: [:i | quad at: i].	(WarpBlt toForm: newForm)		sourceForm: self;		colorMap: (self colormapIfNeededForDepth: depth);		combinationRule: 3;		copyQuad: quad toRect: newForm boundingBox.	newForm offset: (self offset flipBy: direction centerAt: aPoint).	^ newForm"[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))			flipBy: #vertical centerAt: 0@0) display]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: ((p _ Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 _ f flipBy: #vertical centerAt: 0@0.	(f2 flipBy: #vertical centerAt: 0@0) displayAt: p]"! !!Form methodsFor: 'scaling, rotation' stamp: 'jm 6/15/2003 19:00'!magnify: aRectangle by: scale 	"Answer a Form created as a scaling of the receiver. Scale may be a Float, and may be greater or less than 1.0."	^ self magnify: aRectangle by: scale smoothing: 1"Dynamic test...[Sensor anyButtonPressed] whileFalse:	[(Display magnify: (Sensor cursorPoint extent: 31@41) by: 5@3) display]""Scaling test...| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:	[cp _ Sensor cursorPoint.	(f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent) display]]""Consistency test...| f f2 |f _ Form fromDisplay: (Rectangle originFromUser: 100@100).f2 _ f magnify: f boundingBox by: 5@3.(f2 magnify: f2 boundingBox by: 5 reciprocal @ 3 reciprocal) display"! !!Form methodsFor: 'scaling, rotation' stamp: 'jm 5/29/2003 17:59'!magnify: aRectangle by: scale smoothing: cellSize	"Answer a Form created as a scaling of the receiver. Scale may be a Float, and may be greater or less than 1.0."	| newForm |	newForm _ self class extent: (aRectangle extent * scale) truncated depth: depth.	(WarpBlt toForm: newForm)		sourceForm: self;		colorMap: (self colormapIfNeededForDepth: depth);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form over;		copyQuad: aRectangle innerCorners toRect: newForm boundingBox.	^ newForm"Dynamic test...[Sensor anyButtonPressed] whileFalse:        [(Display magnify: (Sensor cursorPoint extent: 131@81) by: 0.5 smoothing: 2) display]""Scaling test...| f cp | f _ Form fromDisplay: (Rectangle originFromUser: 100@100).Display restoreAfter: [Sensor waitNoButton.[Sensor anyButtonPressed] whileFalse:        [cp _ Sensor cursorPoint.        (f magnify: f boundingBox by: (cp x asFloat@cp y asFloat)/f extent smoothing: 2) display]]"! !!Form methodsFor: 'scaling, rotation' stamp: 'jm 6/15/2003 18:52'!magnifyBy: scale 	"Answer a Form created as a scaling of the receiver. Scale may be a Float, and it may be greater or less than 1.0."	^ self		magnify: self boundingBox		by: scale		smoothing: (scale < 1 ifTrue: [2] ifFalse: [1])  "smooth if scale < 1"! !!Form methodsFor: 'scaling, rotation' stamp: 'jm 5/29/2003 18:00'!rotateBy: direction centerAt: aPoint	"Return a rotated copy of the receiver. 	direction = #none, #right, #left, or #pi"	| newForm quad rot |	direction == #none ifTrue: [^ self].	newForm _ self class extent: (direction = #pi ifTrue: [width@height]											ifFalse: [height@width]) depth: depth.	quad _ self boundingBox innerCorners.	rot _ #(right pi left) indexOf: direction.	(WarpBlt toForm: newForm)		sourceForm: self;		colorMap: (self colormapIfNeededForDepth: depth);		combinationRule: 3;		copyQuad: ((1+rot to: 4+rot) collect: [:i | quad atWrap: i])			 toRect: newForm boundingBox.	newForm offset: (self offset rotateBy: direction centerAt: aPoint).	^ newForm"[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: #left centerAt: 0@0) display]""Consistency test... | f f2 p | [Sensor anyButtonPressed] whileFalse:	[f _ Form fromDisplay: ((p _ Sensor cursorPoint) extent: 31@41).	Display fillBlack: (p extent: 31@41).	f2 _ f rotateBy: #left centerAt: 0@0.	(f2 rotateBy: #right centerAt: 0@0) displayAt: p]"! !!Form methodsFor: 'scaling, rotation' stamp: 'jm 5/29/2003 18:00'!rotateBy: deg magnify: scale smoothing: cellSize	"Rotate the receiver by the indicated number of degrees and magnify.  "	"rot is the destination form, big enough for any angle."	| side rot warp r1 pts p bigSide |	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.	bigSide _ (side * scale) rounded.	rot _ Form extent: bigSide@bigSide depth: self depth.	warp _ (WarpBlt toForm: rot)		sourceForm: self;		colorMap: (self colormapIfNeededForDepth: depth);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form paint.	r1 _ (0@0 extent: side@side) align: (side@side)//2 with: self boundingBox center.	"Rotate the corners of the source rectangle." 	pts _ r1 innerCorners collect:		[:pt | p _ pt - r1 center.		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].	warp copyQuad: pts toRect: rot boundingBox.	^ rot" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a _ a+5) magnify: 0.75 smoothing: 2) display].f display"! !!Form methodsFor: 'scaling, rotation' stamp: 'jm 5/29/2003 18:00'!rotateBy: deg smoothing: cellSize	"Rotate the receiver by the indicated number of degrees."	"rot is the destination form, bit enough for any angle."	| side rot warp r1 pts p center |	side _ 1 + ((width*width) + (height*height)) asFloat sqrt asInteger.	rot _ Form extent: side@side depth: self depth.	center _ rot extent // 2.	"Now compute the sin and cos constants for the rotation angle." 	warp _ (WarpBlt toForm: rot)		sourceForm: self;		colorMap: (self colormapIfNeededForDepth: depth);		cellSize: cellSize;  "installs a new colormap if cellSize > 1"		combinationRule: Form over.	r1 _ rot boundingBox align: center with: self boundingBox center.	pts _ r1 innerCorners collect:		[:pt | p _ pt - r1 center.		(r1 center x asFloat + (p x asFloat*deg degreeCos) + (p y asFloat*deg degreeSin)) @		(r1 center y asFloat - (p x asFloat*deg degreeSin) + (p y asFloat*deg degreeCos))].	warp copyQuad: pts toRect: rot boundingBox.	^ rot" | a f |  f _ Form fromDisplay: (0@0 extent: 200@200).  a _ 0.[Sensor anyButtonPressed] whileFalse:	[((Form fromDisplay: (Sensor cursorPoint extent: 130@66))		rotateBy: (a _ a+5) smoothing: 2) display].f display"! !!Form methodsFor: 'scaling, rotation' stamp: 'LB 7/25/2003 09:37'!toThumbnail: aExtent borderWidth: borderWidth borderColor: aColor	"returns a thumbnail with the specified extent, border width and color"	|thumb e r p|	thumb _ Form extent: aExtent depth: 16.	thumb fillColor: aColor.	thumb border: thumb boundingBox width: borderWidth.	"calculate the rectangle to be used by the thumbnail image"	self width > self height			ifTrue: [e _ thumb width @ ((self height * thumb width) // self width)]			ifFalse: [e _ ((self width * thumb height) // self height) @ thumb height].	p _ (thumb extent - e) // 2.	r _ p extent: e.	(WarpBlt toForm: thumb)		sourceForm: self;		cellSize: 2;  "do smoothing; this also installs a colormap"		combinationRule: Form over;		copyQuad: self boundingBox innerCorners toRect: (r insetBy: (borderWidth +1)).	^thumb! !!Form methodsFor: 'editing' stamp: 'jm 6/1/2003 06:07'!bitEdit	"Create and schedule an editor on me located in an area designated by the user."	BitEditor openOnForm: self.! !!Form methodsFor: 'image manipulation' stamp: 'bf 10/12/1999 18:07'!dominantColor	| tally max maxi |	depth > 16 ifTrue:		[^(self asFormOfDepth: 16) dominantColor].	tally _ self tallyPixelValues.	max _ maxi _ 0.	tally withIndexDo: [:n :i | n > max ifTrue: [max _ n. maxi _ i]].	^ Color colorFromPixelValue: maxi - 1 depth: depth! !!Form methodsFor: 'image manipulation' stamp: 'ar 7/23/1999 17:04'!orderedDither32To16	"Do an ordered dithering for converting from 32 to 16 bit depth."	| ditherMatrix ii out inBits outBits index pv dmv r di dmi dmo g b pvOut outIndex |	self depth = 32 ifFalse:[^self error:'Must be 32bit for this'].	ditherMatrix _ #(	0	8	2	10						12	4	14	6						3	11	1	9						15	7	13	5).	ii _ (0 to: 31) collect:[:i| i].	out _ Form extent: self extent depth: 16.	inBits _ self bits.	outBits _ out bits.	index _ outIndex _ 0.	pvOut _ 0.	0 to: self height-1 do:[:y|		0 to: self width-1 do:[:x|			pv _ inBits at: (index _ index + 1).			dmv _ ditherMatrix at: (y bitAnd: 3) * 4 + (x bitAnd: 3) + 1.			r _ pv bitAnd: 255.	di _ r * 496 bitShift: -8.			dmi _ di bitAnd: 15.	dmo _ di bitShift: -4.			r _ dmv < dmi ifTrue:[ii at: 2+dmo] ifFalse:[ii at: 1+dmo].			g _ (pv bitShift: -8) bitAnd: 255.	di _ g * 496 bitShift: -8.			dmi _ di bitAnd: 15.	dmo _ di bitShift: -4.			g _ dmv < dmi ifTrue:[ii at: 2+dmo] ifFalse:[ii at: 1+dmo].			b _ (pv bitShift: -16) bitAnd: 255.	di _ b * 496 bitShift: -8.			dmi _ di bitAnd: 15.	dmo _ di bitShift: -4.			b _ dmv < dmi ifTrue:[ii at: 2+dmo] ifFalse:[ii at: 1+dmo].			pvOut _ (pvOut bitShift: 16) + 						(b bitShift: 10) + (g bitShift: 5) + r.			(x bitAnd: 1) = 1 ifTrue:[				outBits at: (outIndex _ outIndex+1) put: pvOut.				pvOut _ 0].		].		(self width bitAnd: 1) = 1 ifTrue:[			outBits at: (outIndex _ outIndex+1) put: (pvOut bitShift: -16).			pvOut _ 0].	].	^out! !!Form methodsFor: 'image manipulation' stamp: 'jm 5/29/2003 18:06'!pixelCompare: aRect with: otherForm at: otherLoc	"Compare the selected bits of this form (those within aRect) against	those in a similar rectangle of otherFrom.  Return the sum of the	absolute value of the differences of the color values of every pixel.	Obviously, this is most useful for rgb (16- or 32-bit) pixels but,	in the case of 8-bits or less, this will return the sum of the differing	bits of the corresponding pixel values (somewhat less useful)"	| pixPerWord temp |	pixPerWord _ 32//depth.	(aRect left\\pixPerWord = 0 and: [aRect right\\pixPerWord = 0]) ifTrue:		["If word-aligned, use on-the-fly difference"		^ (BitBlt toForm: self) copy: aRect from: otherLoc in: otherForm				fillColor: nil rule: 32].	"Otherwise, combine in a word-sized form and then compute difference"	temp _ self copy: aRect.	temp copy: aRect from: otherLoc in: otherForm rule: 21.	^ (BitBlt toForm: temp) copy: aRect from: otherLoc in: nil				fillColor: (Bitmap with: 0) rule: 32"  Dumb example prints zero only when you move over the original rectangle... | f diff | f _ Form fromUser.[Sensor anyButtonPressed] whileFalse:	[diff _ f pixelCompare: f boundingBox		with: Display at: Sensor cursorPoint.	diff printString , '        ' displayAt: 0@0]"! !!Form methodsFor: 'image manipulation' stamp: 'jm 5/29/2003 18:00'!primCountBits	"Count the non-zero pixels of this form."	depth > 8 ifTrue:		[^(self asFormOfDepth: 8) primCountBits].	^ (BitBlt toForm: self)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: width@height);		combinationRule: 32;		copyBits! !!Form methodsFor: 'image manipulation' stamp: 'jm 5/29/2003 18:10'!rectangleEnclosingPixelsNotOfColor: aColor	"Answer the smallest rectangle enclosing all the pixels of me that are different from the given color. Useful for extracting a foreground graphic from its background."	| cm slice copyBlt countBlt top bottom newH left right |	"map the specified color to 1 and all others to 0"	cm _ Bitmap new: (1 bitShift: (depth min: 15)).	cm primFill: 1.	cm at: (aColor indexInMap: cm) put: 0.	cm _ ColorMap colors: cm.	"build a 1-pixel high horizontal slice and BitBlts for counting pixels of interest"	slice _ Form extent: width@1 depth: 1.	copyBlt _ (BitBlt toForm: slice)		sourceForm: self;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: 1;		colorMap: cm.	countBlt _ (BitBlt toForm: slice)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: slice extent);		combinationRule: 32.	"scan in from top and bottom"	top _ (0 to: height)		detect: [:y |			copyBlt sourceOrigin: 0@y; copyBits.			countBlt copyBits > 0]		ifNone: [^ 0@0 extent: 0@0].	bottom _ (height - 1 to: top by: -1)		detect: [:y |			copyBlt sourceOrigin: 0@y; copyBits.			countBlt copyBits > 0].	"build a 1-pixel wide vertical slice and BitBlts for counting pixels of interest"	newH _ bottom - top + 1.	slice _ Form extent: 1@newH depth: 1.	copyBlt _ (BitBlt toForm: slice)		sourceForm: self;		combinationRule: Form over;		destX: 0 destY: 0 width: 1 height: newH;		colorMap: cm.	countBlt _ (BitBlt toForm: slice)		fillColor: (Bitmap with: 0);		destRect: (0@0 extent: slice extent);		combinationRule: 32.	"scan in from left and right"	left _ (0 to: width)		detect: [:x |			copyBlt sourceOrigin: x@top; copyBits.			countBlt copyBits > 0].	right _ (width - 1 to: left by: -1)		detect: [:x |			copyBlt sourceOrigin: x@top; copyBits.			countBlt copyBits > 0].	^ left@top corner: (right + 1)@(bottom + 1)! !!Form methodsFor: 'image manipulation' stamp: 'jm 5/29/2003 18:00'!replaceColor: oldColor withColor: newColor	"Replace one color with another everywhere is this form"	| cm newInd target ff |	depth = 32		ifTrue: [cm _ (Color  cachedColormapFrom: 16 to: 32) copy]		ifFalse: [cm _ Bitmap new: (1 bitShift: (depth min: 15)).				1 to: cm size do: [:i | cm at: i put: i - 1]].	newInd _ newColor pixelValueForDepth: depth.	cm at: (oldColor pixelValueForDepth: (depth min: 16))+1 put: newInd.	target _ newColor isTransparent 		ifTrue: [ff _ Form extent: self extent depth: depth.			ff fillColor: newColor.  ff]		ifFalse: [self].	(BitBlt toForm: target)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form paint;		destX: 0 destY: 0 width: width height: height;		colorMap: cm;		copyBits.	newColor = Color transparent 		ifTrue: [target displayOn: self].! !!Form methodsFor: 'image manipulation' stamp: 'jm 5/29/2003 18:00'!smear: dir distance: dist	"Smear any black pixels in this form in the direction dir in Log N steps"	| skew bb |	bb _ BitBlt destForm: self sourceForm: self fillColor: nil		combinationRule: Form under destOrigin: 0@0 sourceOrigin: 0@0		extent: self extent clipRect: self boundingBox.	skew _ 1.	[skew < dist] whileTrue:		[bb destOrigin: dir*skew; copyBits.		skew _ skew+skew]! !!Form methodsFor: 'image manipulation' stamp: 'jm 6/18/1999 18:41'!tallyPixelValues	"Answer a Bitmap whose elements contain the number of pixels in this Form with the pixel value corresponding to their index. Note that the pixels of multiple Forms can be tallied together using tallyPixelValuesInRect:into:."	^ self tallyPixelValuesInRect: self boundingBox		into: (Bitmap new: (1 bitShift: (self depth min: 15)))"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r _ Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies _ (Display copy: r) tallyPixelValues.	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!Form methodsFor: 'image manipulation' stamp: 'jm 5/29/2003 18:00'!tallyPixelValuesInRect: aRectangle into: valueTable	"Tally the selected pixels of this Form into valueTable, a Bitmap of depth 2^depth similar to a color map. Answer valueTable."	(BitBlt toForm: self)		sourceForm: self;  "src must be given for color map ops"		sourceOrigin: 0@0;		tallyMap: valueTable;		combinationRule: 33;		destRect: aRectangle;		sourceRect: aRectangle;		copyBits.	^ valueTable"Move a little rectangle around the screen and print its tallies... | r tallies nonZero |Cursor blank showWhile: [[Sensor anyButtonPressed] whileFalse:	[r _ Sensor cursorPoint extent: 10@10.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil.	tallies _ (Display copy: r) tallyPixelValues.	nonZero _ (1 to: tallies size) select: [:i | (tallies at: i) > 0]			thenCollect: [:i | (tallies at: i) -> (i-1)].	nonZero printString , '          ' displayAt: 0@0.	Display border: (r expandBy: 2) width: 2 rule: Form reverse fillColor: nil]]"! !!Form methodsFor: 'image manipulation' stamp: 'jm 6/30/1999 15:36'!trimBordersOfColor: aColor	"Answer a copy of this Form with each edge trimmed in to the first pixel that is not of the given color. (That is, border strips of the given color are removed)."	| r |	r _ self rectangleEnclosingPixelsNotOfColor: aColor.	^ self copy: r! !!Form methodsFor: 'image manipulation' stamp: 'jm 5/29/2003 18:00'!xTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by x-value.	Note that if not is true, then this will tally those different from pv."	| cm slice countBlt copyBlt |	cm _ self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice _ Form extent: 1@height.	copyBlt _ (BitBlt destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: 1 @ slice height				clipRect: slice boundingBox) colorMap: cm.	countBlt _ (BitBlt toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: width-1) collect:		[:x |		copyBlt sourceOrigin: x@0; copyBits.		countBlt copyBits]! !!Form methodsFor: 'image manipulation' stamp: 'jm 5/29/2003 18:06'!yTallyPixelValue: pv orNot: not	"Return an array of the number of pixels with value pv by y-value.	Note that if not is true, then this will tally those different from pv."	| cm slice copyBlt countBlt |	cm _ self newColorMap.		"Map all colors but pv to zero"	not ifTrue: [cm atAllPut: 1].		"... or all but pv to one"	cm at: pv+1 put: 1 - (cm at: pv+1).	slice _ Form extent: width@1.	copyBlt _ (BitBlt destForm: slice sourceForm: self				halftoneForm: nil combinationRule: Form over				destOrigin: 0@0 sourceOrigin: 0@0 extent: slice width @ 1				clipRect: slice boundingBox) colorMap: cm.	countBlt _ (BitBlt toForm: slice)				fillColor: (Bitmap with: 0);				destRect: (0@0 extent: slice extent);				combinationRule: 32.	^ (0 to: height-1) collect:		[:y |		copyBlt sourceOrigin: 0@y; copyBits.		countBlt copyBits]! !!Form methodsFor: 'fileIn/Out' stamp: 'di 8/5/1998 11:37'!hibernate	"Replace my bitmap with a compactly encoded representation (a ByteArray).  It is vital that BitBlt and any other access to the bitmap (such as writing to a file) not be used when in this state.  Since BitBlt will fail if the bitmap size is wrong (not = bitsSize), we do not allow replacement by a byteArray of the same (or larger) size."	"NOTE: This method copies code from Bitmap compressToByteArray so that it can	nil out the old bits during the copy, thus avoiding 2x need for extra storage."	| compactBits lastByte |	(bits isMemberOf: Bitmap) ifFalse: [^ self  "already hibernated or weird state"].	compactBits _ ByteArray new: (bits size*4) + 7 + (bits size//1984*3).	lastByte _ bits compress: bits toByteArray: compactBits.	lastByte < (bits size*4) ifTrue:		[bits _ nil.  "Let GC reclaim the old bits before the copy if necessary"		bits _ compactBits copyFrom: 1 to: lastByte]! !!Form methodsFor: 'fileIn/Out' stamp: 'di 3/15/1999 14:50'!printOn: aStream    aStream        nextPutAll: self class name;        nextPut: $(; print: width;        nextPut: $x; print: height;        nextPut: $x; print: depth;        nextPut: $).! !!Form methodsFor: 'fileIn/Out' stamp: 'jm 1/1/2004 19:04'!readFrom: aBinaryStream	"Reads the receiver from the given binary stream with the format:		depth, extent, offset, bits."	| offsetX offsetY |	depth _ aBinaryStream next.	(depth isPowerOfTwo and: [depth between: 1 and: 32])		ifFalse: [self error: 'invalid depth; bad Form file?'].	width _ aBinaryStream uint16.	height _ aBinaryStream uint16.	offsetX  _ aBinaryStream int16.	offsetY _ aBinaryStream int16.	offset _ offsetX@offsetY.	bits _ Bitmap newFromStream: aBinaryStream.	bits size = self bitsSize ifFalse: [self error: 'wrong bitmap size; bad Form file?'].	^ self! !!Form methodsFor: 'fileIn/Out' stamp: 'jm 1/1/2004 19:02'!readFromOldFormat: aBinaryStream	"Read a Form in the original ST-80 format."	| w h offsetX offsetY newForm theBits pos |	self error: 'this method must be updated to read into 32-bit word bitmaps'.	w _ aBinaryStream uint16.	h _ aBinaryStream uint16.	offsetX  _ aBinaryStream int16.	offsetY _ aBinaryStream int16.	newForm _ (Form extent: w @ h) offset: offsetX @ offsetY.	theBits _ newForm bits.	pos _ 0.	1 to: ((w + 15) // 16) do: [:j |		1 to: h do: [:i | theBits at: (pos _ pos + 1) put: aBinaryStream uint16]].	newForm bits: theBits.	^ newForm! !!Form methodsFor: 'fileIn/Out'!storeBitsOn:aStream base:anInteger	bits do: [:word | 		anInteger = 10			ifTrue: [aStream space]			ifFalse: [aStream crtab: 2].		word printOn: aStream base: anInteger].! !!Form methodsFor: 'fileIn/Out'!storeOn: aStream base: anInteger 	"Store the receiver out as an expression that can be evaluated to recreate a Form with the same contents as the original."	self unhibernate.	aStream nextPut: $(.	aStream nextPutAll: self species name.	aStream crtab: 1.	aStream nextPutAll: 'extent: '.	self extent printOn: aStream.	aStream crtab: 1.	aStream nextPutAll: 'depth: '.	self depth printOn: aStream.	aStream crtab: 1.	aStream nextPutAll: 'fromArray: #('.	self storeBitsOn:aStream base:anInteger.	aStream nextPut: $).	aStream crtab: 1.	aStream nextPutAll: 'offset: '.	self offset printOn: aStream.	aStream nextPut: $).! !!Form methodsFor: 'fileIn/Out' stamp: 'ar 5/28/2000 00:52'!unhibernate	"If my bitmap has been compressed into a ByteArray,	then expand it now, and return true."	bits == nil ifTrue:[bits _ Bitmap new: self bitsSize. ^true].	(bits isMemberOf: ByteArray)		ifTrue: [bits _ Bitmap decompressFromByteArray: bits. ^ true].	^ false! !!Form methodsFor: 'fileIn/Out' stamp: 'jm 1/1/2004 18:49'!writeBMPfileNamed: fName	"Display writeBMPfileNamed: 'display.bmp'"	| fileName bhSize biSize biClrUsed f biSizeImage bfOffBits rowBytes rgb data colorValues |	self unhibernate.	(#(1 4 8 32) includes: depth) ifFalse: [self halt  "depth must be one of these"].	((fileName _ fName) asUppercase endsWith: '.BMP')		ifFalse: [fileName _ fName , '.BMP'].	bhSize _ 14.		"# bytes in file header"	biSize _ 40.		"info header size in bytes"	biClrUsed _ depth = 32 ifTrue: [0] ifFalse: [1 << depth].	"number of color table entries"	bfOffBits _ biSize + bhSize + (4*biClrUsed).	rowBytes _ ((depth min: 24) * width + 31 // 32) * 4.	biSizeImage _ height * rowBytes. 	f _ (FileStream newFileNamed: fileName) binary.	"write the file header"	f position: 0.	f littleEndianUint16: 19778.			"bfType = BM"	f littleEndianUint32: bfOffBits + biSizeImage.	"total file size in bytes"	f littleEndianUint32: 0.				"bfReserved"	f littleEndianUint32: bfOffBits.		"offset of bitmap data from start of hdr (and file)"	"write the bitmap info header"	f position: bhSize.	f littleEndianUint32: biSize.			"info header size in bytes"	f littleEndianUint32: width.			"biWidth"	f littleEndianUint32: height.			"biHeight"	f littleEndianUint16: 1.				"biPlanes"	f littleEndianUint16: (depth min: 24).	"biBitCount"	f littleEndianUint32: 0.				"biCompression"	f littleEndianUint32: biSizeImage.		"size of image section in bytes"	f littleEndianUint32: 2800.			"biXPelsPerMeter"	f littleEndianUint32: 2800.			"biYPelsPerMeter"	f littleEndianUint32: biClrUsed.	f littleEndianUint32: 0.				"biClrImportant"	biClrUsed > 0 ifTrue: [		"write color map; this works for ColorForms, too"		colorValues _ self colormapIfNeededForDepth: 32.		1 to: biClrUsed do: [:i |			rgb _ colorValues at: i.			0 to: 24 by: 8 do: [:j | f nextPut: (rgb >> j bitAnd: 16rFF)]]].	'Writing image data' displayProgressAt: Sensor cursorPoint		from: 1 to: height during: [:bar |			1 to: height do: [:i |				bar value: i.				data _ (self copy: (0@(height-i) extent: width@1)) bits.				depth = 32				ifTrue: [					1 to: data size do: [:j | f littleEndianUint24: (data at: j)].					1 to: (data size*3)+3//4*4-(data size*3) do: [:j | f nextPut: 0 "pad to 32-bits"]]				ifFalse: [					1 to: data size do: [:j | f int32: (data at: j)]]]].	f position = (bfOffBits + biSizeImage) ifFalse: [self halt].	f close.! !!Form methodsFor: 'fileIn/Out' stamp: 'jm 1/1/2004 18:57'!writeOn: file	"Write the receiver on the file in the format		depth, extent, offset, bits."	self unhibernate.	file nextPut: depth.	file uint16: width.	file uint16: height.	file int16: self offset x.	file int16: self offset y.	bits writeOn: file.! !!Form methodsFor: 'fileIn/Out' stamp: 'jm 5/25/2003 11:41'!writeOnFileNamed: fileName 	"Saves the receiver on the file fileName in the format:		fileCode=2, depth, extent, offset, bits."	| file |	file _ FileStream newFileNamed: fileName.	file binary.	file nextPut: 2.	self writeOn: file.	file close." | f |[(f _ Form fromUser) boundingBox area>25] whileTrue:	[f writeOnFileNamed: 'test.form'.	(Form newFromFileNamed: 'test.form') display]."! !!Form methodsFor: 'fileIn/Out' stamp: 'jm 1/1/2004 18:58'!writeUncompressedOn: file	"Write the receiver on the file in the format depth, extent, offset, bits. The sender must write the header byte; see writeUncompressedOnFileNamed:."	self unhibernate.	file binary.	file nextPut: depth.	file uint16: width.	file uint16: height.	file int16: self offset x.	file int16: self offset y.	bits writeUncompressedOn: file.! !!Form methodsFor: 'fileIn/Out' stamp: 'jm 5/25/2003 11:40'!writeUncompressedOnFileNamed: fileName 	"Saves the receiver on the file fileName in the format:		fileCode=2, depth, extent, offset, bits."	| file |	file _ FileStream newFileNamed: fileName.	file binary.	file nextPut: 2.	self writeUncompressedOn: file.	file close."| f |[(f _ Form fromUser) boundingBox area>25] whileTrue:	[f writeUncompressedOnFileNamed: 'test.form'.	(Form fromBinaryStream: (FileStream oldFileNamed: 'test.form')) display]."! !!Form methodsFor: 'other' stamp: 'di 2/26/1999 07:29'!asCursorForm	^ self! !!Form methodsFor: 'other' stamp: 'jm 5/29/2003 17:58'!asFormOfDepth: d	| newForm |	d = depth ifTrue:[^self].	newForm _ Form extent: self extent depth: d.	(BitBlt toForm: newForm)		colorMap: (self colormapIfNeededForDepth: d);		copy: (self boundingBox)		from: 0@0 in: self		fillColor: nil rule: Form over.	^newForm! !!Form methodsFor: 'other' stamp: 'jm 5/29/2003 18:06'!asGrayScale	"Assume the receiver is a grayscale image. Return a grayscale ColorForm computed by extracting the brightness levels of one color component. This technique allows a 32-bit Form to be converted to an 8-bit ColorForm to save space while retaining a full 255 levels of gray. (The usual colormapping technique quantizes to 8, 16, or 32 levels, which loses information.)"	| f32 srcForm result map bb grays |	depth = 32 ifFalse: [		f32 _ Form extent: width@height depth: 32.		self displayOn: f32.		^ f32 asGrayScale].	self unhibernate.	srcForm _ Form extent: (width * 4)@height depth: 8.	srcForm bits: bits.	result _ ColorForm extent: width@height depth: 8.	map _ Bitmap new: 256.	2 to: 256 do: [:i | map at: i put: i - 1].	map at: 1 put: 1.  "map zero pixel values to near-black"	bb _ (BitBlt toForm: result)		sourceForm: srcForm;		combinationRule: Form over;		colorMap: map.	0 to: width - 1 do: [:dstX |		bb  sourceRect: (((dstX * 4) + 2)@0 extent: 1@height);			destOrigin: dstX@0;			copyBits].	"final BitBlt to zero-out pixels that were truely transparent in the original"	map _ Bitmap new: 512.	map at: 1 put: 16rFF.	(BitBlt toForm: result)		sourceForm: self;		sourceRect: self boundingBox;		destOrigin: 0@0;		combinationRule: Form erase;		colorMap: map;		copyBits.		grays _ (0 to: 255) collect: [:brightness | Color gray: brightness asFloat / 255.0].	grays at: 1 put: Color transparent.	result colors: grays.	^ result! !!Form methodsFor: 'other' stamp: 'jm 4/5/1999 19:20'!colorReduced	"Return a color-reduced ColorForm version of the receiver, if possible, or the receiver itself if not."	| tally tallyDepth colorCount newForm cm oldPixelValues newFormColors nextColorIndex c |	tally _ self tallyPixelValues asArray.	tallyDepth _ (tally size log: 2) asInteger.	colorCount _ 0.	tally do: [:n | n > 0 ifTrue: [colorCount _ colorCount + 1]].	(tally at: 1) = 0 ifTrue: [colorCount _ colorCount + 1].  "include transparent"	colorCount > 256 ifTrue: [^ self].  "cannot reduce"	newForm _ self formForColorCount: colorCount.	"build an array of just the colors used, and a color map to translate	 old pixel values to their indices into this color array"	cm _ Bitmap new: tally size.	oldPixelValues _ self colormapIfNeededForDepth: 32.	newFormColors _ Array new: colorCount.	newFormColors at: 1 put: Color transparent.	nextColorIndex _ 2.	2 to: cm size do: [:i |		(tally at: i) > 0 ifTrue: [			oldPixelValues = nil				ifTrue: [c _ Color colorFromPixelValue: i - 1 depth: tallyDepth]				ifFalse: [c _ Color colorFromPixelValue: (oldPixelValues at: i) depth: 32].			newFormColors at: nextColorIndex put: c.			cm at: i put: nextColorIndex - 1.  "pixel values are zero-based indices"			nextColorIndex _ nextColorIndex + 1]].	"copy pixels into new ColorForm, mapping to new pixel values"	newForm copyBits: self boundingBox		from: self		at: 0@0		clippingBox: self boundingBox		rule: Form over		fillColor: nil		map: cm.	newForm colors: newFormColors.	newForm offset: offset.	^ newForm! !!Form methodsFor: 'other' stamp: 'jm 10/14/2003 20:16'!colorReduced8Bit	"Return an 8-bit ColorForm version of the receiver."	| tally tallyDepth colorCount newForm cm oldPixelValues newFormColors nextColorIndex c |	tally _ self tallyPixelValues asArray.	tallyDepth _ (tally size log: 2) asInteger.	colorCount _ 0.	tally do: [:n | n > 0 ifTrue: [colorCount _ colorCount + 1]].	(tally at: 1) = 0 ifTrue: [colorCount _ colorCount + 1].  "include transparent even if it's not used"	colorCount > 256 ifTrue: [^ self].  "cannot reduce"	newForm _ ColorForm extent: self extent depth: 8.	"build an array of just the colors used, and a color map to translate	 old pixel values to their indices into this color array"	cm _ Bitmap new: tally size.	oldPixelValues _ self colormapIfNeededForDepth: 32.	newFormColors _ Array new: colorCount.	newFormColors at: 1 put: Color transparent.	nextColorIndex _ 2.	2 to: cm size do: [:i |		(tally at: i) > 0 ifTrue: [			oldPixelValues = nil				ifTrue: [c _ Color colorFromPixelValue: i - 1 depth: tallyDepth]				ifFalse: [c _ Color colorFromPixelValue: (oldPixelValues at: i) depth: 32].			newFormColors at: nextColorIndex put: c.			cm at: i put: nextColorIndex - 1.  "pixel values are zero-based indices"			nextColorIndex _ nextColorIndex + 1]].	"copy pixels into new ColorForm, mapping to new pixel values"	newForm copyBits: self boundingBox		from: self		at: 0@0		clippingBox: self boundingBox		rule: Form over		fillColor: nil		map: cm.	newForm colors: newFormColors.	newForm offset: offset.	^ newForm! !!Form methodsFor: 'other' stamp: 'jm 5/29/2003 17:59'!mapColor: oldColor to: newColor	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."	| map |	map _ (Color cachedColormapFrom: depth to: depth) copy.	map at: (oldColor indexInMap: map) put: (newColor pixelWordForDepth: depth).	(BitBlt toForm: self)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: height;		colorMap: map;		copyBits.! !!Form methodsFor: 'other' stamp: 'jm 5/29/2003 17:59'!mapColors: oldColorBitsCollection to: newColorBits	"Make all pixels of the given color in this Form to the given new color."	"Warnings: This method modifies the receiver. It may lose some color accuracy on 32-bit Forms, since the transformation uses a color map with only 15-bit resolution."	| map |	depth < 16		ifTrue: [map _ (Color cachedColormapFrom: depth to: depth) copy]		ifFalse: [			"use maximum resolution color map"			"source is 16-bit or 32-bit RGB; use colormap with 5 bits per color component"			map _ Color computeRGBColormapFor: depth bitsPerColor: 5].	oldColorBitsCollection do:[ :oldColor | map at: oldColor put: newColorBits].	(BitBlt toForm: self)		sourceForm: self;		sourceOrigin: 0@0;		combinationRule: Form over;		destX: 0 destY: 0 width: width height: height;		colorMap: map;		copyBits.! !!Form methodsFor: 'transitions' stamp: 'jm 10/14/2002 19:02'!pageImage: otherImage at: topLeft corner: corner	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.  Corner specifies which corner, as		1=topLeft, 2=topRight, 3=bottomRight, 4=bottomLeft."	| bb maskForm resultForm delta maskLoc maskRect stepSize cornerSel smallRect p |	stepSize _ 10.	bb _ otherImage boundingBox.	resultForm _ self copy: (topLeft extent: bb extent).	maskForm _ Form extent: ((otherImage width min: otherImage height) + stepSize) asPoint.	"maskLoc _ starting loc rel to topLeft"	otherImage width > otherImage height		ifTrue: ["wide image; motion is horizontal."				(corner between: 2 and: 3) not ifTrue:					["motion is to the right"					delta _ 1@0.					maskLoc _ bb topLeft - (corner = 1						ifTrue: [maskForm width@0]						ifFalse: [maskForm width@stepSize])]					ifFalse:					["motion is to the left"					delta _ -1@0.					maskLoc _ bb topRight - (corner = 2						ifTrue: [0@0]						ifFalse: [0@stepSize])]]		ifFalse: ["tall image; motion is vertical."				corner <= 2 ifTrue:					["motion is downward"					delta _ 0@1.					maskLoc _ bb topLeft - (corner = 1						ifTrue: [0@maskForm height]						ifFalse: [stepSize@maskForm height])]					ifFalse:					["motion is upward"					delta _ 0@-1.					maskLoc _ bb bottomLeft - (corner = 3						ifTrue: [stepSize@0]						ifFalse: [0@0])]].	"Build a solid triangle in the mask form"	p _ Pen newOnForm: maskForm.	corner even  "Draw 45-degree line"		ifTrue: [p place: 0@0; turn: 135; go: maskForm width*3//2]		ifFalse: [p place: 0@(maskForm height-1); turn: 45; go: maskForm width*3//2].	maskForm smear: delta negated distance: maskForm width.	"Copy the mask to full resolution for speed.  Make it be the reversed	so that it can be used for ORing in the page-corner color"	maskForm _ (Form extent: maskForm extent depth: otherImage depth)		copyBits: maskForm boundingBox from: maskForm at: 0@0		colorMap: (Bitmap with: 16rFFFFFFFF with: 0).	"Now move the triangle maskForm across the resultForm selecting the	triangular part of otherImage to display, and across the resultForm,	selecting the part of the original image to erase."	cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: corner.	1 to: (otherImage width + otherImage height // stepSize)+1 do:		[:i |		"Determine the affected square"		maskRect _ (maskLoc extent: maskForm extent) intersect: bb.		((maskLoc x*delta x) + (maskLoc y*delta y)) < 0 ifTrue:			[smallRect _ 0@0 extent: (maskRect width min: maskRect height) asPoint.			maskRect _ smallRect align: (smallRect perform: cornerSel)								with: (maskRect perform: cornerSel)].		"AND otherForm with triangle mask, and OR into result"		resultForm copyBits: bb from: otherImage at: 0@0				clippingBox: maskRect rule: Form over fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form erase fillColor: nil.		resultForm copyBits: maskForm boundingBox from: maskForm at: maskLoc				clippingBox: maskRect rule: Form under fillColor: Color lightBrown.		"Now update Display in a single BLT."		self copyBits: maskRect from: resultForm at: topLeft + maskRect topLeft				clippingBox: self boundingBox rule: Form over fillColor: nil.		Display forceDisplayUpdate.		maskLoc _ maskLoc + (delta*stepSize)]"1 to: 4 do: [:corner | Display pageImage:				(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 corner: corner]"! !!Form methodsFor: 'transitions' stamp: 'jm 5/29/2003 17:59'!pageWarp: otherImage at: topLeft forward: forward	"Produce a page-turning illusion that gradually reveals otherImage	located at topLeft in this form.	forward == true means turn pages toward you, else away. [ignored for now]"	| pageRect oldPage nSteps buffer p leafRect sourceQuad warp oldBottom d |	pageRect _ otherImage boundingBox.	oldPage _ self copy: (pageRect translateBy: topLeft).	(forward ifTrue: [oldPage] ifFalse: [otherImage])		border: pageRect		widthRectangle: (Rectangle				left: 0				right: 2				top: 1				bottom: 1)		rule: Form over		fillColor: Color black.	oldBottom _ self copy: ((pageRect bottomLeft + topLeft) extent: (pageRect width@(pageRect height//4))).	nSteps _ 8.	buffer _ Form extent: otherImage extent + (0@(pageRect height//4)) depth: self depth.	d _ pageRect topLeft + (0@(pageRect height//4)) - pageRect topRight.	1 to: nSteps-1 do:		[:i | forward			ifTrue: [buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.					p _ pageRect topRight + (d * i // nSteps)]			ifFalse: [buffer copy: pageRect from: oldPage to: 0@0 rule: Form over.					p _ pageRect topRight + (d * (nSteps-i) // nSteps)].		buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.		leafRect _ pageRect topLeft corner: p x @ (pageRect bottom + p y).		sourceQuad _ Array with: pageRect topLeft			with: pageRect bottomLeft + (0@p y)			with: pageRect bottomRight			with: pageRect topRight - (0@p y).		warp _ (WarpBlt toForm: buffer)				clipRect: leafRect;				sourceForm: (forward ifTrue: [oldPage] ifFalse: [otherImage]);				combinationRule: Form paint.		warp copyQuad: sourceQuad toRect: leafRect.		self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.		Display forceDisplayUpdate].	buffer copy: pageRect from: otherImage to: 0@0 rule: Form over.	buffer copy: oldBottom boundingBox from: oldBottom to: pageRect bottomLeft rule: Form over.	self copy: buffer boundingBox from: buffer to: topLeft rule: Form over.	Display forceDisplayUpdate."1 to: 4 do: [:corner | Display pageWarp:				(Form fromDisplay: (10@10 extent: 200@300)) reverse			at: 10@10 forward: false]"! !!Form methodsFor: 'transitions' stamp: 'jm 6/18/1998 12:57'!wipeImage: otherImage at: topLeft clippingBox: clipBox rectForIndex: rectForIndexBlock	| i clipRect t rectOrList waitTime |	i _ 0.	clipRect _ topLeft extent: otherImage extent.	clipBox ifNotNil: [clipRect _ clipRect intersect: clipBox].	[rectOrList _ rectForIndexBlock value: (i _ i + 1).	 rectOrList == nil]		whileFalse: [			t _ Time millisecondClockValue.			rectOrList asOrderedCollection do: [:r |				self copyBits: r from: otherImage at: topLeft + r topLeft					clippingBox: clipRect rule: Form over fillColor: nil].			Display forceDisplayUpdate.			waitTime _ 3 - (Time millisecondClockValue - t).			waitTime > 0 ifTrue:				["(Delay forMilliseconds: waitTime) wait"]].! !!Form methodsFor: 'transitions' stamp: 'di 1/28/1999 09:20'!zoomIn: goingIn orOutTo: otherImage at: topLeft vanishingPoint: vp 	"Display zoomInTo: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40.	Display zoomOutTo: (Form fromDisplay: (40@40 extent: 300@300)) reverse at: 40@40."	| nSteps j bigR lilR minTime startTime lead |	nSteps _ 16.	minTime _ 500.  "milliseconds"	startTime _ Time millisecondClockValue.	^ self wipeImage: otherImage at: topLeft clippingBox: nil rectForIndex:		[:i | "i runs from 1 to nsteps"		i > nSteps			ifTrue: [nil "indicates all done"]			ifFalse:			["If we are going too fast, delay for a bit"			lead _ startTime + (i-1*minTime//nSteps) - Time millisecondClockValue.			lead > 10 ifTrue: [(Delay forMilliseconds: lead) wait].			"Return an array with the difference rectangles for this step."			j _ goingIn ifTrue: [i] ifFalse: [nSteps+1-i].			bigR _ vp - (vp*(j)//nSteps) corner:				vp + (otherImage extent-vp*(j)//nSteps).			lilR _ vp - (vp*(j-1)//nSteps) corner:				vp + (otherImage extent-vp*(j-1)//nSteps).			bigR areasOutside: lilR]]! !!Form methodsFor: 'private' stamp: 'tk 3/13/2000 15:21'!hackBits: bitThing	"This method provides an initialization so that BitBlt may be used, eg, to 	copy ByteArrays and other non-pointer objects efficiently.	The resulting form looks 4 wide, 8 deep, and bitThing-size-in-words high."	width _ 4.	depth _ 8.	bitThing class isBits ifFalse: [self error: 'bitThing must be a non-pointer object'].	bitThing class isBytes		ifTrue: [height _ bitThing basicSize // 4]		ifFalse: [height _ bitThing basicSize].	bits _ bitThing! !!Form methodsFor: 'private' stamp: 'jm 9/24/2003 12:15'!privateOffset	^ offset! !!Form methodsFor: 'private' stamp: 'ar 5/28/2000 15:49'!setExtent: extent depth: bitsPerPixel bits: bitmap	"Create a virtual bit map with the given extent and bitsPerPixel."	width _ extent x asInteger.	width < 0 ifTrue: [width _ 0].	height _ extent y asInteger.	height < 0 ifTrue: [height _ 0].	depth _ bitsPerPixel.	(bits isNil or:[self bitsSize = bitmap size]) ifFalse:[^self error:'Bad dimensions'].	bits _ bitmap! !!Form class methodsFor: 'instance creation' stamp: 'jm 6/15/2003 17:57'!dotOfSize: diameter	"Create a form which contains a round black dot."	| radius form bb rect centerX centerY centerYBias centerXBias radiusSquared xOverY maxy dx |	radius _ diameter//2.	form _ (self extent: diameter@diameter) offset:(radius@radius) negated.		bb _ (BitBlt toForm: form)		sourceX: 0; sourceY: 0;		combinationRule: Form over;		fillColor: Color black.	rect _ form boundingBox.	centerX _ rect center x.	centerY _ rect center y.	centerYBias _ rect height odd ifTrue: [0] ifFalse: [1].	centerXBias _ rect width odd ifTrue: [0] ifFalse: [1].	radiusSquared _ (rect height asFloat / 2.0) squared - 0.01.	xOverY _ rect width asFloat / rect height asFloat.	maxy _ rect height - 1 // 2.	"First do the inner fill, and collect x values"	0 to: maxy do:		[:dy |		dx _ ((radiusSquared - (dy * dy) asFloat) sqrt * xOverY) truncated.		bb	destX: centerX - centerXBias - dx			destY: centerY - centerYBias - dy			width: dx + dx + centerXBias + 1			height: 1;			copyBits.		bb	destY: centerY + dy;			copyBits].	^ form"Time millisecondsToRun:	[1 to: 20 do: [:i | (Form dotOfSize: i) displayAt: (i*20)@(i*20)]]"! !!Form class methodsFor: 'instance creation' stamp: 'ar 10/9/1998 23:44'!extent: extentPoint depth: bitsPerPixel bits: aBitmap	"Answer an instance of me with blank bitmap of the given dimensions and depth."	^ self basicNew setExtent: extentPoint depth: bitsPerPixel bits: aBitmap! !!Form class methodsFor: 'instance creation' stamp: 'jm 6/15/2003 18:05'!fromBinaryStream: aBinaryStream	"Read a Form or ColorForm from given file, using the first byte of the file to guess its format. Currently handles: GIF, uncompressed BMP, and both old and new DisplayObject writeOn: formats, JPEG, and PCX. Return nil if the file could not be read or was of an unrecognized format."	| firstByte secondByte readerClass |	aBinaryStream binary.	firstByte _ aBinaryStream next.	firstByte = 1 ifTrue: [		"old Squeakform format"		^ self new readFromOldFormat: aBinaryStream].	firstByte = 2 ifTrue: [		"new Squeak form format"		^ self new readFrom: aBinaryStream].	firstByte = $B asciiValue ifTrue: [		"BMP format"		aBinaryStream skip: - 1.		^ self fromBMPStream: aBinaryStream].	firstByte = 16rFF ifTrue: [		secondByte _ aBinaryStream next.		aBinaryStream skip: - 2.		secondByte = 16rD8 ifTrue: [			^ FastJPEG uncompress: aBinaryStream upToEnd doDithering: false]].	"Try for GIF, PNG, or other formats understood by subclasses of ImageReadWriter..."	(readerClass _ self imageReaderClass) ifNil: [self error: 'unknown image format'].	"Note: The following call closes the stream."	^ readerClass formFromStream: aBinaryStream! !!Form class methodsFor: 'instance creation' stamp: 'jm 1/11/1999 10:42'!fromFileNamed: fileName	"Read a Form or ColorForm from the given file."	| file form |	file _ (FileStream readOnlyFileNamed: fileName) binary.	form _ self fromBinaryStream: file.	file close.	^ form! !!Form class methodsFor: 'instance creation' stamp: 'jm 6/15/2003 17:54'!fromUser	"Answer an instance of me with bitmap initialized from the rectangle of the display screen designated by the user."	^ self fromDisplay: (Rectangle fromUser)! !!Form class methodsFor: 'mode constants' stamp: 'di 12/31/1998 14:02'!blendAlpha	"Answer the integer denoting BitBlt's blend-with-constant-alpha rule."	^ 30! !!Form class methodsFor: 'mode constants' stamp: 'di 12/31/1998 14:02'!paintAlpha	"Answer the integer denoting BitBlt's paint-with-constant-alpha rule."	^ 31! !!Form class methodsFor: 'examples' stamp: 'jm 6/15/2003 18:50'!exampleMagnify	"Form exampleMagnify"	| f m |	f _ Form fromUser.	m _ f magnify: f boundingBox by: 3.	m displayOn: Display.! !!Form class methodsFor: 'examples' stamp: 'jm 6/15/2003 17:58'!toothpaste: diam		"Display restoreAfter: [Form toothpaste: 30]"	"Draws wormlike lines by laying down images of spheres.	See Ken Knowlton, Computer Graphics, vol. 15 no. 4 p352.	Draw with mouse button down; terminate by option-click."	| facade ball filter point queue port color q colors colr colr2 |	colors _ Display depth = 1		ifTrue: [Array with: Color black]		ifFalse: [Color red wheel: 12].	facade _ (Form extent: diam@diam) offset: (diam//-2) asPoint.	(Form dotOfSize: diam) displayOn: facade			at: (diam//2) asPoint clippingBox: facade boundingBox			rule: Form under fillColor: Color white.	#(1 2 3) do:		[:x |  "simulate facade by circles of gray"		(Form dotOfSize: x*diam//5) displayOn: facade			at: (diam*2//5) asPoint clippingBox: facade boundingBox			rule: Form under			fillColor: (Color perform: 					(#(black gray lightGray) at: x)).		"facade displayAt: 50*x@50"].	ball _ Form dotOfSize: diam.	color _ 8.	[ true ] whileTrue:		[port _ BitBlt toForm: Display.		"Expand 1-bit forms to any pixel depth"		port colorMap: (Bitmap with: 0 with: 16rFFFFFFFF).		queue _ OrderedCollection new: 32.		16 timesRepeat: [queue addLast: -20@-20].		Sensor waitButton.		Sensor yellowButtonPressed ifTrue: [^ self].		filter _ Sensor cursorPoint.		colr _ colors atWrap: (color _ color + 5).  "choose increment relatively prime to colors size"		colr2 _ colr mixed: 0.3 with: Color white.		[Sensor redButtonPressed or: [queue size > 0]] whileTrue:			[filter _ filter * 4 + Sensor cursorPoint // 5.			point _ Sensor redButtonPressed				ifTrue: [filter] ifFalse: [-20@-20].			port copyForm: ball to: point rule: Form paint fillColor: colr.			(q _ queue removeFirst) == nil ifTrue: [^ self].	"exit"			Display depth = 1				ifTrue: [port copyForm: facade to: q rule: Form erase]				ifFalse: [port copyForm: facade to: q rule: Form paint fillColor: colr2].			Sensor redButtonPressed ifTrue: [queue addLast: point]]].! !!Form class methodsFor: 'shut down' stamp: 'jm 1/1/2004 11:10'!shutDown	"Compress all instances of Form and it's subclasses in the image to save space in snapshots. They will decompress on demand."	"Form shutDown"	Form allInstancesDo: [:f | f hibernate].	ColorForm allInstancesDo: [:f | f hibernate].! !!Form class methodsFor: 'private' stamp: 'di 2/3/1999 07:44'!bmpColorsFrom: aBinaryStream count: colorCount depth: depth	"Read colorCount BMP color map entries from the given binary stream. Answer an array of Colors."	| maxLevel colors b g r |	colorCount = 0 ifTrue: [  "this BMP file does not have a color map"		"default monochrome color map"		depth = 1 ifTrue: [^ Array with: Color white with: Color black].		"default gray-scale color map"		maxLevel _ (2 raisedTo: depth) - 1.		^ (0 to: maxLevel) collect: [:level | Color gray: (level asFloat / maxLevel)]].	colors _ Array new: colorCount.	1 to: colorCount do: [:i |		b _ aBinaryStream next.		g _ aBinaryStream next.		r _ aBinaryStream next.		aBinaryStream skip: 1.		colors at: i put: (Color r: r g: g b: b range: 255)].	^ colors! !!Form class methodsFor: 'private' stamp: 'jm 12/3/2003 15:52'!fromBMPStream: aBinaryStream	"Read a BMP format image from the given binary stream."	"Form fromBMPFile:		(HTTPSocket			httpGet: 'http://anHTTPServer/squeak/squeakers.bmp'			accept: 'image/bmp')"	| fType fSize reserved pixDataStart hdrSize w h planes d      compressed colorCount colors colorForm |	(aBinaryStream isMemberOf: String) ifTrue: [^ nil].  "a network error message"	aBinaryStream binary.	fType _ aBinaryStream littleEndianUint16.	fSize _ aBinaryStream littleEndianUint32.	reserved _ aBinaryStream littleEndianUint32.	pixDataStart _ aBinaryStream littleEndianUint32.	hdrSize _ aBinaryStream littleEndianUint32.	w _ aBinaryStream littleEndianUint32.	h _ aBinaryStream littleEndianUint32.	planes _ aBinaryStream littleEndianUint16.	d _ aBinaryStream littleEndianUint16.	compressed _ aBinaryStream littleEndianUint32.	aBinaryStream littleEndianUint32.  "biSizeImage"	aBinaryStream littleEndianUint32.  "biXPelsPerMeter"	aBinaryStream littleEndianUint32.  "biYPelsPerMeter"	colorCount _ aBinaryStream littleEndianUint32.	aBinaryStream littleEndianUint32.  "biClrImportant"	((fType = 19778) & (reserved = 0) & (planes = 1) &	 (hdrSize = 40) & (fSize <= aBinaryStream size))		ifFalse: [self error: 'Bad BMP file header'].	compressed = 0		ifFalse: [self error: 'Can only read uncompressed BMP files'].	d = 24 ifTrue: [		aBinaryStream position: pixDataStart.		^ self bmp24BitPixelDataFrom: aBinaryStream width: w height: h].	"read the color map"	"Note: some programs (e.g. Photoshop 4.0) apparently do not set colorCount; assume that any data between the end of the header and the start of the pixel data is the color map"	colorCount _ (pixDataStart - 54) // 4.	colors _ self bmpColorsFrom: aBinaryStream count: colorCount depth: d.	"read the pixel data"	aBinaryStream position: pixDataStart.	colorForm _ self bmpPixelDataFrom: aBinaryStream width: w height: h depth: d.	colorForm colors: colors.	^ colorForm! !!Form class methodsFor: 'private' stamp: 'jm 6/20/2003 09:08'!imageReaderClass	"If present, answer the class for importing various graphic image files from disk. Otherwise return nil."	| aClass |	^ ((aClass _ Smalltalk at: #ImageReadWriter ifAbsent: [nil]) isKindOf: Class)		ifTrue: [aClass]		ifFalse: [nil]! !My instances are used to save information needed to construct the switch in a menu for a FormEditor. A collection of my instances is stored as a class variable of FormMenuView.!I'm a subclass of Canvas for drawing on Forms.Note that when shadowDrawing is true, shadowStipple may be either a color, for a solid shadow of the given color, or it may be a stipple used to simulate gray shading when the display cannot support alpha blending.!!FormCanvas methodsFor: 'initialize-release' stamp: 'ar 2/17/2000 00:21'!reset	origin _ 0@0.							"origin of the top-left corner of this cavas"	clipRect _ (0@0 corner: 10000@10000).		"default clipping rectangle"	self shadowColor: nil.! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 5/28/2000 17:11'!allocateForm: extentPoint	"Allocate a new form which is similar to the receiver"	^form allocateForm: extentPoint! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 14:06'!clipRect	"Return the currently active clipping rectangle"	^ clipRect translateBy: origin negated! !!FormCanvas methodsFor: 'accessing' stamp: 'jm 6/15/2003 19:08'!contentsOfArea: aRectangle into: aForm	port destForm 		displayOn: aForm 		at: (aRectangle origin + origin) negated		clippingBox: (0@0 extent: aRectangle extent).	^ aForm! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 6/22/1999 14:10'!origin	"Return the current origin for drawing operations"	^ origin! !!FormCanvas methodsFor: 'accessing' stamp: 'jm 11/24/2002 11:16'!shadowColor	^ shadowColor! !!FormCanvas methodsFor: 'accessing' stamp: 'ar 2/17/2000 00:26'!shadowColor: aColor	shadowColor _ aColor! !!FormCanvas methodsFor: 'testing' stamp: 'ar 2/17/2000 00:24'!isShadowDrawing	^ self shadowColor notNil! !!FormCanvas methodsFor: 'testing' stamp: 'ar 6/22/1999 14:08'!isVisible: aRectangle	"Optimization"	(aRectangle right + origin x) < clipRect left	ifTrue: [^ false].	(aRectangle left + origin x) > clipRect right	ifTrue: [^ false].	(aRectangle bottom + origin y) < clipRect top	ifTrue: [^ false].	(aRectangle top + origin y) > clipRect bottom	ifTrue: [^ false].	^ true! !!FormCanvas methodsFor: 'copying' stamp: 'ar 6/17/1999 02:51'!copyClipRect: aRectangle	^ self copyOrigin: origin clipRect: (aRectangle translateBy: origin)! !!FormCanvas methodsFor: 'copying' stamp: 'ar 6/17/1999 02:52'!copyOffset: aPoint	^ self copyOrigin: origin + aPoint clipRect: clipRect! !!FormCanvas methodsFor: 'copying' stamp: 'ar 6/17/1999 02:52'!copyOffset: aPoint clipRect: sourceClip	"Make a copy of me offset by aPoint, and further clipped	by sourceClip, a rectangle in the un-offset coordinates"	^ self copyOrigin: aPoint + origin		clipRect: ((sourceClip translateBy: origin) intersect: clipRect)! !!FormCanvas methodsFor: 'copying' stamp: 'ar 6/17/1999 02:52'!copyOrigin: aPoint clipRect: aRectangle	"Return a copy of this canvas with the given origin. The clipping rectangle of this canvas is the intersection of the given rectangle and the receiver's current clipping rectangle. This allows the clipping rectangles of nested clipping morphs to be composed."	^ self copy		setOrigin: aPoint		clipRect: (clipRect intersect: aRectangle)! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 5/14/2000 15:50'!fillColor: c	"Note: This always fills, even if the color is transparent."	self setClearColor: c.	port fillRect: form boundingBox offset: origin.! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 2/17/2000 00:12'!line: pt1 to: pt2 brushForm: brush	| offset |	offset _ origin.	self setPaintColor: Color black.	port sourceForm: brush; fillColor: nil;		sourceRect: brush boundingBox;		colorMap: (brush colormapIfNeededForDepth: self depth);		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 2/16/2000 22:07'!line: pt1 to: pt2 width: w color: c	| offset |	offset _ origin - (w // 2) asPoint.	self setFillColor: c.	port width: w; height: w;		drawFrom: (pt1 + offset) to: (pt2 + offset)! !!FormCanvas methodsFor: 'drawing' stamp: 'jm 11/25/2002 12:39'!paragraph: para bounds: bounds color: c	| clipR scanner |	self setPaintColor: c.	clipR _ bounds translateBy: origin.	scanner _ (port clippedBy: clipR) displayScannerFor: para		foreground: (self shadowColor ifNil:[c]) background: Color transparent		ignoreColorChanges: self shadowColor notNil.	para displayOn: (self copyClipRect: bounds) using: scanner at: clipR topLeft.! !!FormCanvas methodsFor: 'drawing' stamp: 'ar 5/18/2000 18:35'!text: s bounds: boundsRect font: fontOrNil color: c	| scanner |	scanner _ DisplayScanner quickPrintOn: form				box: ((boundsRect translateBy: origin) intersect: clipRect) truncated				font: fontOrNil				color: (self shadowColor ifNil:[c]).	scanner drawString: s at: boundsRect topLeft + origin! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 03:02'!clipBy: aRectangle during: aBlock	"Set a clipping rectangle active only during the execution of aBlock.	Note: In the future we may want to have more general clip shapes - not just rectangles"	^aBlock value: (self copyClipRect: aRectangle)! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 5/25/2000 18:04'!transformBy: aDisplayTransform clippingTo: aClipRect during: aBlock	 smoothing: cellSize	"Note: This method has been originally copied from TransformationMorph."	| innerRect patchRect sourceQuad warp start subCanvas |	(aDisplayTransform isPureTranslation) ifTrue:[		^aBlock value: (self copyOffset: aDisplayTransform offset negated truncated							clipRect: aClipRect)	].	"Prepare an appropriate warp from patch to innerRect"	innerRect _ aClipRect.	patchRect _ aDisplayTransform globalBoundsToLocal: innerRect.	sourceQuad _ (aDisplayTransform sourceQuadFor: innerRect)					collect: [:p | p - patchRect topLeft].	warp _ self warpFrom: sourceQuad toRect: innerRect.	warp cellSize: cellSize.	"Render the submorphs visible in the clipping rectangle, as patchForm"	start _ (self depth = 1 and: [self isShadowDrawing not])		"If this is true B&W, then we need a first pass for erasure."		ifTrue: [1] ifFalse: [2].	start to: 2 do:		[:i | "If i=1 we first make a shadow and erase it for opaque whites in B&W"		subCanvas _ self class extent: patchRect extent depth: self depth.		i=1	ifTrue: [subCanvas shadowColor: Color black.					warp combinationRule: Form erase]			ifFalse: [self isShadowDrawing ifTrue:					[subCanvas shadowColor: self shadowColor].					warp combinationRule: Form paint].		subCanvas translateBy: patchRect topLeft negated			during:[:offsetCanvas| aBlock value: offsetCanvas].		warp sourceForm: subCanvas form; warpBits.		warp sourceForm: nil.  subCanvas _ nil "release space for next loop"]! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 03:03'!translateBy: delta clippingTo: aRectangle during: aBlock	"Set a translation and clipping rectangle only during the execution of aBlock."	^aBlock value: (self copyOffset: delta clipRect: aRectangle)! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 03:02'!translateBy: delta during: aBlock	"Set a translation only during the execution of aBlock."	^aBlock value: (self copyOffset: delta)! !!FormCanvas methodsFor: 'drawing-support' stamp: 'ar 6/17/1999 02:55'!translateTo: newOrigin clippingTo: aRectangle during: aBlock	"Set a new origin and clipping rectangle only during the execution of aBlock."	aBlock value: (self copyOrigin: newOrigin clipRect: aRectangle)! !!FormCanvas methodsFor: 'other'!forceToScreen:rect	^Display forceToScreen:rect.! !!FormCanvas methodsFor: 'other' stamp: 'ar 5/28/2000 17:07'!printOn: aStream	super printOn: aStream.	aStream nextPutAll:' on: '; print: form.! !!FormCanvas methodsFor: 'other' stamp: 'jm 5/29/2003 18:01'!showAt: pt invalidRects: updateRects	| blt |	blt _ (BitBlt toForm: Display)		sourceForm: form;		combinationRule: Form over.	updateRects do: [:rect |		blt sourceRect: rect;			destOrigin: rect topLeft + pt;			copyBits]! !!FormCanvas methodsFor: 'other' stamp: 'jm 5/29/2003 18:01'!warpFrom: sourceQuad toRect: destRect	^ (WarpBlt toForm: port destForm)		combinationRule: Form paint;		sourceQuad: sourceQuad destRect: (destRect translateBy: origin);		clipRect: clipRect! !!FormCanvas methodsFor: 'private' stamp: 'jm 11/12/2002 13:08'!resetGrafPort	"Private!! Create a new grafPort for a new copy."	port _ GrafPort toForm: form.	port clipRect: clipRect.! !!FormCanvas methodsFor: 'private' stamp: 'jm 10/7/2002 05:27'!setClearColor: aColor	"Install a new clear color - e.g., a color is used for clearing the background"	| clearColor |	clearColor _ aColor ifNil: [Color transparent].	clearColor isColor ifFalse: [		(clearColor isKindOf: InfiniteForm) ifFalse: [^ self error:'Cannot install color'].		port fillPattern: clearColor; combinationRule: Form over.		^ self].	"clearColor really *is* a color"	port sourceForm: nil.	port combinationRule: Form over.	port fillPattern: clearColor.	self depth = 8 ifTrue: [		"use a stipple pattern"		port fillColor: (clearColor balancedPatternForDepth: 8)].! !!FormCanvas methodsFor: 'private' stamp: 'jm 11/24/2002 11:36'!setFillColor: aColor	"Install a new color used for filling."	| screen patternWord fillColor |	fillColor _ self shadowColor ifNil: [aColor].	fillColor ifNil: [fillColor _ Color transparent].	fillColor isColor ifFalse: [		(fillColor isKindOf: InfiniteForm) ifFalse: [^ self error:'Cannot use an InfiniteForm here'].		port fillPattern: fillColor; combinationRule: Form over.  "use a stipple pattern"		^ self].	"fillColor really *is* a color"	port sourceForm: nil.	fillColor isTranslucent ifFalse: [		port combinationRule: Form over.		port fillPattern: fillColor.		self depth = 8 ifTrue: [			"In 8 bit depth it's usually a good idea to use a stipple pattern"			port fillColor: (fillColor balancedPatternForDepth: 8)].		^ self].	"fillColor is a translucent color"	self depth > 8 ifTrue: [		"BitBlt setup for alpha masked transfer"		port fillPattern: fillColor.		self depth = 16			ifTrue: [port alphaBits: fillColor privateAlpha; combinationRule: 30]			ifFalse: [port combinationRule: Form blend].		^ self].	"Can't represent actual transparency -- use stipple pattern"	screen _ Color translucentMaskFor: fillColor alpha depth: self depth.	patternWord _ fillColor pixelWordForDepth: self depth.	port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).	port combinationRule: Form paint.! !!FormCanvas methodsFor: 'private' stamp: 'jm 11/12/2002 13:08'!setForm: aForm	self reset.	form _ aForm.	port _ GrafPort toForm: form.! !!FormCanvas methodsFor: 'private' stamp: 'ar 6/22/1999 14:06'!setOrigin: aPoint clipRect: aRectangle	origin _ aPoint.	clipRect _ aRectangle.	port clipRect: aRectangle.! !!FormCanvas methodsFor: 'private' stamp: 'jm 10/7/2002 05:23'!setPaintColor: aColor	"Install a new color used for filling."	| paintColor screen patternWord |	paintColor _ self shadowColor ifNil: [aColor].	paintColor ifNil: [paintColor _ Color transparent].	paintColor isColor ifFalse:[		(paintColor isKindOf: InfiniteForm) ifFalse:[^ self error:'Cannot install color'].		port fillPattern: paintColor; combinationRule: Form paint.		^ self].	"Okay, so paintColor really *is* a color"	port sourceForm: nil.	(paintColor isTranslucent) ifFalse: [		port fillPattern: paintColor.		port combinationRule: Form paint.		self depth = 8 ifTrue: [			port fillColor: (paintColor balancedPatternForDepth: 8)].		^ self].	"paintColor is a translucent color"	self depth > 8 ifTrue: [		"BitBlt setup for alpha mapped transfer"		port fillPattern: paintColor.		self depth = 16			ifTrue: [port alphaBits: paintColor privateAlpha; combinationRule: 31]			ifFalse: [port combinationRule: Form blend].		^ self].	"Can't represent actual transparency -- use stipple pattern"	screen _ Color translucentMaskFor: paintColor alpha depth: self depth.	patternWord _ paintColor pixelWordForDepth: self depth.	port fillPattern: (screen collect: [:maskWord | maskWord bitAnd: patternWord]).	port combinationRule: Form paint! !!FormCanvas methodsFor: 'converting' stamp: 'jm 1/6/2003 12:25'!asShadowDrawingCanvas: aColor	"Answer a copy of me for drawing drop-shadows."	^ self copy shadowColor: aColor! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 5/14/2000 15:50'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth borderColor: borderColor	| rect |	rect _ r translateBy: origin.	"draw the border of the rectangle"	borderColor isTransparent ifFalse:[		self setFillColor: borderColor.		(r area > 10000 or: [fillColor isTranslucent]) ifTrue: [			port frameRect: rect borderWidth: borderWidth.		] ifFalse: ["for small rectangles, it's faster to fill the entire outer rectangle					than to compute and fill the border rects"					port fillRect: rect offset: origin]].	"fill the inside"	fillColor isTransparent ifFalse:		[self setFillColor: fillColor.		port fillRect: (rect insetBy: borderWidth) offset: origin].! !!FormCanvas methodsFor: 'drawing-rectangles' stamp: 'ar 2/16/2000 22:07'!frameAndFillRectangle: r fillColor: fillColor borderWidth: borderWidth topLeftColor: topLeftColor bottomRightColor: bottomRightColor	| w h rect |	"First use quick code for top and left borders and fill"	self frameAndFillRectangle: r		fillColor: fillColor		borderWidth: borderWidth		borderColor: topLeftColor.	"Now use slow code for bevelled bottom and right borders"	bottomRightColor isTransparent ifFalse: [		borderWidth isNumber			ifTrue: [w _ h _ borderWidth]			ifFalse: [w _ borderWidth x.   h _ borderWidth y].		rect _ r translateBy: origin.		self setFillColor: bottomRightColor.		port 			 frameRectRight: rect width: w;			 frameRectBottom: rect height: h].! !!FormCanvas methodsFor: 'drawing-ovals' stamp: 'jm 11/29/2002 09:29'!fillOval: r color: fillColor borderWidth: borderWidth borderColor: borderColor	| rect |	"draw the border of the oval"	rect _ r translateBy: origin.	borderColor isTransparent ifFalse:[		self setFillColor: borderColor.		(r area > 10000 or: [fillColor isTranslucent]) 			ifTrue: [port frameOval: rect borderWidth: borderWidth]			ifFalse: [port fillOval: rect]]. "faster this way"	"fill the inside"	fillColor isTransparent ifFalse: [		self setFillColor: fillColor.		port fillOval: (rect insetBy: borderWidth)].! !!FormCanvas methodsFor: 'drawing-images' stamp: 'jm 10/7/2002 05:27'!image: aForm at: aPoint sourceRect: sourceRect rule: rule 	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	port colorMap: (aForm colormapIfNeededForDepth: form depth); fillColor: nil.	port image: aForm at: aPoint + origin sourceRect: sourceRect rule: rule.! !!FormCanvas methodsFor: 'drawing-images' stamp: 'jm 3/18/2003 11:22'!image: aForm at: aPoint sourceRect: sourceRect rule: rule alpha: alpha	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	port colorMap: (aForm colormapIfNeededForDepth: form depth); fillColor: nil.	port image: aForm at: aPoint + origin sourceRect: sourceRect rule: rule alpha: alpha.! !!FormCanvas methodsFor: 'drawing-images' stamp: 'jm 10/7/2002 05:20'!stencil: stencilForm at: aPoint sourceRect: sourceRect color: aColor	"Flood this canvas with aColor wherever stencilForm has non-zero pixels"	self setPaintColor: aColor.	port colorMap: (Color maskingMap: stencilForm depth).	port stencil: stencilForm		at: aPoint + origin		sourceRect: sourceRect.! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 11/12/2002 12:23'!test1	"FormCanvas test1"	| canvas |	canvas _ FormCanvas extent: 200@200.	canvas fillColor: (Color black).	canvas line: 10@10 to: 50@30 width: 1 color: (Color red).	canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: (Color green).	canvas text: 'Hello, World!!' at: 40@40 font: nil color: (Color cyan).	canvas fillRectangle: ((10@80) corner: (31@121)) color: (Color magenta).	canvas fillOval: ((10@80) corner: (31@121)) color: (Color cyan).	canvas frameOval: ((40@80) corner: (61@121)) color: (Color blue).	canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: (Color red alpha: 0.2).	canvas fillRectangle: ((130@30) corner: (170@80)) color: (Color lightYellow).	canvas showAt: 0@0.! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 11/12/2002 12:23'!test2	"FormCanvas test2"	| baseCanvas p |	baseCanvas _ FormCanvas extent: 200@200.	p _ Sensor cursorPoint.	[Sensor anyButtonPressed] whileFalse: [		baseCanvas translateBy: (Sensor cursorPoint - p) during:[:canvas|			canvas fillColor: Color white.			canvas line: 10@10 to: 50@30 width: 1 color: Color red.			canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.			canvas text: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.			canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.			canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.			canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.			canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.			canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.			canvas showAt: 0@0]].! !!FormCanvas class methodsFor: 'testing' stamp: 'jm 11/12/2002 12:23'!test3	"FormCanvas test3"	| baseCanvas |	baseCanvas _ FormCanvas extent: 200@200.	baseCanvas fillColor: Color white.	baseCanvas translateBy: 10@10 during:[:canvas|		canvas shadowColor: (Color black alpha: 0.5).		canvas line: 10@10 to: 50@30 width: 1 color: Color red.		canvas frameRectangle: ((20@20) corner: (120@120)) width: 4 color: Color green.		canvas text: 'Hello, World!!' at: 40@40 font: nil color: Color cyan.		canvas fillRectangle: ((10@80) corner: (31@121)) color: Color magenta.		canvas fillOval: ((10@80) corner: (31@121)) color: Color cyan.		canvas frameOval: ((40@80) corner: (61@121)) color: Color blue.		canvas frameOval: ((70@80) corner: (91@121)) width: 3 color: Color red.		canvas fillRectangle: ((130@30) corner: (170@80)) color: Color lightYellow.		canvas showAt: 0@0.	].! !I represent a view of a Form. Editing takes place by modifying a working version of the Form. The message accept is used to copy the working version into the Form; the message cancel copies the Form into the working version.!I represent a Controller that takes control if a key on the keyboard is depressed or if the cursor is within my rectangular area.!I represent a View whose subViews are Switches (and Buttons and OneOnSwitches) whose actions set the mode, color, and tool for editing a Form on the screen. The default controller of my instances is FormMenuController.!I represent a view of a Form.!!FormView methodsFor: 'controller access' stamp: 'jm 10/4/2002 16:07'!defaultControllerClass  ^ NoController! !!FormView methodsFor: 'displaying' stamp: 'jm 5/12/2003 19:59'!displayOn: aBitBlt	(model isKindOf: InfiniteForm) ifTrue: [		model displayUsingBitBlt: aBitBlt at: self displayBox origin.		^ self].	aBitBlt copyForm: model to: self displayBox origin rule: Form over.! !!FormView class methodsFor: 'examples' stamp: 'di 9/12/1998 10:17'!open: aForm named: aString	"FormView open: ((Form extent: 100@100) borderWidth: 1) named: 'Squeak' "	"Open a window whose model is aForm and whose label is aString."	| topView aView |	topView _ StandardSystemView new.	topView model: aForm.	topView label: aString.	topView minimumSize: 80@80.	aView _ FormView new.	aView model: aForm.	aView window: (aForm boundingBox expandBy: 2).	aView borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	topView addSubView: aView.	topView controller open! !I represent some rational number as a fraction. All public arithmetic operations answer reduced fractions.!!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!* aNumber 	"Answer the result of multiplying the receiver by aNumber."	| d1 d2 |	aNumber isFraction ifTrue: 		[d1 _ numerator gcd: aNumber denominator.		d2 _ denominator gcd: aNumber numerator.		(d2 = denominator and: [d1 = aNumber denominator])			ifTrue: [^ numerator // d1 * (aNumber numerator // d2)].		^ Fraction numerator: numerator // d1 * (aNumber numerator // d2)				denominator: denominator // d2 * (aNumber denominator // d1)].	^ aNumber adaptToFraction: self andSend: #*! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!+ aNumber 	"Answer the sum of the receiver and aNumber."	| n d d1 d2 |	aNumber isFraction ifTrue: 		[d _ denominator gcd: aNumber denominator.		n _ numerator * (d1 _ aNumber denominator // d) + (aNumber numerator * (d2 _ denominator // d)).		d1 _ d1 * d2.		n _ n // (d2 _ n gcd: d).		(d _ d1 * (d // d2)) = 1 ifTrue: [^ n].		^ Fraction numerator: n denominator: d].	^ aNumber adaptToFraction: self andSend: #+! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!- aNumber	"Answer the difference between the receiver and aNumber."	aNumber isFraction ifTrue:		[^ self + aNumber negated].	^ aNumber adaptToFraction: self andSend: #-! !!Fraction methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:58'!/ aNumber	"Answer the result of dividing the receiver by aNumber."	aNumber isFraction		ifTrue: [^self * aNumber reciprocal].	^ aNumber adaptToFraction: self andSend: #/! !!Fraction methodsFor: 'comparing' stamp: 'di 11/6/1998 13:58'!< aNumber	aNumber isFraction ifTrue:		[^ numerator * aNumber denominator < (aNumber numerator * denominator)].	^ aNumber adaptToFraction: self andSend: #<! !!Fraction methodsFor: 'comparing' stamp: 'di 8/31/1999 10:33'!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isFraction		ifTrue: [numerator = 0 ifTrue: [^ aNumber numerator = 0].				^ (numerator * aNumber denominator) =					(aNumber numerator * denominator)				"Note: used to just compare num and denom,					but this fails for improper fractions"].	^ aNumber adaptToFraction: self andSend: #=! !!Fraction methodsFor: 'converting' stamp: 'di 11/6/1998 13:10'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Fraction."	^ rcvr asFraction perform: selector with: self! !!Fraction methodsFor: 'private' stamp: 'jm 5/22/2003 20:01'!setNumerator: n denominator: d	d = 0 ifTrue: [^ self error: 'division by 0'].	numerator _ n asInteger.	denominator _ d asInteger abs.  "keep sign in numerator"	d < 0 ifTrue: [numerator _ numerator negated].! !!Fraction class methodsFor: 'instance creation' stamp: 'di 8/31/1999 10:16'!numerator: numInteger denominator: denInteger 	"Answer an instance of me (numInteger/denInteger).	NOTE: This primitive initialization method will not reduce improper fractions,	so normal usage should be coded as, eg,		(Fraction numerator: a denominator: b) reduced	or, more simply, as		a / b."	^self new setNumerator: numInteger denominator: denInteger! !I use stepping both the measure and to report the current Morph frame rate.!!FrameRateMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:02'!includeInNewMorphMenu	^ true! !Copyright (c) Kazuki Yasumatsu, 1995. All rights reserved.Used with permission. Modified for use in Squeak.!!GIFReadWriter methodsFor: 'accessing' stamp: 'jm 10/14/2003 14:42'!nextImage	"Read in the next GIF image from the stream. Read it all into memory first for speed."	| f thisImageColorTable |	stream class == ReadWriteStream ifFalse: [		(stream respondsTo: #binary) ifTrue: [stream binary].		self on: (ReadWriteStream with: (stream contentsOfEntireFile))].	localColorTable _ nil.	self readHeader.	f _ self readBody.	self close.	f ifNil: [^ self error: 'corrupt GIF file'].	thisImageColorTable _ localColorTable ifNil: [colorPalette].	transparentIndex ifNotNil: [		transparentIndex + 1 > thisImageColorTable size ifTrue: [			thisImageColorTable _ thisImageColorTable 				forceTo: transparentIndex + 1 				paddingWith: Color white].		thisImageColorTable at: transparentIndex + 1 put: Color transparent].	f colors: thisImageColorTable.	^ f! !!GIFReadWriter methodsFor: 'accessing' stamp: 'jm 10/14/2003 20:02'!nextPutImage: aForm	| f newF |	aForm unhibernate.	f _ aForm.	f depth > 8 ifTrue: [		f _ aForm colorReduced8Bit.  "try to reduce depth"		f depth > 8 ifTrue: [f _ f asFormOfDepth: 8]].  "quantize colors"	f depth < 8 ifTrue: [		"Note: writeBitData: expects depth of 8"		newF _ f class extent: f extent depth: 8.		(f isKindOf: ColorForm)			ifTrue: [				newF					copyBits: f boundingBox					from: f at: 0@0					clippingBox: f boundingBox					rule: Form over					fillColor: nil					map: nil.				newF colors: f colors]			ifFalse: [f displayOn: newF].		f _ newF].	transparentIndex _ nil.	(f isKindOf: ColorForm) ifTrue: [		f _ f asFormWithSingleTransparentColor.		(f colorsUsed includes: Color transparent) ifTrue: [			transparentIndex _ (f colors indexOf: Color transparent) - 1]].	width _ f width.	height _ f height.	bitsPerPixel _ f depth.	colorPalette _ f colormapIfNeededForDepth: 32.	interlace _ false.	self writeHeader.	self writeBitData: f bits.	self nextPut: Terminator.	self close.! !!GIFReadWriter methodsFor: 'accessing' stamp: 'di 9/15/1998 09:53'!understandsImageFormat	^('abc' collect: [:x | stream next asCharacter]) = 'GIF'! !!GIFReadWriter methodsFor: 'animated GIF writing' stamp: 'jm 6/21/2003 19:19'!formToSaveFrom: aForm warnIfLosingColorPrecision: warningFlag	"Answer a copy of the given Form of the proper depth to be saved, reducing colors if necessary. If warningFlag is true and color precision will be lost, inform the user. Also record the color palette and the transparent color index."	| f newF |	aForm unhibernate.	f _  aForm.	f depth > 8 ifTrue: [		f _ aForm colorReduced.  "minimize depth"		f depth > 8 ifTrue: [			warningFlag ifTrue: [				self inform: 'Too many colors for GIF. Saving image using 8-bit colors.'].			"reduce to 8-bit color."			f _ f asFormOfDepth: 8]].	f depth < 8 ifTrue: [		"writeBitData: expects depth of 8"		newF _ f class extent: f extent depth: 8.		(f isKindOf: ColorForm)			ifTrue: [				newF					copyBits: f boundingBox					from: f at: 0@0					clippingBox: f boundingBox					rule: Form over					fillColor: nil					map: nil.				newF colors: f colors]			ifFalse: [f displayOn: newF].		f _ newF].	colorPalette _ f colormapIfNeededForDepth: 32.	interlace _ false.	transparentIndex _ nil.	((f isKindOf: ColorForm) and: [f colorsUsed includes: Color transparent]) ifTrue: [		transparentIndex _ (f colors indexOf: Color transparent) - 1].	^ f! !!GIFReadWriter methodsFor: 'animated GIF writing' stamp: 'jm 6/21/2003 17:31'!writeAnimatedGIF: forms allFrameDelays: delayInHundredths loopCount: loopCount	"Created an animated GIF from the given collection of Forms. The Forms must all be the same dimensions and depth. All frames will have the given frame delay in hundredths of a second.  If loopCount is zero, the animation will loop forever."	self		writeAnimatedGIF: (forms collect: [:f | Array with: f with: delayInHundredths])		loopCount: loopCount.! !!GIFReadWriter methodsFor: 'animated GIF writing' stamp: 'jm 6/22/2003 08:45'!writeAnimatedGIF: formsWithDelays loopCount: loopCount	"Created an animated GIF from the given collection of (<form>, <delay>) pairs. The Forms should all be the same dimensions and depth. Delays are in hundredths of a second. If loopCount is nil, the animation will loop forever."	| colorLimitedPairs f |	colorLimitedPairs _ formsWithDelays collect: [:pair |		f _ pair first asFormOfDepth: 8.  "for now, use 8-bit Squeak color palette for all forms"		Array with: f with: pair second].	f _ colorLimitedPairs first first.	width _ f width.	height _ f height.	bitsPerPixel _ f depth.	colorPalette _ f colormapIfNeededForDepth: 32.	interlace _ false.	transparentIndex _ nil.	((f isKindOf: ColorForm) and: [f colorsUsed includes: Color transparent]) ifTrue: [		transparentIndex _ (f colors indexOf: Color transparent) - 1].	self writeAnimatedGIFHeader: loopCount.	colorLimitedPairs do: [:pair | self writeAnimatedGIFFrame: pair first delay: pair last].	self nextPut: Terminator.	self close.! !!GIFReadWriter methodsFor: 'animated GIF writing' stamp: 'jm 6/22/2003 08:25'!writeAnimatedGIFFrame: aForm delay: delayInHundredths	"Write one frame of an animated GIF with the given delay in hundredths (1/100's) of a second."	((aForm width = width) &	 (aForm height = height) &	 (aForm depth = bitsPerPixel)) ifFalse: [		^ self error: 'All images of an animated GIF must be the same size and depth'].	"extensions to record the frame delay and transparent color index, if any"	self nextPut: Extension;		nextPutAll: #(16rF9 4) asByteArray;		nextPut: (transparentIndex isNil ifTrue: [0] ifFalse: [9]);		writeWord: (delayInHundredths isNil ifTrue: [0] ifFalse: [delayInHundredths]);		nextPut: (transparentIndex isNil ifTrue: [0] ifFalse: [transparentIndex]);		nextPut: 0.	self nextPut: ImageSeparator.	self writeWord: 0.		"Image Left"	self writeWord: 0.		"Image Top"	self writeWord: width.	"Image Width"	self writeWord: height.	"Image Height"	self nextPut: (interlace ifTrue: [16r40] ifFalse: [0]).	self writeBitData: aForm bits.! !!GIFReadWriter methodsFor: 'animated GIF writing' stamp: 'jm 6/22/2003 08:45'!writeAnimatedGIFHeader: loopCount	"Write the file header for an animated GIF."	| byte |	self nextPutAll: 'GIF89a' asByteArray.	self writeWord: width.	"Screen Width"	self writeWord: height.	"Screen Height"	byte _ 16r80.  "has color map"	byte _ byte bitOr: ((bitsPerPixel - 1) bitShift: 5).  "color resolution"	byte _ byte bitOr: bitsPerPixel - 1.  "bits per pixel"	self nextPut: byte.	self nextPut: 0.		"background color."	self nextPut: 0.		"reserved"	colorPalette do: [:pixelValue |		self	nextPut: ((pixelValue bitShift: -16) bitAnd: 255);			nextPut: ((pixelValue bitShift: -8) bitAnd: 255);			nextPut: (pixelValue bitAnd: 255)].	loopCount ifNotNil: [		"Write a Netscape loop chunk:"		self nextPut: Extension.		self nextPutAll: #(255 11 78 69 84 83 67 65 80 69 50 46 48 3 1) asByteArray.		self writeWord: (loopCount max: 0).		self nextPut: 0].! !!GIFReadWriter methodsFor: 'private-encoding' stamp: 'jm 6/21/2003 13:08'!writeBitData: bits	"using modified Lempel-Ziv Welch algorithm."	| maxBits maxMaxCode tSize initCodeSize ent tShift fCode pixel index disp nomatch |	pass _ 0.	xpos _ 0.	ypos _ 0.	rowByteSize _ width * 8 + 31 // 32 * 4.	remainBitCount _ 0.	bufByte _ 0.	bufStream _ WriteStream on: (ByteArray new: 256).	maxBits _ 12.	maxMaxCode _ 1 bitShift: maxBits.	tSize _ 5003.	prefixTable _ Array new: tSize.	suffixTable _ Array new: tSize.	initCodeSize _ bitsPerPixel <= 1 ifTrue: [2] ifFalse: [bitsPerPixel].	self nextPut: initCodeSize.	self setParameters: initCodeSize.	tShift _ 0.	fCode _ tSize.	[fCode < 65536] whileTrue:		[tShift _ tShift + 1.		fCode _ fCode * 2].	tShift _ 8 - tShift.	1 to: tSize do: [:i | suffixTable at: i put: -1].	self writeCodeAndCheckCodeSize: clearCode.	ent _ self readPixelFrom: bits.	[(pixel _ self readPixelFrom: bits) == nil] whileFalse:		[		fCode _ (pixel bitShift: maxBits) + ent.		index _ ((pixel bitShift: tShift) bitXor: ent) + 1.		(suffixTable at: index) = fCode			ifTrue: [ent _ prefixTable at: index]			ifFalse:				[nomatch _ true.				(suffixTable at: index) >= 0					ifTrue:						[disp _ tSize - index + 1.						index = 1 ifTrue: [disp _ 1].						"probe"						[(index _ index - disp) < 1 ifTrue: [index _ index + tSize].						(suffixTable at: index) = fCode							ifTrue:								[ent _ prefixTable at: index.								nomatch _ false.								"continue whileFalse:"].						nomatch and: [(suffixTable at: index) > 0]]							whileTrue: ["probe"]].				"nomatch"				nomatch ifTrue:					[self writeCodeAndCheckCodeSize: ent.					ent _ pixel.					freeCode < maxMaxCode						ifTrue:							[prefixTable at: index put: freeCode.							suffixTable at: index put: fCode.							freeCode _ freeCode + 1]						ifFalse:							[self writeCodeAndCheckCodeSize: clearCode.							1 to: tSize do: [:i | suffixTable at: i put: -1].							self setParameters: initCodeSize]]]].	prefixTable _ suffixTable _ nil.	self writeCodeAndCheckCodeSize: ent.	self writeCodeAndCheckCodeSize: eoiCode.	self flushBits.	self nextPut: 0.	"zero-length packet"! !!GIFReadWriter methodsFor: 'private-decoding' stamp: 'jm 10/27/2002 08:38'!hasMagicNumber: aByteArray	| oldP |	oldP _ stream position.	((stream size - oldP) >= aByteArray size and:	 [(stream next: aByteArray size) = aByteArray])		ifTrue: [^ true].	stream position: oldP.	^ false! !!GIFReadWriter methodsFor: 'private-decoding' stamp: 'RAA 4/25/2001 09:31'!readBitData	"using modified Lempel-Ziv Welch algorithm."	| outCodes outCount bitMask initCodeSize code curCode oldCode inCode finChar i bytes f c packedBits hasLocalColor localColorSize maxOutCodes |	maxOutCodes _ 4096.	self readWord.	"skip Image Left"	self readWord.	"skip Image Top"	width _ self readWord.	height _ self readWord.	"---	Local Color Table Flag        1 Bit	Interlace Flag                1 Bit	Sort Flag                     1 Bit	Reserved                      2 Bits	Size of Local Color Table     3 Bits	----"	packedBits _ self next.	interlace _ (packedBits bitAnd: 16r40) ~= 0.	hasLocalColor _ (packedBits bitAnd: 16r80) ~= 0.	localColorSize _ 1 bitShift: ((packedBits bitAnd: 16r7) + 1).	hasLocalColor ifTrue: [localColorTable _ self readColorTable: localColorSize].	pass _ 0.	xpos _ 0.	ypos _ 0.	rowByteSize _ ((width + 3) // 4) * 4.	remainBitCount _ 0.	bufByte _ 0.	bufStream _ ReadStream on: ByteArray new.	outCodes _ ByteArray new: maxOutCodes + 1.	outCount _ 0.	bitMask _ (1 bitShift: bitsPerPixel) - 1.	prefixTable _ Array new: 4096.	suffixTable _ Array new: 4096.	initCodeSize _ self next.	self setParameters: initCodeSize.	bitsPerPixel > 8 ifTrue: [^self error: 'never heard of a GIF that deep'].	bytes _ ByteArray new: rowByteSize * height.	[(code _ self readCode) = eoiCode] whileFalse:		[code = clearCode			ifTrue:				[self setParameters: initCodeSize.				curCode _ oldCode _ code _ self readCode.				finChar _ curCode bitAnd: bitMask.				"Horrible hack to avoid running off the end of the bitmap.  Seems to cure problem reading some gifs!!? tk 6/24/97 20:16"				xpos = 0 ifTrue: [						ypos < height ifTrue: [							bytes at: (ypos * rowByteSize) + xpos + 1 put: finChar]]					ifFalse: [bytes at: (ypos * rowByteSize) + xpos + 1 put: finChar].				self updatePixelPosition]			ifFalse:				[curCode _ inCode _ code.				curCode >= freeCode ifTrue:					[curCode _ oldCode.					outCodes at: (outCount _ outCount + 1) put: finChar].				[curCode > bitMask] whileTrue:					[outCount > maxOutCodes						ifTrue: [^self error: 'corrupt GIF file (OutCount)'].					outCodes at: (outCount _ outCount + 1)						put: (suffixTable at: curCode + 1).					curCode _ prefixTable at: curCode + 1].				finChar _ curCode bitAnd: bitMask.				outCodes at: (outCount _ outCount + 1) put: finChar.				i _ outCount.				[i > 0] whileTrue:					["self writePixel: (outCodes at: i) to: bits"					bytes at: (ypos * rowByteSize) + xpos + 1 put: (outCodes at: i).					self updatePixelPosition.					i _ i - 1].				outCount _ 0.				prefixTable at: freeCode + 1 put: oldCode.				suffixTable at: freeCode + 1 put: finChar.				oldCode _ inCode.				freeCode _ freeCode + 1.				self checkCodeSize]].	prefixTable _ suffixTable _ nil.	f _ ColorForm extent: width@height depth: 8.	f bits copyFromByteArray: bytes.	"Squeak can handle depths 1, 2, 4, and 8"	bitsPerPixel > 4 ifTrue: [^ f].	"reduce depth to save space"	c _ ColorForm extent: width@height		depth: (bitsPerPixel = 3 ifTrue: [4] ifFalse: [bitsPerPixel]).	f displayOn: c.	^ c! !!GIFReadWriter methodsFor: 'private-decoding' stamp: 'jm 6/21/2003 11:38'!readBody	"Read the GIF blocks. Modified to return a form.  "	| form extype block blocksize packedFields |	form _ nil.	[stream atEnd] whileFalse: [		block _ self next.		block = Terminator ifTrue: [^ form ].		block = ImageSeparator ifTrue: [			form isNil				ifTrue: [form _ self readBitData]				ifFalse: [self skipBitData].		] ifFalse: [			block = Extension				ifFalse: [^ form "^ self error: 'Unknown block type'"].			"Extension block"			extype _ self next.	"extension type"			extype = 16rF9 ifTrue: [  "graphics control"				self next = 4 ifFalse: [^ form "^ self error: 'corrupt GIF file'"].				"====				Reserved                      3 Bits				Disposal Method               3 Bits				User Input Flag               1 Bit				Transparent Color Flag        1 Bit				===" 				packedFields _ self next.				self next.	"delay time 1"				self next.	"delay time 2"				transparentIndex _ self next.				(packedFields bitAnd: 1) = 0 ifTrue: [transparentIndex _ nil].				self next = 0 ifFalse: [^ form "^ self error: 'corrupt GIF file'"].			] ifFalse: [  "Skip blocks"				[(blocksize _ self next) > 0]					whileTrue: [self next: blocksize]]]].! !!GIFReadWriter methodsFor: 'private-decoding' stamp: 'RAA 4/25/2001 08:48'!readColorTable: numberOfEntries	| array r g b |	array _ Array new: numberOfEntries.	1 to: array size do: [ :i |		r _ self next.  		g _ self next.  		b _ self next.		array at: i put: (Color r: r g: g b: b range: 255)	].	^array! !!GIFReadWriter methodsFor: 'private-decoding' stamp: 'jm 10/14/2003 14:38'!readHeader	| is89 byte hasColorMap |	(self hasMagicNumber: 'GIF87a' asByteArray)		ifTrue: [is89 _ false]		ifFalse: [			(self hasMagicNumber: 'GIF89a' asByteArray)				ifTrue: [is89 _ true]				ifFalse: [^ self error: 'This does not appear to be a GIF file']].	self readWord.  "skip Screen Width"	self readWord.  "skip Screen Height"	byte _ self next.	hasColorMap _ (byte bitAnd: 16r80) ~= 0.	bitsPerPixel _ (byte bitAnd: 7) + 1.	byte _ self next.  "skip background color."	self next ~= 0 ifTrue: [		is89 ifFalse: [^ self error: 'corrupt GIF file (screen descriptor)']].	hasColorMap		ifTrue: [colorPalette _ self readColorTable: (1 bitShift: bitsPerPixel)]		ifFalse: [colorPalette _ nil].  "use default; typically only 1-bit, B/W GIFs lack a palette"! !!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:36'!bytesPerEncodedFrame	^ 33! !!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:44'!decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex	| p |	p _ self	primDecode: decodeState frames: frameCount			from: srcByteArray at: srcIndex			into: dstSoundBuffer at: dstIndex.	^ Array with: p x with: p y! !!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:44'!encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	| p |	p _ self	primEncode: encodeState frames: frameCount			from: srcSoundBuffer at: srcIndex			into: dstByteArray at: dstIndex.	^ Array with: p x with: p y! !!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:32'!reset	"Reset my encoding/decoding state to prepare to encode or decode a new sound stream."	encodeState _ self primNewState.	decodeState _ self primNewState.! !!GSMCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:36'!samplesPerFrame	^ 160! !!GSMCodec methodsFor: 'primitives' stamp: 'jm 2/4/1999 11:33'!primDecode: state frames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	<primitive: 'primitiveGSMDecode' module: 'SoundCodecPrims'>	self primitiveFailed.! !!GSMCodec methodsFor: 'primitives' stamp: 'jm 2/4/1999 11:33'!primEncode: state frames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	<primitive: 'primitiveGSMEncode' module: 'SoundCodecPrims'>	self primitiveFailed.! !!GSMCodec methodsFor: 'primitives' stamp: 'jm 2/4/1999 11:35'!primNewState	<primitive: 'primitiveGSMNewState' module: 'SoundCodecPrims'>	self error: 'The SoundCodecPrims plugin is not available'.! !!GZipReadStream methodsFor: 'initialize' stamp: 'ar 12/27/1999 15:37'!on: aCollection from: firstIndex to: lastIndex	"Check the header of the GZIP stream."	| method magic flags length |	super on: aCollection from: firstIndex to: lastIndex.	magic _ self nextBits: 16.	(magic = GZipMagic) 		ifFalse:[^self error:'Not a GZipped stream'].	method _ self nextBits: 8.	(method = GZipDeflated)		ifFalse:[^self error:'Bad compression method'].	flags _ self nextBits: 8.	(flags anyMask: GZipEncryptFlag) 		ifTrue:[^self error:'Cannot decompress encrypted stream'].	(flags anyMask: GZipReservedFlags)		ifTrue:[^self error:'Cannot decompress stream with unknown flags'].	"Ignore stamp, extra flags, OS type"	self nextBits: 16; nextBits: 16. "stamp"	self nextBits: 8. "extra flags"	self nextBits: 8. "OS type"	(flags anyMask: GZipContinueFlag) "Number of multi-part archive - ignored"		ifTrue:[self nextBits: 16]. 	(flags anyMask: GZipExtraField) "Extra fields - ignored"		ifTrue:[	length _ self nextBits: 16.				1 to: length do:[:i| self nextBits: 8]].	(flags anyMask: GZipNameFlag) "Original file name - ignored"		ifTrue:[[(self nextBits: 8) = 0] whileFalse].	(flags anyMask: GZipCommentFlag) "Comment - ignored"		ifTrue:[[(self nextBits: 8) = 0] whileFalse].! !!GZipReadStream class methodsFor: 'class initialization' stamp: 'ar 12/27/1999 15:37'!initialize	"GZipReadStream initialize"	#(		(GZipMagic 16r8B1F)		"GZIP magic number"		(GZipDeflated 8)			"Compression method"		(GZipAsciiFlag 16r01)		"Contents is ASCII"		(GZipContinueFlag 16r02)	"Part of a multi-part archive"		(GZipExtraField 16r04)	"Archive has extra fields"		(GZipNameFlag 16r08)	"Archive has original file name"		(GZipCommentFlag 16r10)	"Archive has comment"		(GZipEncryptFlag 16r20)	"Archive is encrypted"		(GZipReservedFlags 16rC0)"Reserved" 	) do:[:spec|		GZipConstants declare: spec first from: Undeclared.		GZipConstants at: spec first put: spec last.	].! !!GZipWriteStream methodsFor: 'initialize-release' stamp: 'ar 12/29/1999 20:07'!on: aCollection	crc _ 16rFFFFFFFF.	crcPosition _ 1.	bytesWritten _ 0.	super on: aCollection.	self writeHeader.! !!GZipWriteStream methodsFor: 'initialize-release' stamp: 'ar 1/2/2000 16:36'!release	"Write crc and the number of bytes encoded"	super release.	self updateCrc.	crc _ crc bitXor: 16rFFFFFFFF.	encoder flushBits.	0 to: 3 do:[:i| encoder nextBytePut: (crc >> (i*8) bitAnd: 255)].	0 to: 3 do:[:i| encoder nextBytePut: (bytesWritten >> (i*8) bitAnd: 255)].! !!GZipWriteStream methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 11:41'!writeHeader	"Write the GZip header"	encoder nextBits: 16 put: GZipMagic.	encoder nextBits: 8 put: GZipDeflated.	encoder nextBits: 8 put: 0. "No flags"	encoder nextBits: 32 put: 0. "no time stamp"	encoder nextBits: 8 put: 0. "No extra flags"	encoder nextBits: 8 put: 0. "No OS type"! !!GZipWriteStream methodsFor: 'private' stamp: 'ar 12/27/1999 17:12'!moveContentsToFront	"Need to update crc here"	self updateCrc.	super moveContentsToFront.	crcPosition _ position + 1.! !!GZipWriteStream methodsFor: 'private' stamp: 'ar 12/29/1999 20:09'!updateCrc	crcPosition <= position ifTrue:[		bytesWritten _ bytesWritten + position - crcPosition + 1.		crc _ self updateCrc: crc from: crcPosition to: position in: collection.		crcPosition _ position + 1].! !!GZipWriteStream methodsFor: 'private' stamp: 'ar 12/27/1999 21:17'!updateCrc: oldCrc from: start to: stop in: aCollection	| newCrc |	<primitive: 'primitiveUpdateGZipCrc32'>	newCrc _ oldCrc.	start to: stop do:[:i|		newCrc _ (CrcTable at: ((newCrc bitXor: (aCollection byteAt: i)) 				bitAnd: 255) + 1) bitXor: (newCrc bitShift: -8).	].	^newCrc! !!GZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 12/30/1999 14:35'!crcTable	^CrcTable! !!GZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 12/27/1999 16:55'!initialize	"GZipWriteStream initialize"	CrcTable _ #(16r00000000 16r77073096 16rEE0E612C 16r990951BA 16r076DC419  16r706AF48F 16rE963A535 16r9E6495A3 16r0EDB8832 16r79DCB8A4  16rE0D5E91E 16r97D2D988 16r09B64C2B 16r7EB17CBD 16rE7B82D07  16r90BF1D91 16r1DB71064 16r6AB020F2 16rF3B97148 16r84BE41DE  16r1ADAD47D 16r6DDDE4EB 16rF4D4B551 16r83D385C7 16r136C9856  16r646BA8C0 16rFD62F97A 16r8A65C9EC 16r14015C4F 16r63066CD9  16rFA0F3D63 16r8D080DF5 16r3B6E20C8 16r4C69105E 16rD56041E4  16rA2677172 16r3C03E4D1 16r4B04D447 16rD20D85FD 16rA50AB56B  16r35B5A8FA 16r42B2986C 16rDBBBC9D6 16rACBCF940 16r32D86CE3  16r45DF5C75 16rDCD60DCF 16rABD13D59 16r26D930AC 16r51DE003A  16rC8D75180 16rBFD06116 16r21B4F4B5 16r56B3C423 16rCFBA9599  16rB8BDA50F 16r2802B89E 16r5F058808 16rC60CD9B2 16rB10BE924  16r2F6F7C87 16r58684C11 16rC1611DAB 16rB6662D3D 16r76DC4190  16r01DB7106 16r98D220BC 16rEFD5102A 16r71B18589 16r06B6B51F  16r9FBFE4A5 16rE8B8D433 16r7807C9A2 16r0F00F934 16r9609A88E  16rE10E9818 16r7F6A0DBB 16r086D3D2D 16r91646C97 16rE6635C01  16r6B6B51F4 16r1C6C6162 16r856530D8 16rF262004E 16r6C0695ED  16r1B01A57B 16r8208F4C1 16rF50FC457 16r65B0D9C6 16r12B7E950  16r8BBEB8EA 16rFCB9887C 16r62DD1DDF 16r15DA2D49 16r8CD37CF3  16rFBD44C65 16r4DB26158 16r3AB551CE 16rA3BC0074 16rD4BB30E2  16r4ADFA541 16r3DD895D7 16rA4D1C46D 16rD3D6F4FB 16r4369E96A  16r346ED9FC 16rAD678846 16rDA60B8D0 16r44042D73 16r33031DE5  16rAA0A4C5F 16rDD0D7CC9 16r5005713C 16r270241AA 16rBE0B1010  16rC90C2086 16r5768B525 16r206F85B3 16rB966D409 16rCE61E49F  16r5EDEF90E 16r29D9C998 16rB0D09822 16rC7D7A8B4 16r59B33D17  16r2EB40D81 16rB7BD5C3B 16rC0BA6CAD 16rEDB88320 16r9ABFB3B6  16r03B6E20C 16r74B1D29A 16rEAD54739 16r9DD277AF 16r04DB2615  16r73DC1683 16rE3630B12 16r94643B84 16r0D6D6A3E 16r7A6A5AA8  16rE40ECF0B 16r9309FF9D 16r0A00AE27 16r7D079EB1 16rF00F9344  16r8708A3D2 16r1E01F268 16r6906C2FE 16rF762575D 16r806567CB  16r196C3671 16r6E6B06E7 16rFED41B76 16r89D32BE0 16r10DA7A5A  16r67DD4ACC 16rF9B9DF6F 16r8EBEEFF9 16r17B7BE43 16r60B08ED5  16rD6D6A3E8 16rA1D1937E 16r38D8C2C4 16r4FDFF252 16rD1BB67F1  16rA6BC5767 16r3FB506DD 16r48B2364B 16rD80D2BDA 16rAF0A1B4C  16r36034AF6 16r41047A60 16rDF60EFC3 16rA867DF55 16r316E8EEF  16r4669BE79 16rCB61B38C 16rBC66831A 16r256FD2A0 16r5268E236  16rCC0C7795 16rBB0B4703 16r220216B9 16r5505262F 16rC5BA3BBE  16rB2BD0B28 16r2BB45A92 16r5CB36A04 16rC2D7FFA7 16rB5D0CF31  16r2CD99E8B 16r5BDEAE1D 16r9B64C2B0 16rEC63F226 16r756AA39C  16r026D930A 16r9C0906A9 16rEB0E363F 16r72076785 16r05005713  16r95BF4A82 16rE2B87A14 16r7BB12BAE 16r0CB61B38 16r92D28E9B  16rE5D5BE0D 16r7CDCEFB7 16r0BDBDF21 16r86D3D2D4 16rF1D4E242  16r68DDB3F8 16r1FDA836E 16r81BE16CD 16rF6B9265B 16r6FB077E1  16r18B74777 16r88085AE6 16rFF0F6A70 16r66063BCA 16r11010B5C  16r8F659EFF 16rF862AE69 16r616BFFD3 16r166CCF45 16rA00AE278  16rD70DD2EE 16r4E048354 16r3903B3C2 16rA7672661 16rD06016F7  16r4969474D 16r3E6E77DB 16rAED16A4A 16rD9D65ADC 16r40DF0B66  16r37D83BF0 16rA9BCAE53 16rDEBB9EC5 16r47B2CF7F 16r30B5FFE9  16rBDBDF21C 16rCABAC28A 16r53B39330 16r24B4A3A6 16rBAD03605  16rCDD70693 16r54DE5729 16r23D967BF 16rB3667A2E 16rC4614AB8  16r5D681B02 16r2A6F2B94 16rB40BBE37 16rC30C8EA1 16r5A05DF1B  16r2D02EF8D).! !I am a subclass of BitBlt used by FormCanvas.!!GrafPort methodsFor: 'accessing' stamp: 'ar 2/17/2000 01:07'!alphaBits: a	alpha _ a! !!GrafPort methodsFor: 'accessing' stamp: 'ar 5/18/2000 18:34'!displayScannerFor: para foreground: foreColor background: backColor ignoreColorChanges: shadowMode	^ (DisplayScanner new text: para text textStyle: para textStyle			foreground: foreColor background: backColor fillBlt: self			ignoreColorChanges: shadowMode)		setPort: self clone! !!GrafPort methodsFor: 'accessing' stamp: 'ar 2/17/2000 01:09'!fillPattern: anObject	fillPattern _ anObject.	self fillColor: anObject.! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/16/2000 22:32'!fillOval: rect	| centerX centerY nextY yBias xBias outer nextOuterX |	rect area <= 0 ifTrue: [^ self].	height _ 1.	yBias _ rect height odd ifTrue: [0] ifFalse: [-1].	xBias _ rect width odd ifTrue: [1] ifFalse: [0].	centerX _ rect center x.	centerY _ rect center y.	outer _ EllipseMidpointTracer new on: rect.	nextY _ rect height // 2.	[nextY > 0] whileTrue:[		nextOuterX _ outer stepInY.		width _ (nextOuterX bitShift: 1) + xBias.		destX _ centerX - nextOuterX.		destY _ centerY - nextY.		self copyBits.		destY _ centerY + nextY + yBias.		self copyBits.		nextY _ nextY - 1.	].	destY _ centerY.	height _ 1 + yBias.	width _ rect width.	destX _ rect left.	self copyBits.! !!GrafPort methodsFor: 'drawing support' stamp: 'jm 5/12/2003 19:59'!fillRect: rect offset: aPoint	"The offset is really just for stupid InfiniteForms."	| fc |	fillPattern class == InfiniteForm ifTrue:[		fc _ halftoneForm.		self fillColor: nil.		fillPattern displayUsingBitBlt: ((self clippedBy: rect) colorMap: nil) at: aPoint.		halftoneForm _ fc.		^ self].	destX _ rect left.	destY _ rect top.	sourceX _ 0.	sourceY _ 0.	width _ rect width.	height _ rect height.	self copyBits.! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/16/2000 22:26'!frameOval: rect borderWidth: borderWidth	| centerX centerY nextY yBias xBias wp outer inner nextOuterX nextInnerX fillAlpha |	rect area <= 0 ifTrue: [^ self].	height _ 1.	wp _ borderWidth asPoint.	yBias _ rect height odd ifTrue: [0] ifFalse: [-1].	xBias _ rect width odd ifTrue: [1] ifFalse: [0].	centerX _ rect center x.	centerY _ rect center y.	outer _ EllipseMidpointTracer new on: rect.	inner _ EllipseMidpointTracer new on: (rect insetBy: wp).	nextY _ rect height // 2.	1 to: (wp y min: nextY) do:[:i|		nextOuterX _ outer stepInY.		width _ (nextOuterX bitShift: 1) + xBias.		destX _ centerX - nextOuterX.		destY _ centerY - nextY.		self copyBits.		destY _ centerY + nextY + yBias.		self copyBits.		nextY _ nextY - 1.	].	[nextY > 0] whileTrue:[		nextOuterX _ outer stepInY.		nextInnerX _ inner stepInY.		destX _ centerX - nextOuterX.		destY _ centerY - nextY.		width _ nextOuterX - nextInnerX.		self copyBits.		destX _ centerX + nextInnerX + xBias.		self copyBits.		destX _ centerX - nextOuterX.		destY _ centerY + nextY + yBias.		self copyBits.		destX _ centerX + nextInnerX + xBias.		self copyBits.		nextY _ nextY - 1.	].	destY _ centerY.	height _ 1 + yBias.	width _ wp x.	destX _ rect left.	self copyBits.	destX _ rect right - wp x.	self copyBits.! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 14:44'!frameRect: rect borderWidth: borderWidth	sourceX _ 0.	sourceY _ 0.	(rect areasOutside: (rect insetBy: borderWidth)) do:		[:edgeStrip | self destRect: edgeStrip; copyBits].! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 01:08'!frameRectBottom: rect height: h	destX _ rect left + 1.	destY _ rect bottom - 1.	width _ rect width - 2.	height _ 1.	1 to: h do: [:i |		self copyBits.		destX _ destX + 1.		destY _ destY - 1.		width _ width - 2].! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 01:08'!frameRectRight: rect width: w	width _ 1.	height _ rect height - 1.	destX _ rect right - 1.	destY _ rect top + 1.	1 to: w do: [:i |		self copyBits.		destX _ destX - 1.		destY _ destY + 1.		height _ height - 2].! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 01:08'!image: aForm at: aPoint sourceRect: sourceRect rule: rule	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	sourceForm _ aForm.	combinationRule _ rule.	self sourceRect: sourceRect.	self destOrigin: aPoint.	self copyBits! !!GrafPort methodsFor: 'drawing support' stamp: 'jm 3/18/2003 11:17'!image: aForm at: aPoint sourceRect: sourceRect rule: rule alpha: a	"Draw the portion of the given Form defined by sourceRect at the given point using the given BitBlt combination rule."	sourceForm _ aForm.	combinationRule _ rule.	self sourceRect: sourceRect.	self destOrigin: aPoint.	self copyBitsTranslucent: a.! !!GrafPort methodsFor: 'drawing support' stamp: 'ar 2/17/2000 00:31'!stencil: stencilForm at: aPoint sourceRect: aRect	"Paint using aColor wherever stencilForm has non-zero pixels"	self sourceForm: stencilForm;		destOrigin: aPoint;		sourceRect: aRect.	self copyBits! !!GrafPort methodsFor: 'copying' stamp: 'ar 2/17/2000 01:07'!clippedBy: aRectangle	^ self copy clipRect: (self clipRect intersect: aRectangle)! !!GrafPort methodsFor: 'copying' stamp: 'ar 2/17/2000 01:07'!copyBits	"Override copybits to do translucency if desired"	(combinationRule >= 30 and: [combinationRule <= 31])		ifTrue: [alpha == nil					ifTrue: [self copyBitsTranslucent: 255]					ifFalse: [self copyBitsTranslucent: alpha]]		ifFalse: [super copyBits]! !I display a graph of numbers, normalized so the full range of values just fits my height. I support a movable cursor that can be dragged with the mouse.Implementation notes: Some operations on me may be done at sound sampling rates (e.g. 11-44 thousand times/second). To allow such high bandwidth application, certain operations that change my appearance do not immediately report a damage rectangle. Instead, a flag is set indicating that my display needs to refreshed and a step method reports the damage rectangle if that flag is set. Also, I cache a bitmap of my graph to allow the cursor to be moved without redrawing the graph.!!GraphMorph methodsFor: 'initialization' stamp: 'jm 6/17/1999 20:09'!initialize	super initialize.	self color: (Color r: 0.8 g: 0.8 b: 0.6).	self extent: 365@80.	self borderWidth: 2.	dataColor _ Color darkGray.	cursor _ 1.0.  "may be fractional"	cursorColor _ Color red.	cursorColorAtZeroCrossings _ Color red.	startIndex _ 1.	hasChanged _ false.	self data:		((0 to: 360 - 1) collect:			[:x | (100.0 * (x degreesToRadians sin)) asInteger]).! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 6/17/1999 21:41'!cursor: aNumber	| truncP |	cursor ~= aNumber ifTrue:  [		cursor _ aNumber.		truncP _ aNumber truncated.		truncP > data size ifTrue: [cursor _ data size].		truncP < 0 ifTrue: [cursor _ 1].		self keepIndexInView: truncP.		hasChanged _ true].! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:32'!cursorColorAtZeroCrossing	^ cursorColorAtZeroCrossings! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:32'!cursorColorAtZeroCrossings: aColor	cursorColorAtZeroCrossings _ aColor.	self flushCachedForm.! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 6/17/1999 21:43'!cursorWrapped: aNumber	| sz |	cursor ~= aNumber ifTrue: [		cursor _ aNumber.		sz _ data size.		sz = 0			ifTrue: [cursor _ 1]			ifFalse: [				((cursor >= (sz + 1)) or: [cursor < 0]) ifTrue: [					cursor _ cursor - ((cursor // sz) * sz)].				cursor < 1 ifTrue: [cursor _ sz + cursor]].		"assert: 1 <= cursor < data size + 1"		hasChanged _ true].! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 6/16/1999 13:49'!interpolatedValueAtCursor	| sz prev frac next |	data isEmpty ifTrue: [^ 0].	sz _ data size.	cursor < 0 ifTrue: [^ data at: 1].  "just to be safe, though cursor shouldn't be negative"	prev _ cursor truncated.	frac _ cursor - prev.	prev < 1 ifTrue: [prev _ sz].	prev > sz ifTrue: [prev _ 1].	"assert: 1 <= prev <= sz"	frac = 0 ifTrue: [^ data at: prev].  "no interpolation needed"	"interpolate"	next _ prev = sz ifTrue: [1] ifFalse: [prev + 1].	^ ((1.0 - frac) * (data at: prev)) + (frac * (data at: next))! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 4/21/1999 11:24'!lastValue	data size = 0 ifTrue: [^ 0].	^ data last! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 4/21/1999 11:25'!lastValue: aNumber	self appendValue: aNumber.! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 12/24/2002 09:24'!selection	^ selection! !!GraphMorph methodsFor: 'accessing' stamp: 'jm 1/1/2004 15:04'!selection: anArrayOrNil	"Set the selection to the given (startIndex, stopIndex) pair to to nil."	selection _ anArrayOrNil.! !!GraphMorph methodsFor: 'drawing' stamp: 'jm 11/24/2002 12:45'!drawOn: aCanvas	| c |	cachedForm = nil ifTrue:  [		c _ FormCanvas extent: bounds extent.		c translateBy: bounds origin negated			during:[:tempCanvas| self drawDataOn: tempCanvas].		cachedForm _ c form].	aCanvas paintImage: cachedForm at: bounds origin.	self drawCursorOn: aCanvas.! !!GraphMorph methodsFor: 'events' stamp: 'jm 12/26/2002 10:32'!handlesMouseDown: evt	^ true! !!GraphMorph methodsFor: 'events' stamp: 'jm 1/1/2004 15:20'!mouseDown: evt	| x newCursor middle |	evt shiftPressed		ifTrue: [			x _ evt cursorPoint x - (bounds left + borderWidth).			newCursor _ ((startIndex + x) max: 1) min: data size.			selection				ifNil: [					selection _ Array with: newCursor with: newCursor.					draggingLeftSide _ false]				ifNotNil: [					middle _ (selection first + selection second) // 2.					newCursor < middle						ifTrue: [							selection at: 1 put: newCursor.							draggingLeftSide _ true]						ifFalse: [							selection at: 2 put: newCursor.							draggingLeftSide _ false]]]		ifFalse: [			selection ifNotNil: [				selection _ nil.				self flushCachedForm.				self changed]].! !!GraphMorph methodsFor: 'events' stamp: 'jm 12/26/2002 10:40'!mouseMove: evt	| x w |	x _ evt cursorPoint x - (bounds left + borderWidth).	w _ self width - (2 * borderWidth).	self changed.	x < 0 ifTrue: [		cursor _ startIndex + (3 * x).		cursor _ (cursor max: 1) min: data size.		self adjustSelection.		^ self startIndex: cursor].	x > w ifTrue: [		cursor _ startIndex + w + (3 * (x - w)).		cursor _ (cursor max: 1) min: data size.		self adjustSelection.		^ self startIndex: cursor - w].	cursor _ ((startIndex + x) max: 1) min: data size.	self adjustSelection.! !!GraphMorph methodsFor: 'stepping' stamp: 'jm 6/17/1999 21:32'!step	"Make a deferred damage rectangle if I've changed. This allows applications to call methods that invalidate my display at high-bandwidth without paying the cost of doing the damage reporting on ever call; they can merely set hasChanged to true."	super step.	hasChanged == nil ifTrue: [hasChanged _ false].	hasChanged ifTrue: [		self changed.		hasChanged _ false].! !!GraphMorph methodsFor: 'menu' stamp: 'jm 6/16/1999 13:08'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'open wave editor' action: #openWaveEditor.	aCustomMenu add: 'read file' action: #readDataFromFile.! !!GraphMorph methodsFor: 'menu' stamp: 'jm 6/15/2003 20:03'!openWaveEditor	| scaleFactor scaledData editor |	self data: data.  "make sure maxVal and minVal are current"	scaleFactor _ 32767 // ((minVal abs max: maxVal abs) max: 1).	scaledData _ SoundBuffer newMonoSampleCount: data size.	1 to: data size do: [:i | scaledData at: i put: (scaleFactor * (data at: i)) truncated].	editor _ SimpleWaveEditor new		data: scaledData;		samplingRate: 11025;		perceivedFrequency: 220.0.	editor openInWorld.! !!GraphMorph methodsFor: 'menu' stamp: 'jm 12/4/2003 20:22'!readDataFromFile	| result fName |	result _ StandardFileMenu oldFileExtensions: #(aif aiff au wav).	result ifNil: [^ self].	fName _  result directory pathName, FileDirectory slash, result name.	self data: (SampledSound fromFileNamed: fName) samples.! !!GraphMorph methodsFor: 'commands' stamp: 'jm 7/30/1998 12:17'!centerCursor	"Scroll so that the cursor is as close as possible to the center of my window."	| w |	w _ self width - (2 * borderWidth).	self startIndex: ((cursor - (w // 2)) max: 1).! !!GraphMorph methodsFor: 'commands' stamp: 'jm 4/22/1999 14:49'!loadSineWave	self loadSoundData: FMSound sineTable.! !!GraphMorph methodsFor: 'commands' stamp: 'jm 4/22/1999 14:17'!loadSound: aSound	self loadSoundData: aSound samples.! !!GraphMorph methodsFor: 'commands' stamp: 'jm 4/22/1999 14:23'!loadSoundData: aCollection	| scale absV newData |	scale _ 0.	aCollection do: [:v | (absV _ v abs) > scale ifTrue: [scale _ absV]].	scale _ 100.0 / scale.	newData _ OrderedCollection new: aCollection size.	1 to: aCollection size do: [:i | newData addLast: (scale * (aCollection at: i))].	self data: newData.	self startIndex: 1.	self cursor: 1.! !!GraphMorph methodsFor: 'commands' stamp: 'jm 6/16/1999 11:29'!playOnce	| scale absV scaledData |	data isEmpty ifTrue: [^ self].  "nothing to play"	scale _ 1.	data do: [:v | (absV _ v abs) > scale ifTrue: [scale _ absV]].	scale _ 32767.0 / scale.	scaledData _ SoundBuffer newMonoSampleCount: data size.	1 to: data size do: [:i | scaledData at: i put: (scale * (data at: i)) truncated].	(SampledSound samples: scaledData samplingRate: 11025) play.! !!GraphMorph methodsFor: 'private' stamp: 'jm 1/1/2004 15:22'!adjustSelection	"Adjust the selection, if any, to the current cursor position. Do nothing if there is no selection."	selection ifNil: [^ self].	draggingLeftSide		ifTrue: [			selection at: 1 put: cursor.			selection at: 2 put: ((selection at: 2) max: cursor)]		ifFalse: [			selection at: 1 put: ((selection at: 1) min: cursor).			selection at: 2 put: cursor].	self flushCachedForm; changed.! !!GraphMorph methodsFor: 'private' stamp: 'jm 6/17/1999 21:36'!drawCursorOn: aCanvas	| ptr x r c |	ptr _ (cursor asInteger max: 1) min: data size.	c _ cursorColor.	((ptr > 1) and: [ptr < data size]) ifTrue: [		(data at: ptr) sign ~= (data at: ptr + 1) sign			ifTrue: [c _ cursorColorAtZeroCrossings]].	r _ self innerBounds.	x _ r left + ptr - startIndex.	((x >= r left) and: [x <= r right]) ifTrue: [		aCanvas fillRectangle: (x@r top corner: x + 1@r bottom) color: c].! !!GraphMorph methodsFor: 'private' stamp: 'jm 12/24/2002 09:33'!drawDataOn: aCanvas	| yScale baseLine x start end value left top bottom right |	super drawOn: aCanvas.	self drawSelectionOn: aCanvas.	data isEmpty ifTrue: [^ self].	maxVal = minVal ifTrue: [		yScale _ 1.	] ifFalse: [		yScale _ (bounds height - (2 * borderWidth)) asFloat / (maxVal - minVal)].	baseLine _ bounds bottom - borderWidth + (minVal * yScale) truncated.	left _ top _ 0. right _ 10. bottom _ 0.	x _ bounds left + borderWidth.	start _ (startIndex asInteger max: 1) min: data size.	end _ (start + bounds width) min: data size.	start to: end do: [:i |		left _ x truncated. right _ x + 1.		right > (bounds right - borderWidth) ifTrue: [^ self].		value _ (data at: i) asFloat.		value >= 0.0 ifTrue: [			top _ baseLine - (yScale * value) truncated.			bottom _ baseLine.		] ifFalse: [			top _ baseLine.			bottom _ baseLine - (yScale * value) truncated].		aCanvas fillRectangle: (left@top corner: right@bottom) color: dataColor.		x _ x + 1].! !!GraphMorph methodsFor: 'private' stamp: 'jm 12/24/2002 09:44'!drawSelectionOn: aCanvas	| startVisible endVisible x y |	selection ifNil: [^ self].	startVisible _ (startIndex asInteger max: 1) min: data size.	endVisible _ (startVisible + bounds width) min: data size.	selection first > endVisible ifTrue: [^ self].  "selection is not visible"	selection last < startVisible ifTrue: [^ self].  "selection is not visible"	x _ (bounds left + borderWidth + (selection first - startVisible)).	y _ bounds top + borderWidth.	aCanvas		fillRectangle: (x@y extent: (selection last - selection first)@(self height - (2 * borderWidth)))		color: Color lightYellow.! !!GraphMorph methodsFor: 'private' stamp: 'jm 6/17/1999 20:10'!flushCachedForm	cachedForm _ nil.	hasChanged _ true.! !!GraphMorph methodsFor: 'private' stamp: 'jm 4/21/1999 11:30'!keepIndexInView: index	| w newStart |	w _ bounds width - (2 * borderWidth).	index < startIndex ifTrue: [		newStart _ index - w + 1.		^ self startIndex: (newStart max: 1)].	index > (startIndex + w) ifTrue: [		^ self startIndex: (index min: data size)].! !!GraphMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:00'!includeInNewMorphMenu	^ true! !!GraphMorph class methodsFor: 'instance creation' stamp: 'jm 1/23/2003 16:21'!openOn: dataCollection	"Open a new GraphMorph on the given sequencable collection of data."	^ (self new data: dataCollection) openInWorld! !A subclass of graph that keeps a set of bookmarks. Bookmarks have a label and a selected flag. Selected bookmarks display differently than unselected ones, and can be used to choose which bookmarked sections of a sound file are to be played or exported.!!GraphWithBookmarksMorph methodsFor: 'initialization' stamp: 'jm 12/26/2002 17:29'!initialize	super initialize.	bookmarks _ #().! !!GraphWithBookmarksMorph methodsFor: 'bookmarks' stamp: 'jm 1/1/2003 18:18'!bookmarkAt: index	"Answer the last bookmark before the given index or nil if there is no bookmark before the given index."	| bm |	1 to: bookmarks size do: [:i |		(bookmarks at: i) key <= index ifTrue: [			bm _ bookmarks at: i]].	^ bm! !!GraphWithBookmarksMorph methodsFor: 'bookmarks' stamp: 'jm 12/26/2002 18:47'!bookmarkAt: index put: anArray	"Set the bookmark at the given index to the given array. If there is an existing bookmark at that index, change it. Otherwise, add a new bookmark."	| bm |	bm _ bookmarks detect: [:assoc | assoc key = index] ifNone: [nil].	bm ifNotNil: [bm value: anArray. ^ self].  "update existing entry"	"insert new entry"	bookmarks _ bookmarks copyWith: (index -> anArray).	bookmarks sort.! !!GraphWithBookmarksMorph methodsFor: 'bookmarks' stamp: 'jm 1/1/2003 18:19'!bookmarks	"Answer my bookmarks array, a sorted list of associations whose keys are indices into my data and whose values are arrays of (label, selectedFlag)."	^ bookmarks! !!GraphWithBookmarksMorph methodsFor: 'bookmarks' stamp: 'jm 12/28/2002 19:17'!bookmarks: bookmarksArray	"Set my bookmarks array."	bookmarks _ bookmarksArray.! !!GraphWithBookmarksMorph methodsFor: 'drawing' stamp: 'jm 1/1/2003 18:21'!drawBookmarksOn: aCanvas	"Draw all visible bookmarks. Selected bookmarks are full height; unselected ones are half height."	| startVisible endVisible fullH x y h |	bookmarks size = 0 ifTrue: [^ self].	startVisible _ (startIndex asInteger max: 1) min: data size.	endVisible _ (startVisible + bounds width - (2 * borderWidth)) min: data size.	fullH _ self height - (2 * borderWidth).	bookmarks do: [:bm |		bm key > endVisible ifTrue: [^ self].		bm key >= startVisible ifTrue: [			x _ (bounds left + borderWidth + (bm key - startVisible)).			y _ bounds top + borderWidth.			h _ (bm value at: 2) ifTrue: [fullH] ifFalse: [fullH // 2].			aCanvas fillRectangle: (x@y extent: 1@h) color: Color blue]].! !!GraphWithBookmarksMorph methodsFor: 'drawing' stamp: 'jm 1/1/2003 18:20'!drawDataOn: aCanvas	"Draw bookmarks after drawing (i.e., in front of) my data."	super drawDataOn: aCanvas.	self drawBookmarksOn: aCanvas.! !!GravisPatchReader methodsFor: 'initialization' stamp: 'jm 4/19/2003 17:15'!initialize	fName _ ''.	file _ nil.	keepWaveData _ false.	waveCount _ 0.	waves _ #().! !!GravisPatchReader methodsFor: 'operations' stamp: 'jm 4/20/2003 19:33'!asSampledInstrument	^ SampledInstrument new allSampleSets: (waves collect: [:w | w asSound])"	AbstractSound soundNamed: instName, '-f' put:		(snd _ SampledInstrument new allSampleSets: sampleSet)."! !!GravisPatchReader methodsFor: 'operations' stamp: 'jm 4/19/2003 17:18'!discardSamples	waves do: [:w | w discardSamples].! !!GravisPatchReader methodsFor: 'operations' stamp: 'jm 4/19/2003 17:31'!playAll	waves do: [:w | w play].! !!GravisPatchReader methodsFor: 'operations' stamp: 'jm 4/20/2003 18:45'!playAllLooped	waves do: [:w | w playLooped].! !!GravisPatchReader methodsFor: 'operations' stamp: 'jm 4/19/2003 17:17'!playWave: n	(waves at: n) play! !!GravisPatchReader methodsFor: 'operations' stamp: 'jm 4/18/2003 11:27'!readFile: fileName	"GravisPatchReader new readFile: 'ocarina.pat'"	fName _ FileDirectory localNameFor: fileName.	file _ (FileStream oldFileNamed: fileName) binary.	self readAll.	file close.	file _ nil.! !!GravisPatchReader methodsFor: 'accessing' stamp: 'jm 4/18/2003 11:27'!fileName	^ fName! !!GravisPatchReader methodsFor: 'accessing' stamp: 'jm 4/19/2003 20:37'!instrName	^ (fName copyFrom: 1 to: fName size - 4) asLowercase! !!GravisPatchReader methodsFor: 'accessing' stamp: 'jm 12/12/2002 12:03'!keepWaveData: aBoolean	"If true, then the wave sample data is retained. Otherwise, it is discarded. This flag is false by default."	keepWaveData _ aBoolean.! !!GravisPatchReader methodsFor: 'accessing' stamp: 'jm 4/19/2003 20:38'!mode	"Assume all waves have the same mode bits."	^ waves first mode! !!GravisPatchReader methodsFor: 'accessing' stamp: 'jm 4/19/2003 17:07'!sampleRate	^ waves first sampleRate! !!GravisPatchReader methodsFor: 'accessing' stamp: 'jm 4/19/2003 17:08'!waveSizes	^ waves collect: [:w | w sampleCount]! !!GravisPatchReader methodsFor: 'accessing' stamp: 'jm 12/11/2002 09:26'!waves	^ waves! !!GravisPatchReader methodsFor: 'printing' stamp: 'jm 4/19/2003 17:31'!printOn: aStream	| totalSamples |	totalSamples _ (waves collect: [:w | w sampleCount]) sum.	aStream		nextPutAll: fName;		nextPut: $(;		nextPutAll: waves size printString, ' ', totalSamples printString, ')'.! !!GravisPatchReader methodsFor: 'private' stamp: 'jm 4/19/2003 17:39'!readAll	"Read a Gravis patch file."	"Assume: One instrument per file, one layer per insrument, multiple waves per layer."	self readFileHeader.	self readInstrumentHeader.	self readLayerHeader.	waves _ (1 to: waveCount) collect: [:i |		GravisWave new readWaveDataFrom: file readSamples: keepWaveData].	waves sort: [:w1 :w2 | w1 rootFreq < w2 rootFreq].! !!GravisPatchReader methodsFor: 'private' stamp: 'jm 12/3/2003 15:53'!readFileHeader	| header id description instrCount voiceCount channelCount masterVolume dataSize |	file position: 0.	header _ (file next: 12) asString.	id _ (file next: 10) asString.	description _ (file next: 60) asString.  "usually holds copyright info"	instrCount _ file next.	voiceCount _ file next.	channelCount _ file next.	waveCount _ file littleEndianUint16.	masterVolume _ file littleEndianUint16.	dataSize _ file littleEndianUint32.  "size for Gravis hardware; irrelevant"	file skip: 36.  "skip header reserved bytes"	header = 'GF1PATCH110 ' ifFalse: [self error: 'bad file header'].	id = 'ID#000002 ' ifFalse: [self error: 'bad file header id'].	instrCount ~= 1 ifTrue: [self error: 'instrument count not 1'].	voiceCount ~= 14 ifTrue: [self error: 'voiceCount count not 14'].	channelCount > 1 ifTrue: [self error: 'can only read mono sounds'].	masterVolume = 127 ifFalse: [self error: 'master volume not 127'].	"use vars to avoid warnings:"	description. dataSize.! !!GravisPatchReader methodsFor: 'private' stamp: 'jm 12/3/2003 15:53'!readInstrumentHeader	| instrNum instrName instrSize layerCount |	instrNum _ file littleEndianUint16.  "always zero"	instrName _ (file next: 16) asString.  "sometimes empty"	instrSize _ file littleEndianUint32.  "ignore"	layerCount _ file next.	file skip: 40.  "skip layer header reserved bytes"	layerCount > 1 ifTrue: [self error: 'layer count > 1'].	instrNum = 0 ifFalse: [self error: 'instrument number not zero'].	"use vars to avoid warnings:"	instrName. instrSize.! !!GravisPatchReader methodsFor: 'private' stamp: 'jm 12/3/2003 15:54'!readLayerHeader	| layerDuplicate layer layerSize samples |	layerDuplicate _ file next.	layer _ file next.	layerSize _ file littleEndianUint32.  "ignore"	samples _ file next.	file skip: 40.  "skip layer data reserved bytes"	layerDuplicate = 0 ifFalse: [self error: 'layerDuplicate not zero'].	layer = 0 ifFalse: [self error: 'layer not zero'].	samples = waveCount ifFalse: [self error: 'samples not equal to waveCount'].	"use vars to avoid warnings:"	layerSize.! !!GravisPatchReader methodsFor: 'private' stamp: 'jm 4/19/2003 17:12'!readSampleData: byteCount	"Read the given number of bytes of sample data."	| buf s sampleCount wave v |	buf _ file next: byteCount.	(mode bitAnd: 1) = 1 ifFalse: [^ self halt: 'cannot read 8-bit sample data'].	keepWaveData ifFalse: [^ self].	s _ ReadStream on: buf.	sampleCount _ byteCount // 2.	wave _ SoundBuffer newMonoSampleCount: sampleCount.	(mode bitAnd: 2) = 2		ifTrue: [  "unsigned"			1 to: sampleCount do: [:i |				v _ s next.				v _ v + (s next << 8).				wave at: i put: (v - 32768)]]		ifFalse: [  "signed"			1 to: sampleCount do: [:i |				v _ s next.				v _ v + (s next << 8).				v > 32767 ifTrue: [v _ v - 65536].				wave at: i put: v]].	waves _ waves copyWith: wave.! !!GravisPatchReader methodsFor: 'private' stamp: 'jm 12/3/2003 15:55'!readWaveData	| waveName fractions waveSize startLoop endLoop lowFreq hiFreq rootFreq tune balance envRates envOffset tremoloSweep tremoloRate tremoloDepth vibratoSweep vibratoRate vibratoDepth scaleFreq scaleFactor log |	waveName _ (file next: 7) asString.  "mostly unused"	fractions _ file next.	waveSize _ file littleEndianUint32.	startLoop _ file littleEndianUint32.	endLoop _ file littleEndianUint32.	sampleRate _ file littleEndianUint16.	lowFreq _ file littleEndianUint32.	hiFreq _ file littleEndianUint32.	rootFreq _ file littleEndianUint32.	tune _ file littleEndianUint16.  "always = 512"	balance _ file next.  "we can ignore"	envRates _ file next: 6.	envOffset _ file next: 6.	tremoloSweep _ file next.	tremoloRate _ file next.	tremoloDepth _ file next.	vibratoSweep _ file next.	vibratoRate _ file next.	vibratoDepth _ file next.	mode _ file next.	scaleFreq _ file littleEndianUint16.  "we can ignore"	scaleFactor _ file littleEndianUint16.  "we can ignore"	file skip: 36.  "skip layer data reserved bytes"	self readSampleData: waveSize.	tune = 512 ifFalse: [self error: 'tune ~= 512'].log _ nil.	log ifNotNil: [		log nextPutAll: fName; cr; tab.		log nextPutAll: 'fractions ', fractions hex.		log nextPutAll: ' lowFreq ', (lowFreq / 1000.0) printString.		log nextPutAll: ' rootFreq ', (rootFreq / 1000.0) printString.		log nextPutAll: ' hiFreq ', (hiFreq / 1000.0) printString; cr; tab.		log nextPutAll: 'sampleRate ', sampleRate printString.		log nextPutAll: ' waveSize ', waveSize printString.		log nextPutAll: ' loopStart ', startLoop printString.		log nextPutAll: ' loopEnd ', endLoop printString; cr; tab.		tremoloDepth > 0 ifTrue: [			log nextPutAll: 'tremoloSweep ', tremoloSweep printString.			log nextPutAll: ' tremoloRate ', tremoloRate printString.			log nextPutAll: ' tremoloDepth ', tremoloDepth printString; space].		vibratoDepth > 0 ifTrue: [			log nextPutAll: 'vibratoSweep ', vibratoSweep printString.			log nextPutAll: ' vibratoRate ', vibratoRate printString.			log nextPutAll: ' vibratoDepth ', vibratoDepth printString].		log cr; endEntry].	"use vars to avoid warnings:"	waveName. fractions. tune. balance. envRates. envOffset.	scaleFreq. scaleFactor.! !!GravisPatchReader class methodsFor: 'instance creation' stamp: 'jm 4/20/2003 20:00'!drums	^ #(		(27 highq)		(28 slap)		(29 scratch1)		(30 scratch2)		(31 sticks)		(32 sqrclick)		(33 metclick)		(34 metbell)		(35 kick1)		(36 kick2)		(37 stickrim)		(38 snare1)		(39 claps)		(40 snare2)		(41 tomlo2)		(42 hihatcl)		(43 tomlo1)		(44 hihatpd)		(45 tommid2)		(46 hihatop)		(47 tommid1)		(48 tomhi2)		(49 cymcrsh1)		(50 tomhi1)		(51 cymride1)		(52 cymchina)		(53 cymbell)		(54 tamborin)		(55 cymsplsh)		(56 cowbell)		(57 cymcrsh2)		(58 vibslap)		(59 cymride2)		(60 bongohi)		(61 bongolo)		(62 congahi1)		(63 congahi2)		(64 congalo)		(65 timbaleh)		(66 timbalel)		(67 agogohi)		(68 agogolo)		(69 cabasa)		(70 maracas)		(71 whistle1)		(72 whistle2)		(73 guiro1)		(74 guiro2)		(75 clave)		(76 woodblk1)		(77 woodblk2)		(78 cuica1)		(79 cuica2)		(80 triangl1)		(81 triangl2)		(82 shaker)		(83 jingles)		(84 belltree)		(85 castinet)		(86 surdo1)		(87 surdo2))! !!GravisPatchReader class methodsFor: 'instance creation' stamp: 'jm 4/21/2003 12:19'!firstCut	^ #(acbass acguitar acpiano altosax banjo barisax basslead bassoon celeste cello choir church clarinet concrtna contraba echovox englhorn fiddle flute fngrbass frenchrn fretless ghostie glocken hammond harmonca harp honky hrpschrd jazzgtr kalimba koto marimba mutegtr mutetrum nyguitar oboe ocarina odguitar percorg piccolo pickbass pizzcato polysyn recorder reedorg ringwhsl santur shamisen shannai sitar slapbas2 sprnosax sqrwave startrak steeldrm sweeper synbass1 synbras2 synstr1 synstr2 syntom taiko telephon tenorsax timpani toms tremstr trombone trumpet tuba tubebell unicorn vibes viola violin voxlead woodblk woodflut xylophon)! !!GravisPatchReader class methodsFor: 'instance creation' stamp: 'jm 4/21/2003 11:04'!nonDrumsNamesFrom: directoryName	"GravisPatchReader nonDrumsNamesFrom:		'Sackbut:Desktop Folder:Media Lab:Gravis UltraSound:guspatch Folder'"	| dir instNames |	dir _ FileDirectory on: directoryName.	instNames _ (dir fileNames select: [:n | n endsWith: '.PAT']) asOrderedCollection		collect: [:n | (n copyFrom: 1 to: n size - 4) asLowercase].	instNames remove: 'blank' ifAbsent: [].	self drums do: [:p | instNames remove: p last ifAbsent: []].	^ instNames! !!GravisPatchReader class methodsFor: 'instance creation' stamp: 'jm 4/21/2003 15:57'!readDrumsFrom: directoryName	"AbstractSound unloadSoundNamed: 'drums-g'"	"GravisPatchReader readDrumsFrom:		'Sackbut:Desktop Folder:Media Lab:Gravis UltraSound:guspatch Folder'"	| keyMap midiKey patch wave previousWaves instr |	previousWaves _ OrderedCollection new: 100.	keyMap _ Array new: 128 withAll: (RestSound dur: 0.1).	self drums do: [:pair |		midiKey _ pair first.		patch _ (GravisPatchReader new keepWaveData: true)			readFile: directoryName, ':', pair second, '.pat'.		wave _ patch waves first.		self trimDrumWaveIfNecessary: wave.		wave _ previousWaves detect: [:w | w samples = wave samples] ifNone: [wave].		previousWaves addFirst: wave.		keyMap at: midiKey + 1 put: wave asUnloopedSound].	instr _ SampledInstrument new allKeyMaps: keyMap.	AbstractSound soundNamed: 'drums-g' put: instr.	^ instr! !!GravisPatchReader class methodsFor: 'instance creation' stamp: 'jm 4/21/2003 18:03'!readInstruments: instrNames from: directoryName	"AbstractSound soundNames do:		[:n | (n endsWith: '-g') ifTrue: [ AbstractSound unloadSoundNamed: n]]"	"(AbstractSound soundNames select: [:n | n endsWith: '-g']) do:		[:n | AbstractSound sounds removeKey: n]"	"GravisPatchReader readInstruments: GravisPatchReader thirdCut from:		'Sackbut:Desktop Folder:Media Lab:Gravis UltraSound:guspatch Folder'"	| dir patch notes bytes instr |	dir _ FileDirectory on: directoryName.	^ instrNames collect: [:n |		patch _ (GravisPatchReader new keepWaveData: true)			readFile: (dir fullNameFor: n, '.pat').		notes _ patch waves collect: [:w | w asSound].		bytes _ (patch waves collect: [:w | w sampleCount * 2]) sum.		instr _ SampledInstrument new allSampleSets: notes.		AbstractSound soundNamed: n, '-g' put: instr.		Array with: n with: bytes with: instr].! !!GravisPatchReader class methodsFor: 'instance creation' stamp: 'jm 4/23/2003 21:06'!readPatches: instrNames keep: keepFlag from: directoryName	"GravisPatchReader readPatches: GravisPatchReader thirdCut keep: false from:		'Sackbut:Desktop Folder:Media Lab:Gravis UltraSound:guspatch Folder'"	"GravisPatchReader readPatches: (self drums collect: [:e | e last]) keep: false from:		'Sackbut:Desktop Folder:Media Lab:Gravis UltraSound:guspatch Folder'"	| dir patch bytes |	dir _ FileDirectory on: directoryName.	^ instrNames collect: [:n |		patch _ (GravisPatchReader new keepWaveData: keepFlag)			readFile: (dir fullNameFor: n, '.pat').		bytes _ (patch waves collect: [:w | w sampleCount * 2]) sum.		Array with: n with: bytes with: patch].! !!GravisPatchReader class methodsFor: 'instance creation' stamp: 'jm 4/21/2003 13:09'!secondCut	^ #(acbass acguitar acpiano altosax banjo barisax basslead bassoon celeste cello church clarinet concrtna contraba englhorn fiddle flute fngrbass frenchrn fretless glocken hammond harmonca harp honky hrpschrd jazzgtr kalimba koto marimba mutegtr mutetrum nyguitar oboe odguitar percorg piccolo pickbass pizzcato polysyn reedorg santur shamisen shannai sitar slapbas2 sprnosax steeldrm synbass1 synbras2 taiko telephon tenorsax timpani toms tremstr trombone trumpet tuba tubebell vibes viola violin voxlead woodblk woodflut xylophon)! !!GravisPatchReader class methodsFor: 'instance creation' stamp: 'jm 4/21/2003 16:24'!thirdCut	^ #(acbass acguitar acpiano altosax banjo barisax bassoon celeste cello church clarinet concrtna contraba fiddle flute frenchrn fretless hammond honky hrpschrd koto marimba mutetrum oboe percorg piccolo pickbass pizzcato polysyn reedorg shamisen shannai sitar slapbas2 sprnosax steeldrm synbras2 timpani toms trombone trumpet tuba vibes viola violin voxlead woodblk woodflut xylophon)! !!GravisPatchReader class methodsFor: 'instance creation' stamp: 'jm 4/20/2003 23:12'!trimDrumWaveIfNecessary: aGravisWave	"Several of the drum wave patches have some garbage in the last 32 samples or so. If this wave is one of those, trim it."	| buf tail |	buf _ aGravisWave samples.	tail _ (buf copyFrom: buf size - 32 to: buf size).	(tail max max: tail min abs) > 20000 ifTrue: [		aGravisWave samples: (buf copyFrom: 1 to: buf size - 32)].! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/19/2003 18:28'!checkLoopPoints	self isLooping ifTrue: [		startLoop odd | endLoop odd ifTrue: [self error: 'odd loop point'].		startLoop < endLoop ifFalse: [self error: 'startLoop >= endLoop'].		endLoop <= (2 * sampleCount) ifFalse: [self error: 'endLoop >= sampleCount']].! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/23/2003 21:18'!displayLoopOverlap	| count i j yi yj penI penJ |	Display fillWhite.	Display fill: (0@350 extent: Display width@1) fillColor: Color black.	count _ 1000 min: ((startLoop // 2) - 1).	i _ (startLoop // 2) - count.	j _ (endLoop // 2) - count.	penI _ Pen new color: Color red; place: 0@350.	penJ _ Pen new color: Color blue; place: 0@350.	1 to: count do: [:x |		yi _ 350 + ((samples at: i) // 100).		yj _ 350 + ((samples at: j) // 100).		penI goto: x@yi.		penJ goto: x@yj.		i _ i + 1.		j _ j + 1].! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/20/2003 11:41'!envPairs	| exp mantissa val range |	range _ 15.0 * (2 raisedTo: 15).	^ (1 to: 6) collect: [:i |		exp _ ((envOffset at: i) >> 4) bitAnd: 15.		mantissa _ (envOffset at: i) bitAnd: 15.		val _ (mantissa * (2 raisedTo: exp)) / range.		Array with: (envOffset at: i) with: exp with: mantissa with: (val roundTo: 0.0001)]! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/20/2003 13:30'!envRates	| incr rate mSecs |	^ (1 to: 6) collect: [:i |		incr _ (envRates at: i) bitAnd: 63.		rate _ 8 raisedTo: (((envRates at: i) >> 6) bitAnd: 3).		mSecs _ ((91.7 * rate) / incr) roundTo: 0.1.		Array with: rate with: incr with: mSecs.rate]! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/20/2003 18:36'!envSegTimes	| curVol exp mantissa newVol slowdown incr stepCount |	curVol _ 0.	^ (1 to: 6) collect: [:i |		exp _ ((envOffset at: i) >> 4) bitAnd: 15.		mantissa _ (envOffset at: i) bitAnd: 15.		newVol _ mantissa * (2 raisedTo: exp).		slowdown _ 8 raisedTo: (((envRates at: i) >> 6) bitAnd: 3).		incr _ (envRates at: i) bitAnd: 63.		stepCount _ (((newVol - curVol) abs / incr) * slowdown) rounded.		curVol _ newVol.		stepCount // 44]! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/21/2003 21:39'!envVols	| exp mantissa val range |	range _ 15.0 * (2 raisedTo: 15).	^ (1 to: 6) collect: [:i |		exp _ ((envOffset at: i) >> 4) bitAnd: 15.		mantissa _ (envOffset at: i) bitAnd: 15.		val _ (mantissa * (2 raisedTo: exp)) / range.		"Array with: (envOffset at: i) with: exp with: mantissa with: (val roundTo: 0.0001)"		val roundTo: 0.001]! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/19/2003 18:03'!isLooping	^ (mode bitAnd: 4) > 0! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/19/2003 20:42'!isSustaining	^ (mode bitAnd: 32) > 0! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/20/2003 18:58'!loopFractions		^ Array with: (fractions bitAnd: 15) with: ((fractions >> 4) bitAnd: 15)! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/20/2003 20:04'!loopLength	| endFrac startFrac |	endFrac _ fractions bitAnd: 15.	startFrac _ (fractions >> 4) bitAnd: 15.	^ (((endLoop - startLoop) / 2.0) - ((endFrac - startFrac) / 15.0)) min: (endLoop // 2)! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/19/2003 20:47'!loopPoints	^ Array with: startLoop with: endLoop with: sampleCount * 2! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/19/2003 17:01'!mode	^ mode! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/22/2003 08:22'!releaseSamples	self isLooping ifFalse: [^ 0].	^ sampleCount - (endLoop // 2)! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/19/2003 17:32'!rootFreq	^ rootFreq! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/19/2003 17:01'!sampleCount	^ sampleCount! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/19/2003 17:01'!sampleRate	^ sampleRate! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/19/2003 18:34'!samples	^ samples! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/20/2003 22:54'!samples: aSoundBuffer	samples _ aSoundBuffer.	sampleCount _ samples monoSampleCount.! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/21/2003 21:02'!tremoloParameters	^ Array with: tremoloSweep with: tremoloRate with: tremoloDepth! !!GravisWave methodsFor: 'accessing' stamp: 'jm 4/21/2003 21:11'!vibratoParameters	^ Array with: vibratoSweep with: vibratoRate with: vibratoDepth! !!GravisWave methodsFor: 'operations' stamp: 'jm 4/23/2003 21:23'!asLoopedSound	| snd dur pitch |	pitch _ rootFreq / 1000.0.	snd _ LoopedSampledSound		samples: samples		loopEnd: (endLoop // 2)		loopLength: self loopLength		pitch: pitch		samplingRate: sampleRate.	snd addReleaseEnvelope.	dur _ (samples monoSampleCount asFloat / sampleRate) max: 1.5.	^ snd setPitch: pitch dur: dur loudness: 0.5! !!GravisWave methodsFor: 'operations' stamp: 'jm 4/20/2003 20:23'!asSound	^ self isLooping		ifTrue: [self asLoopedSound]		ifFalse: [self asUnloopedSound]! !!GravisWave methodsFor: 'operations' stamp: 'jm 4/21/2003 09:54'!asUnloopedSound	| pitch snd dur |	pitch _ rootFreq / 1000.0.	snd _ LoopedSampledSound		unloopedSamples: samples		pitch: pitch		samplingRate: sampleRate.	dur _ samples monoSampleCount asFloat / sampleRate.	^ snd setPitch: pitch dur: dur loudness: 0.5.! !!GravisWave methodsFor: 'operations' stamp: 'jm 4/24/2003 22:04'!asWavePlayer	| snd dur pitch |	pitch _ rootFreq / 1000.0.	snd _ GravisWavePlayer new		samples: samples		loopEnd: (endLoop // 2)		loopLength: self loopLength		pitch: pitch		samplingRate: sampleRate.	dur _ (samples monoSampleCount asFloat / sampleRate) max: 1.5.	^ snd setPitch: pitch dur: dur loudness: 0.5! !!GravisWave methodsFor: 'operations' stamp: 'jm 4/19/2003 17:18'!discardSamples	samples _ nil.! !!GravisWave methodsFor: 'operations' stamp: 'jm 4/20/2003 20:23'!play	self asUnloopedSound playAndWaitUntilDone.! !!GravisWave methodsFor: 'operations' stamp: 'jm 4/20/2003 20:23'!playLooped	self asLoopedSound playAndWaitUntilDone.! !!GravisWave methodsFor: 'operations' stamp: 'jm 4/19/2003 18:29'!readSampleData: byteCount from: aStream readSamples: readSamplesFlag	"Read the given number of bytes of sample data. Only 16-bit, signed or unsigned sample data is supported."	| buf s v |	(mode bitAnd: 1) = 1 ifFalse: [  "ignore 8-bit data"		aStream skip: byteCount.		startLoop _ endLoop _ sampleCount _ 0.		^ self].	byteCount odd ifTrue: [self error: 'bytecount should be even for 16-bit samples']. 	sampleCount _ byteCount // 2.	readSamplesFlag		ifTrue: [buf _ aStream next: byteCount]		ifFalse: [			aStream skip: byteCount.			^ self].	s _ ReadStream on: buf.	samples _ SoundBuffer newMonoSampleCount: sampleCount.	(mode bitAnd: 2) > 0		ifTrue: [  "unsigned"			1 to: sampleCount do: [:i |				v _ s next.				v _ v + (s next << 8).				samples at: i put: (v - 32768)]]		ifFalse: [  "signed"			1 to: sampleCount do: [:i |				v _ s next.				v _ v + (s next << 8).				v > 32767 ifTrue: [v _ v - 65536].				samples at: i put: v]].! !!GravisWave methodsFor: 'operations' stamp: 'jm 12/3/2003 15:56'!readWaveDataFrom: aStream readSamples: readSamplesFlag	| waveName waveSize tune balance scaleFreq scaleFactor log |	waveName _ (aStream next: 7) asString.  "mostly unused"	fractions _ aStream next.	waveSize _ aStream littleEndianUint32.	startLoop _ aStream littleEndianUint32.	endLoop _ aStream littleEndianUint32.	sampleRate _ aStream littleEndianUint16.	lowFreq _ aStream littleEndianUint32.	hiFreq _ aStream littleEndianUint32.	rootFreq _ aStream littleEndianUint32.	tune _ aStream littleEndianUint16.  "always = 512"	balance _ aStream next.  "we can ignore"	envRates _ aStream next: 6.	envOffset _ aStream next: 6.	tremoloSweep _ aStream next.	tremoloRate _ aStream next.	tremoloDepth _ aStream next.	vibratoSweep _ aStream next.	vibratoRate _ aStream next.	vibratoDepth _ aStream next.	mode _ aStream next.	scaleFreq _ aStream littleEndianUint16.  "we can ignore"	scaleFactor _ aStream littleEndianUint16.  "we can ignore"	aStream skip: 36.  "skip layer data reserved bytes"	self readSampleData: waveSize from: aStream readSamples: readSamplesFlag.	tune = 512 ifFalse: [self error: 'tune ~= 512'].	waveName. balance. scaleFreq. scaleFactor.  "use variables to avoid compiler warnings"log _ nil.	log ifNotNil: [		log cr; tab.		log nextPutAll: 'fractions ', fractions hex.		log nextPutAll: ' lowFreq ', (lowFreq / 1000.0) printString.		log nextPutAll: ' rootFreq ', (rootFreq / 1000.0) printString.		log nextPutAll: ' hiFreq ', (hiFreq / 1000.0) printString; cr; tab.		log nextPutAll: 'sampleRate ', sampleRate printString.		log nextPutAll: ' waveSize ', waveSize printString.		log nextPutAll: ' loopStart ', startLoop printString.		log nextPutAll: ' loopEnd ', endLoop printString; cr; tab.		tremoloDepth > 0 ifTrue: [			log nextPutAll: 'tremoloSweep ', tremoloSweep printString.			log nextPutAll: ' tremoloRate ', tremoloRate printString.			log nextPutAll: ' tremoloDepth ', tremoloDepth printString; space].		vibratoDepth > 0 ifTrue: [			log nextPutAll: 'vibratoSweep ', vibratoSweep printString.			log nextPutAll: ' vibratoRate ', vibratoRate printString.			log nextPutAll: ' vibratoDepth ', vibratoDepth printString].		log cr; endEntry].! !!GravisWavePlayer methodsFor: 'as yet unclassified' stamp: 'jm 4/24/2003 22:01'!checkLoop	| end intLength preLoopVal |	loopLength = 0 ifTrue: [		loopEnd _ samples monoSampleCount * ScaleFactor.		^ self].  "not looped"	end _ loopEnd // ScaleFactor.	intLength _ loopLength // ScaleFactor.	end > samples monoSampleCount ifTrue: [self error: 'bad loop end'].	(intLength < 0) | (intLength >= end) ifTrue: [self error: 'bad loop length'].	"copy the sample value just before the loop start to the index just after the end"	"(This allows us to always interpolate between samples i and i+1 even if i = end)."	preLoopVal _ samples at: end - intLength.	end = samples monoSampleCount ifTrue: [samples _ samples, #(0)].  "make room if needed"	samples at: end + 1 put: preLoopVal.! !!GravisWavePlayer methodsFor: 'as yet unclassified' stamp: 'jm 4/24/2003 22:46'!generateSamplesInto: aSoundBuffer	"Generate and add my sound into the given buffer."	| n k frac s nextS out |	samplesRemaining <= 0 ifTrue: [^ self].  "done"	n _ aSoundBuffer monoSampleCount min: samplesRemaining.	1 to: n do: [:i |		k _ index // ScaleFactor.		frac _ index \\ ScaleFactor.		s _ samples at: k.		nextS _ samples at: k + 1.		out _ ((nextS * frac) + (s * (ScaleFactor - frac))) // ScaleFactor.		aSoundBuffer at: i put: (aSoundBuffer at: i) + out.		index _ index + indexIncr.		index > loopEnd ifTrue: [			loopLength = 0 ifTrue: [				samplesRemaining _ 0.				^ self].			index _ index - loopLength]].	samplesRemaining _ samplesRemaining - n.! !!GravisWavePlayer methodsFor: 'as yet unclassified' stamp: 'jm 4/24/2003 22:49'!playPitch: pitchNameOrNumber dur: seconds	| buf |	self setPitch: pitchNameOrNumber dur: seconds loudness: 0.5.	buf _ SoundBuffer newMonoSampleCount: (SoundPlayer samplingRate * seconds) asInteger.	self generateSamplesInto: buf.	(SampledSound samples: buf samplingRate: SoundPlayer samplingRate) playAndWaitUntilDone! !!GravisWavePlayer methodsFor: 'as yet unclassified' stamp: 'jm 4/24/2003 22:15'!samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound use the given samples array with a loop of the given length starting at the given index. The loop length may have a fractional part; this is necessary to achieve pitch accuracy for short loops."	samples _ aSoundBuffer.	originalSamplingRate _ samplingRateInHz rounded.	originalPitch _ (perceivedPitchInHz * 100) rounded.	loopEnd _ (loopEndIndex * ScaleFactor) truncated.	loopLength _ (loopSampleCount * ScaleFactor) rounded.	index _ ScaleFactor.	indexIncr _ ScaleFactor.	self checkLoop.! !!GravisWavePlayer methodsFor: 'as yet unclassified' stamp: 'jm 4/24/2003 22:17'!setPitch: pitchNameOrNumber dur: seconds loudness: vol	"Initialize myself to play a note with given parameters."	| p |	p _ AbstractSound new nameOrNumberToPitch: pitchNameOrNumber.	index _ ScaleFactor.	indexIncr _		((p * 100 * originalSamplingRate * ScaleFactor) //		 (originalPitch * SoundPlayer samplingRate)).	samplesRemaining _ (SoundPlayer samplingRate * seconds) rounded.! !!GravisWavePlayer methodsFor: 'as yet unclassified' stamp: 'jm 4/24/2003 21:35'!unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound play the given samples unlooped. The samples have the given perceived pitch when played at the given sampling rate. By convention, unpitched sounds such as percussion sounds should specify a pitch of nil or 100 Hz."	self samples: aSoundBuffer		loopEnd: 0		loopLength: 0		pitch: perceivedPitchInHz		samplingRate: samplingRateInHz.! !!GravisWavePlayer class methodsFor: 'class initialization' stamp: 'jm 4/24/2003 21:02'!initialize	ScaleFactor _ 1024.! !HTTPSockets support HTTP requests, either directly or via an HTTP proxy server. An HTTPSocket saves the parse of the last ASCII header it saw, to avoid having to parse it repeatedly.The real action is in httpGet:accept:.  See the examples in the class, especially httpFileInNewChangeSet: and httpShowGif:.!]style[(206 15 45 23 5 13)f1,f1LHTTPSocket class httpGet:accept:;,f1,f1LHTTPSocket class httpFileInNewChangeSet:;,f1,f1LHTTPSocket class httpShowGif:;!!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'ls 8/14/1998 10:17'!contentType	| type i |	type _ self getHeader: 'content-type' default: nil.	type ifNil: [ ^nil ].	type _ type withBlanksTrimmed.	i _ type indexOf: $;.	i = 0 ifTrue: [ ^type ].	^(type copyFrom: 1 to: i-1) withBlanksTrimmed	! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'ls 8/12/1998 00:23'!contentType: header	"extract the content type from the header.  Content-type: text/plain<cr><lf>,  User may look in headerTokens afterwards."	| this |	headerTokens ifNil: [ headerTokens _ header findTokens: ParamDelimiters keep: (String with: CR) ].	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $c and: [#('content-type:' 'content type') includes: this asLowercase]) ifTrue: [			^ (headerTokens at: ii+1)]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'jm 9/15/97 11:35'!contentsLength: header	"extract the data length from the header.  Content-length: 1234<cr><lf>,  User may look in headerTokens afterwards."	| this |	headerTokens _ header findTokens: ParamDelimiters keep: (String with: CR).	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $c and: [this asLowercase = 'content-length:']) ifTrue: [			^ (headerTokens at: ii+1) asNumber]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'ls 8/12/1998 00:37'!getHeader: name 	^self getHeader: name  default: nil! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'ls 8/12/1998 00:36'!getHeader: name  default: defaultValue	^headers at: name  ifAbsent: [ defaultValue ]! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 11:39'!getResponseUpTo: markerString	"Keep reading until the marker is seen.  Return three parts: header, marker, beginningOfData.  Fails if no marker in first 2000 chars." 	| buf response bytesRead tester mm |	buf _ String new: 2000.	response _ WriteStream on: buf.	tester _ 1. mm _ 1.	[tester _ tester - markerString size + 1 max: 1.  "rewind a little, in case the marker crosses a read boundary"	tester to: response position do: [:tt |		(buf at: tt) = (markerString at: mm) ifTrue: [mm _ mm + 1] ifFalse: [mm _ 1].			"Not totally correct for markers like xx0xx"		mm > markerString size ifTrue: ["got it"			^ Array with: (buf copyFrom: 1 to: tt+1-mm)				with: markerString				with: (buf copyFrom: tt+1 to: response position)]].	 tester _ 1 max: response position.	"OK if mm in the middle"	 (response position < buf size) & (self isConnected | self dataAvailable)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: response position + 1 count: buf size - response position.		"response position+1 to: response position+bytesRead do: [:ii | 			response nextPut: (buf at: ii)].	totally redundant, but needed to advance position!!"		response instVarAt: 2 "position" put: 			(response position + bytesRead)].	"horrible, but fast"	^ Array with: response contents		with: ''		with: ''		"Marker not found and connection closed"! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'tao 6/22/1999 07:56'!getResponseUpTo: markerString ignoring: ignoreString	"Keep reading, until the marker is seen, skipping characters in ignoreString when      comparing to the marker.  Return three parts: header, marker, beginningOfData.     Fails if no marker in first 2000 chars." 	| buf response bytesRead tester mm skipped |	buf _ String new: 2000.	response _ WriteStream on: buf.	tester _ 1. mm _ 1.	skipped _ 0.	[tester _ tester - markerString size + 1 max: 1.  "rewind a little, in case the marker crosses a read boundary"	tester to: response position do: [:tt |		(buf at: tt) = (markerString at: mm) ifFalse:			[[ignoreString includes: (markerString at: mm)] whileTrue:				[mm _ mm + 1. skipped _ skipped + 1]].		(buf at: tt) = (markerString at: mm)			ifTrue: [mm _ mm + 1]			ifFalse: [mm _ 1. skipped _ 0].			"Not totally correct for markers like xx0xx"		mm > markerString size ifTrue: ["got it"			^ Array with: (buf copyFrom: 1 to: tt+1-mm+skipped)				with: markerString				with: (buf copyFrom: tt+1 to: response position)]].	 tester _ 1 max: response position.	"OK if mm in the middle"	 (response position < buf size) & (self isConnected | self dataAvailable)] whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [			Transcript show: 'data was late'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 			startingAt: response position + 1 count: buf size - response position.		"response position+1 to: response position+bytesRead do: [:ii | 			response nextPut: (buf at: ii)].	totally redundant, but needed to advance position!!"		response instVarAt: 2 "position" put: 			(response position + bytesRead)].	"horrible, but fast"	^ Array with: response contents		with: ''		with: ''		"Marker not found and connection closed"! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'tk 9/22/1998 12:24'!getRestOfBuffer: beginning	"We don't know the length.  Keep going until connection is closed.  Part of it has already been received.  Response is of type text, not binary."	| buf response bytesRead |	response _ RWBinaryOrTextStream on: (String new: 2000).	response nextPutAll: beginning.	buf _ String new: 2000.	[self isConnected | self dataAvailable] 	whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifTrue: [	 		Transcript show: 'data was slow'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf 				startingAt: 1 count: buf size. 		bytesRead > 0 ifTrue: [  			response nextPutAll: (buf copyFrom: 1 to: bytesRead)] ].	Transcript cr; show: 'data byte count: ', response position printString.	response reset.	"position: 0."	^ response! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'sma 4/22/2000 17:34'!getRestOfBuffer: beginning totalLength: length	"Reel in a string of a fixed length.  Part of it has already been received.  Close the connection after all chars are received.  We do not strip out linefeed chars.  tk 6/16/97 22:32" 	"if length is nil, read until connection close.  Response is of type text, not binary."	| buf response bytesRead |	length ifNil: [^ self getRestOfBuffer: beginning].	buf _ String new: length.	response _ RWBinaryOrTextStream on: buf.	response nextPutAll: beginning.	buf _ String new: length.	[(response position < length) & (self isConnected | self dataAvailable)] 	whileTrue: [		(self waitForDataUntil: (Socket deadlineSecs: 5)) ifFalse: [	 		Transcript show: 'data was slow'; cr].		bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 				count: (length - response position). 		bytesRead > 0 ifTrue: [  			response nextPutAll: (buf copyFrom: 1 to: bytesRead)] ].	"Transcript cr; show: 'data byte count: ', response position printString."	"Transcript cr; show: ((self isConnected) ifTrue: ['Over length by: ', bytesRead printString] 		ifFalse: ['Socket closed'])."	response position < length ifTrue: [^ 'server aborted early'].	response reset.	"position: 0."	^ response! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'ls 8/13/1998 00:33'!header: headerText	"set the headers.  Then getHeader: can be used"	"divide into basic lines"	| lines foldedLines i statusLine |	lines _ headerText findTokens: (String with: Character cr  with: Character linefeed).	statusLine _ lines first.	lines _ lines copyFrom: 2 to: lines size.	"parse the status (pretty trivial right now)"	responseCode _ (statusLine findTokens: ' ') second.	"fold lines that start with spaces into the previous line"	foldedLines _ OrderedCollection new.	lines do: [ :line |		line first isSeparator ifTrue: [			foldedLines at: foldedLines size  put: (foldedLines last, line) ]		ifFalse: [ foldedLines add: line ] ].	"make a dictionary mapping headers to header contents"	headers _ Dictionary new.	foldedLines do: [ :line |		i _ line indexOf: $:.		i > 0 ifTrue: [			headers 			at: (line copyFrom: 1 to: i-1) asLowercase 			put: (line copyFrom: i+1 to: line size) withBlanksTrimmed ] ]..! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'jm 9/26/97 18:28'!redirect	"See if the header has a 'Location: url CrLf' in it.  If so, return the new URL of this page.  tk 6/24/97 18:03"	| this |	1 to: headerTokens size do: [:ii | 		this _ headerTokens at: ii.		(this first asLowercase = $l and: [this asLowercase = 'location:']) ifTrue: [			^ (headerTokens at: ii+1)]].	^ nil	"not found"! !!HTTPSocket methodsFor: 'as yet unclassified' stamp: 'ls 8/12/1998 00:41'!responseCode	^responseCode! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'tk 9/21/1998 10:45'!blabEmail: aRequest	"Of the form 'From: me@isp.com <crlf>'"	HTTPBlabEmail _ aRequest! !!HTTPSocket class methodsFor: 'class initialization' stamp: 'msk 9/28/1998 15:51'!initialize	"HTTPSocket initialize"	ParamDelimiters _ ' ', CrLf.	HTTPPort _ 80.	HTTPProxyServer _ nil.	HTTPBlabEmail _ ''.  "	'From: tedk@disney.com', CrLf	"! !!HTTPSocket class methodsFor: 'get the page' stamp: 'di 5/6/1998 16:40'!httpFileInNewChangeSet: url	"Do a regular file-in of a file that is served from a web site.  Put it into a new changeSet."	"Notes: To store a file on an HTTP server, use the program 'Fetch'.  After indicating what file to store, choose 'Raw Data' from the popup menu that has MacBinary/Text/etc.  Use any file extension as long as it is not one of the common ones."	"	HTTPSocket httpFileInNewChangeSet: '206.18.68.12/squeak/updates/83tk_test.cs'	 "	| doc |	doc _ self httpGet: url accept: 'application/octet-stream'.	doc class == String ifTrue: [			PopUpMenu notify: 'Cannot seem to contact the web site'].	doc reset.	ChangeSorter newChangesFromStream: doc				named: (url findTokens: '/') last.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'jm 11/4/97 08:25'!httpGet: url	"Return the exact contents of a web page or other web object. The parsed header is saved.  Use a proxy server if one has been registered.  tk 7/23/97 17:21"	"	HTTPSocket httpShowPage: 'http://www.altavista.digital.com/index.html'	 "	"	HTTPSocket httpShowPage: 'www.webPage.com/~kaehler2/ab.html'	 "	"	HTTPSocket httpShowPage: 'www.exploratorium.edu/index.html'	 "	"	HTTPSocket httpShowPage: 'www.apple.com/default.html'	 "	"	HTTPSocket httpShowPage: 'www.altavista.digital.com/'	 "	"	HTTPSocket httpShowPage: 'jumbo/tedk/ab.html'	 "	^ self httpGet: url accept: 'application/octet-stream'! !!HTTPSocket class methodsFor: 'get the page' stamp: 'ls 9/15/1998 23:57'!httpGet: url accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	^self httpGet: url  args: nil accept: mimeType! !!HTTPSocket class methodsFor: 'get the page' stamp: 'jm 9/16/1998 10:31'!httpGet: url args: args accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	| document |	document _ self httpGetDocument: url  args: args  accept: mimeType.	(document isKindOf: String) ifTrue: [		"strings indicate errors"		^ document ].	^ (RWBinaryOrTextStream with: document content) reset! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 9/22/1998 23:25'!httpGetDocument: url	"Return the exact contents of a web page or other web object. The parsed header is saved.  Use a proxy server if one has been registered.  tk 7/23/97 17:21"	"	HTTPSocket httpShowPage: 'http://www.altavista.digital.com/index.html'	 "	"	HTTPSocket httpShowPage: 'www.webPage.com/~kaehler2/ab.html'	 "	"	HTTPSocket httpShowPage: 'www.exploratorium.edu/index.html'	 "	"	HTTPSocket httpShowPage: 'www.apple.com/default.html'	 "	"	HTTPSocket httpShowPage: 'www.altavista.digital.com/'	 "	"	HTTPSocket httpShowPage: 'jumbo/tedk/ab.html'	 "	^ self httpGetDocument: url args: nil accept: 'application/octet-stream' request: ''! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 9/22/1998 23:26'!httpGetDocument: url accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	^self httpGetDocument: url args: nil accept: mimeType request: ''! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 9/22/1998 23:26'!httpGetDocument: url args: args	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIMI type 'application/octet-stream'."	^self httpGetDocument: url args: args accept: 'application/octet-stream' request: ''! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 9/22/1998 17:48'!httpGetDocument: url args: args accept: mimeType	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. The parsed header is saved. Use a proxy server if one has been registered.  Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	^ self httpGetDocument: url args: args accept: mimeType request: ''! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 3/24/2000 11:20'!httpGetDocument: url args: args accept: mimeType request: requestString	"Return the exact contents of a web object. Asks for the given MIME type. If mimeType is nil, use 'text/html'. An extra requestString may be submitted and must end with crlf.  The parsed header is saved. Use a proxy server if one has been registered.  tk 7/23/97 17:12"	"Note: To fetch raw data, you can use the MIME type 'application/octet-stream'."	| serverName serverAddr port sock header length bare page list firstData aStream index connectToHost connectToPort type newUrl |	Socket initializeNetwork.	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	bare _ bare copyUpTo: $#.  "remove fragment, if specified"	serverName _ bare copyUpTo: $/.	page _ bare copyFrom: serverName size + 1 to: bare size.	(serverName includes: $:) 		ifTrue: [ index _ serverName indexOf: $:.			port _ (serverName copyFrom: index+1 to: serverName size) asNumber.			serverName _ serverName copyFrom: 1 to: index-1. ]		ifFalse: [ port _ self defaultPort ].	page size = 0 ifTrue: [page _ '/'].	"add arguments"	args ifNotNil: [page _ page, (self argString: args) ].	HTTPProxyServer isNil		ifTrue: [ 			connectToHost _ serverName.			connectToPort _ port ]		ifFalse:  [			page _ 'http://', serverName, ':', port printString, page.		"put back together"			connectToHost _ HTTPProxyServer.			connectToPort _ HTTPProxyPort].		self flag: #XXX.  "this doesn't make sense if a user isn't available for questioning...  -ls"	self retry: [serverAddr _ NetNameResolver addressForName: connectToHost timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [Socket deadServer: connectToHost.				^ 'Could not resolve the server named: ', connectToHost].3 timesRepeat: [	sock _ HTTPSocket new.	sock connectTo: serverAddr port: connectToPort.	(sock waitForConnectionUntil: (self deadlineSecs: 30)) ifFalse: [		Socket deadServer: connectToHost.  sock destroy.		^ 'Server ',connectToHost,' is not responding'].	Transcript cr; cr; show: url; cr.	sock sendCommand: 'GET ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Host: ', serverName, ':', port printString, CrLf.	"blank line automatically added"	list _ sock getResponseUpTo: CrLf, CrLf ignoring: (String with: CR).	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	"Transcript show: page; cr; show: header; cr."	firstData _ list at: 3.	header isEmpty 		ifTrue: [aStream _ 'server aborted early']		ifFalse: [			"dig out some headers"			sock header: header.			length _ sock getHeader: 'content-length'.			length ifNotNil: [ length _ length asNumber ].			type _ sock getHeader: 'content-type'.			sock responseCode first = $3 ifTrue: [				newUrl _ sock getHeader: 'location'.				newUrl ifNotNil: [ 					Transcript show: 'redirecting to ', newUrl; cr.					sock destroy.					^self httpGetDocument: newUrl  args: args  accept: mimeType ] ].			aStream _ sock getRestOfBuffer: firstData totalLength: length.			sock responseCode = '401' ifTrue: [^ header, aStream contents].			].	sock destroy.	"Always OK to destroy!!"	aStream class ~~ String ifTrue: [ 		^ MIMEDocument contentType: type content: aStream contents url: url].	aStream = 'server aborted early' ifFalse: [		]	].! !!HTTPSocket class methodsFor: 'get the page' stamp: 'di 4/4/1999 09:57'!httpGetNoError: url args: args accept: mimeType	"Return the exact contents of a web file.  Do better error checking.  Asks for the given MIME type.  To fetch raw data, you can use the MIMI type 'application/octet-stream'.  If mimeType is nil, use 'text/html'.  The parsed header is saved. Use a proxy server if one has been registered.""Edited to remove a lineFeed from the source 4/4/99 - di"	| document data |	document _ self httpGetDocument: url  args: args  accept: mimeType.	(document isKindOf: String) ifTrue: [		"strings indicate errors"		^ document ].	data _ document content.	(data beginsWith: '<HTML><HEAD>' , (String with: Character linefeed) , '<TITLE>4')		ifTrue: ["an error message  404 File not found"				^ data copyFrom: 21 to: data size-16].		^ (RWBinaryOrTextStream with: data) reset! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 10/15/97 12:07'!httpGif: url	"Fetch the given URL, parse it using the GIF reader, and return the resulting Form."	"	HTTPSocket httpShowGif: 'www.altavista.digital.com/av/pix/default/av-adv.gif'	 "	"	HTTPSocket httpShowGif: 'www.webPage.com/~kaehler2/ainslie.gif'	 "	| doc ggg |	doc _ self httpGet: url accept: 'image/gif'.	doc class == String ifTrue: [		self inform: 'The server with that GIF is not responding'.		^ ColorForm extent: 20@20 depth: 8].	doc binary; reset.	(ggg _ Smalltalk gifReaderClass new) setStream: doc.	^ ggg nextImage.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tao 10/26/97 23:21'!httpJpeg: url	"Fetch the given URL, parse it using the JPEG reader, and return the resulting Form."	| doc ggg |	doc _ self httpGet: url.	doc binary; reset.	(ggg _ Smalltalk jpegReaderClass new) setStream: doc.	^ ggg nextImage.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 9/22/1998 23:27'!httpPost: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| document |	document _ self httpPostDocument: url  args: argsDict  accept: mimeType  request: ''.	(document isKindOf: String) ifTrue: [ 		"strings indicate errors"		^document ].		^RWBinaryOrTextStream with: document content! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 9/22/1998 23:27'!httpPostDocument: url  args: argsDict	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	^self httpPostDocument: url args: argsDict accept: 'application/octet-stream' request: ''! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 9/22/1998 20:16'!httpPostDocument: url  args: argsDict accept: mimeType 	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	^ self httpPostDocument: url args: argsDict accept: mimeType request: ''! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tao 6/22/1999 07:46'!httpPostDocument: url  args: argsDict accept: mimeType request: requestString	"like httpGET, except it does a POST instead of a GET.  POST allows data to be uploaded"	| serverName serverAddr s header length bare page list firstData aStream port argsStream first specifiedServer type newUrl |	Socket initializeNetwork.	"parse url"	bare _ (url asLowercase beginsWith: 'http://') 		ifTrue: [url copyFrom: 8 to: url size]		ifFalse: [url].	serverName _ bare copyUpTo: $/.	specifiedServer _ serverName.	(serverName includes: $:) ifFalse: [ port _ self defaultPort ] ifTrue: [		port _ (serverName copyFrom: (serverName indexOf: $:) + 1 				to: serverName size) asNumber.		serverName _ serverName copyUpTo: $:.	].	page _ bare copyFrom: (bare indexOf: $/) to: bare size.	page size = 0 ifTrue: [page _ '/'].	HTTPProxyServer ifNotNil: [ 		page _ 'http://', serverName, ':', port printString, page.		"put back together"		serverName _ HTTPProxyServer.		port _ HTTPProxyPort].	"encode the arguments dictionary"	argsStream _ WriteStream on: String new.	first _ true.	argsDict associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first _ false ] ifFalse: [ argsStream nextPut: $& ].			argsStream nextPutAll: assoc key encodeForHTTP.			argsStream nextPut: $=.			argsStream nextPutAll: value encodeForHTTP.	] ].  	"make the request"		self retry: [serverAddr _ NetNameResolver addressForName: serverName timeout: 20.				serverAddr ~~ nil] 		asking: 'Trouble resolving server name.  Keep trying?'		ifGiveUp: [^ 'Could not resolve the server named: ', serverName].	s _ HTTPSocket new.	s connectTo: serverAddr port: port.	s waitForConnectionUntil: self standardDeadline.	Transcript cr; show: url; cr.	s sendCommand: 'POST ', page, ' HTTP/1.0', CrLf, 		(mimeType ifNotNil: ['ACCEPT: ', mimeType, CrLf] ifNil: ['']),		'ACCEPT: text/html', CrLf,	"Always accept plain text"		HTTPBlabEmail,	"may be empty"		requestString,	"extra user request. Authorization"		'User-Agent: Squeak 1.31', CrLf,		'Content-type: application/x-www-form-urlencoded', CrLf,		'Content-length: ', argsStream contents size printString, CrLf,		'Host: ', specifiedServer, CrLf.  "blank line automatically added"	s sendCommand: argsStream contents.	"get the header of the reply"	list _ s getResponseUpTo: CrLf, CrLf ignoring: (String with: CR).	"list = header, CrLf, CrLf, beginningOfData"	header _ list at: 1.	"Transcript show: page; cr; show: argsStream contents; cr; show: header; cr."	firstData _ list at: 3.	"dig out some headers"	s header: header.	length _ s getHeader: 'content-length'.	length ifNotNil: [ length _ length asNumber ].	type _ s getHeader: 'content-type'.	s responseCode first = $3 ifTrue: [		newUrl _ s getHeader: 'location'.		newUrl ifNotNil: [			Transcript show: 'redirecting to: ', newUrl; cr.			s destroy.			^self httpPostDocument: newUrl  args: argsDict  accept: mimeType ] ].	aStream _ s getRestOfBuffer: firstData totalLength: length.	s responseCode = '401' ifTrue: [^ header, aStream contents].	s destroy.	"Always OK to destroy!!"	^ MIMEDocument contentType: type  content: aStream contents url: url! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 5/4/1998 17:00'!httpShowChunk: url	"From a Swiki server, get a text chunk in the changes file.  Show its text in a window with style.  Vertical bar separates class and selector.  BE SURE TO USE ; instead of : in selectors!!"	"	HTTPSocket httpShowChunk: 'http://206.16.12.145:80/OurOwnArea.chunk.Socket|Comment'	 "	"	HTTPSocket httpShowChunk: 'http://206.16.12.145:80/OurOwnArea.chunk.Point|class|x;y;'	"	| doc text |	doc _ (self httpGet: url accept: 'application/octet-stream')."	doc size = 0 ifTrue: [doc _ 'The server does not seem to be responding']."	doc class == String ifTrue: [text _ doc] ifFalse: [text _ doc nextChunkText].	(StringHolder new contents: text) openLabel: url.! !!HTTPSocket class methodsFor: 'get the page' stamp: 'sma 4/30/2000 09:50'!httpShowGif: url	"Display the picture retrieved from the given URL, which is assumed to be a GIF file.	See examples in httpGif:."	self showImage: (self httpGif: url) named: (url findTokens: '/') last! !!HTTPSocket class methodsFor: 'get the page' stamp: 'sma 4/30/2000 09:51'!httpShowJpeg: url	"Display the picture retrieved from the given URL, which is assumed to be a JPEG file.	See examples in httpGif:."	self showImage: (self httpJpeg: url) named: (url findTokens: '/') last! !!HTTPSocket class methodsFor: 'get the page' stamp: 'tk 5/4/1998 17:01'!httpShowPage: url	"Display the exact contents of the given URL as text. See examples in httpGet:"	| doc |	doc _ (self httpGet: url accept: 'application/octet-stream') contents.	doc size = 0 ifTrue: [^ self error: 'Document could not be fetched'].	(StringHolder new contents: doc) openLabel: url.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'jm 9/15/97 12:06'!proxyTestingComment	"Test Kevin's SmartCache on this machine"	"	HTTPSocket useProxyServerNamed: '127.0.0.1' port: 8080.		HTTPSocket httpShowPage: 'http://www.disneyblast.com/default.html'.		HTTPSocket stopUsingProxyServer.	"	"Test getting to outside world from DOL"	"	HTTPSocket useProxyServerNamed: 'web-proxy.online.disney.com' port: 8080.		HTTPSocket httpShowPage: 'http://www.apple.com/default.html'.		HTTPSocket stopUsingProxyServer.	"	"Test Windows Machine in our cubicle at DOL"	"	HTTPSocket useProxyServerNamed: '206.18.67.150' port: 8080.		HTTPSocket httpShowPage: 'http://kids.online.disney.com/~kevin/squeak/k_t.morph'.		HTTPSocket stopUsingProxyServer.	"	"	HTTPSocket httpShowPage: 'kids.online.disney.com/'	"	"	HTTPSocket httpShowGif: 'kids.online.disney.com/~kevin/images/dlogo.gif'	"! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'ls 9/17/1998 07:18'!stopUsingProxyServer	"Stop directing HTTP request through a proxy server."	HTTPProxyServer _ nil.	HTTPProxyPort _ 80.! !!HTTPSocket class methodsFor: 'proxy settings' stamp: 'msk 9/28/1998 15:52'!useProxyServerNamed: proxyServerName port: portNum	"Direct all HTTP requests to the HTTP proxy server with the given name and port number."	proxyServerName ifNil: [  "clear proxy settings"		HTTPProxyServer _ nil.		HTTPProxyPort _ 80.		^ self].	proxyServerName class == String		ifFalse: [self error: 'Server name must be a String or nil'].	HTTPProxyServer _ proxyServerName.	HTTPProxyPort _ portNum.	HTTPProxyPort class == String ifTrue: [HTTPPort _ portNum asNumber].	HTTPProxyPort ifNil: [HTTPProxyPort _ self defaultPort].! !!HTTPSocket class methodsFor: 'utilities' stamp: 'tk 7/16/1999 16:46'!argString: args	"Return the args in a long string, as encoded in a url"	| argsString first |	args class == String ifTrue: ["sent in as a string, not a dictionary"		^ (args first = $? ifTrue: [''] ifFalse: ['?']), args].	argsString _ WriteStream on: String new.	argsString nextPut: $?.	first _ true.	args associationsDo: [ :assoc |		assoc value do: [ :value |			first ifTrue: [ first _ false ] ifFalse: [ argsString nextPut: $& ].			argsString nextPutAll: assoc key encodeForHTTP.			argsString nextPut: $=.			argsString nextPutAll: value encodeForHTTP. ] ].	^ argsString contents! !!HTTPSocket class methodsFor: 'utilities' stamp: 'jm 9/15/97 11:10'!retry: tryBlock asking: troubleString ifGiveUp: abortActionBlock	"Execute the given block. If it evaluates to true, return true. If it evaluates to false, prompt the user with the given string to see if he wants to try again. If not, evaluate the abortActionBlock and return false."	| response |	[tryBlock value] whileFalse: [		response _ (PopUpMenu labels: 'Retry\Give Up' withCRs)			startUpWithCaption: troubleString.		response = 2 ifTrue: [abortActionBlock value. ^ false]].	^ true! !!HTTPSocket class methodsFor: 'utilities' stamp: 'jm 10/14/2002 07:33'!showImage: image named: imageName	Smalltalk isMorphic		ifTrue: [World primaryHand attachMorph: (SketchMorph withForm: image)]		ifFalse: [FormView open: image named: imageName].! !!HTTPSocket class methodsFor: 'magic numbers' stamp: 'ls 9/17/1998 07:17'!defaultPort	"default port to connect on"	^80! !I provide a halo of handles for my target morph. Dragging, duplicating, rotating, resizing and other operations can be done by mousing down on the appropriate handle.!!HaloMorph methodsFor: 'initialization' stamp: 'jm 6/5/2003 21:29'!initialize	super initialize.	self color: (Color r: 0.6 g: 0.8 b: 1.0).	growingOrRotating _ false.! !!HaloMorph methodsFor: 'accessing' stamp: 'sw 1/26/2000 15:36'!haloBox: aBox	haloBox _ aBox! !!HaloMorph methodsFor: 'accessing' stamp: 'jm 10/15/2002 17:36'!setTarget: aMorph	"Private!! Set the target without adding handles."	target _ aMorph.! !!HaloMorph methodsFor: 'events' stamp: 'sw 9/7/1999 15:43'!staysUpWhenMouseIsDownIn: aMorph	^ ((aMorph == target) or: [submorphs includes: aMorph]) or:		["name under edit, special case"		(aMorph isKindOf: StringMorphEditor) and: [submorphs includes: aMorph owner]]! !!HaloMorph methodsFor: 'events' stamp: 'jm 10/15/2002 17:40'!wantsKeyboardFocusFor: aSubmorph	"To allow the name to be edited in the halo."	^ true! !!HaloMorph methodsFor: 'stepping' stamp: 'jm 10/15/2002 17:14'!step	| newBounds |	target ifNil: [^ self].	target isWorldMorph		ifTrue: [newBounds _ target bounds]		ifFalse: [newBounds _ target worldBoundsForHalo].	newBounds = self bounds ifTrue: [^ self].	growingOrRotating ifFalse: [  "adjust halo bounds if appropriate"		submorphs size > 1			ifTrue: [self addHandles].  "recreates full set with new bounds"		self bounds: newBounds].! !!HaloMorph methodsFor: 'private' stamp: 'jm 6/5/2003 21:58'!addCircleHandles	| box |	target isWorldMorph ifTrue: [^ self].	self removeAllMorphs.  "remove old handles, if any"	self bounds: target worldBoundsForHalo.  "update my size"	box _ self basicBox.	target addHandlesTo: self box: box.	self addName.	growingOrRotating _ false.	self layoutChanged.	self changed.! !!HaloMorph methodsFor: 'private' stamp: 'jm 6/5/2003 22:08'!addHandle: handleSpec for: targetMorph	"Add and return the handle defined by the haloSpec for the given target morph."	| helpString aPoint handle colorToUse iconName form |	helpString _ handleSpec addHandleSelector copyFrom: 4 to: handleSpec addHandleSelector size - 7.	(#('Menu') includes: helpString)		ifTrue: [helpString _ helpString, ' for me.']		ifFalse: [helpString _ helpString, ' me.'].	helpString = 'Dup me.' ifTrue: [helpString _ 'Duplicate me.'].	aPoint _ self		positionIn: haloBox		horizontalPlacement: handleSpec horizontalPlacement		verticalPlacement: handleSpec verticalPlacement.	handle _ MouseHandleMorph		newBounds: (Rectangle center: aPoint extent: self handleSize asPoint)		color: (colorToUse _ Color colorFrom: handleSpec color).	handle		target: targetMorph;		mouseUpTarget: self; mouseUpSelector: #endInteraction;		setBalloonText: (target balloonHelpTextFor: helpString).	iconName _ handleSpec iconSymbol.	iconName ifNotNil: [  "add icon if available"		form _ HaloIcons at: iconName ifAbsent: [nil].		form ifNotNil: [			handle addMorphCentered:				(ImageMorph new					form: form; 					color: colorToUse makeForegroundColor;					lock)]].	self addMorph: handle.	^ handle! !!HaloMorph methodsFor: 'private' stamp: 'jm 6/5/2003 20:28'!addHandles	self addCircleHandles.! !!HaloMorph methodsFor: 'private' stamp: 'sw 9/8/1999 11:06'!addName	self addNameBeneath: self basicBox string: target externalName! !!HaloMorph methodsFor: 'private' stamp: 'jm 5/15/2003 22:25'!addNameBeneath: outerRectangle string: aString	"Add a name display centered beneath the bottom of the outer rectangle. Return the handle."	| nameMorph namePosition |	nameMorph _ StringMorph contents: aString.	nameMorph color: Color magenta.	namePosition _ outerRectangle bottomCenter -		((nameMorph width // 2) @ (self handleSize negated // 2 - 1)).	nameMorph position: (namePosition min: self world viewBox bottomRight - nameMorph extent y + 2).	self addMorph: nameMorph.	^ nameMorph! !!HaloMorph methodsFor: 'private' stamp: 'sw 12/21/1999 22:10'!basicBox	| aBox minSide anExtent |	minSide _ 4 * self handleSize.	anExtent _ ((self width + self handleSize + 8) max: minSide) @				((self height + self handleSize + 8) max: minSide).	aBox _ Rectangle center: self center extent: anExtent.	^ self world		ifNil:			[aBox]		ifNotNil:			[aBox intersect: (self world viewBox insetBy: 8@8)]! !!HaloMorph methodsFor: 'private' stamp: 'jm 10/15/2002 17:36'!doDebug: evt with: menuHandle	"Ask hand to invoke the a debugging menu for my inner target.  If shift key is down, immediately put up an inspector on the inner target"	| menu |	self removeAllHandlesBut: nil.  "remove all handles"	self world displayWorld.	evt shiftPressed ifTrue: [		self delete.		^ target inspectInMorphic].	menu _ evt hand buildDebugHandleMenuFor: target.	menu addTitle: target externalName.	evt hand invokeMenu: menu event: evt.! !!HaloMorph methodsFor: 'private' stamp: 'sw 10/28/1999 21:28'!doDirection: anEvent with: directionHandle	self removeAllHandlesBut: directionHandle! !!HaloMorph methodsFor: 'private' stamp: 'di 9/30/1998 11:32'!doDrag: evt with: dragHandle	target setConstrainedPositionFrom:		(target pointFromWorld: evt cursorPoint - positionOffset).! !!HaloMorph methodsFor: 'private' stamp: 'sw 9/21/1998 12:25'!doDup: evt with: dupHandle	"Ask hand to duplicate my target."	evt hand setArgument: target.	self setTarget: evt hand duplicateMorph.	self removeAllHandlesBut: dupHandle! !!HaloMorph methodsFor: 'private' stamp: 'jm 10/15/2002 17:53'!doGrow: evt with: growHandle	| newExtent |	newExtent _ (target pointFromWorld: (evt cursorPoint - positionOffset)) - target topLeft.	evt shiftPressed ifTrue: [newExtent _ (newExtent x max: newExtent y) asPoint].	target extent: (newExtent max: minExtent).	((target respondsTo: #scalePoint) and: [(target scalePoint - 1.0) r < 0.15])		ifTrue: [			target scalePoint: 1.0@1.0.			growHandle color: Color yellow]		ifFalse: [growHandle color: Color orange].	growHandle position: evt cursorPoint - (growHandle extent // 2).	self layoutChanged.! !!HaloMorph methodsFor: 'private' stamp: 'jm 10/15/2002 17:35'!doMenu: evt with: menuHandle	"Ask hand to invoke the halo menu for my inner target."	| menu |	self removeAllHandlesBut: nil.  "remove all handles"	self world displayWorld.	menu _ evt hand buildMorphHandleMenuFor: target.	target addTitleForHaloMenu: menu.	evt hand invokeMenu: menu event: evt.! !!HaloMorph methodsFor: 'private' stamp: 'jm 10/15/2002 17:36'!doRecolor: evt with: menuHandle	target changeColor.! !!HaloMorph methodsFor: 'private' stamp: 'jm 10/15/2002 17:35'!doRot: evt with: rotHandle	"Update the rotation of my target if it is rotatable."	| degrees |	degrees _ (evt cursorPoint - (target pointInWorld: target referencePosition)) degrees.	degrees _ degrees - angleOffset degrees.	degrees _ degrees detentBy: 10.0 atMultiplesOf: 90.0 snap: false.	degrees = 0.0		ifTrue: [rotHandle color: Color lightBlue]		ifFalse: [rotHandle color: Color blue].	rotHandle submorphsDo:		[:m | m color: rotHandle color makeForegroundColor].	((target isKindOf: SketchMorph) and: [target rotationStyle == #normal]) ifTrue:		[self removeAllHandlesBut: rotHandle].	target rotationDegrees: degrees.	rotHandle position: evt cursorPoint - (rotHandle extent // 2).	self layoutChanged! !!HaloMorph methodsFor: 'private' stamp: 'jm 10/15/2002 16:13'!endInteraction	(target isInWorld not or: [owner == nil]) ifTrue: [^ self].	self isInWorld ifTrue: [		self comeToFront.		self addHandles].! !!HaloMorph methodsFor: 'private' stamp: 'sw 1/27/2000 18:42'!handleAllowanceForIconicHalos	^ 12! !!HaloMorph methodsFor: 'private' stamp: 'jm 10/15/2002 17:38'!handleSize	^ 16! !!HaloMorph methodsFor: 'private' stamp: 'bolot 4/14/2000 19:32'!maybeCollapse: evt with: collapseHandle	"Ask hand to collapse my target if mouse comes up in it."	(collapseHandle containsPoint: evt cursorPoint)		ifFalse:			[self delete.			target addHalo: evt]		ifTrue:			[self delete.			target collapse]! !!HaloMorph methodsFor: 'private' stamp: 'jm 10/11/2002 16:51'!maybeDismiss: evt with: dismissHandle	"Ask hand to dismiss my target if mouse comes up in it."	(dismissHandle containsPoint: evt cursorPoint)		ifFalse: [			self delete.			target addHalo: evt]		ifTrue: [			self delete.			target delete].! !!HaloMorph methodsFor: 'private' stamp: 'jm 10/3/2002 19:41'!maybeDoDup: evt with: dupHandle	^ self doDup: evt with: dupHandle! !!HaloMorph methodsFor: 'private' stamp: 'sma 5/3/2000 23:12'!mouseDownInCollapseHandle: evt with: collapseHandle	self removeAllHandlesBut: collapseHandle.	collapseHandle color: Color tan darker! !!HaloMorph methodsFor: 'private' stamp: 'jm 10/11/2002 16:54'!mouseDownInDimissHandle: evt with: dismissHandle	self removeAllHandlesBut: dismissHandle.	dismissHandle color: Color darkGray.! !!HaloMorph methodsFor: 'private' stamp: 'sw 10/28/1999 22:24'!prepareToTrackCenterOfRotation: anEvent with: rotationHandle	self removeAllHandlesBut: rotationHandle! !!HaloMorph methodsFor: 'private' stamp: 'sw 3/22/1999 21:26'!setDismissColor: evt with: dismissHandle	"Called on mouseStillDown in the dismiss handle; set the color appropriately."	| colorToUse |	colorToUse _  (dismissHandle containsPoint: evt cursorPoint)		ifFalse:			[Color red muchLighter]		ifTrue:			[Color lightGray].	dismissHandle color: colorToUse! !!HaloMorph methodsFor: 'private' stamp: 'jm 10/4/2002 07:08'!startDrag: evt with: dragHandle	"Drag my target without removing it from its owner."	self removeAllHandlesBut: dragHandle.	positionOffset _ dragHandle center - target positionInWorld.! !!HaloMorph methodsFor: 'private' stamp: 'jm 10/11/2002 16:38'!startGrow: evt with: growHandle	| botRt |	"Initialize resizing of my target."	growingOrRotating _ true.	self removeAllHandlesBut: growHandle.  "remove all other handles"	botRt _ target pointInWorld: target bottomRight.	(self world viewBox containsPoint: botRt)		ifTrue: [positionOffset _ evt cursorPoint - botRt]		ifFalse: [positionOffset _ 0@0].	target isAlignmentMorph		ifTrue: [minExtent _ target minWidth@target minHeight]		ifFalse: [minExtent _ 3@3].! !!HaloMorph methodsFor: 'private' stamp: 'jm 10/15/2002 15:53'!startRot: evt with: rotHandle	"Initialize rotation of my target. Assume it is rotatable."	growingOrRotating _ true.	self removeAllHandlesBut: rotHandle.  "remove all other handles"	angleOffset _ evt cursorPoint - (target pointInWorld: target referencePosition).	angleOffset _ Point		r: angleOffset r		degrees: angleOffset degrees - target rotationDegrees.! !!HaloMorph methodsFor: 'private' stamp: 'sw 12/30/1999 11:35'!trackCenterOfRotation: anEvent with: rotationCenterHandle	rotationCenterHandle center: anEvent cursorPoint! !!HaloMorph methodsFor: 'handles' stamp: 'jm 10/11/2002 17:28'!addCollapseHandle: haloSpec	(self addHandle: haloSpec for: self)		mouseDownSelector: #mouseDownInCollapseHandle:with:;		mouseMoveSelector: #setDismissColor:with:;		mouseUpSelector: #maybeCollapse:with:.! !!HaloMorph methodsFor: 'handles' stamp: 'jm 10/11/2002 17:29'!addDebugHandle: haloSpec	Preferences debugHaloHandle ifTrue: [		(self addHandle: haloSpec for: self)			mouseDownSelector: #doDebug:with:].! !!HaloMorph methodsFor: 'handles' stamp: 'jm 10/11/2002 17:26'!addDismissHandle: handleSpec	(self addHandle: handleSpec for: self)		mouseDownSelector: #mouseDownInDimissHandle:with:;		mouseMoveSelector: #maybeDismiss:with:;		mouseUpSelector: #setDismissColor:with:.! !!HaloMorph methodsFor: 'handles' stamp: 'jm 10/11/2002 17:27'!addDragHandle: haloSpec	(self addHandle: haloSpec for: self)		mouseDownSelector: #startDrag:with:;		mouseMoveSelector: #doDrag:with:.! !!HaloMorph methodsFor: 'handles' stamp: 'jm 10/11/2002 17:30'!addDupHandle: haloSpec	(self addHandle: haloSpec for: self)		mouseDownSelector: #doDup:with:.! !!HaloMorph methodsFor: 'handles' stamp: 'jm 10/15/2002 17:36'!addFontEmphHandle: haloSpec	(target isKindOf: TextMorph) ifTrue: [		(self addHandle: haloSpec for: self)			target: target;			mouseDownSelector: #chooseEmphasisOrAlignment;			mouseUpTarget: self].! !!HaloMorph methodsFor: 'handles' stamp: 'jm 10/15/2002 17:36'!addFontSizeHandle: haloSpec	(target isKindOf: TextMorph) ifTrue: [		(self addHandle: haloSpec for: self)			target: target;			mouseDownSelector: #chooseFont;			mouseUpTarget: self].! !!HaloMorph methodsFor: 'handles' stamp: 'jm 10/15/2002 17:37'!addFontStyleHandle: haloSpec	(target isKindOf: TextMorph) ifTrue: [		(self addHandle: haloSpec for: self)			target: target;			mouseDownSelector: #chooseStyle;			mouseUpTarget: self].! !!HaloMorph methodsFor: 'handles' stamp: 'jm 10/11/2002 17:31'!addGrabHandle: haloSpec	(self addHandle: haloSpec for: self)		mouseDownSelector: #doGrab:with:.! !!HaloMorph methodsFor: 'handles' stamp: 'jm 10/15/2002 16:12'!addGrowHandle: haloSpec	(self addHandle: haloSpec for: self)		mouseDownSelector: #startGrow:with:;		mouseMoveSelector: #doGrow:with:.! !!HaloMorph methodsFor: 'handles' stamp: 'jm 10/15/2002 17:34'!addHelpHandle: haloSpec	target balloonText ifNotNil: [		(self addHandle: haloSpec for: self)			mouseDownSelector: #mouseDownOnHelpHandle:;			mouseUpSelector: #deleteBalloon;			mouseUpTarget: target].! !!HaloMorph methodsFor: 'handles' stamp: 'jm 10/11/2002 17:35'!addMenuHandle: haloSpec	(self addHandle: haloSpec for: self)		mouseDownSelector: #doMenu:with:.! !!HaloMorph methodsFor: 'handles' stamp: 'jm 10/15/2002 17:34'!addRecolorHandle: haloSpec	target isColorable ifTrue: [		(self addHandle: haloSpec for: self)			mouseDownSelector: #doRecolor:with:].! !!HaloMorph methodsFor: 'handles' stamp: 'jm 12/9/2003 18:06'!addRepaintHandle: haloSpec	target isPaintable ifTrue: [		(self addHandle: haloSpec for: self)			target: target;			mouseDownSelector: #editDrawing;			mouseUpTarget: self].! !!HaloMorph methodsFor: 'handles' stamp: 'jm 3/17/2003 15:23'!addRotateHandle: haloSpec	self flag: 'use isRotatable here:'.	((target isKindOf: SketchMorph) or:	 [target isKindOf: SpriteMorph]) ifTrue: [		(self addHandle: haloSpec for: self)			mouseDownSelector: #startRot:with:;			mouseMoveSelector: #doRot:with:].! !!HaloMorph methodsFor: 'handles' stamp: 'sw 12/21/1999 18:22'!positionIn: aBox horizontalPlacement: horiz verticalPlacement: vert	| xCoord yCoord |	horiz == #left		ifTrue:	[xCoord _ aBox left].	horiz == #leftCenter		ifTrue:	[xCoord _ aBox left + (aBox width // 4)].	horiz == #center		ifTrue:	[xCoord _ (aBox left + aBox right) // 2].	horiz == #rightCenter		ifTrue:	[xCoord _ aBox left + ((3 * aBox width) // 4)].	horiz == #right		ifTrue:	[xCoord _ aBox right].	vert == #top		ifTrue:	[yCoord _ aBox top].	vert == #topCenter		ifTrue:	[yCoord _ aBox top + (aBox height // 4)].	vert == #center		ifTrue:	[yCoord _ (aBox top + aBox bottom) // 2].	vert == #bottomCenter		ifTrue:	[yCoord _ aBox top + ((3 * aBox height) // 4)].	vert == #bottom		ifTrue:	[yCoord _ aBox bottom].	^ xCoord @ yCoord! !I record the parameters of a Halo handle including it's color, icon name, placement, and the selector that determines it's behavior.!!HaloSpec methodsFor: 'initialization' stamp: 'jm 10/11/2002 16:41'!horizontalPlacement: hp verticalPlacement: vp color: col iconSymbol: is addHandleSelector: sel	horizontalPlacement _ hp.	verticalPlacement _ vp.	color _ col.	iconSymbol _ is asSymbol.	addHandleSelector _ sel.! !!HaloSpec methodsFor: 'accessing' stamp: 'sw 1/25/2000 19:54'!addHandleSelector	^ addHandleSelector! !!HaloSpec methodsFor: 'accessing' stamp: 'sw 1/25/2000 18:41'!color	^ color! !!HaloSpec methodsFor: 'accessing' stamp: 'sw 1/25/2000 18:41'!horizontalPlacement	^ horizontalPlacement! !!HaloSpec methodsFor: 'accessing' stamp: 'sw 1/25/2000 18:41'!iconSymbol	^ iconSymbol! !!HaloSpec methodsFor: 'accessing' stamp: 'sw 1/25/2000 18:41'!verticalPlacement	^ verticalPlacement! !The cursor may be thought of as the HandMorph. The hand's submorphs hold anything being carried by dragging. There can be multiple hands in the same world, in which case the user initials are displayed for each remote hand.!!HandMorph methodsFor: 'initialization' stamp: 'jm 8/11/2003 20:53'!initForEvents	mouseDownMorph _ nil.	lastEvent _ MorphicEvent new.	eventTransform _ MorphicTransform identity.	self resetClickState.	mouseOverTimes _ Dictionary new.! !!HandMorph methodsFor: 'initialization' stamp: 'jm 10/14/2002 07:52'!initialize	super initialize.	self initForEvents.	keyboardFocus _ nil.	mouseOverMorphs _ OrderedCollection new.	dragOverMorphs _ OrderedCollection new.	bounds _ 0@0 extent: Cursor normal extent.	userInitials _ ''.	damageRecorder _ DamageRecorder new.	cachedCanvasHasHoles _ false.	grid _ 4@4.	gridOn _ false.	temporaryCursor _ temporaryCursorOffset _ nil! !!HandMorph methodsFor: 'classification' stamp: 'jm 10/14/2002 07:51'!isHandMorph	^ true! !!HandMorph methodsFor: 'cursor' stamp: 'jwh 6/5/2000 07:38'!cursorBounds	^temporaryCursor 		ifNil: [self position extent: NormalCursor extent]		ifNotNil: [self position + temporaryCursorOffset extent: temporaryCursor extent]! !!HandMorph methodsFor: 'cursor' stamp: 'di 3/6/1999 23:52'!showTemporaryCursor: cursorOrNil	"Set the temporary cursor to the given Form. If the argument is nil, revert to the normal cursor."	self showTemporaryCursor: cursorOrNil hotSpotOffset: 0@0! !!HandMorph methodsFor: 'cursor' stamp: 'jwh 6/5/2000 08:48'!showTemporaryCursor: cursorOrNil hotSpotOffset: hotSpotOffset	"Set the temporary cursor to the given Form.	If the argument is nil, revert to the normal hardware cursor."	self changed.	cursorOrNil == nil		ifTrue: [temporaryCursor _ temporaryCursorOffset _ nil]		ifFalse: [temporaryCursor _ cursorOrNil asCursorForm.				temporaryCursorOffset _ temporaryCursor offset - hotSpotOffset].	bounds _ self cursorBounds.	self 		userInitials: userInitials;		layoutChanged;		changed! !!HandMorph methodsFor: 'geometry' stamp: 'jwh 6/5/2000 08:11'!position	^temporaryCursor		ifNil: [bounds topLeft]		ifNotNil: [bounds topLeft - temporaryCursorOffset]! !!HandMorph methodsFor: 'geometry' stamp: 'jwh 6/5/2000 07:52'!position: aPoint	"Overridden to align submorph origins to the grid if gridding is on."	| adjustedPosition |	adjustedPosition := aPoint.	gridOn ifTrue: [adjustedPosition := adjustedPosition grid: grid].	temporaryCursor ifNotNil: [adjustedPosition := adjustedPosition + temporaryCursorOffset].	^super position: adjustedPosition! !!HandMorph methodsFor: 'geometry' stamp: 'ar 5/18/2000 18:35'!userInitials: aString	| qp cb |	userInitials _ aString.	userInitials isEmpty ifFalse:		[qp _ DisplayScanner quickPrintOn: Display.		cb _ self cursorBounds.		self bounds: (cb merge: (cb topRight + (0@4)					extent: (qp stringWidth: userInitials)@(qp lineHeight)))]! !!HandMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:05'!drawOn: aCanvas	"Draw the hand itself (i.e., the cursor)."	temporaryCursor == nil		ifTrue: [aCanvas paintImage: NormalCursor at: bounds topLeft]		ifFalse: [aCanvas paintImage: temporaryCursor at: bounds topLeft].	userInitials size > 0 ifTrue:		[aCanvas text: userInitials					at: (self cursorBounds topRight + (0@4))					font: nil color: color].! !!HandMorph methodsFor: 'drawing' stamp: 'jm 10/14/2002 07:49'!fullDrawOn: aCanvas	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version caches an image of the morphs being held by the hand for	 better performance. This cache is invalidated if one of those morphs changes."	| disableCaching subBnds |	disableCaching _ false.	disableCaching ifTrue: [self nonCachingFullDrawOn: aCanvas. ^ self].	submorphs isEmpty ifTrue:		[cacheCanvas _ nil.		^ self drawOn: aCanvas].  "just draw the hand itself"	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	self updateCacheCanvas: aCanvas.	(cacheCanvas == nil or: [cachedCanvasHasHoles and: [cacheCanvas depth = 1]])		ifTrue:		["could not use caching due to translucency; do full draw"		self nonCachingFullDrawOn: aCanvas. ^ self].	"draw the shadow"	aCanvas asShadowDrawingCanvas		translateBy: self shadowOffset during:[:shadowCanvas|		cachedCanvasHasHoles			ifTrue: ["Have to draw the real shadow of the form"					shadowCanvas paintImage: cacheCanvas form at: subBnds origin]			ifFalse: ["Much faster if only have to shade the edge of a solid rectangle"					(subBnds areasOutside: (subBnds translateBy: self shadowOffset negated)) do:						[:r | shadowCanvas fillRectangle: r color: Color black]]].	"draw morphs in front of the shadow using the cached Form"	cachedCanvasHasHoles		ifTrue: [aCanvas paintImage: cacheCanvas form at: subBnds origin]		ifFalse: [aCanvas drawImage: cacheCanvas form at: subBnds origin					sourceRect: cacheCanvas form boundingBox].	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'ar 2/18/2000 15:19'!nonCachingFullDrawOn: aCanvas	| shadowForm |	"A HandMorph has unusual drawing requirements:		1. the hand itself (i.e., the cursor) appears in front of its submorphs		2. morphs being held by the hand cast a shadow on the world/morphs below	The illusion is that the hand plucks up morphs and carries them above the world."	"Note: This version does not cache an image of the morphs being held by the hand.	 Thus, it is slower for complex morphs, but consumes less space."	submorphs isEmpty ifTrue: [^ self drawOn: aCanvas].  "just draw the hand itself"	aCanvas asShadowDrawingCanvas		translateBy: self shadowOffset during:[:shadowCanvas|		"Note: We use a shadow form here to prevent drawing		overlapping morphs multiple times using the transparent		shadow color."		shadowForm _ self shadowForm."shadowForm displayAt: shadowForm offset negated. Display forceToScreen: (0@0 extent: shadowForm extent)."		shadowCanvas paintImage: shadowForm at: shadowForm offset.  "draw shadows"	].	"draw morphs in front of shadows"	self drawSubmorphsOn: aCanvas.	self drawOn: aCanvas.  "draw the hand itself in front of morphs"! !!HandMorph methodsFor: 'drawing' stamp: 'di 3/19/2000 14:26'!restoreSavedPatchOn: aCanvas	"Clear the changed flag and restore the part of the given canvas under this hand from the previously saved patch. If necessary, handle the transition to using the hardware cursor."	hasChanged _ false.	savedPatch ifNotNil:		[aCanvas drawImage: savedPatch at: savedPatch offset.		((userInitials size = 0) and:		 [(submorphs size = 0) and:		 [temporaryCursor == nil]]) ifTrue: [			"Make the transition to using hardware cursor. Clear savedPatch and			 report one final damage rectangle to erase the image of the software cursor."			super invalidRect: (savedPatch offset extent: savedPatch extent + self shadowOffset).			Sensor currentCursor == Cursor normal ifFalse: [Cursor normal show].  "show hardware cursor"			savedPatch _ nil]].! !!HandMorph methodsFor: 'drawing' stamp: 'ar 5/28/2000 16:01'!savePatchFrom: aCanvas	"Save the part of the given canvas under this hand as a Form and return its bounding rectangle."	"Details: The previously used patch Form is recycled when possible to reduce the burden on storage management."	| damageRect myBnds |	damageRect _ myBnds _ self fullBounds.	savedPatch ifNotNil: [		damageRect _ myBnds merge: (savedPatch offset extent: savedPatch extent)].	(savedPatch == nil or: [savedPatch extent ~= myBnds extent])		ifTrue: [  "allocate new patch form if needed"			savedPatch _ aCanvas form allocateForm: myBnds extent].	aCanvas		contentsOfArea: (myBnds translateBy: aCanvas origin)		into: savedPatch.	savedPatch offset: myBnds topLeft.	^ damageRect! !!HandMorph methodsFor: 'drawing' stamp: 'jm 11/24/2002 10:48'!shadowForm	"Return a 1-bit shadow of my submorphs.  Assumes submorphs is not empty"	| bnds canvas |	bnds _ Rectangle merging: (submorphs collect: [:m | m bounds]).	canvas _ (FormCanvas extent: bnds extent depth: 1) 		asShadowDrawingCanvas: Color black.	canvas translateBy: bnds topLeft negated		during:[:tempCanvas| self drawSubmorphsOn: tempCanvas].	^ canvas form offset: bnds topLeft! !!HandMorph methodsFor: 'drawing' stamp: 'ar 5/28/2000 17:12'!updateCacheCanvas: aCanvas	"Update the cached image of the morphs being held by this hand."	| subBnds rectList |	"Always check for real translucency -- can't be cached in a form"	self allMorphsDo: [:m |		m hasTranslucentColor ifTrue: [			cacheCanvas _ nil.			cachedCanvasHasHoles _ true.			^ self]].	subBnds _ Rectangle merging: (submorphs collect: [:m | m fullBounds]).	(cacheCanvas == nil or: [cacheCanvas extent ~= subBnds extent]) ifTrue: [		cacheCanvas _ (aCanvas allocateForm: subBnds extent) getCanvas.		cacheCanvas translateBy: subBnds origin negated			during:[:tempCanvas| self drawSubmorphsOn: tempCanvas].		self submorphsDo:			[:m | (m areasRemainingToFill: subBnds) isEmpty				ifTrue: [^ cachedCanvasHasHoles _ false]].		cachedCanvasHasHoles _ (cacheCanvas form tallyPixelValues at: 1) > 0.		^ self].	"incrementally update the cache canvas"	rectList _ damageRecorder invalidRectsFullBounds: (0@0 extent: subBnds extent).	damageRecorder reset.	rectList do: [:r |		cacheCanvas translateTo: subBnds origin negated clippingTo: r during:[:c|			c fillColor: Color transparent.  "clear to transparent"			self drawSubmorphsOn: c]].! !!HandMorph methodsFor: 'event handling' stamp: 'jm 10/4/2002 17:58'!checkForMoreKeyboard	"Quick check for more keyboard activity -- Allows, eg, many characters to be accumulated into a single replacement during type-in."	| oldPoint |	Sensor keyboardPressed ifFalse: [^ nil].	oldPoint _ lastEvent cursorPoint.	lastEvent _ MorphicEvent new		setKeyValue: Sensor keyboard asciiValue		mousePoint: oldPoint		buttons: Sensor primMouseButtons		hand: self.	^ lastEvent! !!HandMorph methodsFor: 'event handling' stamp: 'jm 10/13/2002 17:33'!dragOverList: evt	| p roots mList mm root |	p _ evt cursorPoint.	roots _ self world rootMorphsAt: p.  "root morphs in world"	roots isEmpty		ifTrue: [^ Array empty]		ifFalse: [root _ roots first].	mList _ root morphsAt: p.	mList size > 0 ifTrue:		["NOTE: We really only want the top morph and all its owners"		mm _ mList first.		mList _ OrderedCollection new.		[mm == root] whileFalse:			[mList addLast: mm.			mm _ mm owner].		mList add: root].	^ mList! !!HandMorph methodsFor: 'event handling' stamp: 'bf 1/5/2000 18:18'!gridPointRaw	"Private!! Returns the nearest grid point to the cursor to be used as the coordinate for the current event.  Do not include a cursor offset"	| where |	where _ Sensor cursorPoint.	^ gridOn ifTrue: [where grid: grid]			ifFalse: [where]! !!HandMorph methodsFor: 'event handling' stamp: 'mir 5/9/2000 15:28'!handleDragOver: evt	| mList allMouseOvers leftMorphs enteredMorphs |	owner ifNil: [^ self].  "this hand is not in a world"	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self dragOverList: evt.	"Make a list of all potential drag-overs..."	allMouseOvers _ mList select:		[:m | m handlesMouseOverDragging: (evt transformedBy: (m transformFrom: self))].	leftMorphs _ dragOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (dragOverMorphs includes: m) not].	"Notify and remove any morphs that have just been left..."	leftMorphs do: [:m |		dragOverMorphs remove: m.		m mouseLeaveDragging: (evt transformedBy: (m transformFrom: self))].	"Add any new mouse-overs and send mouseEnter:"	enteredMorphs do: [:m |		dragOverMorphs add: m.		mouseOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		m mouseEnterDragging: (evt transformedBy: (m transformFrom: self))].! !!HandMorph methodsFor: 'event handling' stamp: 'jm 8/11/2003 21:43'!handleEvent: evt		(evt anyButtonPressed and:	 [evt controlKeyPressed and:	 [lastEvent anyButtonPressed not]]) ifTrue: [		eventTransform _ MorphicTransform identity.		lastEvent _ evt.		^ self invokeMetaMenu: evt].	evt blueButtonPressed ifTrue: [		lastEvent blueButtonPressed ifFalse: [			eventTransform _ MorphicTransform identity.			lastEvent _ evt.			^ self specialGesture: evt]].	lastEvent _ evt.	self position ~= evt cursorPoint ifTrue: [		self position: evt cursorPoint].	evt isMouse ifTrue: [		evt isMouseMove ifTrue: [^ self handleMouseMove: evt].		evt isMouseDown ifTrue: [ ^ self handleMouseDown: evt].		evt isMouseUp ifTrue: [^ self handleMouseUp: evt]].	evt isKeystroke ifTrue: [		keyboardFocus			ifNil: [self recordUnclaimedKeystroke: evt]			ifNotNil: [keyboardFocus keyStroke: evt].		^ self].! !!HandMorph methodsFor: 'event handling' stamp: 'jm 7/18/2003 11:46'!handleMouseDown: evt	"Dispatch a mouseDown event."	| m localEvt rootForGrab aHalo |	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	clickState ~~ #idle ifTrue: [^ self checkForDoubleClick: evt].	m _ self recipientForMouseDown:			(gridOn  "Don't grid when determining recipient"				ifTrue: ["Should really use original cursorPoint, but this should do"						evt copy setCursorPoint: Sensor cursorPoint]				ifFalse: [evt]).	m ifNotNil:		[aHalo _ self world haloMorphOrNil.		(aHalo == nil or: [aHalo staysUpWhenMouseIsDownIn: m])			ifFalse: [self world abandonAllHalos].		m deleteBalloon.		(m handlesMouseDown: evt)			ifTrue:				["start a mouse transaction on m"				(self newMouseFocus: m) ifNil: [^ self].				localEvt _ self transformEvent: evt.				targetOffset _ localEvt cursorPoint - m position.				m mouseDown: localEvt.				clickState == #firstClickDown					ifTrue: ["clickClient click: firstClickEvent"]					ifFalse:					["ensure that at least one mouseMove: is reported for each mouse transaction:"					m mouseMove: (localEvt copy setType: #mouseMove).					(m handlesMouseOverDragging: localEvt) ifTrue:						["If m also handles dragOver, enter it in the list"						dragOverMorphs add: m.						mouseOverMorphs remove: m ifAbsent: []]]]			ifFalse:				["grab m by the appropriate root"				menuTargetOffset _ targetOffset _ evt cursorPoint.				rootForGrab _ m rootForGrabOf: m.				rootForGrab					ifNotNil:						[self grabMorph: rootForGrab]					ifNil:						[self newMouseFocus: m   "trigger automatic viewing, for example"]].		mouseOverTimes removeKey: m ifAbsent: []]! !!HandMorph methodsFor: 'event handling' stamp: 'di 9/3/1998 15:58'!handleMouseMove: evt	"Dispatch a mouseMove event."	clickState ~~ #idle ifTrue: [self checkForDoubleClick: evt].	mouseDownMorph ifNotNil:		[mouseDownMorph mouseMove: (self transformEvent: evt)].	submorphs isEmpty		ifTrue: [evt anyButtonPressed				ifTrue: [self handleDragOver: evt]				ifFalse: [self handleMouseOver: evt]]		ifFalse: [self handleDragOver: evt]! !!HandMorph methodsFor: 'event handling' stamp: 'sw 4/3/2000 17:44'!handleMouseOver: evt	| mList allMouseOvers leftMorphs enteredMorphs now t oldHalo balloonHelpEnabled |	owner ifNil: [^ self].	balloonHelpEnabled _ Preferences balloonHelpEnabled.	"Start with a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	mList _ self mouseOverList: evt.	now _ Time millisecondClockValue.	"Make a list of all potential mouse-overs..."	allMouseOvers _ mList select:		[:m | m wantsHalo or: [(balloonHelpEnabled and: [m wantsBalloon])  "To start a timer"			or: [m handlesMouseOver: (evt transformedBy: (m transformFrom: self))]  "To send mouseEnter:"]].	leftMorphs _ mouseOverMorphs select: [:m | (allMouseOvers includes: m) not].	enteredMorphs _ allMouseOvers select: [:m | (mouseOverMorphs includes: m) not].	"Notify and remove any mouse-overs that have just been left..."	leftMorphs do: [:m |		mouseOverMorphs remove: m.		m wantsBalloon ifTrue: [m deleteBalloon].		m mouseLeave: (evt transformedBy: (m transformFrom: self)).		mouseOverTimes removeKey: m ifAbsent: [] ].	"Add any new mouse-overs and send mouseEnter: and/or start timers..."	enteredMorphs do: [:m |		mouseOverMorphs add: m.		dragOverMorphs remove: m ifAbsent: [].  "Cant be in two places at once"		(m handlesMouseOver: evt) ifTrue:			[m mouseEnter: (evt transformedBy: (m transformFrom: self))].		(m wantsHalo or: [m wantsBalloon]) ifTrue:			[mouseOverTimes at: m put: now]].	mouseOverTimes keys do:		[:m | "Check pending timers for lingering"		t _ mouseOverTimes at: m.		(now < t "rollover" or: [now > (t+800)]) ifTrue:			["Yes we have lingered for 0.8 seconds..."			mouseOverTimes removeKey: m.			m owner ifNotNil:  "Not deleted during linger (--it happens ;--)"				[m wantsHalo					ifTrue: [oldHalo _ m world haloMorphOrNil.							(oldHalo == nil or: [oldHalo target ~~ m])								ifTrue: ["Put up halo for m"										self popUpHaloFor: m event: evt.										(balloonHelpEnabled and: [m wantsBalloon]) ifTrue:											["...and reschedule balloon after longer linger"											mouseOverTimes at: m put: now]]								ifFalse: ["Halo for m is already up, so show balloon"										(balloonHelpEnabled and: [m wantsBalloon])											ifTrue: [m showBalloon: m balloonText]]]					ifFalse:						[(balloonHelpEnabled and: [m wantsBalloon])							ifTrue: [m showBalloon: m balloonText]]]]]! !!HandMorph methodsFor: 'event handling' stamp: 'di 9/14/1998 08:47'!handleMouseUp: evt	"Dispatch a mouseUp event."	| oldFocus |	clickState ~~ #idle ifTrue: [self checkForDoubleClick: evt].	"drop morphs being carried, if any"	self hasSubmorphs ifTrue: [self dropMorphsEvent: evt].	mouseDownMorph = nil ifTrue: [^ self].	oldFocus := mouseDownMorph.	"make sure that focus becomes nil."	mouseDownMorph _ nil.  "mouse focus transaction ends when mouse goes up"	oldFocus mouseUp: (self transformEvent: evt).	dragOverMorphs copy do: [:m |		dragOverMorphs remove: m.		m mouseLeaveDragging: (evt transformedBy: (m transformFrom: self))].! !!HandMorph methodsFor: 'event handling' stamp: 'di 1/4/1999 22:27'!mouseOverList: evt	"Returns a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame."	"This new version treats halos as independent so as not to mask	mouseovers of morphs beneath an active halo."	| top |	top _ self mouseOverList: evt rank: 1.	(top isEmpty or: [(top last isKindOf: HaloMorph) not])		ifTrue: [^ top]		ifFalse: [^ top , (self mouseOverList: evt rank: 2)]! !!HandMorph methodsFor: 'event handling' stamp: 'jm 10/13/2002 17:34'!mouseOverList: evt rank: rank 	"With rank = 1, returns a list consisting of the topmost unlocked morph in the	innermost frame (pasteUp), and all of its containers in that frame.	With rank = 2, returns the smae kind of list, but rooted in the next lower	rootmorph.  This can be useful to get mouseOvers below an active halo."	| p roots mList mm r |	p _ evt cursorPoint.	roots _ self world rootMorphsAt: p.  "root morphs in world"	roots size >= rank		ifTrue: [mList _ (roots at: rank) unlockedMorphsAt: p.				mList size > 0 ifTrue:					["NOTE: We really only want the top morph and all its owners"					mm _ mList first.  r _ roots at: rank.					mList _ OrderedCollection new.					[mm == r] whileFalse:						[mList addLast: mm.						mm _ mm owner].					mList add: r]]		ifFalse: [mList _ Array empty].	^ mList! !!HandMorph methodsFor: 'event handling' stamp: 'jm 10/4/2002 07:14'!newMouseFocus: aMorphOrNil	((mouseDownMorph isKindOf: MenuItemMorph)		and: [(aMorphOrNil isKindOf: MenuItemMorph) not])		ifTrue: [(mouseDownMorph owner isKindOf: MenuMorph)				ifTrue: ["Crock: If a menu is proffered with the mouse up						and the user clicks down outside it (as is normal in MVC),						then the menu goes away and nothing else happens."						mouseDownMorph owner deleteIfPopUp.						^ nil]].	mouseDownMorph _ aMorphOrNil.	self updateMouseDownTransform.! !!HandMorph methodsFor: 'event handling' stamp: 'jm 8/11/2003 21:41'!nextUnclaimedKeystrokeOrNil	"Answer the next unclaimed keystroke from the buffer or nil if there isn't one."	self unclaimedKeystrokeAvailable		ifTrue: [^ unclaimedKeystrokes removeFirst]		ifFalse: [^ nil].! !!HandMorph methodsFor: 'event handling' stamp: 'jm 10/4/2002 17:59'!processEvents	"Process user input events from the local input devices."	| griddedPoint evt |	griddedPoint _ Sensor cursorPoint "- owner viewBox topLeft".	gridOn ifTrue: [griddedPoint _ griddedPoint grid: grid].	evt _ MorphicEvent new		setMousePoint: griddedPoint		buttons: Sensor primMouseButtons		lastEvent: lastEvent		hand: self.	self handleEvent: evt.	[Sensor keyboardPressed] whileTrue: [		evt _ MorphicEvent new			setKeyValue: Sensor keyboard asciiValue			mousePoint: griddedPoint			buttons: Sensor primMouseButtons			hand: self.		self handleEvent: evt].! !!HandMorph methodsFor: 'event handling' stamp: 'jm 10/11/2002 19:49'!recipientForMouseDown: evt	"Return the morph that should handle the given mouseDown: event."	"Details: To get mouse events, a morph must		a. contain the point at which the mouse went down, and		b. respond true to handlesMouseDown:, and		c1. be in front of all other submorphs that respond true to handlesMouseDown: or		c2. be the outer-most submorph that responds true to preemptsMouseDown:If no morph handles the mouse down, the front-most submorph is grabbed. The complexity in this description arises from the need to resolve conflicts when nested submorphs all want to handle mouse events. The preemptsMouseDown: mechanism allows a morph to intercept mouse events before its submorphs. It is needed only in unusual situations, such as parts bins containing mouse-sensitive objects."	| p roots coreSample |	owner ifNil: [^ nil].  "this hand is not in a world"	p _ evt cursorPoint.	roots _ owner rootMorphsAt: p.  "root morphs in world"	roots size = 0 ifTrue: [		"no morphs at the given point, so world gets it"		^ owner].	"coreSample is submorphs of the front-most root morph in front-to-back order"	coreSample _ roots first unlockedMorphsAt: p.	"first, look for an outer-most submorph that preempts mouse events, if any"	coreSample reverseDo: [:subM |		(subM preemptsMouseDown: evt) ifTrue: [^ subM]].	"second, look for the inner-most submorph that handles mouse events, if any"	coreSample do: [:subM |		(subM handlesMouseDown: evt) ifTrue: [^ subM]].	"no enclosing morph wants the event, so return the front-most submorph"	coreSample size = 0 ifTrue: [		"no morphs at the given point, so world gets it"		^ owner].	^ coreSample first! !!HandMorph methodsFor: 'event handling' stamp: 'jm 8/11/2003 21:38'!recordUnclaimedKeystroke: evt	unclaimedKeystrokes ifNil: [unclaimedKeystrokes _ OrderedCollection new].	unclaimedKeystrokes addLast: evt.	[unclaimedKeystrokes size > 10] whileTrue: [unclaimedKeystrokes removeFirst].  "keep only most recent N keystrokes"! !!HandMorph methodsFor: 'event handling' stamp: 'jm 8/11/2003 21:39'!unclaimedKeystrokeAvailable	"Answer true if there are unclaimed keystrokes. Keystrokes arrive when there is no keyboard focus are considered 'unclaimed'."	^ unclaimedKeystrokes notNil and: [unclaimedKeystrokes size > 0]! !!HandMorph methodsFor: 'event handling' stamp: 'jm 8/11/2003 21:36'!unclaimedKeystrokes	unclaimedKeystrokes ifNil: [unclaimedKeystrokes _ OrderedCollection new].	^ unclaimedKeystrokes! !!HandMorph methodsFor: 'event handling' stamp: 'jm 6/17/1998 08:57'!updateMouseDownTransform	"To help with, eg, autoscrolling"	mouseDownMorph		ifNil: [eventTransform _ MorphicTransform identity]		ifNotNil: [eventTransform _ mouseDownMorph transformFrom: self].! !!HandMorph methodsFor: 'double click support' stamp: 'jm 7/18/2003 11:43'!checkForDoubleClick: evt	"Process the given mouse event to detect a click, double-click, or drag."	| t |	t _ Time millisecondClockValue - firstClickTime.	clickState = #firstClickDown ifTrue: [		(t > DoubleClickTime or:		 [(evt cursorPoint - firstClickEvent cursorPoint) r > 15]) ifTrue: [			"consider it a drag if hand moves or timeout expires"			clickClient startDrag: firstClickEvent.			^ self resetClickState].		evt isMouseUp ifTrue: [			clickState _ #firstClickUp.			^ self]].	clickState = #firstClickUp ifTrue: [		evt isMouseDown ifTrue: [			clickClient doubleClick: firstClickEvent.			^ self resetClickState].		t > DoubleClickTime ifTrue: [			clickClient click: firstClickEvent.			^ self resetClickState]].! !!HandMorph methodsFor: 'double click support' stamp: 'di 10/21/1999 21:10'!resetClickState	"Reset the double-click detection state to normal (i.e., not waiting for a double-click)."	clickClient _ nil.	clickState _ #idle.	eventTransform _ MorphicTransform identity.	firstClickEvent _ nil.	firstClickTime _ nil.! !!HandMorph methodsFor: 'double click support' stamp: 'jm 6/29/2003 15:14'!waitForClicksOrDrag: aMorph event: evt	"Wait until the difference between click, double-click, or drag gesture is known, then inform the given morph what transpired. This message is sent when the given morph first receives a mouse-down event. If the mouse button goes up, then down again within DoubleClickTime, then 'doubleClick: evt' is sent to the morph. If the mouse button goes up but not down again within DoubleClickTime, then the message 'click: evt' is sent to the morph. Finally, if the button does not go up within DoubleClickTime, then 'startDrag: evt' is sent to the morph. In all cases, the event supplied is the original mouseDown event that initiated the gesture. mouseMove: and mouseUp: events are not sent to the morph until it becomes the mouse focus, which is typically done by the client in its click:, doubleClick:, or startDrag: methods." 	clickClient _ aMorph.	clickState _ #firstClickDown.	firstClickEvent _ evt.	firstClickTime _ Time millisecondClockValue.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'sw 11/10/1999 08:23'!attachMorph: m	"Position the center of the given morph under this hand, then grab it. This method is used to grab far away or newly created morphs."	| delta |	delta _ m bounds extent // 2.	gridOn ifTrue: [delta _ delta grid: grid].	m position: (formerPosition _ self position - delta).	self addMorphBack: m.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jm 10/15/2002 16:21'!dropMorphsEvent: evt	"Drop all the morphs this hand is currently holding in response to the given event."	"Details: All submorphs of the front-most composite morph under the hand are given an opportunity to accept the dropping morph. If none of these accepts it, or if there is no morph under the hand, then the morph drops into the world."	| newOwner morphToDrop tfm localPt grabbedMorph |	owner ifNil: [^ self].	self changed.	self submorphs reverseDo: [:m |		"drop in reverse order to maintain back-to-front ordering"		grabbedMorph _ m.		newOwner _ self dropTargetFor: grabbedMorph event: evt.		newOwner ifNil: [  "drop not allowed"			self rejectDropMorph: grabbedMorph event: evt.			^ self].		morphToDrop _ newOwner morphToDropFrom: grabbedMorph. 		morphToDrop == grabbedMorph ifFalse: [			submorphs size == 1 ifTrue: [				self privateRemoveMorph: m.				m privateOwner: nil]].			"the above says: the thing to drop is not what I was carrying; silently vaporize what I was carrying lest it cause trouble later; keep the owner/submorph relationship invariant, but don't go through the standard delete protocol"		tfm _ newOwner transformFromWorld.		localPt _ tfm globalPointToLocal: self position.		morphToDrop position: localPt + (morphToDrop position - self position).		newOwner acceptDroppingMorph: morphToDrop event: evt.		morphToDrop justDroppedInto: newOwner event: evt.		morphToDrop owner = self ifTrue: [self world addMorphFront: m]].	self layoutChanged.	formerOwner _ nil.	formerPosition _ nil.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jm 10/11/2002 06:45'!dropTargetFor: aMorph event: evt	"Return the morph that the given morph is to be dropped onto.  Return nil if we must repel the morph.  Return the world, if no other morph wants the dropping morph."	| root coreSample |	aMorph willingToBeEmbeddedUponLanding ifFalse: [^ self world].	root _ nil.	owner submorphs reverseDo: [:m |		((m fullContainsPoint: evt cursorPoint) and:		 [(m isKindOf: HaloMorph) not]) ifTrue: [root _ m]].	root == nil ifTrue: [^ self world].	coreSample _ root morphsAt: evt cursorPoint.	coreSample do:		[:m |			(m repelsMorph: aMorph event: evt) ifTrue:				[^ nil]].	coreSample do:		[:m |			(m wantsDroppedMorph: aMorph event: evt) ifTrue: [^ m]].	^ self world! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jm 10/15/2002 16:28'!grabMorph: aMorph	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| localPt morphToGrab |	formerOwner _ aMorph owner.	formerPosition _ aMorph position.	localPt _ aMorph pointFromWorld: self position.	morphToGrab _ aMorph aboutToBeGrabbedBy: self.	morphToGrab ifNil: [^ self].	morphToGrab position: self position + (morphToGrab position - localPt).	gridOn ifTrue: [morphToGrab position: (morphToGrab position grid: grid)].	self addMorphBack: morphToGrab.! !!HandMorph methodsFor: 'grabbing/dropping' stamp: 'jm 10/15/2002 16:30'!grabMorphFromMenu: aMorph	"Grab the given morph (i.e., add it to this hand and remove it from its current owner) without changing its position. This is used to pick up a morph under the hand's current position, versus attachMorph: which is used to pick up a morph that may not be near this hand."	| morphToGrab delta |	morphToGrab _ aMorph aboutToBeGrabbedBy: self.	delta _ morphToGrab positionInWorld - menuTargetOffset.	gridOn ifTrue: [delta _ delta grid: grid].	morphToGrab position: self position + delta.	self addMorphBack: morphToGrab.! !!HandMorph methodsFor: 'world menu' stamp: 'sma 6/5/2000 13:51'!appearanceDo	"Build and show the appearance menu for the world."	self appearanceMenu popUpForHand: self! !!HandMorph methodsFor: 'world menu' stamp: 'jm 7/20/2003 20:41'!appearanceMenu	"Build the appearance menu for the world."	| screenCtrl menu |	screenCtrl _ ScreenController new.	menu _ (MenuMorph entitled: 'appearance...') defaultTarget: self.	menu addStayUpItem.	menu add: 'set display depth...' action: #setDisplayDepth.	menu balloonTextForLastItem: 'set the number of bits per pixel for the display'.	menu add: 'set desktop color...' action: #changeBackgroundColor.	menu balloonTextForLastItem: 'set a color to use as desktop background'.	menu addLine.	menu add: 'full screen on' target: screenCtrl action: #fullScreenOn.	menu balloonTextForLastItem: 'puts you in full-screen mode, if not already there'.	menu add: 'full screen off' target: screenCtrl action: #fullScreenOff.	menu balloonTextForLastItem: 'if in full-screen mode, takes you out of it'.	menu addLine.	menu add: 'window colors...' target: Preferences action: #windowSpecificationPanel.	menu balloonTextForLastItem: 'Lets you specify colors for standard system windows'.	menu add: 'system fonts...' target: self action: #standardFontDo.	menu balloonTextForLastItem: 'Choose the standard fonts to use for code, lists, menus, window titles, etc'.	menu add: 'text highlight color...' target: Preferences action: #chooseTextHighlightColor.	menu balloonTextForLastItem: 'Choose which color should be used for text highlighting in Morphic'.	menu add: 'insertion point color...' target: Preferences action: #chooseInsertionPointColor.	menu balloonTextForLastItem: 'Choose which color to use for the text insertion point in Morphic'.	menu addLine.	menu addUpdating: #menuColorString target: Preferences action: #toggleMenuColorPolicy.	menu balloonTextForLastItem: 'Governs whether menu colors should be derived from the desktop color'.	menu addUpdating: #roundedCornersString target: Preferences action: #toggleRoundedCorners.	menu balloonTextForLastItem: 'Governs whether morphic windows and menus should have rounded corners'.	menu addLine.	menu add: 'clear turtle trails from desktop' target: self world action: #clearTurtleTrails.	menu balloonTextForLastItem: 'remove trails left by objects moving with their pens down'.	menu add: 'unlock locked objects' action: #unlockWorldContents.	menu balloonTextForLastItem: 'If any items on the world desktop are currently locked, unlock them'.	menu add: 'unhide hidden objects' action: #showHiders.	menu balloonTextForLastItem: 'If any items on the world desktop are currently hidden, make them visible'.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'jm 5/31/2003 16:37'!buildWorldMenu	"Build the meta menu for the world."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'previous project' target: owner action: #goBack.	menu add: 'jump to project...' target: owner action: #jumpToProject.	menu addLine.	menu add: 'restore display' target: self world action: #restoreDisplay.	menu addLine.	menu add: 'open...' action: #openWindow.	menu add: 'windows...' action: #windowsDo.	menu add: 'changes...' action: #changesDo.	menu add: 'help...' action: #helpDo.	menu add: 'appearance...' action: #appearanceDo.	menu addLine.	menu add: 'new morph...' action: #newMorph.	menu add: 'debug...' action: #debugDo.	menu addLine.	menu add: 'save' action: #saveSession.	menu add: 'save as...' action: #saveAs.	menu add: 'save and quit' action: #saveAndQuit.	menu add: 'quit' action: #quitSession.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sma 6/5/2000 13:52'!changesDo	"Build and show the changes menu for the world."	self changesMenu popUpForHand: self! !!HandMorph methodsFor: 'world menu' stamp: 'jm 12/2/2003 20:49'!changesMenu	"Build the changes menu for the world."	| menu |	menu _ (MenuMorph entitled: 'changes...') defaultTarget: self.	menu addStayUpItem.	menu add: 'create new change set...' target: ChangeSorter action: #newChangeSet.	menu balloonTextForLastItem: 'Create a new change set and make it the current one.'.	menu add: 'check change set for slips' target: Smalltalk changes action: #lookForSlips.	menu balloonTextForLastItem: 'Check the current change set for halts, references to the Transcript, etc., and if any such thing is found, open up a message-list browser detailing all possible slips.'.	menu addLine.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu balloonTextForLastItem: 'Open a 3-paned changed-set viewing tool'.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu balloonTextForLastItem: 'Open a change sorter that shows you two change sets at a time, making it easy to copy and move methods and classes between them.'.	menu addLine.	menu add: 'recover recent changes...' action: #openChangesLog.	menu balloonTextForLastItem: 'Open a browser on the changes log. Useful for recovering work after a crash.'.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sma 6/5/2000 13:52'!debugDo	"Build and show the debug menu for the world."	self debugMenu popUpForHand: self! !!HandMorph methodsFor: 'world menu' stamp: 'jm 12/9/2003 09:11'!debugMenu	"Build the scripting menu for the world."	| menu |	menu _ (MenuMorph entitled: 'debug...') defaultTarget: self.	menu addStayUpItem.	menu add: 'inspect world' target: owner action: #inspect.	menu add: 'start MessageTally' action: #startMessageTally.	menu addLine.	"(self hasProperty: #errorOnDraw) ... Later make following come up only when needed:"		menu add: 'start drawing again' target: owner action: #resumeAfterDrawError.		menu add: 'start stepping again' target: owner action: #resumeAfterStepError.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sma 6/5/2000 13:52'!helpDo	"Build and show the help menu for the world."	self helpMenu popUpForHand: self! !!HandMorph methodsFor: 'world menu' stamp: 'jm 5/31/2003 17:12'!helpMenu	"Build the help menu for the world."	| screenCtrl menu |	screenCtrl _ ScreenController new.	menu _ (MenuMorph entitled: 'help...') defaultTarget: self.	menu addStayUpItem.	menu add: 'about this system...' target: Smalltalk action: #aboutThisSystem.	menu balloonTextForLastItem: 'current version information'.	menu add: 'command-key help' target: Utilities action: #openCommandKeyHelp.	menu balloonTextForLastItem: 'summary of keyboard shortcuts'.	menu add: 'preferences...' target: Preferences action: #openPreferencesInspector.	menu balloonTextForLastItem: 'view and change various options'.	menu addLine.	menu add: 'set author initials...' target: screenCtrl action: #setAuthorInitials.	menu balloonTextForLastItem: 'set initials used to identify method editors'.	menu add: 'memory statistics' target: screenCtrl action: #vmStatistics.	menu balloonTextForLastItem: 'memory and garbage collection statistics'.	menu add: 'space left' target: screenCtrl action: #garbageCollect.	menu balloonTextForLastItem: 'do a full garbage collect and report space left'.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'jm 8/11/2003 21:09'!newMorph	| menu catDict cat subMenu |	menu _ (MenuMorph entitled: 'Add a new morph') defaultTarget: self.	menu addStayUpItem.	menu add: 'grab patch from screen' action: #grabDrawingFromScreen.	menu addLine.	menu add: 'from paste buffer' action: #pasteMorph.	menu add: 'from alphabetical list' subMenu: self alphabeticalMorphMenu.	menu addLine.	catDict _ Dictionary new.	self morphClassesForNewMorphMenu do: [:c |		cat _ c category.		(cat beginsWith: 'Morphic-')			ifTrue: [cat _ cat copyFrom: ('Morphic-' size + 1) to: cat size].		(catDict includesKey: cat) 			ifTrue: [(catDict at: cat) addLast: c]			ifFalse: [catDict at: cat put: (OrderedCollection with: c)]].	catDict keys asArray sort do: [:k |		subMenu _ MenuMorph new.		((catDict at: k) asArray sort: [:c1 :c2 | c1 name < c2 name]) do: [:c |			subMenu				add: c name				target: self				selector: #newMorphOfClass:event:				argument: c].		menu add: k subMenu: subMenu].	menu popUpForHand: self.! !!HandMorph methodsFor: 'world menu'!openMenu	"Build the open window menu for the world."	| menu |	menu _ (MenuMorph entitled: 'open...') defaultTarget: self.	menu addStayUpItem.	menu add: 'browser' action: #openBrowser.	menu add: 'workspace' action: #openWorkspace.	menu add: 'file list' action: #openFileList.	menu add: 'transcript' action: #openTranscript.	menu addLine.	menu add: 'simple change sorter' selector: #openChangeSorter: argument: 1.	menu add: 'dual change sorter' selector: #openChangeSorter: argument: 2.	menu addLine.	(Smalltalk includesKey: #StandardSystemView) ifTrue: [		menu add: 'mvc project' action: #openMVCProject].	menu add: 'morphic project' action: #openMorphicProject.	menu add: 'scratch project' action: #openScratchProject.	^ menu! !!HandMorph methodsFor: 'world menu' stamp: 'sma 6/5/2000 13:53'!openWindow	"Build and show the open menu for the world."	self openMenu popUpForHand: self! !!HandMorph methodsFor: 'world menu' stamp: 'sma 6/5/2000 13:57'!standardFontDo	"Build and show the standard font menu"	Preferences fontConfigurationMenu popUpForHand: self! !!HandMorph methodsFor: 'world menu' stamp: 'sma 6/5/2000 13:57'!windowsDo	"Build the windows menu for the world."	self windowsMenu popUpForHand: self! !!HandMorph methodsFor: 'world menu' stamp: 'jm 10/5/2002 06:34'!windowsMenu	"Build the windows menu for the world."	| menu |	menu _ (MenuMorph entitled: 'windows...') defaultTarget: self.	menu addStayUpItem.	menu add: 'find window' action: #findWindow.	menu balloonTextForLastItem: 'Presents a list of all windows; if you choose one from the list, it becomes the active window.'.	menu add: 'find changed browsers...' action: #findDirtyBrowsers.	menu balloonTextForLastItem: 'Presents a list of browsers that have unsubmitted changes; if you choose one from the list, it becomes the active window.'.	menu add: 'find changed windows...' action: #findDirtyWindows.	menu balloonTextForLastItem: 'Presents a list of all windows that have unsubmitted changes; if you choose one from the list, it becomes the active window.'.	menu addLine.	menu add: 'collapse all windows' action: #collapseAll.	menu balloonTextForLastItem: 'Reduce all open windows to collapsed forms that only show titles.'.	menu add: 'expand all windows' action: #expandAll.	menu balloonTextForLastItem: 'Expand all collapsed windows back to their expanded forms.'.	menu addLine.	menu add: 'delete unchanged windows' action: #closeUnchangedWindows.	menu balloonTextForLastItem: 'Deletes all windows that do not have unsaved text edits.'.	menu addLine.	menu addUpdating: #staggerPolicyString target: Preferences action: #toggleWindowPolicy.	menu balloonTextForLastItem: 'stagger: new windows positioned so you can see a portion of each one.tile: new windows positioned so that they do not overlap others, if possible.'.	^ menu! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 8/4/1999 15:41'!argumentOrNil	"Answer the root of the front-most morph under the cursor. If the cursor is not over any morph, answer nil."	owner submorphsDo:		[:m | ((m fullContainsPoint: targetOffset) and: [m isLocked not]) ifTrue: [^ m rootAt: targetOffset]].	^ nil! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/19/1998 11:54'!buildDebugHandleMenuFor: argMorph	"Build the menu for the given morph's halo's debug handle."	argument _ argMorph.	^ argMorph debuggingMenuFor: self! !!HandMorph methodsFor: 'world menu commands' stamp: 'jm 10/7/2002 07:33'!buildMorphHandleMenuFor: argMorph	"Build the morph menu for the given morph's halo's menu handle. This menu has two sections. The first section contains commands that are interpreted by the hand; the second contains commands provided by the target morph. This method allows the morph to decide which items should be included in the hand's section of the menu."	| menu |	argMorph == owner "i.e., the world" ifTrue:		[^ self buildWorldMenu].	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	argMorph addAddHandMenuItemsForHalo: menu hand: self.	menu defaultTarget: argMorph.	argMorph addCustomHaloMenuItems: menu hand: self.	menu defaultTarget: self.	menu addLine.	^ menu! !!HandMorph methodsFor: 'world menu commands' stamp: 'jm 12/9/2003 09:11'!buildMorphMenuFor: argMorph	"Build the morph menu. This menu has two sections. The first section contains commands that are handled by the hand; the second contains commands handled by the argument morph."	| menu |	argument _ argMorph.	menu _ MenuMorph new defaultTarget: self.	menu addStayUpItem.	menu add: 'grab' action: #grabMorph.	menu add: 'delete' action: #dismissMorph.	menu add: 'duplicate' action: #duplicateMorph.	menu add: 'resize' action: #resizeMorph.	menu add: 'change color...' target: argMorph action: #changeColor.	menu addLine.	menu add: 'go behind' action: #goBehind.	menu add: 'add halo' action: #addHalo.	menu add: 'copy to paste buffer' action: #copyToPasteBuffer.	menu addLine.	self potentialEmbeddingTargets size > 1 ifTrue:		[menu add: 'embed...' action: #placeArgumentIn].	(argMorph morphsAt: targetOffset) size > 1 ifTrue: [		menu add: 'submorphs...'			target: self			selector: #selectSubmorphToOperateOn:sending:event:			argumentList: (Array with: argMorph with: #operateOnSubmorph:event:)].	menu addLine.	Smalltalk isMorphic		ifTrue: [menu add: 'inspect' action: #inspectMorph]		ifFalse: [menu add: 'inspect (in MVC)' action: #inspectMorph.				menu add: 'inspect' action: #inspectMorphInMorphic].	menu add: 'browse' target: argument action: #browseHierarchy.	menu add: 'make own subclass' action: #subclassMorph.	menu addLine.	"add commands supplied by the morph itself"	menu defaultTarget: argMorph.	argMorph addCustomMenuItems: menu hand: self.	^ menu! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/3/1999 09:28'!changeBackgroundColor	self changeColorTarget: self world selector: #color: originalColor: self world color.! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 6/17/1999 14:03'!changeColor	argument changeColor! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/3/1999 09:15'!changeColorTarget: aMorph selector: aSymbol	^ self changeColorTarget: aMorph selector: aSymbol originalColor: Color white! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 11/28/1999 23:17'!changeColorTarget: aMorph selector: aSymbol originalColor: aColor	^ ColorPickerMorph new		sourceHand: self;		target: aMorph;		selector: aSymbol;		originalColor: aColor;		addToWorld: self world			near: (aMorph					ifNil: [Rectangle center: self position extent: 20]					ifNotNil: [aMorph == self world								ifTrue: [aMorph viewBox bottomLeft + (20@-20) extent: 200]								ifFalse: [aMorph fullBounds]]);		yourself! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 9/23/1998 01:33'!closeUnchangedWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	(SelectionMenu confirm:'Do you really want to close all windowsexcept those with unaccepted edits?')		ifFalse: [^ self].	(SystemWindow windowsIn: self world satisfying: [:w | w model canDiscardEdits])		do: [:w | w delete]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 2/21/2000 16:01'!collapseAll	"Collapse all windows"	(SystemWindow windowsIn: self world satisfying: [:w | w isCollapsed not])		reverseDo: [:w | w collapseOrExpand.  self world displayWorld].	self collapseNonWindows! !!HandMorph methodsFor: 'world menu commands' stamp: 'jm 10/5/2002 06:37'!collapseNonWindows	| nonWindowMorphs |	nonWindowMorphs _ self world submorphs		select: [:m | (m isKindOf: SystemWindow) not].	nonWindowMorphs do: [:m | m collapse].! !!HandMorph methodsFor: 'world menu commands' stamp: 'jm 10/15/2002 17:18'!copyToPasteBuffer	"Save this morph in the paste buffer. This is useful for copying morphs between projects."	argument isMorph		ifTrue: [			Cursor wait showWhile: [				PasteBuffer _ argument fullCopy.				PasteBuffer aboutToBeGrabbedBy: self]]		ifFalse: [PasteBuffer _ nil].! !!HandMorph methodsFor: 'world menu commands' stamp: 'jm 10/7/2002 07:27'!duplicateMorph	| newMorph |	newMorph _ argument fullCopy.	self grabMorphFromMenu: newMorph.	formerPosition _ argument position.	^ newMorph! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 11/11/1998 15:20'!findDirtyBrowsers	"Present a menu of window titles for browsers with changes,	and activate the one that gets chosen."	| menu |	menu _ MenuMorph new.	(SystemWindow windowsIn: self world		satisfying: [:w | (w model isKindOf: Browser) and: [w model canDiscardEdits not]])		do: [:w | menu add: w label target: w action: #activate].	menu submorphs size > 0 ifTrue:		[self invokeMenu: menu event: lastEvent]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 11/11/1998 15:22'!findDirtyWindows	"Present a menu of window titles for all windows with changes,	and activate the one that gets chosen."	| menu |	menu _ MenuMorph new.	(SystemWindow windowsIn: self world		satisfying: [:w | w model canDiscardEdits not])		do: [:w | menu add: w label target: w action: #activate].	menu submorphs size > 0 ifTrue:		[self invokeMenu: menu event: lastEvent]! !!HandMorph methodsFor: 'world menu commands' stamp: 'jm 6/15/2003 12:11'!findWindow	"Present a menu of window titles, and activate the one that gets chosen. Collapsed windows appear below the line, expand if chosen."	| menu expanded collapsed nakedMorphs |	menu _ MenuMorph new.	expanded _ SystemWindow windowsIn: self world satisfying: [:w | w isCollapsed not].	collapsed _ SystemWindow windowsIn: self world satisfying: [:w | w isCollapsed].	nakedMorphs _ self world submorphs select: [:m | (m isKindOf: SystemWindow) not].	(expanded isEmpty & (collapsed isEmpty & nakedMorphs isEmpty)) ifTrue: [^ self beep].	(expanded asSortedCollection: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) do:		[:w | menu add: w label target: w action: #activateAndForceLabelToShow.			w model canDiscardEdits ifFalse: [menu lastItem color: Color red]].	(expanded isEmpty | (collapsed isEmpty & nakedMorphs isEmpty)) ifFalse: [menu addLine].	(collapsed asSortedCollection: [:w1 :w2 | w1 label caseInsensitiveLessOrEqual: w2 label]) do: 		[:w | menu add: w label target: w action: #collapseOrExpand.		w model canDiscardEdits ifFalse: [menu lastItem color: Color red]].	nakedMorphs isEmpty ifFalse: [menu addLine].	(nakedMorphs asSortedCollection: [:w1 :w2 | w1 externalName caseInsensitiveLessOrEqual: w2 externalName]) do:		[:w | menu add: w externalName target: w action: #comeToFrontAndAddHalo].	menu addTitle: 'find window'.		self invokeMenu: menu event: lastEvent! !!HandMorph methodsFor: 'world menu commands' stamp: 'sma 6/5/2000 13:28'!invokeMenu: menu event: evt	"Invoke the given menu for the given event."	menu popUpEvent: evt! !!HandMorph methodsFor: 'world menu commands' stamp: 'jm 10/16/2002 12:46'!invokeMetaMenu: evt	"Invoke the meta menu. If the hand is over the background, the world menu is presented. If it is over a morph, a menu of operations for that morph is presented. Each menu entry contains a string to be presented in the menu and a selector. If the selector takes an argument, the mouse-down event that invoked the menu is passed as an argument. This lets the command know which hand invoked it in order to do things like attaching the result of the command to that hand.If the hand is over the background and the shift key is pressed, the find-window menu is immediately put up.If the hand is over the background but the yellow button was pressed, an alternate menu, which individual users are encouraged to personalize, is put up -- see HandMorph.yellowButtonClickOnDesktopWithEvent:"	| menu |	Preferences noviceMode ifTrue: [^ self].	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	targetOffset _ menuTargetOffset _ self position.	argument _ self argumentOrNil.	argument == nil		ifTrue: [			evt shiftPressed				ifFalse: [  "put put screen menu"					menu _ self buildWorldMenu.					menu addTitle: 'World']				ifTrue: [^ self findWindow]]		ifFalse: [			menu _ self buildMorphMenuFor: argument.			menu addTitle: argument class name].	self invokeMenu: menu event: evt.! !!HandMorph methodsFor: 'world menu commands' stamp: 'sma 6/5/2000 13:52'!jumpToProject	(Project buildJumpToMenu: (MenuMorph new defaultTarget: Project; addTitle: 'Projects'))		popUpForHand: self! !!HandMorph methodsFor: 'world menu commands' stamp: 'jm 7/23/2003 23:30'!newMorphOfClass: morphClass event: evt	"Attach a new morph of the given class to the invoking hand."	| m |	m _ morphClass new.	evt hand attachMorph: m.	owner startSteppingSubmorphsOf: m.! !!HandMorph methodsFor: 'world menu commands' stamp: 'jm 10/7/2002 06:42'!objectToPaste	^ Cursor wait showWhile: [PasteBuffer fullCopy]! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 12/6/1999 10:04'!openBrowser	Browser openBrowser! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 10/18/1999 22:44'!openChangeSorter: oneOrTwo	oneOrTwo = 1		ifTrue: [ChangeSorter new morphicWindow openInWorld: self world]		ifFalse: [DualChangeSorter new morphicWindow openInWorld: self world]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/4/1998 18:21'!openFileList	FileList openAsMorph openInWorld: self world! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 6/9/1999 15:45'!openMorphicProject	(ProjectViewMorph newMorphicProjectOn: nil) openInWorld.! !!HandMorph methodsFor: 'world menu commands' stamp: 'jm 9/29/2003 11:26'!openScratchProject	| p f |	(p _ ProjectViewMorph newMorphicProjectOn: nil) openInWorld.	f _ ScratchFrameMorph new fillScreenOn.	p model world addMorph: f.	p model world startSteppingSubmorphsOf: f.! !!HandMorph methodsFor: 'world menu commands' stamp: 'di 10/18/1999 22:39'!openTranscript	(Transcript openAsMorphLabel: 'Transcript')		openInWorld: self world! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 8/4/1998 18:21'!openWorkspace	Workspace new openAsMorphLabel: 'Workspace' inWorld: self world! !!HandMorph methodsFor: 'world menu commands' stamp: 'jm 10/7/2002 07:50'!pasteMorph	| aPastee |	PasteBuffer ifNil: [^ self inform: 'Nothing to paste.'].	self attachMorph: (aPastee _ self objectToPaste).	aPastee align: aPastee center with: self position.! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/9/1998 15:49'!placeArgumentIn 	"Let the user choose a new layer in the core sample for the argument to reside in, but don't allow strange loops"	|  targetMorph |	targetMorph _ self selectEmbedTargetMorph: ('Place ', argument externalName, ' in...').	targetMorph ifNotNil:		[targetMorph addMorphFront: argument fromWorldPosition: argument position]! !!HandMorph methodsFor: 'world menu commands' stamp: 'jm 5/29/2003 19:49'!potentialEmbeddingTargets	"Answer a list of targets into which the hand's arguement could be embedded"	| possibleTargets |	possibleTargets _ self world morphsAt: menuTargetOffset.	argument ifNotNil:		[possibleTargets removeAll: argument allMorphs].	^ possibleTargets! !!HandMorph methodsFor: 'world menu commands' stamp: 'tk 3/10/2000 21:05'!projectThumbnail	"Offer the user a menu of project names. Attach to the hand a thumbnail of the project the user selects."	| menu projName pr |	menu _ MVCMenuMorph entitled: 'Select Project'.	menu add: (Project current name, ' (current)') action: Project current name.	menu addLine.	Project allNames do: [:n | menu add: n action: n].	projName _ menu invokeAt: self position in: self world.	projName ifNotNil:		[(pr _ Project named: projName) 			ifNotNil: [self attachMorph: (ProjectViewMorph on: pr)]			ifNil: [self inform: 'can''t seem to find that project']].! !!HandMorph methodsFor: 'world menu commands' stamp: 'sw 9/9/1998 16:07'!selectEmbedTargetMorph: caption	"Put up a menu of morphs found in a core sample taken of the world at the receiver's menuTargetOffset, with the given caption"	|  menu |	menu _ CustomMenu new.	self potentialEmbeddingTargets  do: [:m | menu add: (self submorphNameFor: m) action: m].	^ caption size == 0		ifTrue:			[menu startUp]		ifFalse:			[menu startUpWithCaption: caption]! !!HandMorph methodsFor: 'world menu commands' stamp: 'sma 6/5/2000 13:42'!selectSubmorphToOperateOn: rootMorph sending: aSymbol event: evt	"Let the user select a submorph of the given root morph. When selected, the given selector is sent with the selected submorph as an argument."	| possibleTargets menu |	possibleTargets _ rootMorph morphsAt: targetOffset.	possibleTargets size = 1 ifTrue: [^ self perform: aSymbol with: possibleTargets first with: evt].	menu _ MenuMorph new.	possibleTargets do: [:m |		menu add: (self submorphNameFor: m)			target: self			selector: aSymbol			argumentList: (Array with: m with: evt)].	menu popUpEvent: evt! !!HandMorph methodsFor: 'world menu commands' stamp: 'sma 4/30/2000 09:57'!setDisplayDepth	"Let the user choose a new depth for the display. "	| result oldDepth |	oldDepth _ Display depth.	(result _ (SelectionMenu selections: Display supportedDisplayDepths) startUpWithCaption:'Choose a display depth(it is currently ' , oldDepth printString , ')') ifNotNil: [Display newDepth: result].	(Smalltalk isMorphic and: [(Display depth < 4) ~= (oldDepth < 4)])		ifTrue:			["Repaint windows since they look better all white in depth < 4"			(SystemWindow windowsIn: World satisfying: [:w | true]) do:				[:w |				oldDepth < 4					ifTrue: [w restoreDefaultPaneColor]					ifFalse: [w updatePaneColors]]]! !!HandMorph methodsFor: 'world menu commands' stamp: 'jm 10/4/2002 07:19'!submorphNameFor: aMorph	^ aMorph class name asString! !!HandMorph methodsFor: 'special gestures' stamp: 'jm 9/30/2003 00:24'!specialGesture: evt	"A special gesture (cmd-mouse on the Macintosh) supports different ways to bring up halos on a morph."	Preferences cmdGesturesEnabled ifFalse: [^ self].	Preferences noviceMode ifTrue: [^ self].	self newMouseFocus: nil.	"if carrying morphs, just drop them"	self hasSubmorphs ifTrue: [^ self dropMorphsEvent: evt].	targetOffset _ menuTargetOffset _ self position.	argument _ self argumentOrNil.	self popUpHaloFromClick: evt.! !!HandMorph methodsFor: 'halos' stamp: 'jm 9/30/2003 00:19'!addHalo	argument addHalo: nil.! !!HandMorph methodsFor: 'halos' stamp: 'jm 9/30/2003 00:13'!addHalo: evt	argument addHalo: evt.! !!HandMorph methodsFor: 'halos' stamp: 'jm 9/30/2003 00:16'!popUpHaloFor: aMorph event: evt	self world abandonAllHalos.	targetOffset _ self position.	aMorph addHalo: evt.! !!HandMorph methodsFor: 'halos' stamp: 'jm 9/30/2003 00:15'!popUpHaloFromClick: evt	"Pop up a halo on a suitable morph below the hand.	If there are multiple possible targets, and one of them already has a halo, then	choose the next inner target.  That is, unless we are already at the bottom, in which case	go topmost again."	| oldTargets targets anIndex |	oldTargets _ OrderedCollection new.	self world haloMorphs do:		[:h | oldTargets addLast: h target. h delete].	targetOffset _ self position.	(argument _ self argumentOrNil) ifNil: [^ owner "the world" addHalo: evt].	argument submorphCount = 0 ifTrue: [^ argument wantsHaloFromClick ifTrue: [argument addHalo: evt "sole target"]].	"Multiple possible targets, choose the outermost suitable one first, but if one already		has a halo, then choose the next farther in."	targets _ argument unlockedMorphsAt: targetOffset.	targets _ targets reversed select: [:aMorph | aMorph wantsHaloFromClick].	targets size = 0 ifTrue: [^ argument wantsHaloFromClick			ifTrue: [argument addHalo: evt "sole target"]			ifFalse: ["no halo recipient"]].	targets size = 1 ifTrue: [^ targets first addHalo: evt "sole target"].	anIndex _ targets findFirst: [:t | oldTargets includes: t].	anIndex = 0 ifTrue:		[^ self popUpNewHaloFromClick: evt targets: targets].	^ (targets atWrap: anIndex + 1) addHalo: evt! !!HandMorph methodsFor: 'halos' stamp: 'jm 12/8/2003 11:56'!popUpNewHaloFromClick: evt targets: targets	"Pop up a halo for the most opportune morph, given that this is not a progressive halo transfer. evt is the precipitating mouse event. targets is the list of potential targets under the mouse."	| outer possible haloRecipient |	possible _ targets		detect: [:m | (m isKindOf: PasteUpMorph) not]		ifNone: [targets last].	outer _ possible owner ifNil: [targets first].	haloRecipient _ targets reversed		detect: [:m | m == outer or: [m seeksOutHalo and: [outer defersHaloOnClickTo: m]]]		ifNone: [outer].	haloRecipient _ targets		detect: [:m | (m defersHaloOnClickTo: haloRecipient) not]		ifNone: [haloRecipient].	haloRecipient addHalo: evt.! !!HandMorph methodsFor: 'from EToyHand' stamp: 'jm 10/11/2002 16:55'!rejectDropMorph: aMorph event: evt	"aMorph has been rejected, and must be put back somewhere.  There are three cases:	(1)  It remembers its former owner and position, and goes right back there	(2)  It remembers its former position only, in which case it was torn off from a parts bin, and the UI is that it floats back to its donor position and then vanishes.	(3)  Neither former owner nor position is remembered, in which case it is just deleted"	(formerOwner notNil and: [formerOwner isPartsBin not]) ifTrue:		[^ aMorph slideBackToFormerSituation: evt].	formerPosition ifNotNil:  "Position but no owner -- can just make it vanish"		[^ aMorph vanishAfterSlidingTo: formerPosition event: evt].			aMorph delete.! !!HandMorph methodsFor: 'from EToyHand' stamp: 'jm 10/14/2002 08:56'!showHiders	| container |	container _ argument ifNotNil: [argument] ifNil: [self world].	container allMorphsDo: [:m | m isHidden: false].! !!HandMorph methodsFor: 'private' stamp: 'jm 6/20/2003 09:37'!alphabeticalMorphMenu	| menu morphClasses |	menu _ MenuMorph new defaultTarget: self.	morphClasses _ self morphClassesForNewMorphMenu.	(morphClasses asArray sort: [:c1 :c2 | c1 name < c2 name]) do: [:cl |		menu add: cl name target: self selector: #newMorphOfClass:event: argument: cl].	^ menu! !!HandMorph methodsFor: 'private' stamp: 'jm 5/31/2003 20:15'!morphClassesForNewMorphMenu	"Answer a collection of morph classes for the 'new morph...' menu."	"HandMorph someInstance morphClassesForNewMorphMenu"	^ Morph allSubclasses asArray select: [:c |		(c class includesSelector: #includeInNewMorphMenu) and: [c includeInNewMorphMenu]]! !!HandMorph methodsFor: 'private' stamp: 'tk 9/26/1999 16:23'!releaseCachedState	| svg svgon oo |	super releaseCachedState.	cacheCanvas _ nil.	svg _ grid.	svgon _ gridOn.	oo _ owner.	self removeAllMorphs.	self initialize.	"nuke everything"	self privateOwner: oo.	grid _ svg.	gridOn _ svgon.	mouseDownMorph _ nil.	argument _ nil.	formerOwner _ nil.! !!HandMorph class methodsFor: 'accessing' stamp: 'jm 10/14/2002 07:34'!clearPasteBuffer	"Clear the paste buffer."	PasteBuffer _ nil.! !A HandleMorph provides mouse-up control behavior.!!HandleMorph methodsFor: 'stepping' stamp: 'ar 6/18/1999 07:44'!startStepping	"Make the receiver the keyboard focus for editing"	super startStepping.	owner isHandMorph ifTrue:[owner newKeyboardFocus: self].! !!HandleMorph methodsFor: 'termination' stamp: 'ar 6/18/1999 07:51'!justDroppedInto: aMorph event: anEvent	"So that when the hand drops me (into the world) I go away"	anEvent hand keyboardFocus == self		ifTrue:[anEvent hand newKeyboardFocus: nil].	self changed.	self delete.! !!HandleMorph methodsFor: 'events' stamp: 'ar 6/18/1999 08:10'!keyStroke: evt	"Check for cursor keys"	| keyValue |	owner isHandMorph ifFalse:[^self].	keyValue _ evt keyValue.	keyValue = 28 ifTrue:[^self position: self position - (1@0)].	keyValue = 29 ifTrue:[^self position: self position + (1@0)].	keyValue = 30 ifTrue:[^self position: self position - (0@1)].	keyValue = 31 ifTrue:[^self position: self position + (0@1)].	"Special case for return"	keyValue = 13 ifTrue:[		"Drop the receiver and be done"		owner newKeyboardFocus: nil.		self delete].! !I represent a user script consisting of a sequence of blocks. I keep track of the name and parameters of that script.I can also hold a process running this script. That process can be started or stopped by clicking on the circle embedded in me. This circle changes color to show the state of my process:  gray - stopped  green - running  red - stopped due to an error!!HatBlockMorph methodsFor: 'initialization' stamp: 'jm 9/28/2003 17:26'!initialize	super initialize.	self color: (Color r: 0.6 g: 0.0 b: 0.8).	self extent: 29@23.	scriptOwner _ nil.	scratchProc _ nil.	isClickable _ false.	parameters _ OrderedCollection new.	scriptNameMorph _ StringMorph new		contents: 'script';		font: LabelFont;		color: Color white.	self addMorph: scriptNameMorph.	indicatorMorph _ EllipseMorph new 		extent: 10@10;		color: Color lightGray.	self addMorph: indicatorMorph.! !!HatBlockMorph methodsFor: 'accessing' stamp: 'jm 9/28/2003 17:29'!commandSpec	"Returns a command spec for the invoking this script. Currently assume all parameters are numbers."	| spec |	spec _ self scriptName.	parameters do: [:p | spec _ spec, ' %n'].	^ spec! !!HatBlockMorph methodsFor: 'accessing' stamp: 'jm 9/29/2003 23:39'!indicatorColor	^ indicatorMorph color! !!HatBlockMorph methodsFor: 'accessing' stamp: 'jm 9/28/2003 17:29'!isClickable	^ isClickable! !!HatBlockMorph methodsFor: 'accessing' stamp: 'dh 8/14/2003 17:51'!scratchProc	^ scratchProc! !!HatBlockMorph methodsFor: 'accessing' stamp: 'dh 8/14/2003 17:46'!scratchProc: anObject	scratchProc _ anObject.! !!HatBlockMorph methodsFor: 'accessing' stamp: 'jm 9/28/2003 17:25'!scriptName	"Answer the name of this script."	^ scriptNameMorph contents! !!HatBlockMorph methodsFor: 'accessing' stamp: 'jm 9/28/2003 17:26'!scriptName: aString	"Set the name of this script and resize myself to fit."	scriptNameMorph contents: aString.	self layoutChanged.! !!HatBlockMorph methodsFor: 'accessing' stamp: 'jm 3/5/2003 16:52'!scriptOwner	^ scriptOwner! !!HatBlockMorph methodsFor: 'accessing' stamp: 'jm 9/25/2003 12:27'!scriptOwner: anObject	| index defaultName |	scriptOwner _ anObject.	index _ 1.	defaultName _ 'script', index asString.	[scriptOwner hasScriptNamed: defaultName] whileTrue: [		index _ index + 1.		defaultName _ 'script', index asString].	self scriptName: defaultName.! !!HatBlockMorph methodsFor: 'drawing' stamp: 'jm 8/24/2003 20:21'!fixBlockLayout	"Update the positions of my submorphs."	| nonBlockSubmorphs maxH totalH x |	"Fix sizes of parameter morphs."	self submorphs do: [:m |		(m isKindOf: ParameterMorph) ifTrue: [m fixParameterLayout]].	nonBlockSubmorphs _ self submorphs select: [:m |		(m isKindOf: BlockMorph) not].	maxH _ nonBlockSubmorphs inject: 10 into: [:h :m | h max: m height].	totalH _ maxH + 5.	x _ self left + 5.	nonBlockSubmorphs do: [:m |		m position: x@(self top + ((totalH - m height) // 2)).		x _ x + m width + 5].	self extent: (x - self left) @ totalH.	self nextBlock ifNotNil: [self nextBlock fixBlockLayout].! !!HatBlockMorph methodsFor: 'evaluation' stamp: 'jm 12/10/2003 20:54'!isHatBlock	"Answer true if I am a script hat."	^ false! !!HatBlockMorph methodsFor: 'evaluation' stamp: 'jm 8/3/2003 10:05'!justDroppedInto: aMorph event: anEvent	"I am only allowed to be dropped into script editor pane."	(owner isKindOf: ScratchScriptsMorph) ifFalse: [		^ self rejectDropEvent: anEvent].! !!HatBlockMorph methodsFor: 'event handling' stamp: 'jm 8/3/2003 23:32'!click: evt	"Run or stop my script."	self toggleProcess.! !!HatBlockMorph methodsFor: 'event handling' stamp: 'jm 8/3/2003 23:32'!wantsKeyboardFocusFor: aSubmorph	(aSubmorph wouldAcceptKeyboardFocus and:	 [Sensor shiftPressed])		ifTrue: [^ true].	^ super wantsKeyboardFocusFor: aSubmorph! !!HatBlockMorph methodsFor: 'stepping' stamp: 'jm 9/29/2003 20:14'!step	"Update the color of my indicator to show my process state: stopped, running, or error."	| c |	super step.	scratchProc		ifNil: [c _ Color lightGray]		ifNotNil: [			c _ Color green.			scratchProc errorFlag				ifTrue: [c _ Color red]  "error: show red and don't nil out process"				ifFalse: [					(scratchProc readyToTerminate or:					 [scratchProc isTerminated]) ifTrue: [  "process terminated normally"						c _ Color lightGray.						scratchProc _ nil]]].	indicatorMorph color: c.! !!HatBlockMorph methodsFor: 'stepping' stamp: 'jm 3/6/2003 16:58'!stepTime	^ 100! !!HatBlockMorph methodsFor: 'right button menu' stamp: 'jm 8/24/2003 17:09'!addParameter	"Add a new formal parameter to the end of the method signature."	| parameter ref index name |	index _ 1.	name _ 'x'.	[self hasParameterNamed: name] whileTrue:		[index _ index + 1.		name _ 'x', index asString].	parameter _ ParameterMorph new name: name.	ref _ ParameterReferenceMorph new.	parameter addMorph: ref.	self addMorphBack: parameter.	ref parameter: parameter.	parameters add: parameter.	ref startStepping.	self layoutChanged.! !!HatBlockMorph methodsFor: 'right button menu' stamp: 'jm 9/28/2003 16:53'!createButton	| newButton |	newButton _ ScratchButtonMorph new target: self.	self activeHand attachMorph: newButton.! !!HatBlockMorph methodsFor: 'right button menu' stamp: 'TIS 7/16/2003 11:44'!disableMouseClick	isClickable _ false.	self color: (Color r: 0.6 g: 0.0 b: 0.8).! !!HatBlockMorph methodsFor: 'right button menu' stamp: 'jm 12/1/2003 16:14'!duplicate	"Overridden to pick an unused script name for the duplicate."	| m |	m _ self fullCopy.	scriptOwner ifNotNil: [m scriptOwner: scriptOwner].	self world activeHand attachMorph: m.! !!HatBlockMorph methodsFor: 'right button menu' stamp: 'jm 9/28/2003 21:50'!editScriptName	scriptNameMorph launchMiniEditor: (MorphicEvent new setHand: self world activeHand).! !!HatBlockMorph methodsFor: 'right button menu' stamp: 'TIS 7/16/2003 11:44'!enableMouseClick	isClickable _ true.	self color: Color red.! !!HatBlockMorph methodsFor: 'right button menu' stamp: 'jm 12/1/2003 15:59'!rightButtonMenu	| menu |	menu _ CustomMenu new.	menu add: 'rename' action: #editScriptName.	menu add: 'add parameter' action: #addParameter.	menu addLine.	isClickable		ifTrue: [menu add: 'disable mouse click' action: #disableMouseClick]		ifFalse: [menu add: 'enable mouse click' action: #enableMouseClick].	parameters size = 0 ifTrue: [		menu add: 'create button' action: #createButton].	menu addLine.	menu add: 'copy' action: #duplicate.	menu add: 'delete' action: #delete.	menu invokeOn: self.! !!HatBlockMorph methodsFor: 'parameters' stamp: 'jm 9/28/2003 17:34'!hasParameterNamed: aString	"Answer true if any of my parameters has the given name."	^ parameters anySatisfy: [:p | p name = aString]! !!HatBlockMorph methodsFor: 'parameters' stamp: 'jm 7/21/2003 01:39'!parameters	^ parameters! !!HatBlockMorph methodsFor: 'parameters' stamp: 'jm 8/24/2003 17:10'!removeParameter: aParameterMorph	parameters remove: aParameterMorph.	aParameterMorph delete.! !!HatBlockMorph methodsFor: 'processes' stamp: 'jm 9/29/2003 23:34'!isRunning	self step.  "update scratchProc if offscreen"	^ scratchProc notNil and: [scratchProc errorFlag not]! !!HatBlockMorph methodsFor: 'processes' stamp: 'jm 9/29/2003 23:36'!start	| frame |	self stop.  "make sure the process is stopped"	scratchProc ifNil: [		(scriptOwner isNil or: [parameters size > 0]) ifTrue: [^ self].		frame _ scriptOwner scratchFrame.		scratchProc _ frame startProcessForStatements: self blockSequence allButFirst.		indicatorMorph color: Color green].! !!HatBlockMorph methodsFor: 'processes' stamp: 'jm 9/28/2003 16:46'!stop	self step.  "update scratchProc if offscreen"	scratchProc ifNotNil: [		scratchProc stop.		scratchProc _ nil.		indicatorMorph color: Color lightGray].! !!HatBlockMorph methodsFor: 'processes' stamp: 'jm 9/28/2003 17:37'!toggleProcess	self isRunning		ifTrue: [self stop]		ifFalse: [self start].! !!HatBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:07'!fieldsVersion	^ 1! !!HatBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/28/2003 18:15'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		scriptNameMorph		indicatorMorph		scriptOwner		parameters		isClickable	) from: anObjStream.! !!HatBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/28/2003 18:16'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		scriptNameMorph		indicatorMorph		scriptOwner		parameters		isClickable	) on: anObjStream.! !!HatBlockMorph methodsFor: 'private' stamp: 'jm 10/21/2003 19:14'!printCodeOn: aStream indent: indent	"Append a human-readable string for this block on the given stream."	aStream nextPutAll: self scriptName, ':'; cr.	self nextBlock ifNotNil: [self nextBlock printCodeOn: aStream indent: 1].	aStream nextPutAll: 'end'; cr.! !Class Heap implements a special data structure commonly referred to as 'heap'. Heaps are more efficient than SortedCollections if:a) Elements are only removed at the beginningb) Elements are added with arbitrary sort order.The sort time for a heap is O(n log n) in all cases.Instance variables:	array		<Array>		the data repository	tally		<Integer>	the number of elements in the heap	sortBlock	<Block|nil>	a two-argument block defining the sort order,							or nil in which case the default sort order is								[:element1 :element2| element1 <= element2]!!Heap methodsFor: 'accessing' stamp: 'ar 9/10/1999 13:02'!at: index	"Return the element at the given position within the receiver"	(index < 1 or:[index > tally]) ifTrue:[^self errorSubscriptBounds: index].	^array at: index! !!Heap methodsFor: 'accessing' stamp: 'ar 7/1/1999 04:14'!at: index put: newObject	"Heaps are accessed with #add: not #at:put:"	^self shouldNotImplement! !!Heap methodsFor: 'accessing' stamp: 'ar 9/10/1999 13:02'!first	"Return the first element in the receiver"	self emptyCheck.	^array at: 1! !!Heap methodsFor: 'accessing' stamp: 'ar 9/10/1999 14:08'!reSort	"Resort the entire heap"	self isEmpty ifTrue:[^self].	tally // 2 to: 1 by: -1 do:[:i| self downHeap: i].! !!Heap methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:37'!size	"Answer how many elements the receiver contains."	^ tally! !!Heap methodsFor: 'accessing' stamp: 'ar 7/1/1999 04:21'!sortBlock	^sortBlock! !!Heap methodsFor: 'accessing' stamp: 'ar 7/1/1999 04:21'!sortBlock: aBlock	sortBlock _ aBlock.	sortBlock fixTemps.	self reSort.! !!Heap methodsFor: 'testing' stamp: 'ar 9/10/1999 13:03'!isEmpty	"Answer whether the receiver contains any elements."	^tally = 0! !!Heap methodsFor: 'testing' stamp: 'ar 9/10/1999 13:03'!sorts: element1 before: element2	"Return true if element1 should be sorted before element2.	This method defines the sort order in the receiver"	^sortBlock == nil		ifTrue:[element1 <= element2]		ifFalse:[sortBlock value: element1 value: element2].! !!Heap methodsFor: 'adding' stamp: 'ar 9/10/1999 13:04'!add: anObject	"Include newObject as one of the receiver's elements. Answer newObject."	tally = array size ifTrue:[self grow].	array at: (tally _ tally + 1) put: anObject.	self upHeap: tally.	^anObject! !!Heap methodsFor: 'removing' stamp: 'ar 9/10/1999 13:04'!remove: oldObject ifAbsent: aBlock	"Remove oldObject as one of the receiver's elements. If several of the 	elements are equal to oldObject, only one is removed. If no element is 	equal to oldObject, answer the result of evaluating anExceptionBlock. 	Otherwise, answer the argument, oldObject."	1 to: tally do:[:i| 		(array at: i) = oldObject ifTrue:[^self privateRemoveAt: i]].	^aBlock value! !!Heap methodsFor: 'removing' stamp: 'ar 9/10/1999 13:05'!removeAt: index	"Remove the element at given position"	(index < 1 or:[index > tally]) ifTrue:[^self errorSubscriptBounds: index].	^self privateRemoveAt: index! !!Heap methodsFor: 'removing' stamp: 'ar 9/10/1999 13:05'!removeFirst	"Remove the first element from the receiver"	^self removeAt: 1! !!Heap methodsFor: 'comparing' stamp: 'ar 9/10/1999 13:05'!= aHeap	"Answer true if my and aHeap's species are the same,	and if our blocks are the same, and if our elements are the same."	self species = aHeap species ifFalse: [^ false].	sortBlock = aHeap sortBlock		ifTrue: [^ super = aHeap]		ifFalse: [^ false]! !!Heap methodsFor: 'enumerating' stamp: 'ar 9/10/1999 13:05'!do: aBlock	"Evaluate aBlock with each of the receiver's elements as the argument."	1 to: tally do:[:i| aBlock value: (array at: i)]! !!Heap methodsFor: 'growing' stamp: 'ar 7/1/1999 04:17'!grow	"Become larger."	self growTo: self size + self growSize.! !!Heap methodsFor: 'growing' stamp: 'ar 7/1/1999 04:18'!growSize	"Return the size by which the receiver should grow if there are no empty slots left."	^array size max: 5! !!Heap methodsFor: 'growing' stamp: 'ar 7/1/1999 04:18'!growTo: newSize	"Grow to the requested size."	| newArray |	newArray _ Array new: (newSize max: tally).	newArray replaceFrom: 1 to: array size with: array startingAt: 1.	array _ newArray! !!Heap methodsFor: 'growing' stamp: 'ar 7/1/1999 04:18'!trim	"Remove any empty slots in the receiver."	self growTo: self size.! !!Heap methodsFor: 'private-heap' stamp: 'ar 7/1/1999 04:34'!downHeap: anIndex	"Check the heap downwards for correctness starting at anIndex.	 Everything above (i.e. left of) anIndex is ok."	| value k n j |	anIndex = 0 ifTrue:[^self].	n _ tally bitShift: -1.	k _ anIndex.	value _ array at: anIndex.	[k <= n] whileTrue:[		j _ k + k.		"use max(j,j+1)"		(j < tally and:[self sorts: (array at: j+1) before: (array at: j)])				ifTrue:[ j _ j + 1].		"check if position k is ok"		(self sorts: value before: (array at: j)) 			ifTrue:[	"yes -> break loop"					n _ k - 1]			ifFalse:[	"no -> make room at j by moving j-th element to k-th position"					array at: k put: (array at: j).					"and try again with j"					k _ j]].	array at: k put: value.! !!Heap methodsFor: 'private-heap' stamp: 'ar 7/1/1999 04:34'!downHeapSingle: anIndex	"This version is optimized for the case when only one element in the receiver can be at a wrong position. It avoids one comparison at each node when travelling down the heap and checks the heap upwards after the element is at a bottom position. Since the probability for being at the bottom of the heap is much larger than for being somewhere in the middle this version should be faster."	| value k n j |	anIndex = 0 ifTrue:[^self].	n _ tally bitShift: -1.	k _ anIndex.	value _ array at: anIndex.	[k <= n] whileTrue:[		j _ k + k.		"use max(j,j+1)"		(j < tally and:[self sorts: (array at: j+1) before: (array at: j)])				ifTrue:[	j _ j + 1].		array at: k put: (array at: j).		"and try again with j"		k _ j].	array at: k put: value.	self upHeap: k! !!Heap methodsFor: 'private-heap' stamp: 'ar 7/1/1999 04:34'!upHeap: anIndex	"Check the heap upwards for correctness starting at anIndex.	 Everything below anIndex is ok."	| value k kDiv2 tmp |	anIndex = 0 ifTrue:[^self].	k _ anIndex.	value _ array at: anIndex.	[ (k > 1) and:[self sorts: value before: (tmp _ array at: (kDiv2 _ k bitShift: -1))] ] 		whileTrue:[			array at: k put: tmp.			k _ kDiv2].	array at: k put: value.! !!Heap methodsFor: 'private' stamp: 'ar 7/1/1999 04:19'!array	^array! !!Heap methodsFor: 'private' stamp: 'ar 7/1/1999 04:36'!privateRemoveAt: index	"Remove the element at the given index and make sure the sorting order is okay"	| removed |	removed _ array at: index.	array at: index put: (array at: tally).	array at: tally put: nil.	tally _ tally - 1.	"Use #downHeapSingle: since only one element has been removed"	self downHeapSingle: index.	^removed! !!Heap methodsFor: 'private' stamp: 'ar 7/1/1999 04:35'!setCollection: aCollection	array _ aCollection.	tally _ 0.! !!Heap methodsFor: 'private' stamp: 'ar 9/10/1999 13:18'!setCollection: aCollection tally: newTally	array _ aCollection.	tally _ newTally.! !!Heap methodsFor: 'private' stamp: 'sma 4/22/2000 19:30'!species	^ Array! !!Heap class methodsFor: 'instance creation' stamp: 'ar 7/1/1999 04:20'!new	^self new: 10! !!Heap class methodsFor: 'instance creation' stamp: 'ar 7/1/1999 04:20'!new: n	^super new setCollection: (Array new: n)! !!Heap class methodsFor: 'instance creation' stamp: 'ar 9/10/1999 14:13'!sortBlock: aBlock	"Create a new heap sorted by the given block"	^self new sortBlock: aBlock! !!Heap class methodsFor: 'instance creation' stamp: 'ar 9/10/1999 13:23'!withAll: aCollection	"Create a new heap with all the elements from aCollection"	^(self basicNew)		setCollection: aCollection asArray copy tally: aCollection size;		reSort;		yourself! !!Heap class methodsFor: 'examples' stamp: 'ar 9/10/1999 14:07'!heapExample	"Heap heapExample"	"Create a sorted collection of numbers, remove the elements	sequentially and add new objects randomly.	Note: This is the kind of benchmark a heap is designed for."	| n rnd array time sorted |	n _ 5000. "# of elements to sort"	rnd _ Random new.	array _ (1 to: n) collect:[:i| rnd next].	"First, the heap version"	time _ Time millisecondsToRun:[		sorted _ Heap withAll: array.		1 to: n do:[:i| 			sorted removeFirst.			sorted add: rnd next].	].	Transcript cr; show:'Time for Heap: ', time printString,' msecs'.	"The quicksort version"	time _ Time millisecondsToRun:[		sorted _ SortedCollection withAll: array.		1 to: n do:[:i| 			sorted removeFirst.			sorted add: rnd next].	].	Transcript cr; show:'Time for SortedCollection: ', time printString,' msecs'.! !!Heap class methodsFor: 'examples' stamp: 'ar 9/10/1999 13:32'!heapSortExample	"Heap heapSortExample"	"Sort a random collection of Floats and compare the results with	SortedCollection (using the quick-sort algorithm) and 	ArrayedCollection>>mergeSortFrom:to:by: (using the merge-sort algorithm)."	| n rnd array out time sorted |	n _ 10000. "# of elements to sort"	rnd _ Random new.	array _ (1 to: n) collect:[:i| rnd next].	"First, the heap version"	out _ Array new: n. "This is where we sort into"	time _ Time millisecondsToRun:[		sorted _ Heap withAll: array.		1 to: n do:[:i| sorted removeFirst].	].	Transcript cr; show:'Time for heap-sort: ', time printString,' msecs'.	"The quicksort version"	time _ Time millisecondsToRun:[		sorted _ SortedCollection withAll: array.	].	Transcript cr; show:'Time for quick-sort: ', time printString,' msecs'.	"The merge-sort version"	time _ Time millisecondsToRun:[		array mergeSortFrom: 1 to: array size by: [:v1 :v2| v1 <= v2].	].	Transcript cr; show:'Time for merge-sort: ', time printString,' msecs'.! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'sw 5/8/2000 01:28'!changed: sym	sym == #classList ifTrue: [self updateAfterClassChange].	super changed: sym! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'sw 5/8/2000 01:02'!initHierarchyForClass: aClassOrMetaClass	| tab stab index nonMetaClass |	centralClass _ aClassOrMetaClass.	nonMetaClass _ aClassOrMetaClass theNonMetaClass.	self systemOrganizer: SystemOrganization.	metaClassIndicated _ aClassOrMetaClass isMeta.	classList _ OrderedCollection new.	tab _ ''.	nonMetaClass allSuperclasses reverseDo: 		[:aClass | 		classList add: tab , aClass name.		tab _ tab , '  '].	index _ classList size + 1.	nonMetaClass allSubclassesWithLevelDo:		[:aClass :level |		stab _ ''.  1 to: level do: [:i | stab _ stab , '  '].		classList add: tab , stab , aClass name]	 	startingLevel: 0.	self classListIndex: index! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'sw 11/8/1999 09:38'!potentialClassNames	"Answer the names of all the classes that could be viewed in this browser"	^ self classList collect:		[:aName | aName copyWithout: $ ]! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'di 4/26/2000 20:20'!systemCategorySingleton	| cls |	cls _ self selectedClass.	^ cls ifNil: [Array new]		ifNotNil: [Array with: cls category]! !!HierarchyBrowser methodsFor: 'initialization' stamp: 'sw 5/8/2000 01:04'!updateAfterClassChange	"It is possible that some the classes comprising the hierarchy have changed, so reinitialize the entire browser."	centralClass ifNotNil:		[self initHierarchyForClass: centralClass]! !!HierarchyBrowser methodsFor: 'menu messages' stamp: 'sw 11/8/1999 13:35'!systemCatSingletonKey: aChar from: aView	^ self systemCatListKey: aChar from: aView! !!HierarchyBrowser methodsFor: 'menu messages' stamp: 'sw 11/8/1999 14:08'!systemCatSingletonMenu: aMenu	^ aMenu labels:'find class... (f)browseprintOutfileOutupdaterename...remove' 	lines: #(1 4)	selections:		#(findClass buildSystemCategoryBrowser		printOutSystemCategory fileOutSystemCategory updateSystemCategories		 renameSystemCategory removeSystemCategory )! !!HierarchyBrowser methodsFor: 'class list' stamp: 'mir 3/22/2000 13:02'!classList	classList _ classList select: [:each | Smalltalk includesKey: each withBlanksTrimmed asSymbol].	^ classList! !!HierarchyBrowser class methodsFor: 'as yet unclassified' stamp: 'sw 5/8/2000 02:10'!newFor: aClass	"Open a new HierarchyBrowser on the given class"	|  newBrowser |	newBrowser _ HierarchyBrowser new initHierarchyForClass: aClass.	Browser openBrowserView: (newBrowser openSystemCatEditString: nil)		label: aClass theNonMetaClass name, ' hierarchy'"HierarchyBrowser newFor: Boolean"! !The Class apes StandardFileStream, but converts the text to HTML before putting it out (primarily intended for printOut).  It can be invoked with	((FileStream fileNamed: 'changes.html') asHtml) fileOutChangesUse usual FileStream methods to put out text converted to	HTML fairly approximating that text  (for best looks, use 	method:, methodHeader:, methodBody:, for code);verbatim: puts text out without conversion;command: put out HTML items, such as <br>, supplying the brackets.header: and trailer: put out an HTML wrapper (preamble and closing text)nextPut does the actual conversion, nextPutAll: defers characters to nextPut.The code is fairly dumb at present, doing a wooden straightforward conversion of the text without attempting to capture the style or fonts in which the original text was rendered.  Tabs are handled awkwardly, using &nbsp, so that probably only leading strings are working right.  Style sheets now permit us to do a much neater looking job if there is interest in improving the looks of things.!]style[(1039)f1cred;!!HtmlFileStream methodsFor: 'read, write, position' stamp: 'acg 01/01/1999 13:59'!nextPut: char	"Put a character on the file, but translate it first. 4/6/96 tk 1/1/98 acg"	char = $< ifTrue: [^ super nextPutAll: '&lt;'].	char = $> ifTrue: [^ super nextPutAll: '&gt;'].	char = $& ifTrue: [^ super nextPutAll: '&amp;'].	char asciiValue = 13 "return" 		ifTrue: [self command: 'br'].	char = $	"tab" 		ifTrue: [self verbatim: TabThing. ^super nextPut: char].	^ super nextPut: char! !!HtmlFileStream methodsFor: 'read, write, position' stamp: 'acg 01/07/1999 09:24'!trailer	"append the HTML trailer.  Call this just before file close.	4/4/96 tk"	| cr |	cr _ String with: Character cr.	self command: '/BODY'; verbatim: cr.	self command: '/HTML'; verbatim: cr.!]style[(7 192)f1bcblue;,f1! !!HtmlFileStream methodsFor: 'read, write, position' stamp: 'acg 01/02/1999 00:38'!verbatim: aString	"Put out the string without HTML conversion. 1/1/99 acg"	super nextPutAll: aString	"'super verbatim:' in the 2.3beta draft didn't perform as expected -- the code was printed with conversion.  In a sense, that wouldn't make sense either -- we don't want strictly verbatim printing, just printing without the HTML conversion (that is, skipping around just the nextPut: and nextPutAll: for just this Class).  If there were intermediate conversions (say, CRLF!!), we would want those to happen as advertised -- perhaps we should use a differently named selector, perhaps something like nextPutWithoutHTMLConversion:, so that verbatim isn't overridden?"! !!HtmlFileStream class methodsFor: 'instance creation' stamp: 'acg 01/07/1999 09:24'!newFrom: aFileStream	"Answer an HtmlFileStream that is 'like' aFileStream.  As a side-effect, the surviving fileStream answered by this method replaces aFileStream on the finalization registry. 1/6/99 acg"	|inst|	inst _ super newFrom: aFileStream.	StandardFileStream unregister: aFileStream.	HtmlFileStream register: inst.	inst detectLineEndConvention.	^inst! !!HtmlFileStream class methodsFor: 'class initialization' stamp: 'acg 01/01/1999 13:57'!initialize   "HtmlFileStream initialize"	TabThing _ '&nbsp;&nbsp;&nbsp;'"I took Ted's suggestion to use &nbsp, which works far better for the HTML.  Style sheets provide an alternative, possibly better, solution since they permit finer-grain control of the HTML formatting, and thus would permit capturing the style in which text was originally rendered.  Internal tabbings would still get lost. 1/1/99 acg."! !A specialized version of the general ScratchViewerMorph which displays the blocks relevant to a particular script type (input videos, output video, or hub).!!IACTBlockViewer methodsFor: 'initialization' stamp: 'jm 10/12/2003 18:05'!addHeadingRow	"Add a morph that allows editing of my object's name."	| secondColumn secondColumnTop secondColumnBottom menuIconPopUp |	secondColumn _ AlignmentMorph newColumn		color: Color transparent;		inset: 0;		vResizing: #shrinkWrap.	secondColumnTop _ AlignmentMorph newColumn		color: Color transparent;		centering: #center;		vResizing: #shrinkWrap.	secondColumnTop addMorphBack:		 (StringMorph new contents: 'Blocks';				font: (StrikeFont familyName: #NewYork size: 24)).	nameMorph _ UpdatingStringMorph new useStringFormat.	secondColumnBottom _ AlignmentMorph newRow.	secondColumnBottom		inset: 3;		color: (Color gray: 0.6);		vResizing: #shrinkWrap.		menuIconPopUp _  (IconicButton new		labelGraphic: MenuIcon;		extent: 16@16;		color: Color transparent;		borderWidth: 0;		target: self;		actWhen: #buttonDown;		actionSelector: #setCategory).	chooser _ StringMorph new.	chooser contents: 'no category'.	buttonPane _ (AlignmentMorph newSpacer: Color transparent).	secondColumnBottom addMorphBack: buttonPane."xxx commented out to save space:	secondColumnBottom addMorphBack: (StringMorph		contents: 'Category: ' font: TextStyle default defaultFont emphasis: 1).xxx"	secondColumnBottom addMorphBack: chooser; addMorphBack: menuIconPopUp.	secondColumnBottom addMorphBack: (AlignmentMorph newSpacer: Color transparent).	secondColumn		addMorphBack: secondColumnTop;		addMorphBack: secondColumnBottom.	topRow _ AlignmentMorph newRow		color: self color;		inset: 3;		centering: #center;		vResizing: #shrinkWrap.	topRow addMorphBack: (Morph new color: Color transparent; extent: 0).	topRow addMorphBack: secondColumn.	self addMorph: topRow.! !!IACTBlockViewer methodsFor: 'accessing' stamp: 'jm 12/18/2003 11:59'!target: aScratchObject	"Start viewing the given object, if not object, return an empty viewer."	aScratchObject ifNil: [		nameMorph target: nil; contents: 'no object '.		^ self].		nameMorph		target: aScratchObject;		getSelector: #objName;		putSelector: #objName:.	self currentCategory: (aScratchObject blockCategoriesFor: #type) first.	self isInWorld ifTrue: [self world startSteppingSubmorphsOf: self].! !!IACTBlockViewer methodsFor: 'accessing' stamp: 'jm 10/12/2003 18:16'!thumbnail	"I don't have a thumbnail, but all that's needed by the caller is an object that responds appropriately to 'target', which nameMorph does."	^ nameMorph! !Specialized verson of the HatBlock, which allows the user to click on the hat block to start or stop a script from executing. (In IACT scripts are normally run continously without stopping)!!IACTHatBlock methodsFor: 'initialization' stamp: 'jm 12/10/2003 11:42'!initialize	super initialize.	self color: (Color r: 0.6 g: 0.0 b: 0.8).	isEnabled _ true.	scratchProc _ nil.	indicatorMorph _ EllipseMorph new 		extent: 12@12;		position: 6@6;		color: Color green.	self addMorph: indicatorMorph.	self extent: 23@23.! !!IACTHatBlock methodsFor: 'accessing' stamp: 'jm 12/10/2003 20:56'!isHatBlock	"Answer true if I am a script hat."	^ true! !!IACTHatBlock methodsFor: 'accessing' stamp: 'jm 12/10/2003 14:20'!scriptOwner: anObject	"ignore"! !!IACTHatBlock methodsFor: 'event handling' stamp: 'jm 12/11/2003 14:44'!click: evt	"Toggle my enabled flag."	isEnabled _ true.	indicatorMorph color: Color green.	scratchProc _ nil.! !!IACTHatBlock methodsFor: 'event handling' stamp: 'jm 12/10/2003 10:48'!handlesMouseDown: evt	^ true! !!IACTHatBlock methodsFor: 'event handling' stamp: 'jm 12/10/2003 11:47'!justDroppedInto: aMorph event: anEvent	"Do nothing."! !!IACTHatBlock methodsFor: 'event handling' stamp: 'jm 12/10/2003 11:47'!mouseDown: evt	evt hand waitForClicksOrDrag: self event: evt.! !!IACTHatBlock methodsFor: 'scripts' stamp: 'jm 12/10/2003 10:54'!isEnabled	^ isEnabled! !!IACTHatBlock methodsFor: 'scripts' stamp: 'jm 12/11/2003 14:41'!stepScript	isEnabled ifFalse: [scratchProc _ nil. ^ self].	scratchProc ifNil: [		scratchProc _ ScratchProcess new expression: self blockSequence].	IACTMainWindow userMode		ifTrue: [  "catch errors"			[scratchProc runStep]				ifError: [					isEnabled _ false.					scratchProc _ nil.					indicatorMorph color: Color red]]		ifFalse: [  "errors can be debugged"			scratchProc runStep].	(scratchProc notNil and: [scratchProc isTerminated])		ifTrue: [scratchProc _ nil].  "a fresh process will be created next step"! !The "hub" or "switcher" graphical object.!!IACTHub methodsFor: 'initialization' stamp: 'jm 11/6/2003 08:01'!initialize	super initialize.	snapSlots _ Array new: 5.	self form: (IACTMainWindow skin at: #hub).! !!IACTHub methodsFor: 'accessing' stamp: 'jm 11/6/2003 08:02'!highlight	self form: (IACTMainWindow skin at: #hubHighlighted).! !!IACTHub methodsFor: 'accessing' stamp: 'dh 7/17/2003 12:51'!mainWindow	^ mainWindow.! !!IACTHub methodsFor: 'accessing' stamp: 'dh 7/17/2003 12:51'!mainWindow: obj	mainWindow _ obj.! !!IACTHub methodsFor: 'accessing' stamp: 'dh 8/13/2003 14:35'!snapSlots	^ snapSlots.! !!IACTHub methodsFor: 'accessing' stamp: 'jm 11/6/2003 08:02'!unhighlight	self form: (IACTMainWindow skin at: #hub).! !!IACTHub methodsFor: 'event handling' stamp: 'jm 10/12/2003 13:17'!handlesMouseOver: evt	"Handle mouse over events as long as a wire is being created."	mainWindow ifNil: [^ false].	mainWindow wires do: [:w | w creatingWire ifTrue: [^ true]].	^ false! !!IACTHub methodsFor: 'event handling' stamp: 'dh 7/18/2003 14:46'!mouseEnter: evt	self highlight.	self mainWindow wires do: [:i | i creatingWire ifTrue: [^self]].	self mainWindow wires		 do: [:i | i otherObject = self 			ifTrue: [ i borderColor: Color white. 					 i sensorObject highlight]].! !!IACTHub methodsFor: 'event handling' stamp: 'jm 12/10/2003 18:19'!mouseLeave: evt	self unhighlight.	mainWindow wires do: [:w | w creatingWire ifTrue: [^ self]].	mainWindow wires do: [:w |		w otherObject = self ifTrue: [ 			mainWindow blockViewer target = w scriptButton ifTrue: [				self highlight.				^ self]. 			w borderColor: Color green. 			w sensorObject unhighlight]].! !The script button for scripts which are connected between a sensor and the hub, which are used to control which input video is displayed in the output video box.!!IACTHubScript methodsFor: 'accessing' stamp: 'jm 12/10/2003 17:22'!blockReceiver	"Answer the receiver for my blocks."	^ wire mainWindow outputVideo! !!IACTHubScript class methodsFor: 'scratch' stamp: 'jm 12/10/2003 15:56'!classBlockSpecs	^ #(		'video source'			('set input video %n'	-	selectedInputVideo:)	)! !Scratch ImageBoxMorph.!!IACTImageBox methodsFor: 'event handling' stamp: 'jm 12/11/2003 18:44'!handlesMouseDown: evt	^ false! !The main interface window for the IACT application.!!IACTMainWindow methodsFor: 'intialization' stamp: 'jm 12/10/2003 11:28'!initialize	super initialize.	self color: Color gray.	self isSticky: true.	self extent: 1008@717.	self loadPanels.	self loadVideoViewers.	self loadPortButtons.	self loadHub.	wires _ OrderedCollection new.	sensorButtonForms _ #(nil nil).	inProjectionMode _ false.	selectedVideo _ 1.	vBarX _ (self width - 330).	hBar1Y _ (12 + blockViewer height).	hBar2Y _ (12 + blockViewer height + scriptArea height + 12).	panelMode _ #script.! !!IACTMainWindow methodsFor: 'intialization' stamp: 'jm 11/3/2003 11:05'!loadHub	"Creates the hub/switcher object."	hub _ IACTHub new 		position: self position + (22@299);		mainWindow: self.	leftPanel addMorphFront: hub.! !!IACTMainWindow methodsFor: 'intialization' stamp: 'jm 12/10/2003 15:24'!loadPanels	"Loads the four main IACT panels."	leftPanel _ Morph new		position: (self left + 13)@(self top + 13);		extent: (self right - 337)@(self bottom - 26);		isSticky: true;		color: (Color gray: 0.8).	self addMorph: leftPanel.	blockViewer _ IACTBlockViewer new		position:  (self left + 700)@(self top + 12);		extent: (self width - 713)@290;		isSticky: true.	self addMorph: blockViewer.	scriptArea _ IACTScriptArea new		position: (self left + 700)@(blockViewer bottom + 13);		extent: (self width - 713)@330;		isSticky: true.	self addMorph: scriptArea.	rangeArea _ IACTRangeArea new		position: (self left + 700)@(scriptArea bottom + 13);		extent: (self width - 713)@108;		isSticky: true;		mainWindow: self.	self addMorph: rangeArea.! !!IACTMainWindow methodsFor: 'intialization' stamp: 'jm 11/3/2003 11:07'!loadPortButtons	"Load the sensor port buttons onto the main window."	portButtons _ (IACTSensorGroup new 		color: Color transparent;		position: (self left + 223)@(self bottom - 210);		extent: 500@75;		mainWindow: self).! !!IACTMainWindow methodsFor: 'intialization' stamp: 'jm 10/30/2003 14:09'!loadVideoViewers	"Loads the three input video viewers and the output viewer into the main IACT window."	| inX inY |	inX _ self left + 130.	inY _ self top + 81.	videos _ Array new: 3.	videos at: 1 put:		(IACTVideoBox new 			position: inX@inY;			indexNum: 1).	videos at: 2 put:		(IACTVideoBox new 			position: (inX + 185)@inY;			indexNum: 2).	videos at: 3 put:		(IACTVideoBox new 			position: (inX + 370)@inY;			indexNum: 3).	outputVideo _ IACTOutputVideo new		position: self bottomLeft + (30 @ -203);		mainWindow: self.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:11'!barForms: formList	"Set the forms used for my joints and dividing bars, create my toolbar, then position everything."	| topJointForm leftJointForm rightJointForm bottomJointForm vBarForm hBarForm |	topJointForm _ formList at: 1.	topJointFormHeight _ topJointForm height.	leftJointForm _ formList at: 2.	rightJointForm _ formList at: 3.	bottomJointForm _ formList at: 4.	vBarForm _ formList at: 5.	hBarForm _ formList at: 6.	vBar _ IACTPaneDivider new scratchFrame: self.	vBar startForm: topJointForm edgeForm: vBarForm endForm: bottomJointForm.	hBar1 _ IACTPaneDivider new scratchFrame: self; label: #first.	hBar1 startForm: leftJointForm edgeForm: hBarForm endForm: rightJointForm.	hBar2 _ IACTPaneDivider new scratchFrame: self; label: #second.	hBar2 startForm: leftJointForm edgeForm: hBarForm endForm: rightJointForm.	self addMorphFront: vBar.	self addMorphFront: hBar1.	self addMorphFront: hBar2.	self positionBars.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:11'!blockViewer	^ blockViewer! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:12'!blockViewer: obj	blockViewer _ obj.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:12'!clickAreas	^ clickAreas! !!IACTMainWindow methodsFor: 'accessing' stamp: 'dh 8/14/2003 16:51'!deleting	^ deleting.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:12'!deleting: boolean	deleting _ boolean.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:12'!enterProjectionMode	"Start full screen projection mode."	inProjectionMode _ true.	"screenExtent _ (Display width max: MinWidth)@(Display height max: MinHeight).	self position: 0@0.	self extent: screenExtent."	Smalltalk fullScreenMode: true.	World restoreDisplay.	blackBox _ Morph new extent: Display extent; color: Color black.	self addMorph: blackBox.	projectionVideo _ IACTProjectionVideo new.	projectionVideo		mainWindow: self;		position: Display center - (projectionVideo extent // 2).	self addMorph: projectionVideo.	projectionVideo startStepping.	World displayWorldSafely.	self world hands first newKeyboardFocus: self.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 10/30/2003 12:37'!exitProjectionMode	"Exit full screen projection mode and return to the main IACT window."	inProjectionMode _ false.	blackBox delete.	projectionVideo delete.	Smalltalk fullScreenMode: false.	World restoreDisplay.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:12'!extent: aPoint	"Position my bars whenever I get resized."	super extent: aPoint.	self positionBars.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:12'!hBar1	^ hBar1! !!IACTMainWindow methodsFor: 'accessing' stamp: 'dh 7/23/2003 12:28'!hBar1Y: aNumber	"Fix my layout whenever my horizontal bar is moved."	hBar1Y _ aNumber.	self positionBars.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:12'!hBar2	^ hBar2! !!IACTMainWindow methodsFor: 'accessing' stamp: 'dh 7/23/2003 12:28'!hBar2Y: aNumber	"Fix my layout whenever my horizontal bar is moved."	hBar2Y _ aNumber.	self positionBars.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:11'!hub	^ hub! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 10/30/2003 14:09'!outputVideo	^ outputVideo! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:13'!panelMode	^ panelMode! !!IACTMainWindow methodsFor: 'accessing' stamp: 'dh 7/29/2003 17:33'!panelMode: mode	panelMode _ mode.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:13'!portButtons	^ portButtons! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 12/10/2003 16:15'!positionBars	"Upon resizing, do the following:		- constrain my size		- constrain the movement of my vertical and horizontal bars		- position my vertical and horizontal bars		- position my panes"	| constrainedX minVBarX maxVBarX minHBar1Y maxHBar1Y constrained1Y minHBar2Y maxHBar2Y constrained2Y |	topEdgeForm ifNil: [^ self].	(self height < MinHeight) ifTrue: [self height: MinHeight].	(self width < MinWidth) ifTrue: [self width: MinWidth].	minHBar1Y _ topEdgeForm height + 125.	maxHBar1Y _ rangeArea position y - self position y - hBar2 height - 125.	constrained1Y _ (hBar1Y max: minHBar1Y) min: maxHBar1Y.	minHBar2Y _ blockViewer height + hBar1 height + 125.	maxHBar2Y _ self height - hBar1 height - 125.	constrained2Y _ (hBar2Y max: minHBar2Y) min: maxHBar2Y.	minVBarX _  694.	panelMode = #script		ifTrue: [maxVBarX _ self width - (rightEdgeForm width + 170)]		ifFalse: [maxVBarX _ self width - 300].	constrainedX _ (vBarX max: minVBarX) min: maxVBarX.	constrainedX = maxVBarX ifTrue: [vBarX _ constrainedX].	vBar position: self topLeft + (constrainedX @ 0).	vBar height: self height.	hBar1 position: self topLeft + ((constrainedX + 5) @ constrained1Y).												hBar1 width: self width - (constrainedX + 5).	hBar2 position: self topLeft + ((constrainedX + 5) @ constrained2Y).												hBar2 width: self width - (constrainedX + 5).	leftPanel position: self topLeft + ((leftEdgeForm width)@topEdgeForm height).	leftPanel height: self height - (bottomEdgeForm height + topEdgeForm height).	leftPanel width: constrainedX.	panelMode = #script 		ifTrue: [			blockViewer position: self topLeft + 				((constrainedX + 20)@(topEdgeForm height)); comeToFront.			blockViewer height: constrained1Y - topEdgeForm height + 5.			blockViewer width: self width - (constrainedX + rightEdgeForm width + 20)]		ifFalse: [			sensorEditor position: self topLeft + 				((constrainedX + 20)@(topEdgeForm height)); comeToFront.			sensorEditor height: self height - topEdgeForm height - bottomEdgeForm height.			sensorEditor width: self width - (constrainedX + rightEdgeForm width + 20).			sensorEditor updateControls].	scriptArea position: self topLeft + ((constrainedX + 20)@(constrained1Y + 20)); 	comeToFront.	scriptArea height: constrained2Y - constrained1Y - 15.	scriptArea width: self width - (constrainedX + rightEdgeForm width + 20).	rangeArea position: self topLeft + ((constrainedX + 20)@(constrained2Y + 20)); 		comeToFront.	rangeArea height: self height - constrained2Y - 20 - bottomEdgeForm height.	rangeArea width: self width - (constrainedX + rightEdgeForm width + 20).	rangeArea updateObjects.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:13'!rangeArea	^ rangeArea! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:13'!rangeArea: obj	rangeArea _ obj.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 10/12/2003 14:50'!resetSensorReader	portButtons sensorBase		initialize;		startReadingData.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:13'!scriptArea	^ scriptArea! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 12/10/2003 15:08'!scriptArea: obj	scriptArea _ obj.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:13'!sensorButtonForms	^ sensorButtonForms! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:13'!sensorEditor	^ sensorEditor! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:13'!sensorEditor: obj	sensorEditor _ obj.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 10/12/2003 16:10'!sensorRawValueAt: sensorIndex	^ portButtons sensorBase sensor: sensorIndex! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:13'!startDeleteMode	deleting _ true.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:13'!vBar	^ vBar.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'dh 7/23/2003 15:42'!vBarX: aNumber	"Fix my layout whenever my vertical bar is moved."	vBarX _ aNumber.	self positionBars.! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:14'!videos	^ videos! !!IACTMainWindow methodsFor: 'accessing' stamp: 'jm 11/3/2003 11:14'!wires	^ wires! !!IACTMainWindow methodsFor: 'event handling' stamp: 'dh 7/4/2003 15:38'!handlesMouseDown: evtSensor cursorPoint x > (self left + 700)	ifTrue: [^false]	ifFalse: [^true].! !!IACTMainWindow methodsFor: 'event handling' stamp: 'jm 10/30/2003 14:36'!keyStroke: evt	"Any key exits from projection mode."	inProjectionMode ifTrue: [self exitProjectionMode].! !!IACTMainWindow methodsFor: 'event handling' stamp: 'dh 9/20/2003 16:27'!mouseDown: evt"if right click and creating a wire, cancels the wire creation.  also starts wire creation if it is the hub that is clicked on"| flag |evt yellowButtonPressed ifTrue: 	[wires 		do: [:i | i creatingWire			ifTrue: [i sensorObject snapSlots 						at: i sensorSnapIndex put: 0.					wires removeLast delete. ^ self.]].	^ self.].flag _ false.self wires do: [:i | i creatingWire ifTrue: [flag _ true]].flag ifTrue: [	(hub bounds containsPoint: Sensor cursorPoint) ifTrue:		[ self doWireProcessing: #hub at: (hub right)@(hub center y) evt: evt object: hub]].! !!IACTMainWindow methodsFor: 'open/save' stamp: 'jm 12/18/2003 12:41'!open	self beep.! !!IACTMainWindow methodsFor: 'open/save' stamp: 'jm 12/18/2003 12:43'!saveAs	self beep.	"Smalltalk saveAs."	"self resetSensorReader."! !!IACTMainWindow methodsFor: 'wires' stamp: 'jm 10/14/2003 11:06'!createNewWire: type at: point"usually called by a sensorButton ojbect to make a new wire"| newWire |newWire  _  (IACTWire new		setVertices: (Array with: point with: Sensor cursorPoint);		creatingWire: true;		mainWindow: self;		firstNodeObject: type).self wires add: newWire.self addMorph: newWire.newWire startStepping.! !!IACTMainWindow methodsFor: 'wires' stamp: 'jm 12/10/2003 12:29'!doWireProcessing: type at: point evt: evt object: obj	"This method is called by various other objects--like videoPlayer or hub--when they are clicked on while a wire is being created. This method makes that wire permanent."	| snapNum break newWire |	evt yellowButtonPressed ifTrue: [		self wires do: [:i |			i creatingWire ifTrue: [				self wires removeLast delete.				^ self]].		^ self].	self wires do: [:i |		i creatingWire ifTrue: [			snapNum _ 1.			break _ false.			obj snapSlots doWithIndex: [:a :idx |				(a = 0) & (break = false) ifTrue: [snapNum _ idx. break _ true]].			obj snapSlots at: snapNum put: 1.			i snapIndex: snapNum.			type = #sensor				ifTrue: [					i firstNodeObject ~= #sensor ifTrue: [						i secondNodeObject: type.						i sensorObject: obj.						i createScriptButton: i firstNodeObject.						i creatingWire: false.						^ self].					^ self]				ifFalse: [					i firstNodeObject = #sensor ifTrue: [						i secondNodeObject: type.						i otherObject: obj.						i createScriptButton: i secondNodeObject.						i creatingWire: false.						^ self].					^ self]]].	newWire _ (IACTWire new		setVertices: (Array with: point with: point with: Sensor cursorPoint with: Sensor cursorPoint);		creatingWire: true;		mainWindow: self;		firstNodeObject: type).	type = #sensor ifTrue: [newWire sensorObject: obj] ifFalse: [newWire otherObject: obj].	self wires add: newWire.	self reorderWires.	self addMorph: newWire.	newWire startStepping.	^ newWire! !!IACTMainWindow methodsFor: 'wires' stamp: 'dh 9/20/2003 16:28'!reorderWires"sorts the wires from top to bottom based on the y value of their horizontal segment"wires sortBy: [:a :b | (a vertices at: 2) y < (b vertices at: 2) y].! !!IACTMainWindow methodsFor: 'private' stamp: 'jm 10/30/2003 14:04'!background: formList	"sets up background graphical objects, also adds certain other objects, like videos and sensor buttons that need to be in the foreground to the world.  also adds click area objects for the videos"	| bottomBase outputVideoBack form videoBase inputVideoBack |	form _ formList at: 1.	bottomBase _ ImageMorph new form: form; 		position: (self left)@(self bottom - form height).	self addMorph: bottomBase.	form _ formList at: 2.	outputVideoBack _ ImageMorph new form: form;		position: (self left + 25)@(bottomBase top + 25).	self addMorph: outputVideoBack.	form _ formList at: 3.	videoBase _ ImageMorph new form: form;		position: (self left + 89)@(self top + 70).	self addMorph: videoBase.	self videos do: [:video |		form _ formList at: 4.		inputVideoBack _ ImageMorph new form: form;			position: (video display left - 4)@(video display top - 4).		self addMorph: inputVideoBack].	self portButtons setForms: (formList at: 5) highlight: (formList at: 6).	self addMorph: portButtons.	videos do: [:m | self addMorph: (m mainWindow: self)]. 	self addMorph: (outputVideo mainWindow: self).	leftPanel addMorphBack: (ImageMorph new 		form: (formList at: 7);		position: 41@40).	leftPanel addMorphBack: (ImageMorph new		form: (formList at: 8);		position: 80@40).	clickAreas _ Array new: 5.	clickAreas at: 1 put: (ClickArea new		object: (videos at: 1);		position: (self left + 125)@(self top + 83);		color: Color transparent;		extent: (152@160)).	clickAreas at: 2 put: (ClickArea new		object: (videos at: 1);		position: (self left + 160)@(self top + 243);		color: Color transparent;		extent: (115@30)).		clickAreas at: 3 put: (ClickArea new		object: (videos at: 2);		position: (self left + 315)@(self top + 81);		color: Color transparent;		extent: (150@200)).	clickAreas at: 4 put: (ClickArea new		object: (videos at: 3);		position: (self left + 495)@(self top + 83);		color: Color transparent;		extent: (160@161)).	clickAreas at: 5 put: (ClickArea new		object: (videos at: 3);		position: (self left + 495)@(self top + 244);		color: Color transparent;		extent: (109@30)).		clickAreas do: [:i | self addMorphFront: i]."xxx	videos do: [:i | 		i framePosition: (TextBox new			extent: 40@20;			contents: '0' wrappedTo: 40;			position: (i left + 75 + 48)@(i top + 143 - 3);			fontName: #ComicPlain size: 6).		self addMorphFront: i framePosition].xxx"! !!IACTMainWindow methodsFor: 'private' stamp: 'jm 12/11/2003 14:57'!buttons: formList	"adds clickable buttons to the world"	sensorButtonForms at: 1 put: (formList at: 1).	sensorButtonForms at: 2 put: (formList at: 2).	plugForm _ (formList at: 3).	portButtons addLabelButtons.	deleting _ false.	deleteButton _ ToggleButton new 		onForm: (formList at: 5) offForm: (formList at: 4);		isMomentary: true;		position: (self left + 465)@(self bottom - 68); 		target: self; 		actionSelector: #startDeleteMode.	self addMorphFront: deleteButton.	saveButton _ ToggleButton new 		onForm: (formList at: 7) offForm: (formList at: 6);		isMomentary: true;		position: (self left + 535)@(self bottom - 68); 		target: self; 		actionSelector: #saveAs.	self addMorphFront: saveButton.	openButton _ ToggleButton new 		onForm: (formList at: 9) offForm: (formList at: 8);		isMomentary: true;		position: (self left + 605)@(self bottom - 68); 		target: self; 		actionSelector: #open.	self addMorphFront: openButton.	projectionButton _ ToggleButton new 		onForm: (formList at: 11) offForm: (formList at: 10);		label: 'Projection';		isMomentary: true;		position: (self left + 58)@(self bottom - 48); 		target: self; 		actionSelector: #enterProjectionMode.	self addMorphFront: projectionButton.! !!IACTMainWindow class methodsFor: 'instance creation' stamp: 'dh 8/19/2003 13:47'!includeInNewMorphMenu	^ true! !!IACTMainWindow class methodsFor: 'instance creation' stamp: 'jm 10/14/2003 14:32'!new	| corners edges bars background buttons |	corners _ Array		with: (Skin at: #topLeft)		with: (Skin at: #topRight)		with: (Skin at: #bottomLeft)		with: (Skin at: #bottomRight).	edges _ Array		with: (Skin at: #topEdge)		with: (Skin at: #leftEdge)		with: (Skin at: #rightEdge)		with: (Skin at: #bottomEdge).	bars _ Array		with: (Skin at: #topJoint)		with: (Skin at: #leftJoint)		with: (Skin at: #rightJoint)		with: (Skin at: #bottomJoint)		with: (Skin at: #vBar)		with: (Skin at: #hBar).	background _ {		(Skin at: #bottomBase).		(Skin at: #outputVideoBack).		(Skin at: #videoBase).		(Skin at: #inputVideoBack).		(Skin at: #sensorValButton).		(Skin at: #sensorValButtonHighlight).		(Skin at: #leftWires).		(Skin at: #topWires)}.	buttons _ {		(Skin at: #sensorButtonNormal).		(Skin at: #sensorButtonPressed).		(Skin at: #plug).		(Skin at: #deleteButton).		(Skin at: #deleteButtonPressed).		(Skin at: #saveFileButton).		(Skin at: #saveFileButtonPressed).		(Skin at: #openFileButton).		(Skin at: #openFileButtonPressed).		(Skin at: #projectionButton).		(Skin at: #projectionButtonPressed)}.	^ super new 		cornerForms: corners; 		edgeTileForms: edges;		barForms: bars;		background: background;		buttons: buttons! !!IACTMainWindow class methodsFor: 'class initialization' stamp: 'jm 12/11/2003 14:39'!initialize	MinWidth _ 1008.	MinHeight _ 717.	UserMode _ true.! !!IACTMainWindow class methodsFor: 'user mode' stamp: 'jm 12/11/2003 14:40'!userMode	^ UserMode! !!IACTMainWindow class methodsFor: 'user mode' stamp: 'jm 12/11/2003 14:43'!userMode: aBoolean	"IACTMainWindow userMode: false"	"for development and debugging"	"IACTMainWindow userMode: true"	"for end-users"	UserMode _ aBoolean.! !!IACTMainWindow class methodsFor: 'skin' stamp: 'jm 12/18/2003 10:39'!readSkinFrom: aDirectory	"Read the Forms for my skin from the given directory and store them in my Skin dictionary."	"self readSkinFrom: (FileDirectory default directoryNamed: 'IACTSkin')"	| d |	d _ Dictionary new.	"read frame forms"	#(topLeft topRight bottomLeft bottomRight	  topEdge leftEdge rightEdge bottomEdge	  topJoint leftJoint rightJoint bottomJoint	  vBar hBar) do: [:n |		d at: n put: (Utilities form: n from: aDirectory)].	"read background forms"	#(bottomBase outputVideoBack videoBase inputVideoBack sensorValButton		sensorValButtonHighlight leftWires topWires) do: [:n |		d at: n put: (Utilities form: n from: aDirectory)].	"read button forms"	#(sensorButtonNormal sensorButtonPressed plug	  deleteButton deleteButtonPressed	  saveFileButton saveFileButtonPressed	  openFileButton openFileButtonPressed	  playButton playButtonPressed	  projectionButton projectionButtonPressed) do: [:n |		d at: n put: (Utilities form: n from: aDirectory)].	"read more button forms"	#(scriptButton scriptButtonLight	  hub hubHighlighted	  calibrateButtonNormal calibrateButtonPressed	  openVideoButton openVideoButtonPressed) do: [:n |		d at: n put: (Utilities form: n from: aDirectory)].	Skin _ d.! !!IACTMainWindow class methodsFor: 'skin' stamp: 'jm 11/6/2003 07:19'!skin	^ Skin! !The script button which is used to define scripts controlling only the output video.!!IACTOutputScript class methodsFor: 'scratch' stamp: 'jm 12/12/2003 11:24'!classBlockSpecs	^ #(		'movie'			('fade color %c'		-	fadeColor:)	)! !!IACTOutputScript class methodsFor: 'scratch' stamp: 'jm 12/12/2003 11:19'!varSpecs	^ #(		(sensorValue	0 1024)		(mouseX			0 1024)		(mouseY		0 1024)		(panX			-200 200)		(panY			-200 200)		(zoom			0.1 10)		(fade			0 1)	)! !A subclass of video player that is used to display the output video after a specific input video is selected depending on hub scripts.!!IACTOutputVideo methodsFor: 'initialization' stamp: 'jm 10/30/2003 14:32'!initialize	super initialize.	self removeAllMorphs.	maxDisplayW _ 172.	maxDisplayH _ 142.	self extent: maxDisplayW@maxDisplayH.	snapSlots _ Array new: 5 withAll: 0.	selectedInputVideo _ 1.	display _ (IACTImageBox new		extent: self extent;		position: self position;		color: Color black).	self addMorph: display."xxx uncomment this to highlight using a translucent rectangle	highlight _ (RectangleMorph new		extent: maxDisplayW@maxDisplayH;		position: self position;		color: (Color white alpha: 0)).	self addMorph: highlight.xxx"! !!IACTOutputVideo methodsFor: 'accessing' stamp: 'jm 10/30/2003 12:10'!selectedInputVideo	^ selectedInputVideo! !!IACTOutputVideo methodsFor: 'accessing' stamp: 'jm 10/30/2003 14:10'!selectedInputVideo: anInteger	selectedInputVideo _ anInteger.! !!IACTOutputVideo methodsFor: 'event handling' stamp: 'jm 10/30/2003 12:08'!handlesMouseDown: evt	mainWindow wires do: [:i | i creatingWire ifTrue: [^ true]].	^ false! !!IACTOutputVideo methodsFor: 'stepping' stamp: 'jm 10/30/2003 14:56'!step	"Take the form from the selected input video, transform it to the correct size of the output video display, and put the new form in the output video's display."	| source |	((selectedInputVideo < 1) |	 (selectedInputVideo > 3)) ifTrue: [  "no input video"		display fade: 0.		^ self].	source _ (self mainWindow videos at: selectedInputVideo) display.	"NOTE: should check and possibly adjust display aspect ratio here"	display		fadeColor: source fadeColor;		fade: source fade;		form: source form.! !!IACTOutputVideo methodsFor: 'stepping' stamp: 'jm 10/30/2003 12:10'!stepTime	^ 20! !I represent the divider bars that seperate the four panes in IACT.!!IACTPaneDivider methodsFor: 'accessing' stamp: 'jm 10/12/2003 11:49'!label: aString	label _ aString.! !!IACTPaneDivider methodsFor: 'event handling' stamp: 'dh 7/23/2003 14:02'!mouseMove: evt	"Inform my frame that the position of my vertical or horizontal bar is changing."	scratchFrame ifNil: [^ self].	self bounds isWide		ifTrue: [label = #first 			ifTrue: [scratchFrame hBar1Y: evt cursorPoint y - scratchFrame top]			ifFalse: [scratchFrame hBar2Y: evt cursorPoint y - scratchFrame top]]		ifFalse: [scratchFrame vBarX: evt cursorPoint x - scratchFrame left].! !The video viewer used in Projection (full screen) mode to present the final output.!!IACTProjectionVideo methodsFor: 'initialization' stamp: 'jm 10/30/2003 14:54'!initialize	super initialize.	self removeAllMorphs.	maxDisplayW _ 400.	maxDisplayH _ 300.	self extent: maxDisplayW@maxDisplayH.	display _ (IACTImageBox new		extent: self extent;		position: self position;		color: Color black).	self addMorph: display.! !!IACTProjectionVideo methodsFor: 'event handling' stamp: 'jm 10/30/2003 14:34'!handlesMouseDown: evt	^ false! !!IACTProjectionVideo methodsFor: 'event handling' stamp: 'jm 10/30/2003 12:21'!handlesMouseOver: evt	^ false! !Bottom right pane in IACT which displays the output range associated with the sensor connected to the currently selected script.!!IACTRangeArea methodsFor: 'as yet unclassified' stamp: 'dh 8/5/2003 16:33'!addHeadingRow	"Add a morph that allows editing of my object's name."	topRow _ AlignmentMorph newRow		color: (Color gray: 0.8);		inset: 3;		centering: #center;		vResizing: #shrinkWrap.	topRow addMorphBack: (AlignmentMorph newSpacer: Color transparent).	topRow addMorphBack: (nameMorph _ StringMorph new contents: 'Sensor Range').	nameMorph font: (StrikeFont familyName: #NewYork size: 24).	topRow addMorphBack: (AlignmentMorph newSpacer: Color transparent).	self addMorph: topRow! !!IACTRangeArea methodsFor: 'as yet unclassified' stamp: 'dh 8/5/2003 17:21'!initialize	super initialize.	self orientation: #vertical.	self color: (Color gray: 0.9).	self borderWidth: 2; borderColor: (Color gray: 0.5).	self inset: 0.	self useRoundedCorners.	self addHeadingRow.	self addMorphBack: (AlignmentMorph newRow 		vResizing: #rigid; height: 15; color: Color transparent).	back _ AlignmentMorph newRow		color: (Color gray: 0.9);		extent: 145@85;		centering: #center;		vResizing: #shrinkWrap.		back addMorphBack: (AlignmentMorph newSpacer: Color transparent).	back addMorphBack: (StringMorph new contents: 'Min   ';		font: (StrikeFont familyName: #ComicPlain size: 16)).	minBox _ (RectangleMorph new		color: Color white;		borderInset;		borderWidth: 2;		extent: 45@30).	back addMorphBack: minBox.	minText _ (StringMorph new contents: '0';		font: (StrikeFont familyName: #ComicPlain size: 16);		position: (minBox left + 4)@(minBox top + 4)).	minBox addMorph: minText.	back addMorphBack: (AlignmentMorph newSpacer: Color transparent).	maxBox _ RectangleMorph new		color: Color white;		borderInset;		borderWidth: 2;		extent: 45@30.	back addMorphBack: maxBox.	maxText _ (StringMorph new contents: '0';		font: (StrikeFont familyName: #ComicPlain size: 16);		position: (minBox left + 4)@(minBox top + 4)).	maxBox addMorph: maxText.	back addMorphBack: (StringMorph new contents: '   Max';		font: (StrikeFont familyName: #ComicPlain size: 16)).	back addMorphBack: (AlignmentMorph newSpacer: Color transparent).	self addMorphBack: back.! !!IACTRangeArea methodsFor: 'as yet unclassified' stamp: 'dh 8/4/2003 16:30'!mainWindow	^ mainWindow.! !!IACTRangeArea methodsFor: 'as yet unclassified' stamp: 'dh 8/4/2003 16:30'!mainWindow: obj	mainWindow _ obj.! !!IACTRangeArea methodsFor: 'as yet unclassified' stamp: 'dh 8/13/2003 17:28'!maxText	^ maxText.! !!IACTRangeArea methodsFor: 'as yet unclassified' stamp: 'dh 8/13/2003 17:27'!minText	^ minText.! !!IACTRangeArea methodsFor: 'as yet unclassified' stamp: 'dh 8/4/2003 16:27'!sensor: obj	sensorObj _ obj.! !!IACTRangeArea methodsFor: 'as yet unclassified' stamp: 'dh 9/20/2003 16:35'!updateObjects	"makes sure the min an max values are updated"	sensorObj = nil ifFalse: 		[minText contents: sensorObj editor minVal contents.		 maxText contents: sensorObj editor maxVal contents].! !I represent a script object and graphical button. I store all the information about a script.!!IACTScript methodsFor: 'initialization' stamp: 'jm 12/11/2003 16:27'!initialize	| hatBlock |	super initialize.	self form: (IACTMainWindow skin at: #scriptButton).	"create my one-and-only hat block"	hatBlock _ IACTHatBlock new position: blocksBin topLeft + (10@12).	blocksBin addMorph: hatBlock.! !!IACTScript methodsFor: 'accessing' stamp: 'jm 11/18/2003 16:57'!form: aForm	"Makes sure form rotates okay."	originalForm _ (aForm asFormOfDepth: 16).	scalePoint _ 1.0@1.0.	rotationCenter _ aForm extent // 2.	self layoutChanged.! !!IACTScript methodsFor: 'accessing' stamp: 'jm 12/10/2003 14:48'!installScripts: aBlocksBin	blocksBin _ aBlocksBin.! !!IACTScript methodsFor: 'accessing' stamp: 'jm 12/10/2003 17:24'!sensorValue	"Calculates the adjusted sensor value based on what is input in the sensor editor for this sensor."	| val minVal maxVal initMinVal initMaxVal finalVal |	val _ wire mainWindow sensorRawValueAt: wire sensorObject index.	minVal _ wire mainWindow rangeArea minText contents asNumber.	maxVal _ wire mainWindow rangeArea maxText contents asNumber.	initMinVal _ wire sensorObject editor inputRangeSlider position1Text contents asNumber.	initMaxVal _ wire sensorObject editor inputRangeSlider position2Text contents asNumber.	initMinVal = initMaxVal ifTrue: [initMaxVal _ initMinVal + 0.01].	val > initMaxVal ifTrue: [val _ initMaxVal].	val < initMinVal ifTrue: [val _ initMinVal].	finalVal _ (((val / (initMaxVal - initMinVal)) * (maxVal - minVal)) + minVal) asFloat.	^ finalVal! !!IACTScript methodsFor: 'accessing' stamp: 'jm 12/12/2003 13:51'!variablesPage	"Fix sensorValue, the only variable that I handle myself."	| bin |	bin _ super variablesPage.	bin submorphsDo: [:m |		(((m isKindOf: WatcherMorph) and: [m getVariable = #sensorValue]) or:		 [(m isKindOf: SimpleButtonMorph) and: [m arguments first = #sensorValue]])			ifTrue: [m target: self]].	^ bin! !!IACTScript methodsFor: 'accessing' stamp: 'jm 11/18/2003 16:58'!wire	^ wire! !!IACTScript methodsFor: 'accessing' stamp: 'jm 11/18/2003 16:58'!wire: obj	wire _ obj.! !!IACTScript methodsFor: 'event handling' stamp: 'jm 11/18/2003 16:59'!handlesMouseDown: evt	^ true! !!IACTScript methodsFor: 'event handling' stamp: 'jm 11/18/2003 17:05'!handlesMouseOver: evt	^ true! !!IACTScript methodsFor: 'event handling' stamp: 'jm 12/10/2003 18:20'!mouseDown: evt	"If in delete mode, delete the script button and clear its associated panels and objects. If not in delete mode, open up panels for this script button and highlight the appropriate connected objects."	| mainWin oldScriptButton |	oldPosition _ wire vertices.	oldObject _ wire otherObject.	oldIndex _ wire snapIndex.	mainWin _ wire mainWindow.	mainWin deleting ifTrue: [		mainWin deleting: false.		mainWin blockViewer target = self ifTrue: [			mainWin blockViewer delete.			mainWin scriptArea delete.			mainWin rangeArea delete.						mainWin blockViewer: (IACTBlockViewer new				position: mainWin position + (700@12);				extent: (mainWin width - 713)@330;				isSticky: true).			mainWin addMorph: mainWin blockViewer.			mainWin scriptArea: (IACTScriptArea new				position: (mainWin left + 700)@(mainWin blockViewer bottom + 13);				extent: (mainWin width - 713)@330;				isSticky: true).			mainWin addMorph: mainWin scriptArea.			mainWin scriptArea target: nil.			mainWin rangeArea: (IACTRangeArea new				position: (mainWin left + 700)@(mainWin scriptArea bottom + 13);				extent: (mainWin width - 713)@(108);				isSticky: true;				mainWindow: mainWin).			mainWin addMorph: mainWin rangeArea.				mainWin positionBars].		wire otherObject snapSlots at: wire snapIndex put: 0.		wire sensorObject snapSlots at: wire sensorSnapIndex put: 0.		wire delete.		^ self].	mainWin panelMode = #sensor ifTrue: [		mainWin panelMode: #script.		mainWin sensorEditor delete.		mainWin addMorph: mainWin hBar1.		mainWin addMorph: mainWin hBar2.		mainWin portButtons labelButtons do: [:b | b off]].	oldScriptButton _ mainWin blockViewer target.	oldScriptButton ifNotNil: [		oldScriptButton wire borderColor: Color green.		oldScriptButton wire sensorObject unhighlight.		oldScriptButton wire otherObject unhighlight].	wire borderColor: Color white.	wire sensorObject highlight.	wire otherObject highlight.	self openBlocksBin.	mainWin scriptArea target: self.	mainWin rangeArea delete.	mainWin rangeArea sensor: wire sensorObject.	mainWin addMorph: mainWin rangeArea.	mainWin positionBars.! !!IACTScript methodsFor: 'event handling' stamp: 'jm 12/10/2003 17:22'!mouseEnter: evt	wire mainWindow wires do: [:i | i creatingWire ifTrue: [^ self]].	self highlight.	wire borderColor: Color white.	wire sensorObject highlight.	wire otherObject highlight.! !!IACTScript methodsFor: 'event handling' stamp: 'jm 12/10/2003 18:21'!mouseLeave: evt	wire mainWindow wires do: [:i | i creatingWire ifTrue: [^ self]].	self unhighlight.	wire mainWindow blockViewer target = self ifFalse: [		wire borderColor: Color green.		wire sensorObject unhighlight.		wire otherObject unhighlight].! !!IACTScript methodsFor: 'event handling' stamp: 'jm 12/10/2003 17:23'!mouseMove: evt	wire creatingWire: true.	wire setScriptButtonPos.	oldObject snapSlots at: oldIndex put: 0.! !!IACTScript methodsFor: 'event handling' stamp: 'jm 12/10/2003 18:15'!mouseUp: evt	"Used when dragging a script button to move its associated wire to a new location. If mouse is released when over a new video or other valid target, adjusts the variables associated with the script button appropriately."	| flag mainWin |	flag _ true.	mainWin _ wire mainWindow.	mainWin videos do: [:i |		(i containsPoint: Sensor cursorPoint) ifTrue: [			flag _ false.			mainWin doWireProcessing: #inputVideo				at: (i center x)@(i bottom) evt: evt object: i]].	(mainWin outputVideo containsPoint: Sensor cursorPoint) ifTrue: [		flag _ false.		mainWin doWireProcessing: #outputVideo			at: (mainWin outputVideo center x)@(mainWin outputVideo bottom)			evt: evt object: mainWin outputVideo].	(mainWin hub containsPoint: Sensor cursorPoint) ifTrue: [		flag _ false.		mainWin doWireProcessing: #hub			at: (mainWin hub center x)@(mainWin hub bottom)			evt: evt object: mainWin hub].	wire creatingWire: false.	flag		ifTrue: [oldObject snapSlots at: oldIndex put: 1. wire setVertices: oldPosition]		ifFalse: [			oldObject snapSlots at: oldIndex put: 0.			mainWin blockViewer target: wire scriptButton.			self highlight.			wire borderColor: Color white.			wire sensorObject highlight.			wire otherObject highlight.			(wire otherObject isKindOf: IACTHub)				ifTrue: [self changeBlocksReceiversTo: mainWin outputVideo]				ifFalse: [self changeBlocksReceiversTo: wire otherObject display]].	wire setScriptButtonPos.	wire layoutChanged.! !!IACTScript methodsFor: 'blocks' stamp: 'jm 11/18/2003 16:04'!blockCategoriesFor: aSymbol	"Answer the block categories for my object-specific, type-specific, or generic blocks, depending on the given symbol."	#object = aSymbol ifTrue: [^ #('variables')].	#type = aSymbol ifTrue: [		^ (self class classBlockSpecs select: [:el | el isKindOf: String]) asArray sort].	"generic"	^ (self class genericBlockSpecs select: [:el | el isKindOf: String]) asArray sort! !!IACTScript methodsFor: 'blocks' stamp: 'jm 12/10/2003 17:22'!blockReceiver	"Answer the receiver for my blocks."	^ wire otherObject display! !!IACTScript methodsFor: 'blocks' stamp: 'jm 12/10/2003 22:28'!blocksFor: aCategory	"Answer my blocks initialized so that the receiver is the appropriate object."	aCategory = 'scripts' ifTrue: [^ #()].  "no scripts for now"	^ (super blocksFor: aCategory) collect: [:b |		b isHatBlock ifFalse: [b receiver: self blockReceiver].		b]! !!IACTScript methodsFor: 'blocks' stamp: 'jm 12/10/2003 18:17'!openBlocksBin	"Open a blocks bin for me."		wire mainWindow blockViewer = nil 		ifFalse: [wire mainWindow blockViewer delete].	wire mainWindow blockViewer: (IACTBlockViewer new		target: self;		position:  (wire mainWindow left + 700)@(wire mainWindow top + 12);		extent: (wire mainWindow width - 713)@330;		layoutChanged).	wire mainWindow positionBars.	wire mainWindow addMorph: wire mainWindow blockViewer.	self world startSteppingSubmorphsOf: wire mainWindow blockViewer.! !!IACTScript methodsFor: 'other' stamp: 'jm 12/10/2003 15:12'!changeBlocksReceiversTo: newReceiver	"Change the receiver of all blocks in my scripts to the given object."	blocksBin allMorphsDo: [:m |		(m isKindOf: CommandBlockMorph) ifTrue: [			m receiver: newReceiver].		(m isKindOf: HatBlockMorph) ifTrue: [			m scriptOwner: newReceiver.			m scratchProc ifNotNil: [m scratchProc stop].			m scratchProc: nil]].! !!IACTScript methodsFor: 'other' stamp: 'jm 11/6/2003 07:52'!highlight	self form: (IACTMainWindow skin at: #scriptButtonLight).! !!IACTScript methodsFor: 'other' stamp: 'jm 12/10/2003 15:43'!stepScripts	"Step all my enabled scripts."	| enabledHatBlocks |	enabledHatBlocks _ blocksBin submorphs select: [:m |		(m isKindOf: IACTHatBlock) and: [m isEnabled]].	enabledHatBlocks do: [:hat | hat stepScript].! !!IACTScript methodsFor: 'other' stamp: 'jm 11/6/2003 07:52'!unhighlight	self form: (IACTMainWindow skin at: #scriptButton).! !!IACTScript class methodsFor: 'scratch' stamp: 'jm 11/18/2003 16:50'!classBlockSpecs	^ #()! !!IACTScript class methodsFor: 'scratch' stamp: 'jm 12/12/2003 13:58'!genericBlockSpecs	"See comment in ScriptableScratchMorph>genericBlockSpecs."	^ #('control and logic'			('if %b'					csu	doIf)			('repeat %n'				csu	doRepeat)			('wait until %b'			su	doWaitUntil)			('wait secs %n'			stu	doWait:elapsed:)			('%b and %b'			ru	&)			('%b or %b'				ru	|)			('not %b'				ru	not)		'math'			('%n + %n'				ru	+)			('%n - %n'				ru	-)			('%n * %n'				ru	*)			('%n / %n'				ru	/)			('%n mod %n'			ru	\\)			('%n < %n'				ru	<)			('%n = %n'				ru	=)			('%n > %n'				ru	>)			('random from %n to %n'	ru	randomFrom:to:)	)! !!IACTScript class methodsFor: 'scratch' stamp: 'jm 12/10/2003 15:51'!varSpecs	^ #(		(sensorValue	0 1024)		(mouseX			0 1024)		(mouseY		0 1024)	)! !I am an editor for IACT block scripts.!!IACTScriptArea methodsFor: 'initialization' stamp: 'jm 12/10/2003 17:33'!addHeadingRow	"Details: I create a nameMorph and, even though I do not add it to myself, I use its target slot to keep track of my target script."	topRow _ AlignmentMorph newRow		color: self color;		inset: 3;		centering: #center;		vResizing: #shrinkWrap.	topRow addMorphBack: (AlignmentMorph newSpacer: Color transparent).	topRow addMorphBack: (StringMorph new contents: 'Script'; 		font: (StrikeFont familyName: #NewYork size: 24)).	nameMorph _ UpdatingStringMorph new useStringFormat.  "used to hold target"	topRow addMorphBack: (AlignmentMorph newSpacer: Color transparent).	self addMorph: topRow.! !!IACTScriptArea methodsFor: 'other' stamp: 'jm 11/5/2003 09:54'!suppressBlockReceivers	"Answer true if block receivers should not be display for blocks in me."	^ true! !!IACTScriptArea methodsFor: 'other' stamp: 'jm 12/10/2003 14:28'!target: aScratchObjectOrNil	"Start viewing the given object or no object."	(aScratchObjectOrNil isNil or:	 [aScratchObjectOrNil isScriptable not]) ifTrue: [		nameMorph target: nil; contents: 'no object '.		bin ifNotNil: [bin delete. bin _ nil].		^ self].	nameMorph		target: aScratchObjectOrNil;		getSelector: #objName;		putSelector: #objName:.	bin ifNotNil: [bin delete].	bin _ aScratchObjectOrNil blocksBin.	pageViewer contents: bin.	self world ifNotNil: [self world startSteppingSubmorphsOf: bin].! !!IACTScriptArea methodsFor: 'other' stamp: 'jm 10/12/2003 18:16'!thumbnail	"I don't have a thumbnail, but all that's needed by the caller is an object that responds appropriately to 'target', which nameMorph does."	^ nameMorph! !The sensor button graphical object, used to create a new wire to connect up a sensor to a video.!!IACTSensorButton methodsFor: 'as yet unclassified' stamp: 'dh 8/4/2003 16:36'!editor	^ editor.! !!IACTSensorButton methodsFor: 'as yet unclassified' stamp: 'jm 10/12/2003 12:59'!handlesMouseDown: evt	sensorGroup mainWindow ifNil: [^ false].	sensorGroup mainWindow wires do: [:w | w creatingWire ifTrue: [^ false]].	^ true! !!IACTSensorButton methodsFor: 'as yet unclassified' stamp: 'jm 10/12/2003 12:58'!handlesMouseOver: evt	sensorGroup mainWindow ifNil: [^ false].	sensorGroup mainWindow wires do: [:w | w creatingWire ifTrue: [^ false]].	^ true! !!IACTSensorButton methodsFor: 'as yet unclassified' stamp: 'dh 8/6/2003 13:46'!highlight	self form: sensorGroup buttonHighlight.! !!IACTSensorButton methodsFor: 'as yet unclassified' stamp: 'dh 7/21/2003 17:07'!index	^ index.! !!IACTSensorButton methodsFor: 'as yet unclassified' stamp: 'dh 8/11/2003 17:24'!index: num		index _ num.	editor sensor: num.! !!IACTSensorButton methodsFor: 'as yet unclassified' stamp: 'jm 10/14/2003 19:53'!initialize	super initialize.	snapSlots _ Array new: 5 withAll: 0.	editor _ IACTSensorEditor new isSticky: true.	editor sensor: index.! !!IACTSensorButton methodsFor: 'as yet unclassified' stamp: 'dh 9/20/2003 16:43'!mouseDown: evt	"creates a new wire"	| snapPosList break snapNum wire main |	evt yellowButtonPressed ifTrue: 		[sensorGroup mainWindow wires 			do: [:i | i creatingWire				ifTrue: [sensorGroup mainWindow wires removeLast delete. ^ self.]].		^ self].	main _ sensorGroup mainWindow.	snapPosList _ {((260 + ((index - 1) * 90))@(main height - 209)). ((270 + ((index - 1) * 90))@(main height - 209)). ((250 + ((index - 1) * 90))@(main height - 209)). ((280 + ((index - 1) * 90))@(main height - 209)). ((240 + ((index - 1) * 90))@(main height - 209))}.	snapNum_ 1.	break _ false.	self snapSlots doWithIndex: [:a :idx | 		(a = 0) & (break = false) ifTrue: [snapNum _ idx. break _ true]].	snapSlots at: snapNum put: 1.		wire _ sensorGroup mainWindow doWireProcessing: #sensor		 at: (sensorGroup mainWindow position) + (snapPosList at: snapNum) evt: evt object: self.	wire sensorSnapIndex: snapNum.! !!IACTSensorButton methodsFor: 'as yet unclassified' stamp: 'dh 7/18/2003 14:41'!mouseEnter: evt	self highlight.	sensorGroup mainWindow wires do: [:i | i creatingWire ifTrue: [^self]].	sensorGroup mainWindow wires		 do: [:i | i sensorObject = self 			ifTrue: [ i borderColor: Color white. 					 i otherObject highlight]].! !!IACTSensorButton methodsFor: 'as yet unclassified' stamp: 'jm 12/10/2003 18:22'!mouseLeave: evt	self unhighlight.	sensorGroup mainWindow wires do: [:w | w creatingWire ifTrue: [^ self]].	sensorGroup mainWindow wires do: [:w |		w sensorObject = self ifTrue: [			sensorGroup mainWindow blockViewer target = w scriptButton ifTrue: [				self highlight.				^ self]. 			w otherObject = nil ifFalse: [				w borderColor: Color green.				w otherObject unhighlight]]].! !!IACTSensorButton methodsFor: 'as yet unclassified' stamp: 'jm 12/10/2003 15:04'!openSensorEditor	self sensorGroup mainWindow panelMode: #sensor.	self sensorGroup labelButtons do: [:b | b off].	"turn all buttons off"	(self sensorGroup labelButtons at: index) on.		"turn selected button on"	self sensorGroup mainWindow hBar1 delete.	self sensorGroup mainWindow hBar2 delete.	self sensorGroup mainWindow scriptArea delete.	self sensorGroup mainWindow rangeArea delete.	self sensorGroup mainWindow blockViewer delete.	self sensorGroup mainWindow sensorEditor: editor.	self sensorGroup mainWindow addMorph: editor.	editor mainWindow: self sensorGroup mainWindow.	editor world startSteppingSubmorphsOf: editor.	self sensorGroup mainWindow positionBars.! !!IACTSensorButton methodsFor: 'as yet unclassified' stamp: 'dh 7/18/2003 13:53'!sensorGroup	^ sensorGroup.! !!IACTSensorButton methodsFor: 'as yet unclassified' stamp: 'dh 7/18/2003 13:52'!sensorGroup: obj	sensorGroup _ obj.! !!IACTSensorButton methodsFor: 'as yet unclassified' stamp: 'dh 8/13/2003 12:32'!snapSlots	^ snapSlots.! !!IACTSensorButton methodsFor: 'as yet unclassified' stamp: 'dh 8/6/2003 13:46'!unhighlight	self form: sensorGroup buttonNormal.! !The editing pane for all sensor related information, including input and output ranges.!!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'dh 7/29/2003 18:08'!addHeadingRow	"Add a morph that allows editing of my object's name."	topRow _ AlignmentMorph newRow		color: (Color gray: 0.8);		inset: 3;		centering: #center;		vResizing: #shrinkWrap.	topRow addMorphBack: (AlignmentMorph newSpacer: Color transparent).	topRow addMorphBack: (nameMorph _ StringMorph new contents: 'Sensor Range Editor').	nameMorph font: (StrikeFont familyName: #NewYork size: 24).	topRow addMorphBack: (AlignmentMorph newSpacer: Color transparent).	self addMorph: topRow! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'dh 8/5/2003 17:35'!addMorphCentered: obj	back addMorphBack: 		(AlignmentMorph newRow vResizing: #rigid; color: Color transparent;			addMorphBack: (AlignmentMorph newSpacer: Color transparent);			addMorphBack: obj;			addMorphBack: (AlignmentMorph newSpacer: Color transparent)).! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'dh 8/11/2003 15:04'!handlesMouseDown: evt	^ true.! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'dh 8/25/2003 15:13'!initialize	super initialize.	self orientation: #vertical.	self color: Color white.	self borderWidth: 2; borderColor: (Color gray: 0.5).	self color: (Color gray: 0.9).	self inset: 0.	self useRoundedCorners.	self addHeadingRow.	calibrating _ false.		back _ AlignmentMorph newColumn 		color: (Color gray: 0.9).		"extent: 200@500;		position: (self left)@(self top)."	self loadControls.	self addMorphBack: back.! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'dh 8/13/2003 17:30'!inputRangeSlider	^inputRangeSlider.! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'jm 12/11/2003 16:21'!loadControls	| m |	back addMorphBack: 		(AlignmentMorph newRow color: Color transparent; vResizing: #rigid; height: 20).	inputString _ (StringMorph new contents: 'Input Range';		font: (StrikeFont familyName: #ComicPlain size: 20)).	self addMorphCentered: inputString.	currentPositionSlider _ (SimpleSliderMorph new		extent: 200@30;		maxVal: 1024;		adjustToValue: 500).	slidePosition _ BorderedMorph new		borderRaised;		extent: 28@20;		position: (self left - 12)@(self bottom);		borderWidth: 1;		color: Color lightGray.	positionText _ UpdatingStringMorph new		getSelector: #sliderVal;		target: self;		contents: '0';		position: (slidePosition left + 3)@(slidePosition top + 4).	slidePosition addMorph: positionText.	inputRangeSlider _ (DoubleSlider new		extent: 200@30;		maxVal: 1024).	m _ (Morph new 		color: Color transparent;		extent: 250@125;		addMorph: currentPositionSlider; 		addMorph: slidePosition;		addMorph: inputRangeSlider).	currentPositionSlider position: m position + (25@0).	inputRangeSlider position: m position + (25@70).	self addMorphCentered: m.	back addMorphBack: 		(AlignmentMorph newRow color: Color transparent; vResizing: #rigid; height: 20).	calibrateButton _ ToggleButton new		onForm: (IACTMainWindow skin at: #calibrateButtonPressed)			offForm: (IACTMainWindow skin at: #calibrateButtonNormal);		label: ' Auto Adjust Range' font: (StrikeFont familyName: #ComicBold size: 14);		target: self;		actionSelector: #startCalibration;		isMomentary: false.	self addMorphCentered: calibrateButton.	back addMorphBack: 		(AlignmentMorph newRow color: Color transparent; vResizing: #rigid; height: 40).	outputString _ (StringMorph new contents: 'Output Range';		font: (StrikeFont familyName: #ComicPlain size: 20)).	self addMorphCentered: outputString.	minValBox _ RectangleMorph new		color: Color white;		borderInset;		borderWidth: 2;		extent: 45@25.		minVal _ IACTTextMorph new		extent: 40@20;		contents: '0' wrappedTo: 40;		position: (minValBox left + 3)@(minValBox top + 3).	minValBox addMorph: minVal.	maxValBox _ RectangleMorph new		color: Color white;		borderInset;		borderWidth: 2;		extent: 45@25.		maxVal _ IACTTextMorph new		extent: 40@20;		contents: '100' wrappedTo: 40;		position: (maxValBox left + 3)@(maxValBox top + 3).	maxValBox addMorph: maxVal.	minText _ (StringMorph new contents: 'Min   ';		font: (StrikeFont familyName: #ComicPlain size: 14)).	maxText _ (StringMorph new contents: '   Max';		font: (StrikeFont familyName: #ComicPlain size: 14)).	back addMorphBack: 		(AlignmentMorph newRow vResizing: #rigid; color: (Color gray: 0.9);			addMorphBack: (AlignmentMorph newSpacer: Color transparent);			addMorphBack: minText;			addMorphBack: minValBox;			addMorphBack: (AlignmentMorph newSpacer: Color transparent);			addMorphBack: maxValBox;			addMorphBack: maxText;			addMorphBack: (AlignmentMorph newSpacer: Color transparent)).		back addMorphBack: 		(AlignmentMorph newRow color: Color transparent; vResizing: #rigid; height: 40).	resetButton _ ToggleButton new		onForm: (IACTMainWindow skin at: #calibrateButtonPressed)			offForm: (IACTMainWindow skin at: #calibrateButtonNormal);		label: ' Reset Sensors' font: (StrikeFont familyName: #ComicBold size: 14);		target: self;		actionSelector: #resetSensors;		isMomentary: true.	self addMorphCentered: resetButton.! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'dh 7/30/2003 14:29'!mainWindow	^ mainWindow.! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'dh 7/30/2003 14:30'!mainWindow: obj	mainWindow _ obj.! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'dh 8/4/2003 16:39'!maxVal	^ maxVal.! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'dh 8/4/2003 16:34'!minVal	^ minVal.! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'dh 8/11/2003 16:42'!mouseDown: evt	! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'jm 10/12/2003 14:51'!resetSensors	mainWindow resetSensorReader.! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'dh 7/30/2003 14:47'!sensor	^ sensor.! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'dh 7/30/2003 14:26'!sensor: num	sensor _ num.! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'jm 10/12/2003 14:52'!sliderVal	^ self mainWindow sensorRawValueAt: sensor! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'jm 11/6/2003 07:47'!startCalibration	"Start calibration mode, which automatically adjusts the range of the sensor input based on realtime values of the sensor. Calibration runs until the button is pressed again."	| val |	calibrating		ifTrue: [			calibrating _ false] 		ifFalse: [			calibrating _ true.			val _ self mainWindow sensorRawValueAt: sensor.			inputRangeSlider slider1Val: val.			inputRangeSlider slider2Val: val.			inputRangeSlider computeSlider].! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'jm 10/12/2003 14:52'!step	| val |	self mainWindow panelMode = #sensor ifTrue: [		val _ self mainWindow sensorRawValueAt: sensor.		currentPositionSlider adjustToValue: val.		slidePosition position:			(currentPositionSlider slider center x - (slidePosition width // 2))@				(currentPositionSlider slider bottom).				calibrating ifTrue: [			val > inputRangeSlider slider2Val				ifTrue: [inputRangeSlider slider2Val: val].				val < inputRangeSlider slider1Val				ifTrue: [inputRangeSlider slider1Val: val]].			inputRangeSlider computeSlider].! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'dh 7/30/2003 14:36'!stepTime	^ 50.! !!IACTSensorEditor methodsFor: 'as yet unclassified' stamp: 'dh 8/5/2003 17:25'!updateControls	"back width: self width - 10.		inputString position: (back center x - (inputString extent x / 2))@(back top + 20).	outputString position: (back center x - (inputString extent x / 2))@(back top + 280).	currentPositionSlider position: 		(back center x - (currentPositionSlider extent x / 2))@(back top + 50).	slidePosition position:		(currentPositionSlider slider center x - (slidePosition width // 2))@			(currentPositionSlider slider bottom).	inputRangeSlider position:		(back center x - (inputRangeSlider extent x / 2))@(back top + 130).	calibrateButton position:		(back center x - (calibrateButton extent x / 2))@(back top + 210).	minVal position:		(back center x - 30 - minVal width)@(back top + 310).	maxVal position:		(back center x + 30 + 5)@(back top + 310).	minValBox position:		(back center x - 30 - minValBox width - 5)@(back top + 310 - 2).	maxValBox position:		(back center x + 30)@(back top + 310 - 2).	minText position:		(minValBox left - 23)@(back top + 310).	maxText position:		(maxValBox right + 6)@(back top + 310).	back layoutChanged."! !The sensor board port interface; displays the current sensor values on five seperate buttons within the main IACT window.!!IACTSensorGroup methodsFor: 'as yet unclassified' stamp: 'jm 10/14/2003 19:51'!addButtonsAndReadouts"creates the individual sensor buttons, and they're associated readouts"| rect |readouts _ Array new: 5.buttons _ Array new: 5.1 to: 5 do: [:i | 	rect _(IACTSensorButton new 		position: (self left - 3 + (i - 1 * 90))@(self top);		extent: 78@66;		sensorGroup: self;		index: i).		self addMorph: rect.	readouts at: i put: (StringMorph new		font: (StrikeFont familyName: #ComicBold size: 20) emphasis: 0;		color: Color white;		position: (self left + 28 + (i - 1 * 90))@(self top + 7);		contents: '0').	self addMorph: (readouts at: i).	"self addMorph: (StringMorph new		font: (StrikeFont familyName: #ComicPlain size: 16) emphasis: 1;		position: (self left + 15 + (i - 1 * 90))@(self top + 67);		contents: 'Sensor ', i asString)."	buttons at: i put: rect].! !!IACTSensorGroup methodsFor: 'as yet unclassified' stamp: 'jm 12/11/2003 16:15'!addLabelButtons	"Create the 'open sensor editor' buttons."	| button |	labelButtons _ Array new: 5.	1 to: 5 do: [:i |		button _ ToggleButton new			position: (self left + 10 + (i - 1 * 90))@(self top + 67);			onForm: (self mainWindow sensorButtonForms at: 2)				offForm: (self mainWindow sensorButtonForms at: 1);			isMomentary: false;			label: ' Sensor ', i asString font: (StrikeFont familyName: #ComicBold size: 14);			target: (buttons at: i);			actionSelector: #openSensorEditor.		self addMorph: button.		labelButtons at: i put: button].! !!IACTSensorGroup methodsFor: 'as yet unclassified' stamp: 'dh 8/6/2003 13:46'!buttonHighlight	^ buttonHighlight.! !!IACTSensorGroup methodsFor: 'as yet unclassified' stamp: 'dh 8/6/2003 13:46'!buttonNormal	^ buttonNormal.! !!IACTSensorGroup methodsFor: 'as yet unclassified' stamp: 'dh 6/26/2003 15:59'!buttons^ buttons.! !!IACTSensorGroup methodsFor: 'as yet unclassified' stamp: 'jm 12/12/2003 11:41'!initialize	super initialize.	sensorBase _ SensorBoardMorph new.  "not added to world"	self addButtonsAndReadouts.	sensorBase startReadingData.! !!IACTSensorGroup methodsFor: 'as yet unclassified' stamp: 'dh 7/30/2003 12:27'!labelButtons	^ labelButtons.! !!IACTSensorGroup methodsFor: 'as yet unclassified' stamp: 'dh 7/17/2003 11:55'!mainWindow	^ mainWindow.! !!IACTSensorGroup methodsFor: 'as yet unclassified' stamp: 'dh 6/25/2003 15:34'!mainWindow: objmainWindow _ obj.! !!IACTSensorGroup methodsFor: 'as yet unclassified' stamp: 'dh 7/30/2003 14:27'!readouts	^ readouts.! !!IACTSensorGroup methodsFor: 'as yet unclassified' stamp: 'dh 7/4/2003 16:12'!sensorBase	^ sensorBase.! !!IACTSensorGroup methodsFor: 'as yet unclassified' stamp: 'dh 8/6/2003 13:44'!setForms: form1 highlight: form2	buttonNormal _ form1.	buttonHighlight _ form2.	buttons do: [:i |		i form: buttonNormal].! !!IACTSensorGroup methodsFor: 'as yet unclassified' stamp: 'jm 12/18/2003 12:39'!step	"Keeps the sensor button readouts up to date."	| basePos val readout |	sensorBase processIncomingData.	1 to: 5 do: [:i |		basePos _ (self left + 35 + (i - 1 * 90))@(self top + 8).		val _ sensorBase sensor: i.		readout _ readouts at: i.		readout contents: val printString.		readout position: basePos - ((readout width // 2) @ 0)].! !!IACTSensorGroup methodsFor: 'as yet unclassified' stamp: 'jm 12/12/2003 11:35'!stepTime	^ 50! !Provides base functions like input and output from a sensor board for higher level SensorBoardMorphs, which provide the interface!!IACTSensorReader methodsFor: 'initialization' stamp: 'jm 10/12/2003 16:05'!initialize	super initialize.	portNum _ 1.	sensorValues _ Array new: 16 withAll: 0.	currentState _ #idle.	highByte _ 0.! !!IACTSensorReader methodsFor: 'sensor ops' stamp: 'jm 10/12/2003 16:12'!sensor: n	"Answer the value of sensor n. Sensors are numbered 1-16."	^ sensorValues at: ((n asInteger max: 1) min: sensorValues size)! !!IACTSensorReader methodsFor: 'sensor ops' stamp: 'jm 10/12/2003 16:05'!startReadingData	"Ensure that the serial port is open, turn off all motors and put them into a known state, and begin streaming sensor data."	self openPort: portNum.	self portIsOpen ifFalse: [^ self].	self startStreamingSensors: 16rFF.  "all 8 GoGoBoard sensors"! !!IACTSensorReader methodsFor: 'serial port' stamp: 'jm 10/12/2003 16:12'!closePort	port ifNotNil: [port close].	port _ nil.	sensorValues _ Array new: sensorValues size withAll: 0.! !!IACTSensorReader methodsFor: 'serial port' stamp: 'jm 10/12/2003 16:12'!openPort: anInteger	self closePort.	currentState _ #idle.	sensorValues _ Array new: sensorValues size withAll: 0.	port _ SerialPort new openPort: anInteger ifFail: [^ self].	self startStreamingSensors: 0.  "in case board was left in streaming mode"	(Delay forMilliseconds: 100) wait.	port flushInputBuffer.! !!IACTSensorReader methodsFor: 'serial port' stamp: 'dh 6/23/2003 12:07'!portIsOpen	^ port notNil and: [port isOpen]! !!IACTSensorReader methodsFor: 'serial port' stamp: 'dh 6/23/2003 12:07'!selectPort	| menu n |	menu _ CustomMenu new.	(0 to: 8) do: [:w | menu add: w printString action: w].	n _ menu startUp.	n ifNotNil: [portNum _ n].! !!IACTSensorReader methodsFor: 'private' stamp: 'dh 6/23/2003 12:07'!processByte: aByte	"Process one byte of the incoming data stream."	"Details: This code recognizes three-byte sensor update messages starting with 16r0C using a simple, three-state finite state machine. We assume that sensor updates are always contiguous--that is, replies to motor or other GoGo board commands will not be inserted between the bytes of any given three-byte sensor update message. The sensor number is the top three bits of the byte two. The data value is the bottom two bits of byte two plus all eight bits of byte three."	| sensorNum val |	currentState = #idle ifTrue: [ 		aByte = 16r0C ifTrue: [currentState _ #startByteSeen].		^ self].	currentState = #startByteSeen ifTrue: [		highByte _ aByte.		currentState _ #highByteSeen.		^ self].	currentState = #highByteSeen ifTrue: [		"final byte of message: report the sensor value"		sensorNum _ highByte bitShift: -5.		val _ ((highByte bitAnd: 3) bitShift: 8) + aByte.		sensorValues at: sensorNum + 1 put: val.		currentState _ #idle].! !!IACTSensorReader methodsFor: 'private' stamp: 'jm 10/12/2003 14:42'!processIncomingData	"Process incoming bytes from the serial port."	"On a Macintosh G4 Powerbook, I measured a sensor reading rate of 234 sensor readings/sec."	| buf |	self portIsOpen ifFalse: [^ self].	buf _ port readByteArray.	buf do: [:b | self processByte: b].! !!IACTSensorReader methodsFor: 'private' stamp: 'dh 6/23/2003 12:07'!startStreamingSensors: sensorByte	"Begin streaming data from the set of sensors specified by the bits of the given byte. Invoke this method with 0 to stop streaming. Incoming sensor data is processed by frequent calls to processIncomingData."	| cmd |	port flushInputBuffer.	cmd _ #(84 254 160 0) asByteArray.	cmd at: 4 put: sensorByte.	port nextPutAll: cmd.! !Specialized version of TextMorph. Supposed to allow editing with control over maximum number of characters.!!IACTTextMorph methodsFor: 'event handling' stamp: 'jm 10/30/2003 14:39'!keyStroke: evt	| charValue |	charValue _ evt keyCharacter asciiValue.	charValue = 13 ifTrue: [^ self].	self handleInteraction: [editor readKeyboard] fromEvent: evt.	self updateFromParagraph.	self paragraph text size > 6 ifTrue: [		self owner changed.		self contents: (self contents string copyFrom: 1 to: (self contents size - 1)).		editor ifNil: [self installEditorToReplace: nil].		editor selectAt: self contents size + 1].! !The video player within IACT; includes the actual display, as well as a position slider, previous and next frame buttons, and the ability to open a new video.!!IACTVideoBox methodsFor: 'initialization' stamp: 'jm 12/18/2003 11:32'!initialize	| skin box |	super initialize.	color _ Color black.	maxDisplayW _ 143.	maxDisplayH _ 117.	snapSlots _ Array new: 5 withAll: 0.	self extent: maxDisplayW@maxDisplayH.	display _ (IACTImageBox new		extent: 0@0;		position: self position;		color: Color yellow).	self addMorph: display.	display color: Color yellow.	"xxx uncomment this to indicate selection with translucent overlay	highlight _ (RectangleMorph new		extent: maxDisplayW@maxDisplayH;		position: self position;		color: (Color white alpha: 0)).	self addMorph: highlight.	xxx"	skin _ IACTMainWindow skin.	self addMorph: (ToggleButton new		onForm: (skin at: #openVideoButton) offForm: (skin at: #openVideoButtonPressed);		actionSelector: #openFileAndScale;		target: self;		isMomentary: true;		position: self position + (-3 @ (maxDisplayH + 17))).	playButton _ ToggleButton new		onForm: (skin at: #playButtonPressed) offForm: (skin at: #playButton);		actionSelector: #togglePlaying;		target: self;		isMomentary: false;		position: self position + (58 @ (maxDisplayH + 2)).	self addMorph: playButton.	positionSlider _ (SimpleSliderMorph new		color: Color gray;		height: 7;		initializeSlider;		position: (self left + 29)@(self bottom + 27);		extent: (maxDisplayW - 58)@7;		target: self;		actionSelector: #updateSlider:;		adjustToValue: 0).	self addMorph: positionSlider.	box _ (BorderedMorph new		color: Color gray;		position: (self left + 119)@(self top + maxDisplayW - 4);		extent: 28@18;		useRoundedCorners;		borderWidth: 0;		addMorph: (RectangleMorph new			color: Color white;			borderInset;			borderWidth: 2;			position: (self left + 119)@(self top + maxDisplayW - 4);			useRoundedCorners;			extent: 28@18)).	self addMorph: box.	frameNumberDisplay _ IACTTextMorph new		extent: 40@20;		contents: '0' wrappedTo: 40;		position: (self left + 123)@(self top + 140);		fontName: #ComicPlain size: 6.	self addMorph: frameNumberDisplay.! !!IACTVideoBox methodsFor: 'accessing' stamp: 'jm 10/27/2003 15:50'!currentFrame	^ display currentFrame! !!IACTVideoBox methodsFor: 'accessing' stamp: 'jm 10/27/2003 15:40'!display	^ display! !!IACTVideoBox methodsFor: 'accessing' stamp: 'jm 10/27/2003 15:40'!indexNum	^ indexNum! !!IACTVideoBox methodsFor: 'accessing' stamp: 'jm 10/27/2003 15:41'!indexNum: anInteger	indexNum _ anInteger.! !!IACTVideoBox methodsFor: 'accessing' stamp: 'jm 10/27/2003 15:40'!mainWindow	^ mainWindow! !!IACTVideoBox methodsFor: 'accessing' stamp: 'jm 10/27/2003 15:41'!mainWindow: anIACTMainWindow	mainWindow _ anIACTMainWindow.! !!IACTVideoBox methodsFor: 'accessing' stamp: 'jm 10/27/2003 15:44'!snapSlots	^ snapSlots! !!IACTVideoBox methodsFor: 'event handling' stamp: 'jm 10/12/2003 13:19'!handlesMouseDown: evt	mainWindow ifNil: [^ false].	mainWindow wires do: [:w | w creatingWire ifTrue: [^ true]].	^ false! !!IACTVideoBox methodsFor: 'event handling' stamp: 'jm 10/12/2003 13:15'!handlesMouseOver: evt	mainWindow ifNil: [^ false].	mainWindow wires do: [:w | w creatingWire ifTrue: [^ false]].	^ true! !!IACTVideoBox methodsFor: 'event handling' stamp: 'jm 10/27/2003 15:41'!mouseDown: evt	| offset |	indexNum = 2		ifTrue: [offset _ 66]		ifFalse: [offset _ 45].	mainWindow doWireProcessing: #inputVideo 		at: (self center x)@(self bottom + offset) 		evt: evt object: self.! !!IACTVideoBox methodsFor: 'event handling' stamp: 'jm 10/27/2003 15:42'!mouseEnter: evt	self highlight.	self mainWindow wires do: [:i | i creatingWire ifTrue: [^ self]].	self mainWindow wires do: [:i |		i otherObject = self ifTrue: [			i borderColor: Color white. 			i sensorObject highlight]].! !!IACTVideoBox methodsFor: 'event handling' stamp: 'jm 12/10/2003 18:22'!mouseLeave: evt	self unhighlight.	mainWindow wires do: [:w | w creatingWire ifTrue: [^ self]].	mainWindow wires do: [:w |		w otherObject = self ifTrue: [			(mainWindow blockViewer target = w scriptButton)				ifTrue: [^ self highlight]. 			w borderColor: Color green.			w sensorObject unhighlight]].! !!IACTVideoBox methodsFor: 'stepping' stamp: 'jm 12/18/2003 11:32'!step	| frameNum |	frameNum _ display currentFrame.	positionSlider adjustToValue: frameNum.	frameNumberDisplay contents: frameNum truncated asString.	display isPlaying		ifTrue: [playButton on]		ifFalse: [playButton off].! !!IACTVideoBox methodsFor: 'stepping' stamp: 'jm 10/27/2003 15:44'!stepTime	^ 20! !!IACTVideoBox methodsFor: 'other' stamp: 'jm 10/27/2003 19:01'!highlight	highlight		ifNil: [display borderColor: Color red]		ifNotNil: [highlight color: (Color white alpha: 0.25)].! !!IACTVideoBox methodsFor: 'other' stamp: 'jm 12/12/2003 11:54'!openFileAndScale	"Opens an MPEG file dialog box, then loads the selected movie and resizes it to fit the video viewer, maintaining aspect ratio."	| menu localName fullName scale |	menu _ CustomMenu new title: 'Movie file:'.	FileDirectory default fileNames do: [:fn |		(#(jmv mpg mpeg) includes: (FileDirectory extensionFor: fn) asLowercase) ifTrue: [			menu add: fn action: fn]].	(localName _ menu startUp) ifNil: [^ self].	fullName _ FileDirectory default pathName, FileDirectory slash, localName.	display loadFile: (self asPathRelativeToProject: fullName).	scale _ ((maxDisplayW / display width) min: (maxDisplayH / display height)) min: 1.	display extent: (display extent * scale) rounded.	display position: self position + (((maxDisplayW@maxDisplayH) - display extent) // 2).	positionSlider maxVal: display frameCount.! !!IACTVideoBox methodsFor: 'other' stamp: 'jm 12/18/2003 11:34'!togglePlaying	display isPlaying		ifTrue: [display stopPlaying]		ifFalse: [display startPlaying].! !!IACTVideoBox methodsFor: 'other' stamp: 'jm 10/27/2003 19:02'!unhighlight	highlight		ifNil: [display borderColor: Color black]		ifNotNil: [highlight color: Color transparent].! !!IACTVideoBox methodsFor: 'other' stamp: 'jm 12/15/2003 14:03'!updateSlider: val	display currentFrame: val.! !A script button that is connected between a sensor and an input video. Used to define scripts that control one or more input videos.!!IACTVideoScript class methodsFor: 'scratch' stamp: 'jm 12/12/2003 13:55'!classBlockSpecs	^ #(		'movie'			('play'						-	startPlaying)			('pause'						-	stopPlaying)			('forward %n frames'		-	forwardFrames:)			('fade color %c'				-	fadeColor:)	)! !!IACTVideoScript class methodsFor: 'scratch' stamp: 'jm 12/12/2003 11:19'!varSpecs	^ #(		(sensorValue	0 1024)		(mouseX			0 1024)		(mouseY		0 1024)		(panX			-200 200)		(panY			-200 200)		(zoom			0.1 10)		(fade			0 1)		(currentFrame	0 1000)		(currentSeconds	0 100)		(volume			0 1)		(balance		0 1)	)! !I visually and internally connect two or more components, either a sensor and the output video, a sensor and one or more input videos, or a sensor and the hub.!!IACTWire methodsFor: 'initialization' stamp: 'jm 12/10/2003 14:48'!createScriptButton: type	"Create a new script button of the appropriate type, place it on the wire, and create a new script area for it."	| oldScripts |	oldScripts _ nil.	scriptButton ifNotNil: [		oldScripts _ scriptButton blocksBin.		scriptButton delete].	type = #inputVideo ifTrue: [scriptButton _ IACTVideoScript new].	type = #outputVideo ifTrue: [scriptButton _ IACTOutputScript new].	type = #hub ifTrue: [scriptButton _ IACTHubScript new].	self addMorph: scriptButton.	scriptButton wire: self.	self setScriptButtonPos.	oldScripts ifNotNil: [scriptButton installScripts: oldScripts].! !!IACTWire methodsFor: 'initialization' stamp: 'jm 12/10/2003 12:07'!initialize	| bottomColor topColor middleColor |	super initialize.	bottomColor _ Color green darker mixed: 0.75 with: Color blue.	topColor _ Color green lighter mixed: 0.75 with: Color blue.	middleColor _ Color green.	colorArray _ (bottomColor mix: middleColor shades: 15), 				  (middleColor mix: topColor shades: 15),				  (topColor mix: middleColor shades: 15), 				  (middleColor mix: bottomColor shades: 15).	colorIndex _ 15.	self quickFill: false.	self makeOpen.	self borderColor: (Color r: 0 g: 1 b: 0).	scriptButton _ nil.! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:18'!creatingWire	^ creatingWire! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:00'!creatingWire: aBoolean	creatingWire _ aBoolean.! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:18'!firstNodeObject	^ firstNodeObject! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:18'!firstNodeObject: type	firstNodeObject _ type! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:19'!leftPointX	^ ((self vertices at: 1) x min: (self vertices at: 4) x)! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:18'!mainWindow	^ mainWindow! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:19'!mainWindow: anIACTMainWindow	mainWindow _ anIACTMainWindow.! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:19'!otherObject	^ otherObject! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:19'!otherObject: obj	otherObject _ obj.! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:29'!rightPointX	^ ((self vertices at: 1) x max: (self vertices at: 4) x)! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:30'!scriptButton	^ scriptButton! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:30'!secondNodeObject	^ secondNodeObject! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:30'!secondNodeObject: obj	secondNodeObject _ obj.! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:30'!sensorObject	^ sensorObject! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:30'!sensorObject: obj	sensorObject _ obj.! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:30'!sensorSnapIndex	^ sensorSnapIndex! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:30'!sensorSnapIndex: num	sensorSnapIndex _ num.! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:30'!snapIndex	^ snapIndex! !!IACTWire methodsFor: 'accessing' stamp: 'jm 12/10/2003 12:30'!snapIndex: num	snapIndex _ num.! !!IACTWire methodsFor: 'event handling' stamp: 'jm 12/10/2003 12:05'!handlesMouseDown: evt	(creatingWire | mainWindow deleting) ifTrue: [^ false].	^ scriptButton bounds containsPoint: Sensor cursorPoint! !!IACTWire methodsFor: 'event handling' stamp: 'dh 7/28/2003 13:57'!mouseDown: evt	creatingWire ifFalse:		[evt redButtonPressed ifTrue: 			[(scriptButton bounds containsPoint: Sensor cursorPoint) ifTrue:				[  ]]].! !!IACTWire methodsFor: 'stepping' stamp: 'jm 12/10/2003 15:19'!step	| firstPoint lastPoint |	creatingWire ifTrue: [		self changed.		firstPoint _ self vertices at: 1.		lastPoint _ Sensor cursorPoint.		lastPoint _ self doSnaps.		self setInBetweenPoints: firstPoint endPoint: lastPoint.			self layoutChanged].	scriptButton ifNotNil: [scriptButton stepScripts].	"color animation"	self borderColor = Color white ifFalse: [		self borderColor: (colorArray at: colorIndex).		colorIndex = colorArray size ifTrue: [colorIndex _ 0].		colorIndex _ colorIndex + 1].! !!IACTWire methodsFor: 'stepping' stamp: 'jm 12/10/2003 11:48'!stepTime	^ 20! !!IACTWire methodsFor: 'wire positioning' stamp: 'jm 12/10/2003 12:33'!doSnaps	"Controls the wire snapping as the mouse hovers over certain screen locations while creating a wire."		| lastPoint snapPosList break snapNum |	lastPoint _ Sensor cursorPoint.	snapPosList _ Array new: 5.	firstNodeObject = #sensor		ifTrue: [ 			mainWindow clickAreas do: [:i |				(i bounds containsPoint: Sensor cursorPoint)					ifTrue: [						i object indexNum = 1 ifTrue: [							snapPosList _ {(186@269). (216@275). (156@260). (246@281). (126@250)}].						i object indexNum = 2 ifTrue: [							snapPosList _ {(374@286). (408@286). (340@286). (442@286). (306@286)}].						i object indexNum = 3 ifTrue: [							snapPosList _ {(557@269). (527@275). (587@260). (497@281). (617@250)}].														snapNum _ 1.						break _ false.						i object snapSlots doWithIndex: [:a :idx | 							(a = 0) & (break = false) ifTrue: [snapNum _ idx. break _ true]].											lastPoint _ (mainWindow position) + 							(snapPosList at: snapNum) + (15@0)]].			(mainWindow outputVideo bounds containsPoint: Sensor cursorPoint) ifTrue: [				snapPosList _ {(100@(mainWindow height - 233)). (130@(mainWindow height - 233)). (160@(mainWindow height - 233)). (70@(mainWindow height - 233)). nil}.				snapIndex _ 1.				break _ false.				mainWindow outputVideo snapSlots doWithIndex: [:a :idx | 					(a = 0) & (break = false) ifTrue: [snapIndex _ idx. break _ true]].									lastPoint _ (mainWindow position) + (snapPosList at: snapIndex) + (15@0)].			(mainWindow hub bounds containsPoint: Sensor cursorPoint)					ifTrue: [lastPoint _ (mainWindow hub right)@							(mainWindow hub center y - 5)]]		ifFalse: [			mainWindow portButtons buttons				do: [:i | (i bounds containsPoint: Sensor cursorPoint)					ifTrue: [lastPoint _ (i bounds center x - 2)@(i bounds top + 2)]]].	^ lastPoint! !!IACTWire methodsFor: 'wire positioning' stamp: 'dh 9/20/2003 20:35'!setInBetweenPoints: oldFirstPoint endPoint: oldLastPoint	"calculates the two center vertices of the wire as it is being created depending on the cursor posiiton and the other wires around it, makes sure no wires are overlapping""the position of the wire being created is calculated by first ordering all the wires on screen by the y value of their horizontal segment, finding the distances between every two adjacent y values, selecting the one with the greatest distance, and placing the new wire's horizontal segment vertically between the two y values associated with the biggest distance"	| firstPoint lastPoint secondPoint thirdPoint 		newVertices match wireList wireDistances biggestIndex biggestVal yVal wireVals myLeftPoint 		myRightPoint |	firstPoint _ oldFirstPoint.	lastPoint _ oldLastPoint.creatingWire ifTrue: [	"if the wire originated from the hub, make special middle points"	firstNodeObject = #hub 		ifTrue: [ 			secondPoint _ (lastPoint x)@(firstPoint y).			thirdPoint _ secondPoint.			newVertices _ { firstPoint. secondPoint. thirdPoint. lastPoint }.			self setVertices: newVertices.			^ self.].	"if the wire is currently snapped to a hub, make special middle points"	(mainWindow hub bounds containsPoint: Sensor cursorPoint)		ifTrue: [			secondPoint _ (firstPoint x)@(lastPoint y).			thirdPoint _ secondPoint.			newVertices _ { firstPoint. secondPoint. thirdPoint. lastPoint }.			self setVertices: newVertices.			^ self.].	"if the wire originated from an output video, make special middle points"	firstNodeObject = #outputVideo		ifTrue: [			secondPoint _ (firstPoint x)@(firstPoint y - 100).			thirdPoint _ (lastPoint x)@(firstPoint y - 100).			match _ true.			[match] whileTrue: [				match _ false.				1 to: mainWindow wires size - 1 do: [:i | 					secondPoint y  = ((mainWindow wires at: i) vertices at: 2) y						 ifTrue: [match _ true.							secondPoint _ (secondPoint x)@(secondPoint y + 10).							thirdPoint _ (thirdPoint x)@(thirdPoint y + 10)]]].			newVertices _ { firstPoint. secondPoint. thirdPoint. lastPoint }.			self setVertices: newVertices.			^ self.].	"if wire is snapped to an output video, set special middle points"	(mainWindow outputVideo bounds containsPoint: Sensor cursorPoint)		ifTrue: [			secondPoint _ (firstPoint x)@(lastPoint y - 100).			thirdPoint _ (lastPoint x)@(lastPoint y - 100).			match _ true.			[match] whileTrue: [				match _ false.				1 to: mainWindow wires size do: [:i | 					self = (mainWindow wires at: i) ifFalse: [					secondPoint y  = ((mainWindow wires at: i) vertices at: 2) y						 ifTrue: [match _ true.							secondPoint _ (secondPoint x)@(secondPoint y + 10).							thirdPoint _ (thirdPoint x)@(thirdPoint y + 10)]]]].			newVertices _ { firstPoint. secondPoint. thirdPoint. lastPoint }.			self setVertices: newVertices.			^ self.]].	"select out all the wires whose horizontal segment is vertically below the top endpoint of the wire I'm creating (the cursor position) and whose horizontal segment overlaps with my horizontal segment"	myLeftPoint _ firstPoint x min: lastPoint x.	myRightPoint _ firstPoint x max: lastPoint x.	wireList _ mainWindow wires select: [:i | ((i vertices at: 2) y > lastPoint y) &		(i ~= self) &		(((myLeftPoint <= i leftPointX) & (myRightPoint >= i rightPointX)) |		((myLeftPoint >= i leftPointX) & (myLeftPoint <= i rightPointX)) |		((myRightPoint <= i rightPointX) & (myRightPoint >= i leftPointX)))].	"create a new list of the vertical positions of the horizontal segment of the wires, then order it from highest to lowest"	wireVals _ OrderedCollection new.	wireVals add: firstPoint y.	wireList do: [:w | wireVals add: (w vertices at: 2) y].	wireVals add: lastPoint y.	wireVals _ wireVals asArray.	wireVals sort: [:a :b | a > b].	wireDistances _ OrderedCollection new.	"create a new list consisting of the distances between corresponding y values from the previous list"	wireVals doWithIndex: [:val :i | 		wireVals size = i ifFalse: [			wireDistances add: ((wireVals at: i) - (wireVals at: i + 1) abs)]].	"find the indexes of the two y values with the largest distance between them"	biggestIndex _ 0.	biggestVal _ 0.	wireDistances doWithIndex: 		[:d :index | d > biggestVal ifTrue: [biggestVal _ d. biggestIndex _ index]].	"make my horizontal segment fall exactly between those two y values (ie between the two wires with the largest distance between them"	yVal _ (lastPoint y + firstPoint y // 2).	biggestIndex = 0 		ifFalse: [			yVal _ ((wireVals at: biggestIndex) + (wireVals at: biggestIndex + 1)) // 2].	secondPoint _ (firstPoint x)@yVal.	thirdPoint _ (lastPoint x)@yVal.					"set the new vertices"	newVertices _ { firstPoint. secondPoint. thirdPoint. lastPoint }.	self setVertices: newVertices.	! !!IACTWire methodsFor: 'wire positioning' stamp: 'dh 9/11/2003 13:45'!setScriptButtonPos	"calculates and then places the script button object at the end of the wire"	| scriptButtonPosX scriptButtonPosY point |	point _ (self vertices at: 4).	scriptButtonPosX _ point x - (scriptButton width // 2) - 2.	scriptButtonPosY _ point y - 2.	scriptButton heading: 0.		creatingWire 	ifTrue: [		(mainWindow outputVideo containsPoint: Sensor cursorPoint) ifTrue: [			scriptButton heading: 180. 			scriptButtonPosY _ scriptButtonPosY - 20].		(mainWindow hub containsPoint: Sensor cursorPoint) ifTrue: [			scriptButton heading: -90.			scriptButtonPosX _ scriptButtonPosX + 10.			scriptButtonPosY _ scriptButtonPosY - 15]]	ifFalse: [			(secondNodeObject = #outputVideo) ifTrue: [			scriptButton heading: 180. 			scriptButtonPosY _ scriptButtonPosY - 20].		(secondNodeObject = #hub) ifTrue: [			scriptButton heading: -90.			scriptButtonPosX _ scriptButtonPosX + 10.			scriptButtonPosY _ scriptButtonPosY - 15]].	scriptButton position: scriptButtonPosX@scriptButtonPosY.! !!IACTWire class methodsFor: 'class initialization' stamp: 'jm 10/14/2003 11:23'!initialize	RandomGen _ Random new.! !A "Simple Button" in which the appearance is provided by a Form.!!IconicButton methodsFor: 'as yet unclassified' stamp: 'jm 12/8/2003 11:59'!hasLabel	"I do not have a text label."	^ false! !!IconicButton methodsFor: 'as yet unclassified' stamp: 'jm 10/19/2002 10:09'!initialize	super initialize.	self useSquareCorners.! !!IconicButton methodsFor: 'as yet unclassified' stamp: 'di 2/17/2000 20:30'!labelGraphic: aForm	| oldLabel graphicalMorph |	(oldLabel _ self findA: SketchMorph)		ifNotNil: [oldLabel delete].	graphicalMorph _ SketchMorph withForm: aForm.	self extent: graphicalMorph extent + (borderWidth + 6).	graphicalMorph position: self center - (graphicalMorph extent // 2).	self addMorph: graphicalMorph.	graphicalMorph lock! !!IconicButton methodsFor: 'as yet unclassified' stamp: 'jm 12/9/2003 17:48'!setDefaultLabel	self labelGraphic: ImageMorph defaultForm.! !!IdentityDictionary methodsFor: 'private' stamp: 'di 12/1/1999 20:54'!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key that is the external name for the argument, value. If 	there is none, answer the result of evaluating exceptionBlock." 	self associationsDo: 		[:association | value == association value ifTrue: [^ association key]].	^ exceptionBlock value! !I represent an image box that can transform the image that it contains. I can also play MPEG or JPEG movies.The panning offsets represents where I am in the image. A zero offset means that if you zoom in or out on an image, the centerpoint of zooming is the center of the image.!!ImageBoxMorph methodsFor: 'initialization' stamp: 'jm 12/10/2003 16:09'!initialize	super initialize.	color _ Color black.	fileName _ movieFile _ nil.	borderColor _ Color black.	borderWidth _ 2.	fade _ 1.0.	fadeColor _ Color black.	transparency _ 1.0.	panX _ panY _ 0.	zoom _ 1.0.	origForm _ (Form extent: 128@128 depth: 4) fillColor: Color lightGray.	outForm _ nil.  "will be initialized by call to extent:"	sound _ nil.	balance _ volume _ 0.5.	currentFrame _ 1.	msecsPerFrame _ 100.	moviePlaying _ false.	syncToSound _ true.	self extent: 200@150.! !!ImageBoxMorph methodsFor: 'accessing' stamp: 'jm 9/26/2003 08:47'!borderColor	^ borderColor! !!ImageBoxMorph methodsFor: 'accessing' stamp: 'jm 9/26/2003 08:47'!borderColor: aColor	borderColor _ aColor.	self changed.! !!ImageBoxMorph methodsFor: 'accessing' stamp: 'jm 7/7/2003 21:28'!colorCode	^ Color r: 0.32 g: 0.45 b: 0.91! !!ImageBoxMorph methodsFor: 'accessing' stamp: 'jm 10/14/2003 23:05'!currentFrame	movieFile ifNil: [^ 0].	^ currentFrame! !!ImageBoxMorph methodsFor: 'accessing' stamp: 'jm 12/15/2003 14:01'!currentFrame: frameIndex	| proportion |	(self movieFileIsOpen and: [movieFile hasVideo]) ifFalse: [^ self].	proportion _ ((frameIndex / self frameCount) max: 0.0) min: 1.0.	self jumpToSeconds: proportion * self totalSeconds.! !!ImageBoxMorph methodsFor: 'accessing' stamp: 'jm 9/25/2003 20:50'!fadeColor	^ fadeColor! !!ImageBoxMorph methodsFor: 'accessing' stamp: 'jm 9/27/2003 09:13'!fadeColor: aColor	fadeColor _ aColor.	self renderingChanged.! !!ImageBoxMorph methodsFor: 'accessing' stamp: 'jm 9/26/2003 08:56'!form	^ origForm! !!ImageBoxMorph methodsFor: 'accessing' stamp: 'jm 9/26/2003 10:54'!form: aForm	self closeMovieFile.	origForm _ aForm.	self updateOutForm.! !!ImageBoxMorph methodsFor: 'accessing' stamp: 'jm 12/18/2003 11:31'!isPlaying	^ moviePlaying! !!ImageBoxMorph methodsFor: 'accessing' stamp: 'jm 10/3/2003 11:27'!outForm	^ outForm! !!ImageBoxMorph methodsFor: 'accessing' stamp: 'jm 12/15/2003 15:04'!totalSeconds	movieFile ifNil: [^ 0].	self movieFileIsOpen ifFalse: [^ 0].	^ movieFile duration: 1! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 12/10/2003 16:06'!balance	^ balance! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 12/10/2003 16:07'!balance: aNumber	"Set my sound left-right balance, a number between 0.0 and 1.0."	balance _ (aNumber asFloat max: 0.0) min: 1.0.	sound ifNotNil: [sound setPan: balance volume: volume for: 1].! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 9/26/2003 08:47'!borderWidth	^ borderWidth! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 9/27/2003 11:04'!borderWidth: aNumber	| newW oldCenter |	newW _ aNumber rounded max: 0.	borderWidth = newW ifTrue: [^ self].	borderWidth _ newW.	oldCenter _ self center.	self extent: (outForm extent + (2 * borderWidth)).	self center: oldCenter.! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 12/18/2003 11:51'!currentSeconds	self movieFileIsOpen ifFalse: [^ 0].	sound ifNotNil: [^ sound soundPosition * sound duration].	^ movieFile currentSeconds: 0.! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 11/24/2003 12:21'!currentSeconds: seconds	"Currently, this doesn't do anything. It should jump to the given seconds offset."	self jumpToSeconds: seconds.! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 9/26/2003 08:58'!fade	^ fade! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 9/27/2003 09:13'!fade: aNumber	"Set the opacity of the fade color. Zero means no fade color, one means the fade color completely hides the image."	fade = aNumber ifTrue: [^ self].	fade _ (aNumber asFloat min: 1.0) max: 0.0.	self renderingChanged.! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 3/16/2003 21:23'!framesPerSecond	^ 1000.0 / msecsPerFrame! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 9/29/2003 16:00'!framesPerSecond: aNumber	syncToSound _ false.	aNumber < 0.1		ifTrue: [msecsPerFrame _ 10000]		ifFalse: [msecsPerFrame _ 1000.0 / aNumber].! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 9/26/2003 09:10'!panX	^ panX! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 9/27/2003 09:14'!panX: aNumber	"Set the left-right pan of my movie. Zero is centered."	panX = aNumber ifTrue: [^ self].	panX _ aNumber.	self renderingChanged.! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 9/26/2003 09:10'!panY	^ panY! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 9/27/2003 09:14'!panY: aNumber	"Set the up-down pan of my movie. Zero is centered."	panY = aNumber ifTrue: [^ self].	panY _ aNumber.	self renderingChanged.! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 3/18/2003 11:04'!transparency	"Answer my transparency, a number between 0.0 and 1.0."	^ transparency! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 9/26/2003 16:00'!transparency: aNumber	"Set my transparency, a number between 0.0 and 1.0."	transparency = aNumber ifTrue: [^ self].	transparency _ (aNumber asFloat max: 0.0) min: 1.0.	self changed.! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 9/26/2003 09:06'!volume	^ volume! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 12/10/2003 16:09'!volume: aNumber	"Set my sound left-right balance, a number between 0.0 and 1.0."	volume _ (aNumber asFloat max: 0.0) min: 1.0.	sound ifNotNil: [sound setPan: balance volume: volume for: 1].! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 9/26/2003 08:58'!zoom	^ zoom! !!ImageBoxMorph methodsFor: 'scratch vars' stamp: 'jm 9/27/2003 09:14'!zoom: aNumber	"Set my movie zoom. Values greater than one magnify or zoom in; values less than one shrink the movie within the frame. One is normal size."	zoom = aNumber ifTrue: [^ self].	zoom _ aNumber asFloat max: 0.01.	self renderingChanged.! !!ImageBoxMorph methodsFor: 'file ops' stamp: 'jm 12/10/2003 16:09'!basicLoadFile: relativeFilePath	"Load an image or movie from the file with the given name. If the movie has sound, this intializes the sound as well."	| fullName extension sndIcon |	fullName _ self projectDirectory relativeToFullPath: relativeFilePath.	(FileDirectory default fileExists: fullName)		ifFalse: [^ self inform: 'File not found: ', relativeFilePath].	self closeMovieFile.	extension _ (FileDirectory extensionFor: relativeFilePath) asLowercase.	((extension = 'jmv') and:	 [JPEGMovieFile isJPEGMovieFile: fullName]) ifTrue: [		movieFile _ JPEGMovieFile new openFileNamed: fullName.		movieFile hasAudio ifTrue: [			sound _ movieFile audioPlayerForChannel: 1]].	((#('mpg' 'mpeg' 'mp3') includes: extension) and:	 [MPEGFile isFileValidMPEG: fullName]) ifTrue: [		movieFile _ MPEGFile openFile: fullName.		movieFile hasAudio ifTrue: [			sound _ movieFile audioPlayerForChannel: 1]].	sound ifNotNil: [sound setPan: balance volume: volume for: 1].	movieFile ifNotNil: [		movieFile hasVideo			ifTrue: [				origForm _ Form					extent: (movieFile videoFrameWidth: 0)@(movieFile videoFrameHeight: 0)					depth: (Display depth max: 16).				]			ifFalse: [  "audio only"				msecsPerFrame _ 10000.				origForm _ (Form extent: 60@40 depth: 8) fillColor: Color gray.				(sndIcon _ SoundMorph scratchSoundForm) ifNotNil: [					sndIcon displayOn: origForm at: (origForm extent - sndIcon extent) // 2].				sound ifNil: ["no audio either!! close the file"					movieFile closeFile.					movieFile _ nil]].		fileName _ relativeFilePath.		^ self].	"if not a movie, try to open image file"	origForm _ Form fromFileNamed: fullName.	fileName _ relativeFilePath.! !!ImageBoxMorph methodsFor: 'file ops' stamp: 'jm 9/26/2003 10:53'!closeMovieFile	"first, try to open file as a movie"	self stopPlaying.	movieFile ifNotNil: [movieFile closeFile].	movieFile _ nil.	sound _ nil.! !!ImageBoxMorph methodsFor: 'file ops' stamp: 'jm 12/10/2003 16:09'!loadFile: relativeFilePath	"Load an image or movie from the file with the given name. If the movie has sound, this intializes the sound as well."	self basicLoadFile: relativeFilePath.	"reset fade, pan, zoom, and sound"	fade _ 1.0.	panX _ panY _ 0.	zoom _ 1.0.	balance _ volume _ 0.5.	syncToSound _ true.	"set extent to movie extent"	self extent: origForm extent + (2 * borderWidth).	"set frame rate"	movieFile ifNotNil: [		movieFile hasVideo			ifTrue: [msecsPerFrame _ 1000.0 / (movieFile videoFrameRate: 0)]			ifFalse: [msecsPerFrame _ 1000]].  "audio only"	self showFrame: 1.! !!ImageBoxMorph methodsFor: 'file ops' stamp: 'jm 12/15/2003 14:37'!openAfterLoad	"Attempt to re-open my file. Do nothing if the file is not found."	| fullName |	fullName _ self projectDirectory relativeToFullPath: fileName.	(FileDirectory default fileExists: fullName) ifFalse: [^ self].	[self basicLoadFile: fileName] ifError: [^ self].	self extent: self extent.  "create output form"	self currentFrame: currentFrame.	self updateOutForm.  "update output form for still images"! !!ImageBoxMorph methodsFor: 'file ops' stamp: 'jm 9/26/2003 09:26'!saveFile: fName	"Save an image to the file with the given name."	outForm ifNil: [^ self inform: 'No image loaded'].	outForm writeBMPfileNamed: fName.! !!ImageBoxMorph methodsFor: 'movie ops' stamp: 'jm 12/15/2003 15:44'!forwardFrames: aNumber	"Go forward the given number of frames. Go backward if the argument is negative. Wrap at the ends."	| newFrame |	newFrame _ currentFrame + aNumber.	(newFrame < 1 or: [newFrame > self frameCount]) ifTrue: [		newFrame _ ((newFrame - 1) \\ self frameCount) + 1].	self currentFrame: newFrame.! !!ImageBoxMorph methodsFor: 'movie ops' stamp: 'jm 9/29/2003 15:37'!frameCount	movieFile ifNil: [^ 1].	(self movieFileIsOpen and: [movieFile hasVideo])		ifTrue: [^ movieFile videoFrames: 0]		ifFalse: [^ 1].! !!ImageBoxMorph methodsFor: 'movie ops' stamp: 'jm 12/15/2003 14:06'!jumpToSeconds: secs	| fraction totalFrames totalSecs |	sound ifNotNil: [		fraction _ ((secs asFloat / sound duration) max: 0.0) min: 1.0.		sound soundPosition: secs asFloat / sound duration].	(movieFile notNil and: [movieFile hasVideo]) ifTrue: [		totalFrames _ movieFile videoFrames: 0.		fraction ifNil: [			totalSecs _ totalFrames asFloat / (movieFile videoFrameRate: 0).			totalSecs > 0				ifTrue: [fraction _ secs / totalSecs]				ifFalse: [fraction _ 0]].		self showFrame: fraction * totalFrames].	lastFrameMSecs _ Time millisecondClockValue.! !!ImageBoxMorph methodsFor: 'movie ops' stamp: 'jm 9/29/2003 18:08'!showFrame: frameIndex	"Go to the given frame.  updates only video, not sound."	self movieFileIsOpen ifFalse: [^ self].	movieFile hasVideo ifFalse: [^ self].	currentFrame _ frameIndex rounded max: 1.	movieFile videoSetFrame: currentFrame stream: 0.	movieFile videoReadFrameInto: origForm stream: 0.	self updateOutForm.! !!ImageBoxMorph methodsFor: 'movie ops' stamp: 'jm 12/15/2003 15:55'!startPlaying	| frameIndex |	self stopPlaying.	movieFile = nil ifTrue: [^ self].	movieFile hasAudio ifTrue: [		movieFile hasVideo ifTrue: [			currentFrame >= (self frameCount - 3) ifTrue: [  "start over if very close to end"				currentFrame _ 1].			sound reset.			sound soundPosition: currentFrame / self frameCount.			frameIndex _ sound millisecondsSinceStart // msecsPerFrame.			"MPEGFile plugin can crash on seeks to last few frames, so limit max frameIndex:"			frameIndex _ (frameIndex max: 1) min: ((movieFile videoFrames: 0) - 3). 			movieFile videoSetFrame: frameIndex - 1 stream: 0.			self showFrame: frameIndex].			SoundPlayer stopReverb.			sound setPan: balance volume: volume for: 1.			sound resumePlaying]		ifFalse: [			movieFile hasVideo ifTrue: [				frameIndex _ (currentFrame max: 0) min: ((movieFile videoFrames: 0) - 3). 				movieFile videoSetFrame: frameIndex stream: 0].			sound _ nil].	lastFrameMSecs _ Time millisecondClockValue.	moviePlaying _ true.! !!ImageBoxMorph methodsFor: 'movie ops' stamp: 'jm 8/12/2003 15:18'!stopPlaying	sound ifNotNil: [sound pause].	moviePlaying _ false.! !!ImageBoxMorph methodsFor: 'movie ops' stamp: 'jm 9/29/2003 21:06'!syncToSound	"Reset my frame rate and start synchronizing to the sound track."	syncToSound _ true.	(movieFile notNil and: [movieFile hasVideo]) ifTrue: [		msecsPerFrame _ 1000.0 / (movieFile videoFrameRate: 0)].! !!ImageBoxMorph methodsFor: 'drawing' stamp: 'jm 9/27/2003 11:03'!areasRemainingToFill: aRectangle	"Drawing optimization. Since I completely fill my bounds with opaque pixels, this method tells Morphic that it isn't necessary to draw any morphs covered by me."		^ aRectangle areasOutside: self bounds! !!ImageBoxMorph methodsFor: 'drawing' stamp: 'jm 10/1/2003 09:10'!drawBorderOn: aCanvas	| borderC |	(borderWidth < 1 or: [transparency <= 0]) ifTrue: [^ self].	transparency < 1.0		ifTrue: [borderC _ borderColor alpha: transparency]		ifFalse: [borderC _ borderColor].	aCanvas frameAndFillRectangle: bounds		fillColor: Color transparent		borderWidth: borderWidth		borderColor: borderC.! !!ImageBoxMorph methodsFor: 'drawing' stamp: 'jm 10/1/2003 09:14'!drawOn: aCanvas	| p alpha |	self drawBorderOn: aCanvas.	outForm ifNil: [^ self].	p _ bounds center - (outForm extent // 2).	transparency < 1.0		ifTrue: [			transparency > 0.0 ifTrue: [				alpha _ (255.0 * transparency) truncated.				aCanvas paintImage: outForm at: p sourceRect: outForm boundingBox alpha: alpha]]		ifFalse: [			aCanvas paintImage: outForm at: p].! !!ImageBoxMorph methodsFor: 'drawing' stamp: 'jm 9/26/2003 10:12'!extent: aPoint	"Set the size of outForm to match my extent."	| e |	super extent: aPoint.	e _ (bounds extent - (2 * borderWidth)) rounded max: 0@0.	(outForm notNil and: [outForm extent = e]) ifFalse: [		outForm _ Form extent: e depth: 16.		self updateOutForm.		self changed].! !!ImageBoxMorph methodsFor: 'drawing' stamp: 'jm 9/26/2003 11:09'!hasTranslucentColor	"Answer true if this any of this morph is translucent but not transparent."	transparency < 1.0 ifTrue: [^ true].	(borderColor isColor and: [borderColor isTranslucentColor]) ifTrue: [^ true].	^ false! !!ImageBoxMorph methodsFor: 'stepping' stamp: 'jm 9/29/2003 16:28'!step	"If I have a movie file and it is playing, advance to the next frame if it is time."	| now deltaT newFrame |	moviePlaying ifFalse: [^ self].	self movieFileIsOpen ifFalse: [		moviePlaying _ false.		^ self].	movieFile hasVideo ifFalse: [^ self].  "no video"	(syncToSound and: [sound notNil]) ifTrue: [		^ self advanceFrameWithSound].  "sync frame rate to sound"	now _ Time millisecondClockValue.	deltaT _ now - lastFrameMSecs.	(deltaT < 0 or: [deltaT >= msecsPerFrame]) ifTrue: [		newFrame _ currentFrame + (deltaT // msecsPerFrame).		newFrame > self frameCount ifTrue: [newFrame _ 1].		self showFrame: newFrame.		lastFrameMSecs _ now].! !!ImageBoxMorph methodsFor: 'stepping' stamp: 'jm 3/16/2003 16:48'!stepTime	^ 0! !!ImageBoxMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 17:09'!fieldsVersion	^ 1! !!ImageBoxMorph methodsFor: 'object i/o' stamp: 'jm 12/10/2003 16:05'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		fileName		borderColor		borderWidth		fade		fadeColor		transparency		panX		panY		zoom		balance		volume		currentFrame		msecsPerFrame		syncToSound	) from: anObjStream.! !!ImageBoxMorph methodsFor: 'object i/o' stamp: 'jm 12/10/2003 16:05'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		fileName		borderColor		borderWidth		fade		fadeColor		transparency		panX		panY		zoom		balance		volume		currentFrame		msecsPerFrame		syncToSound	) on: anObjStream.! !!ImageBoxMorph methodsFor: 'private' stamp: 'jm 12/15/2003 15:40'!advanceFrameWithSound	"Used in the step method when a movie that has sound is playing."	| msecs desiredFrame framesToAdvance currFrame |	sound isPlaying ifFalse: [		moviePlaying _ false.		^ self].	msecs _ sound millisecondsSinceStart - SoundPlayer bufferMSecs.	desiredFrame _ (msecs // msecsPerFrame) + 1.	desiredFrame _ desiredFrame min: (movieFile videoFrames: 0).	currFrame _ movieFile videoGetFrame: 0.	framesToAdvance _ desiredFrame - currFrame.	framesToAdvance <= 0 ifTrue: [^ self].	self showFrame: desiredFrame.! !!ImageBoxMorph methodsFor: 'private' stamp: 'jm 7/4/2003 10:49'!imageForm: depth forRectangle: rect	| saved f |	saved _ transparency.	transparency _ 1.0.	f _ super imageForm: depth forRectangle: rect.	transparency _ saved.	^ f! !!ImageBoxMorph methodsFor: 'private' stamp: 'jm 9/29/2003 16:29'!movieFileIsOpen	"Answer true if I have an open movie file. If movie is not nil but is not currently open, try to reopen it."	movieFile ifNil: [^ false].	movieFile fileHandle ifNil: [		"try to reopen the file:"		movieFile _ nil.		self basicLoadFile: fileName].	^ movieFile notNil! !!ImageBoxMorph methodsFor: 'private' stamp: 'jm 12/5/2003 18:51'!readFromFile	"Read my form from an image file."	| result fullName |	result _ StandardFileMenu oldFileExtensions: #(jmv mpg mpeg mp3).	result ifNil: [^ self].	fullName _ result directory pathName, FileDirectory slash, result name.	self loadFile: (self asPathRelativeToProject: fullName).! !!ImageBoxMorph methodsFor: 'private' stamp: 'jm 9/27/2003 09:13'!renderingChanged	"Update my output form after changing a rendering parameter. If the movie is playing at a fairly high frame rate, do nothing because the next frame will be displayed shortly."	(moviePlaying and: [msecsPerFrame < 100]) ifTrue: [^ self].  "next frame will be drawn soon"	self updateOutForm.! !!ImageBoxMorph methodsFor: 'private' stamp: 'jm 9/27/2003 09:04'!updateOutForm	"Update my output form."	| srcRect |	((zoom = 1.0) & (panX = 0) & (panY = 0) and:	 [outForm extent = origForm extent])		ifTrue: [  "optimization: no scaling"			origForm displayOn: outForm]		ifFalse: [  "scaling needed"			srcRect _ Rectangle				center: (origForm boundingBox center + (panX@panY negated))				extent: (origForm extent / zoom asFloat).			(WarpBlt toForm: outForm)				sourceForm: origForm;				colorMap: (origForm colormapIfNeededForDepth: outForm depth);				cellSize: 1;  "installs a colormap"				combinationRule: Form over;				copyQuad: srcRect innerCorners toRect: outForm boundingBox].	fade < 1.0 ifTrue: [  "handle fade"		(BitBlt toForm: outForm)			destRect: outForm boundingBox;			fillColor: fadeColor;			combinationRule: 30;			copyBitsTranslucent: (255.0 * (1.0 - fade)) truncated]. 			self changed.! !!ImageBoxMorph class methodsFor: 'scratch' stamp: 'jm 12/15/2003 14:05'!classBlockSpecs	^ #(		'movie'			('play'						-	startPlaying)			('pause'						-	stopPlaying)			('jump to %n secs'			-	jumpToSeconds:)			('forward %n frames'		-	forwardFrames:)			('frameCount'				r	frameCount)			('total secs'					r	totalSeconds)			('sync to sound'				-	syncToSound)			('border color %c'			-	borderColor:)			('fade color %c'				-	fadeColor:)	).! !!ImageBoxMorph class methodsFor: 'scratch' stamp: 'jm 12/15/2003 14:08'!varSpecs	^ #((x 0 1000)		(y 0 1000)		(layer 1 100)		(width 0 500)		(height 0 500)		(transparency 0 1)		(borderWidth 0 100)		(panX -200 200)		(panY -200 200)		(zoom 0.1 10)		(fade 0 1)		(currentSeconds 0 100)		(volume 0 1)		(balance 0 1))! !I am draw a rectangular frame using Forms. I have Forms for my four corners Forms that are used to tile my edges so that I can be resized. It's okay for any of these forms to be missing.!!ImageFrameMorph methodsFor: 'intialization' stamp: 'ee 7/1/2003 15:59'!cornerForms: formList	"Set the forms used for my corners."	topLeftForm _ formList at: 1.	topRightForm _ formList at: 2.	bottomLeftForm _ formList at: 3.	bottomRightForm _ formList at: 4.! !!ImageFrameMorph methodsFor: 'intialization' stamp: 'jm 6/26/2003 21:22'!edgeTileForms: formList	"Set the forms used to tile my edges." 	topEdgeForm _ formList at: 1.	leftEdgeForm _ formList at: 2.	rightEdgeForm _ formList at: 3.	bottomEdgeForm _ formList at: 4.! !!ImageFrameMorph methodsFor: 'intialization' stamp: 'ee 6/30/2003 15:18'!initialize	super initialize.	self extent: 900@500.! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'jm 12/2/2003 19:51'!drawBottomEdgeOn: aCanvas	"Draw my bottom edge."	| clipC w y |	clipC _ aCanvas copyClipRect: (self topLeft extent: (self width - bottomRightForm width) @ 10000).	w _ bottomEdgeForm width.	y _ self bottom - bottomEdgeForm height.	(self left + bottomLeftForm width)		to: (self right - bottomRightForm width)		by: w		do: [:x | clipC paintImage: bottomEdgeForm at: x@y].! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'jm 12/2/2003 19:50'!drawLeftEdgeOn: aCanvas	"Draw my left edge."	| clipC h x |	clipC _ aCanvas copyClipRect: (self topLeft extent: (10000 @ self height - bottomLeftForm height)).	h _ leftEdgeForm height.	x _ self left.	(self top + topLeftForm height)		to: (self bottom - bottomLeftForm height)		by: h		do: [:y | clipC paintImage: leftEdgeForm at: x@y].! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'jm 12/2/2003 20:21'!drawOn: aCanvas	"Draw my edges and corners. Draw a simple border if any of my forms is nil."	| clipC |	(topLeftForm isNil | topRightForm isNil | bottomLeftForm isNil | bottomRightForm isNil |	 topEdgeForm isNil | leftEdgeForm isNil | rightEdgeForm isNil | bottomEdgeForm isNil)		ifTrue: [^ aCanvas frameRectangle: self bounds width: 3 color: Color red].	"draw edges"	self drawTopEdgeOn: aCanvas.	self drawLeftEdgeOn: aCanvas.	self drawRightEdgeOn: aCanvas.	self drawBottomEdgeOn: aCanvas.	"draw corners"	clipC _ aCanvas copyClipRect: self bounds.	clipC paintImage: topLeftForm at: self topLeft.	clipC paintImage: topRightForm at: self topRight - (topRightForm width@0).	clipC paintImage: bottomLeftForm at: self bottomLeft - (0@bottomLeftForm height).	clipC paintImage: bottomRightForm at: self bottomRight - bottomRightForm extent.! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'jm 12/2/2003 19:52'!drawRightEdgeOn: aCanvas	"Draw my right edge."	| clipC h x |	clipC _ aCanvas copyClipRect: (self topLeft extent: (10000 @ self height - bottomRightForm height)).	h _ rightEdgeForm height.	x _ self right - rightEdgeForm width.	(self top + topRightForm height)		to: (self bottom - bottomRightForm height)		by: h		do: [:y | clipC paintImage: rightEdgeForm at: x@y].! !!ImageFrameMorph methodsFor: 'drawing' stamp: 'jm 12/2/2003 19:51'!drawTopEdgeOn: aCanvas	"Draw my top edge."	| clipC w y |	clipC _ aCanvas copyClipRect: (self topLeft extent: (self width - topRightForm width) @ 10000).	w _ topEdgeForm width.	y _ self top.	(self left + topLeftForm width)		to: (self right - topRightForm width)		by: w		do: [:x | clipC paintImage: topEdgeForm at: x@y].! !!ImageFrameMorph class methodsFor: 'instance creation' stamp: 'jm 7/20/2003 22:31'!withFormsFrom: aDirectory	"Answer an image of me using the forms from the given directory."	"ImageFrameMorph withFormsFrom: (FileDirectory default directoryNamed: 'ScratchSkin')" 	| corners edges |	corners _ Array		with: (Utilities form: 'topLeft' from: aDirectory)		with: (Utilities form: 'topRight' from: aDirectory)		with: (Utilities form: 'bottomLeft' from: aDirectory)		with: (Utilities form: 'bottomRight' from: aDirectory).	edges _ Array		with: (Utilities form: 'topEdge' from: aDirectory)		with: (Utilities form: 'leftEdge' from: aDirectory)		with: (Utilities form: 'rightEdge' from: aDirectory)		with: (Utilities form: 'bottomEdge' from: aDirectory).	^ self new cornerForms: corners; edgeTileForms: edges.! !I am used to display a simple image with no rotation or scaling. I'm often used to create icons, halo handles, or simple buttons.  form -- a Form or ColorForm; the image that I draw  transparency -- a number (usually a Float) between 0.0 to 1.0!!ImageMorph methodsFor: 'initialization' stamp: 'jm 6/30/2003 18:00'!initialize	super initialize.	self form: DefaultForm.	transparency _ 1.0.! !!ImageMorph methodsFor: 'accessing' stamp: 'jm 11/13/2002 10:59'!color: aColor	"If my Form is one bit deep, change its non-transparent pixels to the given color. The color must be a solid color, not a stipple."	(form depth = 1 and: [aColor isColor]) ifTrue: [		color _ aColor.		form colors: (Array with: Color transparent with: aColor).		self changed].! !!ImageMorph methodsFor: 'accessing' stamp: 'jm 11/13/2002 11:00'!form	^ form! !!ImageMorph methodsFor: 'accessing' stamp: 'jm 11/13/2002 11:00'!form: aForm	"Set my image to the given Form. If it is a 1-bit Form, treat white pixels as transparent."	self changed.	aForm depth = 1		ifTrue: [form _ ColorForm mappingWhiteToTransparentFrom: aForm]		ifFalse: [form _ aForm].	super extent: form extent.! !!ImageMorph methodsFor: 'accessing' stamp: 'jm 6/30/2003 18:02'!transparency	^ transparency! !!ImageMorph methodsFor: 'accessing' stamp: 'jm 6/30/2003 18:04'!transparency: aNumber	transparency _ aNumber.	self changed.! !!ImageMorph methodsFor: 'other' stamp: 'jm 6/30/2003 18:00'!drawOn: aCanvas	"Draw my image. If transparency is between 0.0 and 1.0, display with alpha blending. If transparency is 0.0, don't draw at all."	| alpha |	transparency ifNil: [transparency _ 1.0].  "backward compatability"	transparency < 1.0 ifTrue: [		transparency > 0.0 ifTrue: [			alpha _ (255.0 * transparency) truncated.			aCanvas paintImage: form at: bounds origin sourceRect: form boundingBox alpha: alpha].		^ self].	aCanvas paintImage: form at: bounds origin.! !!ImageMorph methodsFor: 'other' stamp: 'jm 11/13/2002 10:59'!releaseCachedState	super releaseCachedState.	form hibernate.! !!ImageMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:00'!includeInNewMorphMenu	^ true! !!ImageMorph class methodsFor: 'class initialization' stamp: 'jm 12/9/2003 17:48'!defaultForm	^ DefaultForm! !!ImageMorph class methodsFor: 'class initialization' stamp: 'jm 12/9/2003 17:47'!initialize	"ImageMorph initialize"	"DefaultForm display"	| h p d |	DefaultForm _ (Form extent: 60@40 depth: 16).	h _ DefaultForm height // 2.	0 to: h - 1 do: [:i |		p _ (i * 2)@i.		d _ i asFloat / h asFloat.		DefaultForm fill:			(p corner: DefaultForm extent - p)			fillColor: (Color r: 0.9 g: d b: 0.0)].! !!ImageMorph class methodsFor: 'form creation' stamp: 'jm 12/17/2003 13:56'!bezelDiameter: d width: w baseColor: baseColor inset: insetFlag	"Answer a Form for a circular bezel with the given diameter and border width. Assume the light source is the top-left corner."	| hue sat bri baseTheta f blt rOuter rInner center vector r angle newBri newSat |	hue _ baseColor hue.	sat _ baseColor saturation.	bri _ baseColor brightness.	baseTheta _ (-1@-1) theta.  "light comes from top-left"	insetFlag ifTrue: [baseTheta _ baseTheta + Float pi].	f _ Form extent: d@d depth: 16.	blt _ BitBlt bitPokerToForm: f.	rOuter _ d / 2.0.	rInner _ rOuter - w.	center _ rOuter truncated asPoint.	0 to: d - 1 do: [:y |		0 to: d - 1 do: [:x |			vector _ (x@y) - center.			r _ vector r.			(r < rOuter and: [r >= rInner]) ifTrue: [				angle _ vector theta - baseTheta.				newBri _ ((bri + (angle cos / 4.0)) max: 0.0) min: 1.0.				newSat _ sat - (angle cos / 6.0) abs.				blt pixelAt: x@y put: ((Color h: hue s: newSat v: newBri) pixelValueForDepth: f depth)]]].	^ f! !!ImageMorph class methodsFor: 'form creation' stamp: 'jm 12/17/2003 13:57'!glowDiameter: d color: glowColor on: onFlag	"Answer a form containing a circular gradiant of the given diameter and color with the brightest point in the center (like an indicator light or LED). If onFlag is true, it is bright (on), otherwise it is dark (off)."	| hue sat baseBri divider f blt radius center r c |	hue _ glowColor hue.	sat _ glowColor saturation.	baseBri _ onFlag ifTrue: [1.0] ifFalse: [0.5].	divider _ onFlag ifTrue: [1.5] ifFalse: [3.0].	f _ Form extent: d@d depth: 32.	blt _ BitBlt bitPokerToForm: f.	radius _ d / 2.0.	center _ radius truncated asPoint.	0 to: d - 1 do: [:y |		0 to: d - 1 do: [:x |			r _ ((x@y) - center) r.			r < radius ifTrue: [				c _ Color h: hue s: sat v: baseBri - (r / (divider * radius)).				blt pixelAt: x@y put: (c pixelValueForDepth: f depth)]]].	^ f! !!ImageMorph class methodsFor: 'form creation' stamp: 'jm 12/17/2003 14:03'!indicatorDiameter: d borderWidth: w borderColor: bColor isInset: insetFlag onColor: onColor isOn: onFlag	"Answer a form for an indicator light with a bezel around it. Examples:	(ImageMorph indicatorDiameter: 15 borderWidth: 2 borderColor: Color gray		isInset: true onColor: Color red isOn: true) display.	(ImageMorph indicatorDiameter: 15 borderWidth: 2 borderColor: Color gray		isInset: true onColor: Color red isOn: false) display."	| f |	f _ self bezelDiameter: d width: w baseColor: bColor inset: insetFlag.	(self glowDiameter: (d - (2 * w)) color: onColor on: onFlag)		displayOn: f at: w@w rule: Form paint.	^ f! !Copyright (c) Kazuki Yasumatsu, 1995. All rights reserved.I am an abstract class to provide for encoding and/or decoding an image on a stream.Instance Variables:	stream		<ReadStream | WriteStream>	stream for image storageSubclasses must implement the following messages:	nextImage	nextPutImage:Subclasses typically also implement:	understandsImageFormat!!ImageReadWriter methodsFor: 'accessing'!nextImage	"Dencoding an image on stream and answer the image."	^self subclassResponsibility! !!ImageReadWriter methodsFor: 'accessing'!nextPutImage: anImage	"Encoding anImage on stream."	^self subclassResponsibility! !!ImageReadWriter methodsFor: 'stream access'!atEnd	^stream atEnd! !!ImageReadWriter methodsFor: 'stream access'!close	"close if you can"	(stream respondsTo: #close) ifTrue: [			stream closed ifFalse: [stream close]]! !!ImageReadWriter methodsFor: 'stream access'!contents	^stream contents! !!ImageReadWriter methodsFor: 'stream access'!cr	^stream nextPut: Character cr asInteger! !!ImageReadWriter methodsFor: 'stream access'!lf	"PPM and PBM are used LF as CR."	^stream nextPut: Character lf asInteger! !!ImageReadWriter methodsFor: 'stream access'!next	^stream next! !!ImageReadWriter methodsFor: 'stream access'!next: size	^stream next: size! !!ImageReadWriter methodsFor: 'stream access'!nextLong	"Read a 32-bit quantity from the input stream."	^(stream next bitShift: 24) + (stream next bitShift: 16) +		(stream next bitShift: 8) + stream next! !!ImageReadWriter methodsFor: 'stream access'!nextPut: aByte	^stream nextPut: aByte! !!ImageReadWriter methodsFor: 'stream access'!nextPutAll: aByteArray	^stream nextPutAll: aByteArray! !!ImageReadWriter methodsFor: 'stream access'!nextWord	"Read a 16-bit quantity from the input stream."	^(stream next bitShift: 8) + stream next! !!ImageReadWriter methodsFor: 'stream access'!nextWordPut: a16BitW	"Write out a 16-bit integer as 16 bits."	stream nextPut: ((a16BitW bitShift: -8) bitAnd: 16rFF).	stream nextPut: (a16BitW bitAnd: 16rFF).	^a16BitW! !!ImageReadWriter methodsFor: 'stream access' stamp: 'tao 10/23/97 18:00'!peekFor: aValue	^stream peekFor: aValue! !!ImageReadWriter methodsFor: 'stream access'!position	^stream position! !!ImageReadWriter methodsFor: 'stream access'!position: anInteger	^stream position: anInteger! !!ImageReadWriter methodsFor: 'stream access'!size	^stream size! !!ImageReadWriter methodsFor: 'stream access'!skip: anInteger	^stream skip: anInteger! !!ImageReadWriter methodsFor: 'stream access'!space	^stream nextPut: Character space asInteger! !!ImageReadWriter methodsFor: 'stream access'!tab	^stream nextPut: Character tab asInteger! !!ImageReadWriter methodsFor: 'private' stamp: 'di 9/15/1998 11:42'!on: aStream	(stream _ aStream) reset.	(stream respondsTo: #binary) ifTrue: [stream binary].	"Note that 'reset' makes a file be text.  Must do this after."! !!ImageReadWriter methodsFor: 'testing' stamp: 'tao 10/27/97 09:26'!understandsImageFormat	"Test to see if the image stream format is understood by this decoder.	This should be implemented in each subclass of ImageReadWriter so that	a proper decoder can be selected without ImageReadWriter having to know	about all possible image file types."	^ false! !!ImageReadWriter class methodsFor: 'instance creation'!on: aStream	"Answer an instance of the receiver for encoding and/or decoding images on the given."	^ self new on: aStream! !!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'ls 9/15/1998 19:10'!formFromStream: aBinaryStream	"Answer a ColorForm stored on the given stream.  closes the stream"	| reader readerClass form  |	readerClass _ self withAllSubclasses		detect: [:subclass | aBinaryStream reset. (subclass new on: aBinaryStream) understandsImageFormat]		ifNone: [			(aBinaryStream respondsTo: #close) ifTrue: [ aBinaryStream close ].			^self error: 'image format not recognized'].	reader _ readerClass new on: aBinaryStream reset.	Cursor read showWhile: [		form _ reader nextImage.		reader close].	^ form! !!ImageReadWriter class methodsFor: 'image reading/writing'!putForm: aForm onFileNamed: fileName	"Store the given form on a file of the given name."	| writer |	writer _ self on: (FileStream newFileNamed: fileName) binary.	Cursor write showWhile: [writer nextPutImage: aForm].	writer close.! !I represent a Form obtained by replicating a pattern form indefinitely in all directions.!!InfiniteForm methodsFor: 'displaying' stamp: 'jm 5/29/2003 18:01'!displayOn: aDisplayMedium at: aDisplayPoint clippingBox: clipRectangle rule: ruleInteger fillColor: aForm	"This is the real display message, but it doesn't get used until the new	display protocol is installed."	| targetBox patternBox bb |	(patternForm isKindOf: Form) ifFalse:		[^ aDisplayMedium fill: clipRectangle rule: ruleInteger fillColor: patternForm].	"Do it iteratively"	targetBox _ aDisplayMedium boundingBox intersect: clipRectangle.	patternBox _ patternForm boundingBox.	bb _ BitBlt destForm: aDisplayMedium sourceForm: patternForm fillColor: aForm		combinationRule: ruleInteger destOrigin: 0@0 sourceOrigin: 0@0		extent: patternBox extent clipRect: clipRectangle.	bb colorMap:		(patternForm colormapIfNeededForDepth: aDisplayMedium depth).	(targetBox left truncateTo: patternBox width)		to: targetBox right - 1 by: patternBox width do:		[:x |		(targetBox top truncateTo: patternBox height)			to: targetBox bottom - 1 by: patternBox height do:			[:y |			bb destOrigin: x@y; copyBits]]! !!InfiniteForm methodsFor: 'displaying' stamp: 'jm 5/12/2003 19:58'!displayUsingBitBlt: aBitBlt at: offset	| targetBox patternBox savedMap top left |	(patternForm isKindOf: Form) ifFalse: [		"patternForm is a Pattern or Color; just use it as a mask for BitBlt"		^ aBitBlt fill: aBitBlt clipRect fillColor: patternForm rule: Form over].	"do it iteratively"	targetBox _ aBitBlt clipRect.	patternBox _ patternForm boundingBox.	savedMap _ aBitBlt colorMap.	aBitBlt		sourceForm: patternForm;		fillColor: nil;		combinationRule: Form over;		sourceRect: (0@0 extent: patternBox extent);		colorMap: (patternForm colormapIfNeededForDepth: aBitBlt destForm depth).	top _ (targetBox top truncateTo: patternBox height) - (offset y \\ patternBox height).	left _  (targetBox left truncateTo: patternBox width) - (offset x \\ patternBox width).	left to: (targetBox right - 1) by: patternBox width do: [:x |		top to: (targetBox bottom - 1) by: patternBox height do: [:y |			aBitBlt				destOrigin: x@y;				copyBits]].	aBitBlt colorMap: savedMap.! !!InfiniteForm methodsFor: 'display box access' stamp: 'jm 6/15/2003 18:20'!computeBoundingBox 	"Refer to the comment in DisplayObject|computeBoundingBox."	^ 0@0 corner: SmallInteger maxVal @ SmallInteger maxVal! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'bolot 9/15/1999 10:13'!bitPatternForDepth: suspectedDepth	^ patternForm! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'ar 7/2/1999 14:56'!direction	^patternForm width @ 0! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'ar 7/2/1999 14:54'!form	"Bitmap fills respond to #form"	^patternForm! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'ar 9/2/1999 14:32'!isTranslucent	"Return true since the bitmap may be translucent and we don't really want to check"	^true! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'ar 7/2/1999 14:57'!normal	^0 @ patternForm height! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'ar 7/2/1999 14:56'!origin	^0@0! !!InfiniteForm methodsFor: 'fillstyle protocol' stamp: 'ar 7/2/1999 14:56'!origin: aPoint	"Ignored"! !This class implements the Inflate decompression algorithm as defined by RFC1951 and used in PKZip, GZip and ZLib (and many, many more). It is a variant of the LZ77 compression algorithm described in[LZ77] Ziv J., Lempel A., "A Universal Algorithm for Sequential Data Compression", IEEE Transactions on Information Theory", Vol. 23, No. 3, pp. 337-343.[RFC1951] Deutsch. P, "DEFLATE Compressed Data Format Specification version 1.3"For more information see the above mentioned RFC 1951 which can for instance be found at	http://www.leo.org/pub/comp/doc/standards/rfc/index.htmlHuffman Tree Implementation Notes:===========================================The huffman tree used for decoding literal, distance and length codes in the inflate algorithm has been encoded in a single Array. The tree is made up of subsequent tables storing all entries at the current bit depth. Each entry in the table (e.g., a 32bit Integer value) is either a leaf or a non-leaf node. Leaf nodes store the immediate value in its low 16 bits whereas non-leaf nodes store the offset of the subtable in its low 16bits. The high 8 bits of non-leaf nodes contain the number of additional bits needed for the sub table (the high 8 bits of leaf-nodes are always zero). The first entry in each table is always a non-leaf node indicating how many bits we need to fetch initially. We can thus travel down the tree as follows (written in sort-of-pseudocode the actual implementation can be seen in InflateStream>>decodeValueFrom:):	table _ initialTable.	bitsNeeded _ high 8 bits of (table at: 1).		"Determine initial bits"	table _ initialTable + (low 16 bits of (table at: 1)). "Determine start of first real table"	[bits _ fetch next bitsNeeded bits.			"Grab the bits"	value _ table at: bits.						"Lookup the value"	value has high 8 bit set] whileTrue:[		"Check if it's leaf"		table _ initialTable + (low 16 bits of value).	"No - compute new sub table start"		bitsNeeded _ high 8 bit of value].		"Compute additional number of bits needed"	^value!!InflateStream methodsFor: 'initialize' stamp: 'jm 6/6/2003 07:39'!on: aCollectionOrStream	(aCollectionOrStream isKindOf: Stream) 		ifTrue: [			sourceStream _ aCollectionOrStream.			self getFirstBuffer]		ifFalse: [		source _ aCollectionOrStream].	^ self on: source from: 1 to: source size! !!InflateStream methodsFor: 'initialize' stamp: 'ar 12/23/1999 15:35'!on: aCollection from: firstIndex to: lastIndex	bitBuf _ bitPos _ 0.	"The decompression buffer has a size of at 64k,	since we may have distances up to 32k back and	repetitions of at most 32k length forward"	collection _ aCollection species new: 1 << 16.	readLimit _ 0. "Not yet initialized"	position _ 0.	source _ aCollection.	sourceLimit _ lastIndex.	sourcePos _ firstIndex-1.	state _ StateNewBlock.! !!InflateStream methodsFor: 'initialize' stamp: 'ar 12/3/1998 16:32'!reset	"Position zero - nothing decoded yet"	position _ readLimit _ 0.	sourcePos _ 0.	bitBuf _ bitPos _ 0.	state _ 0.! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 15:31'!close	sourceStream ifNotNil:[sourceStream close].! !!InflateStream methodsFor: 'accessing' stamp: 'tk 2/4/2000 10:26'!contents	^ self upToEnd! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/22/1999 01:29'!next	"Answer the next decompressed object in the Stream represented by the	receiver."	<primitive: 65>	position >= readLimit		ifTrue: [^self pastEndRead]		ifFalse: [^collection at: (position _ position + 1)]! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/3/1998 16:18'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for simplicity"	| newArray |	newArray _ collection species new: anInteger.	1 to: anInteger do: [:index | newArray at: index put: self next].	^newArray! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 16:06'!next: n into: buffer startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	| c numRead count |	numRead _ 0.	["Force decompression if necessary"	(c _ self next) == nil 		ifTrue:[^buffer copyFrom: 1 to: startIndex+numRead-1].	"Store the first value which provoked decompression"	buffer at: startIndex + numRead put: c.	numRead _ numRead + 1.	"After collection has been filled copy as many objects as possible"	count _ (readLimit - position) min: (n - numRead).	buffer 		replaceFrom: startIndex + numRead 		to: startIndex + numRead + count - 1 		with: collection 		startingAt: position+1.	position _ position + count.	numRead _ numRead + count.	numRead = n] whileFalse.	^buffer! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/3/1998 16:19'!size	"This is a compressed stream - we don't know the size beforehand"	^self shouldNotImplement! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/21/1999 23:54'!sourceLimit	^sourceLimit! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/21/1999 23:52'!sourcePosition	^sourcePos! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 15:31'!sourceStream	^sourceStream! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/3/1998 16:19'!upTo: anObject 	"Answer a subcollection from the current access position to the 	occurrence (if any, but not inclusive) of anObject in the receiver. If 	anObject is not in the collection, answer the entire rest of the receiver."	| newStream element |	newStream _ WriteStream on: (collection species new: 100).	[self atEnd or: [(element _ self next) = anObject]]		whileFalse: [newStream nextPut: element].	^newStream contents! !!InflateStream methodsFor: 'accessing' stamp: 'ar 12/22/1999 02:04'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	| newStream buffer |	buffer _ collection species new: 1000.	newStream _ WriteStream on: (collection species new: 100).	[self atEnd] whileFalse: [newStream nextPutAll: (self nextInto: buffer)].	^ newStream contents! !!InflateStream methodsFor: 'testing' stamp: 'ar 12/27/1999 13:43'!atEnd	"Note: It is possible that we have a few bits left,	representing just the EOB marker. To check for	this we must force decompression of the next	block if at end of data."	super atEnd ifFalse:[^false]. "Primitive test"	(position >= readLimit and:[state = StateNoMoreData]) ifTrue:[^true].	"Force decompression, by calling #next. Since #moveContentsToFront	will never move data to the beginning of the buffer it is safe to	skip back the read position afterwards"	self next == nil ifTrue:[^true].	position _ position - 1.	^false! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 02:24'!decodeValueFrom: table	"Decode the next value in the receiver using the given huffman table."	| bits bitsNeeded tableIndex value |	bitsNeeded _ (table at: 1) bitShift: -24.	"Initial bits needed"	tableIndex _ 2.							"First real table"	[bits _ self nextSingleBits: bitsNeeded.	"Get bits"	value _ table at: (tableIndex + bits).		"Lookup entry in table"	(value bitAnd: 16r3F000000) = 0] 			"Check if it is a non-leaf node"		whileFalse:["Fetch sub table"			tableIndex _ value bitAnd: 16rFFFF.	"Table offset in low 16 bit"			bitsNeeded _ (value bitShift: -24) bitAnd: 255. "Additional bits in high 8 bit"			bitsNeeded > MaxBits ifTrue:[^self error:'Invalid huffman table entry']].	^value! !!InflateStream methodsFor: 'inflating' stamp: 'ar 3/15/1999 15:38'!decompressBlock: llTable with: dTable	"Process the compressed data in the block.	llTable is the huffman table for literal/length codes	and dTable is the huffman table for distance codes."	| value extra length distance oldPos oldBits oldBitPos |	[readLimit < collection size and:[sourcePos <= sourceLimit]] whileTrue:[		"Back up stuff if we're running out of space"		oldBits _ bitBuf.		oldBitPos _ bitPos.		oldPos _ sourcePos.		value _ self decodeValueFrom: llTable.		value < 256 ifTrue:[ "A literal"			collection byteAt: (readLimit _ readLimit + 1) put: value.		] ifFalse:["length/distance or end of block"			value = 256 ifTrue:["End of block"				state _ state bitAnd: StateNoMoreData.				^self].			"Compute the actual length value (including possible extra bits)"			extra _ #(0 0 0 0 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 0) at: value - 256.			length _ #(3 4 5 6 7 8 9 10 11 13 15 17 19 23 27 31 35 43 51 59 67 83 99 115 131 163 195 227 258) at: value - 256.			extra > 0 ifTrue:[length _ length + (self nextBits: extra)].			"Compute the distance value"			value _ self decodeValueFrom: dTable.			extra _ #(0 0 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13) at: value+1.			distance _ #(1 2 3 4 5 7 9 13 17 25 33 49 65 97 129 193 257 385 513 769						1025 1537 2049 3073 4097 6145 8193 12289 16385 24577) at: value+1.			extra > 0 ifTrue:[distance _ distance + (self nextBits: extra)].			(readLimit + length >= collection size) ifTrue:[				bitBuf _ oldBits.				bitPos _ oldBitPos.				sourcePos _ oldPos.				^self].			collection 					replaceFrom: readLimit+1 					to: readLimit + length + 1 					with: collection 					startingAt: readLimit - distance + 1.			readLimit _ readLimit + length.		].	].! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/3/1998 20:49'!proceedDynamicBlock	self decompressBlock: litTable with: distTable! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/3/1998 20:49'!proceedFixedBlock	self decompressBlock: litTable with: distTable! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/27/1999 13:49'!proceedStoredBlock	"Proceed decompressing a stored (e.g., uncompressed) block"	| length decoded |	"Literal table must be nil for a stored block"	litTable == nil ifFalse:[^self error:'Bad state'].	length _ distTable.	[length > 0 and:[readLimit < collection size and:[sourcePos < sourceLimit]]] 		whileTrue:[			collection at: (readLimit _ readLimit + 1) put: 				(source at: (sourcePos _ sourcePos + 1)).			length _ length - 1].	length = 0 ifTrue:[state _ state bitAnd: StateNoMoreData].	decoded _ length - distTable.	distTable _ length.	^decoded! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 01:46'!processDynamicBlock	| nLit nDist nLen codeLength lengthTable bits |	nLit _ (self nextBits: 5) + 257.	nDist _ (self nextBits: 5) + 1.	nLen _ (self nextBits: 4) + 4.	codeLength _ Array new: 19.	codeLength atAllPut: 0.	1 to: nLen do:[:i|		bits _ #(16 17 18 0 8 7 9 6 10 5 11 4 12 3 13 2 14 1 15) at: i.		codeLength at: bits+1 put: (self nextBits: 3).	].	lengthTable _ self huffmanTableFrom: codeLength mappedBy: nil.	"RFC 1951: In other words, all code lengths form a single sequence..."	codeLength _ self decodeDynamicTable: nLit+nDist from: lengthTable.	litTable _ self 				huffmanTableFrom: (codeLength copyFrom: 1 to: nLit)				mappedBy: self literalLengthMap.	distTable _ self 				huffmanTableFrom: (codeLength copyFrom: nLit+1 to: codeLength size)				mappedBy: self distanceMap.	state _ state bitOr: BlockProceedBit.	self proceedDynamicBlock.! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/4/1998 19:13'!processFixedBlock	litTable _ self 				huffmanTableFrom: FixedLitCodes				mappedBy: self literalLengthMap.	distTable _ self 				huffmanTableFrom: FixedDistCodes				mappedBy: self distanceMap.	state _ state bitOr: BlockProceedBit.	self proceedFixedBlock.! !!InflateStream methodsFor: 'inflating' stamp: 'ar 12/27/1999 13:49'!processStoredBlock	| chkSum length |	"Skip to byte boundary"	self nextBits: (bitPos bitAnd: 7).	length _ self nextBits: 16.	chkSum _ self nextBits: 16.	(chkSum bitXor: 16rFFFF) = length		ifFalse:[^self error:'Bad block length'].	litTable _ nil.	distTable _ length.	state _ state bitOr: BlockProceedBit.	^self proceedStoredBlock! !!InflateStream methodsFor: 'private' stamp: 'ar 12/4/1998 02:03'!decompressAll	"Profile the decompression speed"	[self atEnd] whileFalse:[		position _ readLimit.		self next "Provokes decompression"	].! !!InflateStream methodsFor: 'private' stamp: 'ar 12/23/1999 15:15'!getFirstBuffer	"Get the first source buffer after initialization has been done"	sourceStream == nil ifTrue:[^self].	source _ sourceStream next: 1 << 16. "This is more than enough..."	sourceLimit _ source size.! !!InflateStream methodsFor: 'private' stamp: 'ar 12/3/1998 17:32'!getNextBlock	^self nextBits: 3! !!InflateStream methodsFor: 'private' stamp: 'ar 12/23/1999 15:17'!moveContentsToFront	"Move the decoded contents of the receiver to the front so that we have enough space for decoding more data."	| delta |	readLimit > 32768 ifTrue:[		delta _ readLimit - 32767.		collection 			replaceFrom: 1 			to: collection size - delta + 1 			with: collection 			startingAt: delta.		position _ position - delta + 1.		readLimit _ readLimit - delta + 1].! !!InflateStream methodsFor: 'private' stamp: 'ar 12/23/1999 15:27'!moveSourceToFront	"Move the encoded contents of the receiver to the front so that we have enough space for decoding more data."	(sourceStream == nil or:[sourceStream atEnd]) ifTrue:[^self].	sourcePos > 10000 ifTrue:[		source 			replaceFrom: 1 			to: source size - sourcePos			with: source 			startingAt: sourcePos + 1.		source _ sourceStream 			next: sourcePos 			into: source 			startingAt: source size - sourcePos + 1.		sourcePos _ 0.		sourceLimit _ source size].! !!InflateStream methodsFor: 'private' stamp: 'ar 12/27/1999 15:25'!pastEndRead	"A client has attempted to read beyond the read limit.	Check in what state we currently are and perform	the appropriate action"	| blockType |	state = StateNoMoreData ifTrue:[^nil]. "Get out early if possible"	"Check if we can move decoded data to front"	self moveContentsToFront.	"Check if we can fetch more source data"	self moveSourceToFront.	state = StateNewBlock ifTrue:[state _ self getNextBlock].	blockType _ state bitShift: -1.	self perform: (BlockTypes at: blockType+1).	^self next! !!InflateStream methodsFor: 'private' stamp: 'ar 12/4/1998 02:03'!profile	"Profile the decompression speed"	MessageTally spyOn:[self decompressAll].! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/21/1999 22:59'!computeHuffmanValues: aCollection counts: counts from: minBits to: maxBits	"Assign numerical values to all codes.	Note: The values are stored according to the bit length"	| offsets values baseOffset codeLength |	offsets _ Array new: maxBits.	offsets atAllPut: 0.	baseOffset _ 1.	minBits to: maxBits do:[:bits|		offsets at: bits put: baseOffset.		baseOffset _ baseOffset + (counts at: bits+1)].	values _ WordArray new: aCollection size.	1 to: aCollection size do:[:i|		codeLength _ aCollection at: i.		codeLength > 0 ifTrue:[			baseOffset _ offsets at: codeLength.			values at: baseOffset put: i-1.			offsets at: codeLength put: baseOffset + 1]].	^values! !!InflateStream methodsFor: 'huffman trees' stamp: 'sma 5/12/2000 10:49'!createHuffmanTables: values counts: counts from: minBits to: maxBits	"Create the actual tables"	| table tableStart tableSize tableEnd 	valueIndex tableStack numValues deltaBits maxEntries	lastTable lastTableStart tableIndex lastTableIndex |	table _ WordArray new: ((4 bitShift: minBits) max: 16).	"Create the first entry - this is a dummy.	It gives us information about how many bits to fetch initially."	table at: 1 put: (minBits bitShift: 24) + 2. "First actual table starts at index 2"	"Create the first table from scratch."	tableStart _ 2. "See above"	tableSize _ 1 bitShift: minBits.	tableEnd _ tableStart + tableSize.	"Store the terminal symbols"	valueIndex _ (counts at: minBits+1).	tableIndex _ 0.	1 to: valueIndex do:[:i|		table at: tableStart + tableIndex put: (values at: i).		tableIndex _ self increment: tableIndex bits: minBits].	"Fill up remaining entries with invalid entries"	tableStack _ OrderedCollection new: 10. "Should be more than enough"	tableStack addLast: 		(Array 			with: minBits	"Number of bits (e.g., depth) for this table"			with: tableStart	"Start of table"			with: tableIndex "Next index in table"			with: minBits	"Number of delta bits encoded in table"			with: tableSize - valueIndex "Entries remaining in table").	"Go to next value index"	valueIndex _ valueIndex + 1.	"Walk over remaining bit lengths and create new subtables"	minBits+1 to: maxBits do:[:bits|		numValues _ counts at: bits+1.		[numValues > 0] whileTrue:["Create a new subtable"			lastTable _ tableStack last.			lastTableStart _ lastTable at: 2.			lastTableIndex _ lastTable at: 3.			deltaBits _ bits - (lastTable at: 1).			"Make up a table of deltaBits size"			tableSize _ 1 bitShift: deltaBits.			tableStart _ tableEnd.			tableEnd _ tableEnd + tableSize.			[tableEnd > table size ]				whileTrue:[table _ self growHuffmanTable: table].			"Connect to last table"			self assert:[(table at: lastTableStart + lastTableIndex) = 0]."Entry must be unused"			table at: lastTableStart + lastTableIndex put: (deltaBits bitShift: 24) + tableStart.			lastTable at: 3 put: (self increment: lastTableIndex bits: (lastTable at: 4)).			lastTable at: 5 put: (lastTable at: 5) - 1.			self assert:[(lastTable at: 5) >= 0]. "Don't exceed tableSize"			"Store terminal values"			maxEntries _ numValues min: tableSize.			tableIndex _ 0.			1 to: maxEntries do:[:i|				table at: tableStart + tableIndex put: (values at: valueIndex).				valueIndex _ valueIndex + 1.				numValues _ numValues - 1.				tableIndex _ self increment: tableIndex bits: deltaBits].			"Check if we have filled up the current table completely"			maxEntries = tableSize ifTrue:[				"Table has been filled. Back up to the last table with space left."				[tableStack isEmpty not and:[(tableStack last at: 5) = 0]]						whileTrue:[tableStack removeLast].			] ifFalse:[				"Table not yet filled. Put it back on the stack."				tableStack addLast:					(Array						with: bits		"Nr. of bits in this table"						with: tableStart	"Start of table"						with: tableIndex "Index in table"						with: deltaBits	"delta bits of table"						with: tableSize - maxEntries "Unused entries in table").			].		].	].	 ^table copyFrom: 1 to: tableEnd-1! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:25'!decodeDynamicTable: nItems from: aHuffmanTable	"Decode the code length of the literal/length and distance table	in a block compressed with dynamic huffman trees"	| values index value repCount theValue |	values _ Array new: nItems.	index _ 1.	theValue _ 0.	[index <= nItems] whileTrue:[		value _ self decodeValueFrom: aHuffmanTable.		value < 16 ifTrue:[			"Immediate values"			theValue _ value.			values at: index put: value.			index _ index+1.		] ifFalse:[			"Repeated values"			value = 16 ifTrue:[				"Repeat last value"				repCount _ (self nextBits: 2) + 3.			] ifFalse:[				"Repeat zero value"				theValue _ 0.				value = 17 					ifTrue:[repCount _ (self nextBits: 3) + 3]					ifFalse:[value = 18 								ifTrue:[repCount _ (self nextBits: 7) + 11]								ifFalse:[^self error:'Invalid bits tree value']]].			0 to: repCount-1 do:[:i| values at: index+i put: theValue].			index _ index + repCount].	].	^values! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 01:51'!distanceMap	"This is used by the fast decompressor"	^nil! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/3/1998 13:16'!growHuffmanTable: table	| newTable |	newTable _ table species new: table size * 2.	newTable replaceFrom: 1 to: table size with: table startingAt: 1.	^newTable! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:27'!huffmanTableFrom: aCollection mappedBy: valueMap	"Create a new huffman table from the given code lengths.	Map the actual values by valueMap if it is given.	See the class comment for a documentation of the huffman	tables used in this decompressor."	| counts  values table minBits maxBits |	minBits _ MaxBits + 1.	maxBits _ 0.	"Count the occurences of each code length and compute minBits and maxBits"	counts _ Array new: MaxBits+1.	counts atAllPut: 0.	aCollection do:[:length| 		length > 0 ifTrue:[			length < minBits ifTrue:[minBits _ length].			length > maxBits ifTrue:[maxBits _ length].			counts at: length+1 put: (counts at: length+1)+1]].	maxBits = 0 ifTrue:[^nil]. "Empty huffman table"	"Assign numerical values to all codes."	values _ self computeHuffmanValues: aCollection counts: counts from: minBits to: maxBits.	"Map the values if requested"	self mapValues: values by: valueMap.	"Create the actual tables"	table _ self createHuffmanTables: values counts: counts from: minBits to: maxBits.	^table! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 01:48'!increment: value bits: nBits	"Increment a value of nBits length.	The fast decompressor will do this differently"	^value+1! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 01:50'!literalLengthMap	"This is used by the fast decompressor"	^nil! !!InflateStream methodsFor: 'huffman trees' stamp: 'ar 12/4/1998 02:28'!mapValues: values by: valueMap	| oldValue |	valueMap ifNil:[^values].	1 to: values size do:[:i|		oldValue _ values at: i.		"Note: there may be nil values if not all values are used"		oldValue isNil			ifTrue:[^values]			ifFalse:[values at: i put: (valueMap at: oldValue+1)]].! !!InflateStream methodsFor: 'bit access' stamp: 'ar 12/27/1999 13:47'!bitPosition	"Return the current bit position of the source"	sourceStream == nil		ifTrue:[^sourcePos * 8 + bitPos]		ifFalse:[^sourceStream position + sourcePos * 8 + bitPos]! !!InflateStream methodsFor: 'bit access' stamp: 'ar 12/4/1998 02:00'!nextBits: n	| bits |	[bitPos < n] whileTrue:[		bitBuf _ bitBuf + (self nextByte bitShift: bitPos).		bitPos _ bitPos + 8].	bits _ bitBuf bitAnd: (1 bitShift: n)-1.	bitBuf _ bitBuf bitShift: 0 - n.	bitPos _ bitPos - n.	^bits! !!InflateStream methodsFor: 'bit access' stamp: 'ar 12/5/1998 14:54'!nextByte	^source byteAt: (sourcePos _ sourcePos + 1)! !!InflateStream methodsFor: 'bit access' stamp: 'ar 12/4/1998 02:01'!nextSingleBits: n	| out |	out _ 0.	1 to: n do:[:i| out _ (out bitShift: 1) + (self nextBits: 1)].	^out! !!InflateStream class methodsFor: 'class initialization' stamp: 'ar 12/4/1998 19:12'!initialize	"InflateStream initialize"	MaxBits _ 16.	StateNewBlock _ 0.	StateNoMoreData _ 1.	BlockProceedBit _ 8.	BlockTypes _ #(	processStoredBlock	"New block in stored format"					processFixedBlock	"New block with fixed huffman tables"					processDynamicBlock	"New block with dynamic huffman tables"					errorBadBlock		"Bad block format"					proceedStoredBlock	"Continue block in stored format"					proceedFixedBlock	"Continue block in fixed format"					proceedDynamicBlock	"Continue block in dynamic format"					errorBadBlock		"Bad block format").	"Initialize fixed block values"	FixedLitCodes _ 	((1 to: 144) collect:[:i| 8]),					((145 to: 256) collect:[:i| 9]),					((257 to: 280) collect:[:i| 7]),					((281 to: 288) collect:[:i| 8]).	FixedDistCodes _ ((1 to: 32) collect:[:i| 5]).! !I am an extension of the DialogBoxMorph used to request string input from the user.Examples:	InputDialogBoxMorph ask: 'What is your name?'	InputDialogBoxMorph ask: 'What is your favorite color?' defaultResponse: 'Red, no blue'	InputDialogBoxMorph askWithCancel: 'File name?' defaultResponse: 'filename.wav'!!InputDialogBoxMorph methodsFor: 'initialization' stamp: 'jm 12/7/2003 15:14'!defaultResponse: aString	"Set the default answer string."	responseMorph contents: aString.! !!InputDialogBoxMorph methodsFor: 'initialization' stamp: 'jm 12/7/2003 17:13'!initialize	"Add one more morph for the user's response."	| col |	super initialize.	responseMorph _ TextMorph new contents: '<your answer>'.	"re-build column"	col _ self submorphs at: 1.	col removeAllMorphs.	col addMorphBack: messageMorph.	col addMorphBack: (AlignmentMorph newSpacer: Color transparent).	col addMorphBack: responseMorph.	col addMorphBack: (AlignmentMorph newSpacer: Color transparent).	col addMorphBack: buttonRow.	self extent: self extent.  "fix layout"! !!InputDialogBoxMorph methodsFor: 'interaction' stamp: 'jm 12/7/2003 17:33'!getUserResponse	"Wait for the user to respond, then report their response. The symbol #cancelled is returned if the user wishes to cancel the operation. True/false is returned if they respond yes/no, and a string is returned if this this a string input dialog and they don't cancel."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."	| w |	self openInWorld.	w _ self world.	self position: w center - (self extent // 2).  "center on screen"	self extent: self extent.  "force layout"	response _ #cancelled.  "default response"	responseMorph editor.	responseMorph editor selectFrom: 1 to: responseMorph contents size.	done _ false.	[done] whileFalse: [w doOneCycle].  "wait for user to press a button"	self delete.	w doOneCycle.  "erase myself from the screen"	response = #cancelled		ifTrue: [^ #cancelled]		ifFalse: [^ responseMorph contents asString]! !!InputDialogBoxMorph class methodsFor: 'instance creation' stamp: 'jm 12/7/2003 15:16'!ask: questionString	"Put up an instance of me to ask the user for string input (such as file name). Answer the edited string."	^ self ask: questionString defaultResponse: '      '! !!InputDialogBoxMorph class methodsFor: 'instance creation' stamp: 'jm 12/7/2003 15:10'!ask: questionString defaultResponse: aString	"Put up an instance of me to ask the user for string input (such as file name). The initial response text is set to the given string, which the user can replace or edit. Answer the edited string."	| dialogBox |	dialogBox _ self new		type: 1 withButtonsForYes: false no: false okay: true cancel: false;		message: questionString;		defaultResponse: aString.	^ dialogBox getUserResponse! !!InputDialogBoxMorph class methodsFor: 'instance creation' stamp: 'jm 12/7/2003 15:11'!askWithCancel: questionString defaultResponse: aString	"Put up an instance of me to ask the user for string input (such as file name). The initial response text is set to the given string, which the user can replace or edit. This version includes a cancel button. Answer the edited string or the symbol #cancelled."	| dialogBox |	dialogBox _ self new		type: 1 withButtonsForYes: false no: false okay: true cancel: true;		message: questionString;		defaultResponse: aString.	^ dialogBox getUserResponse! !I represent an interface to the user input devices. There is at least one instance of me named Sensor in the system.!!InputSensor methodsFor: 'modifier keys' stamp: 'di 9/28/1999 08:29'!anyModifierKeyPressed	"ignore, however, the shift keys 'cause that's not REALLY a command key"	^ self primMouseButtons anyMask: 16r70	"cmd | opt | ctrl"! !!InputSensor methodsFor: 'modifier keys' stamp: 'bf 9/22/1999 15:47'!macOptionKeyPressed	"Answer whether the option key on the Macintosh keyboard is being held down. Macintosh specific."	Preferences macOptionKeyAllowed ifFalse: [self notify: 'Portability note:InputSensor>>macOptionKeyPressed is not portable.Please use InputSensor>>yellowButtonPressed instead!!'].	^ self primMouseButtons anyMask: 32! !!InputSensor methodsFor: 'mouse' stamp: 'bf 9/22/1999 12:59'!blueButtonPressed	"Answer whether only the blue mouse button is being pressed. This is the third mouse button or cmd+click on the Mac."	^self buttons = 1! !!InputSensor methodsFor: 'mouse' stamp: 'bf 9/22/1999 12:43'!redButtonPressed	"Answer true if the red mouse button is being pressed. This is the first mouse button."	^self buttons = 4! !!InputSensor methodsFor: 'mouse' stamp: 'bf 11/1/1999 20:12'!waitButton	"Wait for the user to press any mouse button and then answer with the 	current location of the cursor."	[self anyButtonPressed] whileFalse:		[(Delay forMilliseconds: 50) wait].	^self cursorPoint! !!InputSensor methodsFor: 'mouse' stamp: 'sma 5/28/2000 12:04'!waitButtonOrKeyboard	"Wait for the user to press either any mouse button or any key.	Answer the current cursor location or nil if a keypress occured."	[self anyButtonPressed] whileFalse:		[(Delay forMilliseconds: 50) wait.		self keyboardPressed ifTrue: [^ nil]].	^ self cursorPoint! !!InputSensor methodsFor: 'mouse' stamp: 'bf 11/1/1999 20:22'!waitNoButton	"Wait for the user to release any mouse button and then answer with the 	current location of the cursor."	[self anyButtonPressed] whileTrue:		[(Delay forMilliseconds: 50) wait].	^self cursorPoint! !!InputSensor methodsFor: 'mouse' stamp: 'bf 9/22/1999 12:43'!yellowButtonPressed	"Answer whether only the yellow mouse button is being pressed. This is the second mouse button or option+click on the Mac."	^self buttons = 2! !!InputSensor methodsFor: 'cursor' stamp: 'di 4/13/2000 12:15'!currentCursor	"The current cursor is maintained in class Cursor."	^ Cursor currentCursor! !!InputSensor methodsFor: 'cursor' stamp: 'di 4/13/2000 12:16'!currentCursor: newCursor 	"The current cursor is maintained in class Cursor."	Cursor currentCursor: newCursor.! !!InputSensor methodsFor: 'joystick' stamp: 'di 4/13/1999 14:32'!testJoystick: index	"Sensor testJoystick: 3"	| f pt buttons status |	f _ Form extent: 110@50.	[Sensor anyButtonPressed] whileFalse: [		pt _ Sensor joystickXY: index.		buttons _ Sensor joystickButtons: index.		status _'xy: ', pt printString, 'buttons: ', buttons hex.		f fillWhite.		status displayOn: f at: 10@10.		f displayOn: Display at: 10@10.	].! !!InputSensor methodsFor: 'user interrupts' stamp: 'di 2/4/1999 15:24'!userInterruptWatcher	"Wait for user interrupts and open a notifier on the active process when one occurs."	[true] whileTrue: [		InterruptSemaphore wait.		Display deferUpdates: false.		Smalltalk at: #SoundPlayer ifPresent: [:theClass | theClass shutDown].		Smalltalk handleUserInterrupt]! !!InputSensor methodsFor: 'private' stamp: 'jm 5/8/2003 19:10'!fileDropPoint	"Answer the point a which a file (or files) were dropped or nil if no file has been dropped. Requires Squeak VM version 3.1 or later."	| evtBuf |	evtBuf _ Array new: 8.	[true] whileTrue: [		evtBuf at: 1 put: 0.		Sensor primGetNextEvent: evtBuf.		evtBuf first = 0 ifTrue: [^ nil].		(evtBuf first = 3 and: [(evtBuf at: 3) = 4]) ifTrue: [			^ (evtBuf at: 4) @ (evtBuf at: 5)]].! !!InputSensor methodsFor: 'private' stamp: 'jm 5/4/2003 08:26'!primGetNextEvent: array	"Store the next OS event available into the given 8-element array. This primitive was added around Squeak version 2.9."	"The event structure is for file drop events is: <type=3><timestamp><subtype><x><y><0><count><0>	 The subtypes are: 1=start, 2=move, 3=end, 4=dropped"	<primitive: 94>! !!InputSensor methodsFor: 'private' stamp: 'jm 4/12/1999 13:04'!primTabletGetParameters: cursorIndex	"Answer the pen tablet parameters. For parameters that differ from cursor to cursor, answer those associated with the cursor having the given index. Answer nil if there is no pen tablet. The parameters are:	1. tablet width, in tablet units	2. tablet height, in tablet units	3. number of tablet units per inch	4. number of cursors (pens, pucks, etc; some tablets have more than one)	5. this cursor index	6. and 7. x scale and x offset for scaling tablet coordintes (e.g., to fit the screen)	8. and 9. y scale and y offset for scaling tablet coordintes  (e.g., to fit the screen)	10. number of pressure levels	11. presure threshold needed close pen tip switch 	12. number of pen tilt angles"	<primitive: 548>	^ nil! !!InputSensor methodsFor: 'private' stamp: 'jm 4/10/1999 22:57'!primTabletRead: cursorIndex	"Answer the pen tablet data for the cursor having the given index. Answer nil if there is no pen tablet. The data is:	1. index of the cursor to which this data applies	2. timestamp of the last state chance for this cursor	3., 4., and 5. x, y, and z coordinates of the cursor (z is typically 0)	6. and 7. xTilt and yTilt of the cursor; (signed)	8. type of cursor (0 = unknown, 1 = pen, 2 = puck, 3 = eraser)	9. cursor buttons	10. cursor pressure, downward	11. cursor pressure, tangential	12. flags"	<primitive: 549>	self primitiveFailed! !!InputSensor methodsFor: 'tablet' stamp: 'jm 4/10/1999 22:14'!hasTablet	"Answer true if there is a pen tablet available on this computer."	^ (self primTabletGetParameters: 1) notNil! !!InputSensor methodsFor: 'tablet' stamp: 'jm 4/13/1999 11:02'!tabletExtent	"Answer the full tablet extent in tablet coordinates."	| params |	params _ self primTabletGetParameters: 1.	params ifNil: [^ self error: 'no tablet available'].	^ (params at: 1)@(params at: 2)! !!InputSensor methodsFor: 'tablet' stamp: 'jm 4/13/1999 11:12'!tabletPoint	"Answer the current position of the first tablet pointing device (pen, puck, or eraser) in tablet coordinates."	| data |	data _ self primTabletRead: 1.  "state of first/primary pen"	^ (data at: 3) @ (data at: 4)! !!InputSensor methodsFor: 'tablet' stamp: 'jm 4/12/1999 13:05'!tabletPressure	"Answer the current pressure of the first tablet pointing device (pen, puck, or eraser), a number between 0.0 (no pressure) and 1.0 (max pressure)"	| params data |	params _ self primTabletGetParameters: 1.	params ifNil: [^ self].	data _ self primTabletRead: 1.  "state of first/primary pen"	^ (data at: 10) asFloat / ((params at: 10) - 1)! !!InputSensor methodsFor: 'tablet' stamp: 'jm 4/10/1999 23:03'!tabletTimestamp	"Answer the time (in tablet clock ticks) at which the tablet's primary pen last changed state. This can be used in polling loops; if this timestamp hasn't changed, then the pen state hasn't changed either."	| data |	data _ self primTabletRead: 1.  "state of first/primary pen"	^ data at: 2! !I represent a query path into the internal representation of an object. As a StringHolder, the string I represent is the value of the currently selected variable of the observed object.!!Inspector methodsFor: 'accessing' stamp: 'svp 3/14/2000 21:57'!modelWakeUpIn: aWindow	| newText |	self updateListsAndCodeIn: aWindow.	newText _ self contentsIsString		ifTrue: [newText _ self selection]		ifFalse: ["keep it short to reduce time to compute it"			self selectionPrintString ].	newText = contents ifFalse:		[contents _ newText.		self changed: #contents]! !!Inspector methodsFor: 'accessing' stamp: 'sw 10/30/1999 23:59'!noteSelectionIndex: anInteger for: aSymbol	aSymbol == #fieldList		ifTrue:			[selectionIndex _ anInteger]! !!Inspector methodsFor: 'accessing' stamp: 'svp 3/14/2000 21:57'!stepAt: millisecondClockValue in: aWindow	| newText |	(Preferences smartUpdating and: [(millisecondClockValue - self timeOfLastListUpdate) > 8000]) "Not more often than once every 8 seconds"		ifTrue:			[self updateListsAndCodeIn: aWindow.			timeOfLastListUpdate _ millisecondClockValue].	newText _ self contentsIsString		ifTrue: [newText _ self selection]		ifFalse: ["keep it short to reduce time to compute it"			self selectionPrintString ].	newText = contents ifFalse:		[contents _ newText.		self changed: #contents]! !!Inspector methodsFor: 'accessing' stamp: 'sw 10/20/1999 15:54'!timeOfLastListUpdate	^ timeOfLastListUpdate ifNil: [timeOfLastListUpdate _ 0]! !!Inspector methodsFor: 'accessing' stamp: 'tk 6/11/1998 22:23'!trash: newText	"Don't save it"	^ true! !!Inspector methodsFor: 'accessing' stamp: 'svp 3/14/2000 21:56'!update	"Reshow contents, assuming selected value may have changed."	selectionIndex = 0		ifFalse:			[contents _ self selectionPrintString.			self changed: #selection.			self changed: #selectionIndex]! !!Inspector methodsFor: 'accessing' stamp: 'di 1/13/1999 14:36'!wantsSteps	^ true! !!Inspector methodsFor: 'selecting' stamp: 'di 9/22/1998 21:24'!contentsIsString	"Hacked so contents empty when deselected and = long printString when item 2"	^ (selectionIndex = 2) | (selectionIndex = 0)! !!Inspector methodsFor: 'selecting' stamp: 'hg 10/8/2000 14:46'!selectedSlotName	^ self fieldList at: self selectionIndex! !!Inspector methodsFor: 'selecting' stamp: 'jm 5/22/2003 20:35'!selectionPrintString	| text |	^ [self selection printStringLimitedTo: 5000]		ifError: [			text _ ('<printing error>') asText.			text addAttribute: TextColor red from: 1 to: text size.			text]! !!Inspector methodsFor: 'selecting' stamp: 'svp 3/14/2000 22:00'!toggleIndex: anInteger	"The receiver has a list of variables of its inspected object. One of these 	is selected. If anInteger is the index of this variable, then deselect it. 	Otherwise, make the variable whose index is anInteger be the selected 	item."	selectionIndex = anInteger		ifTrue: 			["same index, turn off selection"			selectionIndex _ 0.			contents _ '']		ifFalse:			["different index, new selection"			selectionIndex _ anInteger.			self contentsIsString				ifTrue: [contents _ self selection]				ifFalse: [contents _ self selectionPrintString]].	self changed: #selection.	self changed: #contents.	self changed: #selectionIndex.! !!Inspector methodsFor: 'menu commands' stamp: 'di 4/28/1999 11:33'!copyName	"Copy the name of the current variable, so the user can paste it into the window below and work with is.  If collection, do (xxx at: 1). "	| sel aClass |	self selectionUnmodifiable ifTrue: [^ self changed: #flash].	(aClass _ self object class) isVariable ifTrue: [^ self changed: #flash].	sel _ aClass allInstVarNames at: selectionIndex - 2.	(self selection isKindOf: Collection) ifTrue: [sel _ '(',sel,' at: 1)'].	ParagraphEditor clipboardTextPut: sel asText.	"no undo allowed"! !!Inspector methodsFor: 'menu commands' stamp: 'sw 10/10/1999 14:34'!defsOfSelection	"Open a browser on all defining references to the selected instance variable, if that's what currently selected. "	| aClass sel |	self selectionUnmodifiable ifTrue: [^ self changed: #flash].	(aClass _ self object class) isVariable ifTrue: [^ self changed: #flash].	sel _ aClass allInstVarNames at: self selectionIndex - 2.	aClass browseAllStoresInto: sel! !!Inspector methodsFor: 'menu commands' stamp: 'jm 12/9/2003 09:27'!fieldListMenu: aMenu	| sel |	((((sel _ self selection) isMemberOf: Array) or: [sel isMemberOf: OrderedCollection])			and: [sel size >= 1])		ifTrue:			[^ self fieldListMenuForCollection: aMenu].	^ aMenu labels: 'inspect (i)method refs to this inst varmethods storing into this inst varobjects pointing to this valuecopy namebrowse full (b)browse classbrowse hierarchyinst var refs...inst var defs...class var refs...class variablesclass refsbasic inspect'	lines: #(1 4 5 8 10 13)	selections: #(inspectSelection referencesToSelection defsOfSelection objectReferencesToSelection copyName  browseMethodFull browseClass classHierarchy browseInstVarRefs browseInstVarDefs classVarRefs browseClassVariables browseClassRefs inspectBasic).! !!Inspector methodsFor: 'menu commands' stamp: 'jm 12/9/2003 09:29'!fieldListMenuForCollection: aMenu	^ aMenu labels:'inspect (i)inspect element...method refs to this inst varmethods storing into this inst varobjects pointing to this valuecopy namebrowse full (b)browse classbrowse hierarchyinst var refs...inst var defs...class var refs...class variablesclass refsbasic inspect'	lines: #(2 5 6 9 11 14)	selections: #(inspectSelection inspectElement referencesToSelection defsOfSelection objectReferencesToSelection copyName  browseMethodFull browseClass classHierarchy browseInstVarRefs browseInstVarDefs classVarRefs browseClassVariables browseClassRefs inspectBasic)! !!Inspector methodsFor: 'menu commands' stamp: 'sw 1/14/2000 12:19'!inspectElement	| sel selSize countString count |	"Create and schedule an Inspector on an element of the receiver's model's currently selected collection."	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	((sel _ self selection) isKindOf: SequenceableCollection) ifFalse:		[^ sel inspect].	(selSize _ sel size) == 1 ifTrue: [^ sel first inspect].	selSize <= 10 ifTrue:		[count _ (SelectionMenu selections: (1 to: selSize) asArray) startUpWithCaption: 'which element?'.		count ifNil: [^ self] ifNotNil: [^ (sel at: count) inspect]].	countString _ FillInTheBlank request: 'Which element? (1 - ', selSize printString, ')' initialAnswer: '1'.	countString isEmptyOrNil ifTrue: [^ self].	count _ Integer readFrom: (ReadStream on: countString).	(count > 0 and: [count <= selSize])		ifTrue:			[(sel  at: count) inspect]		ifFalse:			[self beep]! !!Inspector methodsFor: 'menu commands' stamp: 'sw 1/14/2000 13:39'!inspectSelection	"Create and schedule an Inspector on the receiver's model's currently selected object."	self selectionIndex = 0 ifTrue: [^ self changed: #flash].	^ self selection inspect! !!Inspector methodsFor: 'menu commands' stamp: 'jm 12/9/2003 09:13'!inspectorKey: aChar from: view	"Respond to a Command key. Got here from a list of fields being inspected."	aChar == $i ifTrue: [self selection inspect].	aChar == $b ifTrue:	[self browseMethodFull].	aChar == $c ifTrue: [self copyName].	^ self arrowKey: aChar from: view! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 1/19/1999 14:38'!horizontalDividerProportion	^ 0.3! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 9/23/1998 08:16'!openAsMorphOn: anObject	^ self openAsMorphOn: anObject withLabel: anObject defaultLabelForInspector! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 9/23/1998 08:30'!openAsMorphOn: anObject withEvalPane: withEval withLabel: label valueViewClass: valueViewClass	"Note: for now, this always adds an eval pane, and ignores the valueViewClass"	(self openAsMorphOn: anObject withLabel: label) openInWorld! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 1/12/2000 16:34'!openAsMorphOn: anObject withLabel: aLabel	"(Inspector openAsMorphOn: SystemOrganization) openInMVC"	| window inspector |	inspector _ self inspect: anObject.	window _ (SystemWindow labelled: aLabel) model: inspector.	window addMorph: ((PluggableListMorph on: inspector list: #fieldList				selected: #selectionIndex changeSelected: #toggleIndex:				menu: ((inspector isMemberOf: DictionaryInspector)						ifTrue: [#dictionaryMenu:]						ifFalse: [#fieldListMenu:])				keystroke: #inspectorKey:from:) doubleClickSelector: #inspectSelection)		frame: (0@0 corner: self horizontalDividerProportion @ self verticalDividerProportion).	window addMorph: (PluggableTextMorph on: inspector text: #contents accept: #accept:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (self horizontalDividerProportion @0 corner: 1@self verticalDividerProportion).	window addMorph: ((PluggableTextMorph on: inspector text: #trash accept: #trash:				readSelection: #contentsSelection menu: #codePaneMenu:shifted:)					askBeforeDiscardingEdits: false)		frame: (0@self verticalDividerProportion corner: 1@1).	window setUpdatablePanesFrom: #(fieldList).	window position: 16@0.  "Room for scroll bar."	^ window! !!Inspector class methodsFor: 'instance creation' stamp: 'di 2/16/2000 10:52'!openOn: anObject withEvalPane: withEval withLabel: label	Smalltalk isMorphic ifTrue:		[^ self openAsMorphOn: anObject withEvalPane: withEval			withLabel: label valueViewClass: nil].	^ self openOn: anObject 		withEvalPane: withEval 		withLabel: label 		valueViewClass: PluggableTextView! !!Inspector class methodsFor: 'instance creation' stamp: 'di 2/16/2000 10:52'!openOn: anObject withEvalPane: withEval withLabel: label valueViewClass: valueViewClass	| topView inspector listView valueView evalView |	inspector _ self inspect: anObject.	topView _ StandardSystemView new model: inspector.	topView borderWidth: 1.	listView _ PluggableListView on: inspector		list: #fieldList		selected: #selectionIndex		changeSelected: #toggleIndex:		menu: #fieldListMenu:		keystroke: #inspectorKey:from:.	(inspector isMemberOf: DictionaryInspector)		ifTrue: [listView menu: #dictionaryMenu:].	listView window: (0 @ 0 extent: 40 @ 40).	topView addSubView: listView.	valueView _ valueViewClass new.		"PluggableTextView or PluggableFormView"	(valueView respondsTo: #getText) ifTrue: [		valueView on: inspector 			text: #contents accept: #accept:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:].	(valueViewClass inheritsFrom: FormView) ifTrue: [		valueView model: inspector].	valueView window: (0 @ 0 extent: 75 @ 40).	topView addSubView: valueView toRightOf: listView.		withEval ifTrue:		[evalView _ PluggableTextView new on: inspector 			text: #trash accept: #trash:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.		evalView window: (0 @ 0 extent: 115 @ 20).		evalView askBeforeDiscardingEdits: false.		topView addSubView: evalView below: listView].	topView label: label.	topView minimumSize: 180 @ 120.	topView setUpdatablePanesFrom: #(fieldList).	topView controller open! !!Inspector class methodsFor: 'instance creation' stamp: 'sw 1/19/1999 14:38'!verticalDividerProportion	^ 0.7! !My instances can print the object code of a CompiledMethod in symbolic format. They print into an instance variable, stream, and uses oldPC to determine how many bytes to print in the listing. The inherited variable, sender, is used in an ugly way to hold the method being printed.!My instances can interpret the byte-encoded Smalltalk instruction set. They maintain a program counter (pc) for streaming through CompiledMethods. My subclasses are Contexts, which inherit this capability. They store the return pointer in the instance variable sender, and the current position in their method in the instance variable pc. For other users, sender can hold a method to be similarly interpreted. The unclean re-use of sender to hold the method was to avoid a trivial subclass for the stand-alone scanning function.!!InstructionStream methodsFor: 'testing' stamp: 'di 1/29/2000 14:42'!willJumpIfTrue 	"Answer whether the next bytecode is a jump-if-true." 	| byte |	byte _ self method at: pc.	^ byte between: 168 and: 171! !I am a common abstract superclass for all Integer implementations. My implementation subclasses are SmallInteger, LargePositiveInteger, and LargeNegativeInteger.	Integer division consists of:	/	exact division, answers a fraction if result is not a whole integer	//	answers an Integer, rounded towards negative infinity	\\	is modulo rounded towards negative infinity	quo: truncated division, rounded towards zero!!Integer methodsFor: 'testing' stamp: 'ar 6/9/2000 18:56'!isPowerOfTwo	"Return true if the receiver is an integral power of two."	^ (self bitAnd: self-1) = 0! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59'!* aNumber	"Refer to the comment in Number * " 	aNumber isInteger ifTrue:		[^ self digitMultiply: aNumber 					neg: self negative ~~ aNumber negative].	^ aNumber adaptToInteger: self andSend: #*! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59'!+ aNumber	"Refer to the comment in Number + "	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [^ (self digitAdd: aNumber) normalize]			ifFalse: [^ self digitSubtract: aNumber]].	^ aNumber adaptToInteger: self andSend: #+! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 13:59'!- aNumber	"Refer to the comment in Number - "	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [^ self digitSubtract: aNumber]			ifFalse: [^ (self digitAdd: aNumber) normalize]].	^ aNumber adaptToInteger: self andSend: #-! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:00'!/ aNumber	"Refer to the comment in Number / "	| quoRem |	aNumber isInteger ifTrue:		[quoRem _ self digitDiv: aNumber abs	"*****I've added abs here*****"						neg: self negative ~~ aNumber negative.		(quoRem at: 2) = 0			ifTrue: [^ (quoRem at: 1) normalize]			ifFalse: [^ (Fraction numerator: self denominator: aNumber) reduced]].	^ aNumber adaptToInteger: self andSend: #/! !!Integer methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:00'!quo: aNumber 	"Refer to the comment in Number quo: "	| ng quo |	aNumber isInteger ifTrue: 		[ng _ self negative == aNumber negative == false.		quo _ (self digitDiv:			(aNumber class == SmallInteger				ifTrue: [aNumber abs]				ifFalse: [aNumber])			neg: ng) at: 1.		^ quo normalize].	^ aNumber adaptToInteger: self andSend: #quo:! !!Integer methodsFor: 'comparing' stamp: 'di 11/6/1998 14:00'!< aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^ (self digitCompare: aNumber) > 0]						ifFalse: [^ (self digitCompare: aNumber) < 0]]			ifFalse: [^ self negative]].	^ aNumber adaptToInteger: self andSend: #<! !!Integer methodsFor: 'comparing' stamp: 'di 11/6/1998 14:00'!= aNumber	aNumber isNumber ifFalse: [^ false].	aNumber isInteger ifTrue:		[aNumber negative == self negative			ifTrue: [^ (self digitCompare: aNumber) = 0]			ifFalse: [^ false]].	^ aNumber adaptToInteger: self andSend: #=! !!Integer methodsFor: 'comparing' stamp: 'di 11/6/1998 14:00'!> aNumber	aNumber isInteger ifTrue:		[self negative == aNumber negative			ifTrue: [self negative						ifTrue: [^(self digitCompare: aNumber) < 0]						ifFalse: [^(self digitCompare: aNumber) > 0]]			ifFalse: [^ aNumber negative]].	^ aNumber adaptToInteger: self andSend: #>! !!Integer methodsFor: 'truncation and round off' stamp: 'sma 5/12/2000 12:35'!atRandom	"Answer a random integer from 1 to self.  This implementation uses a	shared generator. Heavy users should their own implementation or use	Interval>atRandom: directly."	^ self atRandom: Collection randomForPicking! !!Integer methodsFor: 'truncation and round off' stamp: 'sma 5/12/2000 12:35'!atRandom: aGenerator	"Answer a random integer from 1 to self picked from aGenerator."	^ aGenerator nextInt: self! !!Integer methodsFor: 'mathematical functions' stamp: 'LC 6/17/1998 19:22'!gcd: anInteger	"See Knuth, Vol 2, 4.5.2, Algorithm L"	"Initialize"	| higher u v k uHat vHat a b c d vPrime vPrimePrime q t |	higher _ SmallInteger maxVal highBit.	u _ self abs max: (v _ anInteger abs).	v _ self abs min: v.	[v class == SmallInteger]		whileFalse: 			[(uHat _ u bitShift: (k _ higher - u highBit)) class == SmallInteger				ifFalse: 					[k _ k - 1.					uHat _ uHat bitShift: -1].			vHat _ v bitShift: k.			a _ 1.			b _ 0.			c _ 0.			d _ 1.			"Test quotient"			[(vPrime _ vHat + d) ~= 0				and: [(vPrimePrime _ vHat + c) ~= 0 and: [(q _ uHat + a // vPrimePrime) = (uHat + b // vPrime)]]]				whileTrue: 					["Emulate Euclid"					c _ a - (q * (a _ c)).					d _ b - (q * (b _ d)).					vHat _ uHat - (q * (uHat _ vHat))].			"Multiprecision step"			b = 0				ifTrue: 					[v _ u rem: (u _ v)]				ifFalse: 					[t _ u * a + (v * b).					v _ u * c + (v * d).					u _ t]].	^ v gcd: u! !!Integer methodsFor: 'bit manipulation' stamp: 'dwh 8/18/1999 21:57'!>> shiftAmount  "right shift"	shiftAmount < 0 ifTrue: [self error: 'negative arg'].	^ self bitShift: 0 - shiftAmount! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/9/2000 10:14'!anyBitOfMagnitudeFrom: start to: stopArg 	"Tests for any magnitude bits in the interval from start to stopArg."	| magnitude firstDigitIx lastDigitIx rightShift leftShift stop |	<primitive: 'primAnyBitFromTo' module:'LargeIntegers'>	start < 1 | (stopArg < 1) ifTrue: [^ self error: 'out of range'].	magnitude _ self abs.	stop _ stopArg min: magnitude highBit.	start > stop ifTrue: [^ false].	firstDigitIx _ start - 1 // 8 + 1.	lastDigitIx _ stop - 1 // 8 + 1.	rightShift _ (start - 1 \\ 8) negated.	leftShift _ 7 - (stop - 1 \\ 8).	firstDigitIx = lastDigitIx		ifTrue: 			[| digit mask | 			mask _ (255 bitShift: rightShift negated)						bitAnd: (255 bitShift: leftShift negated).			digit _ magnitude digitAt: firstDigitIx.			^ (digit bitAnd: mask)				~= 0].	((magnitude digitAt: firstDigitIx)		bitShift: rightShift)		~= 0 ifTrue: [^ true].	firstDigitIx + 1 to: lastDigitIx - 1 do: [:ix | (magnitude digitAt: ix)			~= 0 ifTrue: [^ true]].	((magnitude digitAt: lastDigitIx)		bitShift: leftShift)		~= 0 ifTrue: [^ true].	^ false! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 3/13/2000 17:47'!bitAnd: n 	"Answer an Integer whose bits are the logical AND of the receiver's bits  	and those of the argument, n."	| norm |	<primitive: 'primDigitBitAnd' module:'LargeIntegers'>	norm _ n normalize.	^ self		digitLogic: norm		op: #bitAnd:		length: (self digitLength max: norm digitLength)! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 3/13/2000 17:47'!bitOr: n 	"Answer an Integer whose bits are the logical OR of the receiver's bits  	and those of the argument, n."	| norm |	<primitive: 'primDigitBitOr' module:'LargeIntegers'>	norm _ n normalize.	^ self		digitLogic: norm		op: #bitOr:		length: (self digitLength max: norm digitLength)! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/9/2000 10:09'!bitShift: shiftCount 	"Answer an Integer whose value (in twos-complement representation) is  	the receiver's value (in twos-complement representation) shifted left by 	the number of bits indicated by the argument. Negative arguments  	shift right. Zeros are shifted in from the right in left shifts."	| magnitudeShift |	magnitudeShift _ self bitShiftMagnitude: shiftCount.	^ ((self negative and: [shiftCount negative])		and: [self anyBitOfMagnitudeFrom: 1 to: shiftCount negated])		ifTrue: [magnitudeShift - 1]		ifFalse: [magnitudeShift]! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/9/2000 14:02'!bitShiftMagnitude: shiftCount 	"Answer an Integer whose value (in magnitude representation) is  	the receiver's value (in magnitude representation) shifted left by  	the number of bits indicated by the argument. Negative arguments	shift right. Zeros are shifted in from the right in left shifts."	| rShift |	<primitive: 'primDigitBitShiftMagnitude' module:'LargeIntegers'>	shiftCount >= 0 ifTrue: [^ self digitLshift: shiftCount].	rShift _ 0 - shiftCount.	^ (self		digitRshift: (rShift bitAnd: 7)		bytes: (rShift bitShift: -3)		lookfirst: self digitLength) normalize! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 3/13/2000 17:47'!bitXor: n 	"Answer an Integer whose bits are the logical XOR of the receiver's bits  	and those of the argument, n."	| norm |	<primitive: 'primDigitBitXor' module:'LargeIntegers'>	norm _ n normalize.	^ self		digitLogic: norm		op: #bitXor:		length: (self digitLength max: norm digitLength)! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:13'!highBit	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to  	get the highest bit of the magnitude."	^ self subclassResponsibility! !!Integer methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 01:55'!highBitOfMagnitude	"Answer the index of the high order bit of the magnitude of the  	receiver, or zero if the receiver is zero."	^ self subclassResponsibility! !!Integer methodsFor: 'converting' stamp: 'di 11/6/1998 13:43'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert me to a Fraction."	^ rcvr perform: selector with: self asFraction! !!Integer methodsFor: 'converting' stamp: 'ar 10/31/1998 23:04'!asColorOfDepth: d	"Return a color value representing the receiver as color of the given depth"	^Color colorFromPixelValue: self depth: d! !!Integer methodsFor: 'converting' stamp: 'di 1/13/1999 12:45'!asFloat	"Answer a Float that represents the value of the receiver.	Optimized to process only the significant digits of a LargeInteger.	SqR: 11/30/1998 21:11"	| sum firstByte shift |	shift _ 0.	sum _ 0.0.	firstByte _ self size - 7 max: 1.	firstByte to: self size do:		[:byteIndex | 		sum _ ((self digitAt: byteIndex) asFloat timesTwoPower: shift) + sum.		shift _ shift + 8].	^sum * self sign asFloat timesTwoPower: firstByte - 1 * 8! !!Integer methodsFor: 'converting' stamp: 'ls 5/26/1998 20:53'!asHexDigit	^'0123456789ABCDEF' at: self+1! !!Integer methodsFor: 'printing' stamp: 'sw 11/24/1998 14:53'!asStringWithCommas	"123456789 asStringWithCommas"	"-123456789 asStringWithCommas"	| digits |	digits _ self abs printString.	^ String streamContents:		[:strm | 		self sign = -1 ifTrue: [strm nextPut: $-].		1 to: digits size do: 			[:i | strm nextPut: (digits at: i).			(i < digits size and: [(i - digits size) \\ 3 = 0])				ifTrue: [strm nextPut: $,]]]! !!Integer methodsFor: 'printing' stamp: 'sw 11/13/1999 23:00'!asTwoCharacterString	"Answer a two-character string representing the receiver, with leading zero if required.  Intended for use with integers in the range 0 to 99, but plausible replies given for other values too"	^ (self >= 0 and: [self < 10])		ifTrue:	['0', self printString]		ifFalse:	[self printString copyFrom: 1 to: 2]"2 asTwoCharacterString11 asTwoCharacterString1943 asTwoCharacterString0 asTwoCharacterString-2 asTwoCharacterString-234 asTwoCharacterString"! !!Integer methodsFor: 'printing' stamp: 'MPW 1/1/1901 00:14'!destinationBuffer:digitLength  digitLength <= 1		ifTrue: [self]		ifFalse: [LargePositiveInteger new: digitLength].! !!Integer methodsFor: 'printing' stamp: 'MPW 1/1/1901 00:16'!digitBuffer:digitLength  ^Array new:digitLength*8.! !!Integer methodsFor: 'printing' stamp: 'MPW 1/1/1901 01:04'!printOn: aStream base: b 	"Print a representation of the receiver on the stream, aStream, in base, b, 	where 2<=b<=16."	| digits source dest i j pos t rem |	self negative ifTrue:[aStream nextPut:$-].	b = 10 ifFalse: [aStream print: b; nextPut: $r].	i _ self digitLength.	"Estimate size of result, conservatively"	digits _ Array new: i * 8.	pos _ 0.	dest _ i <= 1		ifTrue: [self]		ifFalse: [LargePositiveInteger new: i].	source _ self.	[i >= 1]		whileTrue: 			[rem _ 0.			j _ i.			[j > 0]				whileTrue: 					[t _ (rem bitShift: 8) + (source digitAt: j).					dest digitAt: j put: t // b.					rem _ t \\ b.					j _ j - 1].			pos _ pos + 1.			digits at: pos put: rem.			source _ dest.			(source digitAt: i) = 0 ifTrue: [i _ i - 1]].	"(dest digitAt: 1) printOn: aStream base: b."	[pos > 0]		whileTrue:			[aStream nextPut: (Character digitValue: (digits at: pos)).			pos _ pos - 1]! !!Integer methodsFor: 'printing' stamp: 'jm 5/22/2003 19:33'!romanString	"Answer myself as represented in Roman numerals."	"1999 romanString"	self assert: [self > 0].	^ String streamContents: [:s |		self // 1000 timesRepeat: [s nextPut: $M].		self romanDigits: 'MDC' for: 100 on: s.		self romanDigits: 'CLX' for: 10 on: s.		self romanDigits: 'XVI' for: 1 on: s]! !!Integer methodsFor: 'system primitives' stamp: 'tk 3/24/1999 20:26'!lastDigit	"Answer the last digit of the integer base 256.  LargePositiveInteger uses bytes of base two number, and each is a 'digit'."	^self digitAt: self digitLength! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:41'!digitAdd: arg 	| len arglen accum sum |	<primitive: 'primDigitAdd' module:'LargeIntegers'>	accum _ 0.	(len _ self digitLength) < (arglen _ arg digitLength) ifTrue: [len _ arglen].	"Open code max: for speed"	sum _ Integer new: len neg: self negative.	1 to: len do: 		[:i | 		accum _ (accum bitShift: -8)					+ (self digitAt: i) + (arg digitAt: i).		sum digitAt: i put: (accum bitAnd: 255)].	accum > 255		ifTrue: 			[sum _ sum growby: 1.			sum at: sum digitLength put: (accum bitShift: -8)].	^ sum! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:43'!digitCompare: arg 	"Compare the magnitude of self with that of arg.   	Return a code of 1, 0, -1 for self >, = , < arg"	| len arglen argDigit selfDigit |	<primitive: 'primDigitCompare' module:'LargeIntegers'>	len _ self digitLength.	(arglen _ arg digitLength) ~= len		ifTrue: [arglen > len				ifTrue: [^ -1]				ifFalse: [^ 1]].	[len > 0]		whileTrue: 			[(argDigit _ arg digitAt: len) ~= (selfDigit _ self digitAt: len)				ifTrue: [argDigit < selfDigit						ifTrue: [^ 1]						ifFalse: [^ -1]].			len _ len - 1].	^ 0! !!Integer methodsFor: 'private' stamp: 'jm 5/22/2003 19:57'!digitDiv: arg neg: ng 	"Answer with an array of (quotient, remainder)."	| quo rem ql d div dh dnh dl qhi qlo j l hi lo r3 a t |	<primitive: 'primDigitDivNegative' module:'LargeIntegers'>	arg = 0 ifTrue: [^ self error: 'division by 0'].	"TFEI added this line"	l _ self digitLength - arg digitLength + 1.	l <= 0 ifTrue: [^ Array with: 0 with: self].	"shortcut against #highBit"	d _ 8 - arg lastDigit highBitOfPositiveReceiver.	div _ arg digitLshift: d.	div _ div growto: div digitLength + 1.	"shifts so high order word is >=128"	rem _ self digitLshift: d.	rem digitLength = self digitLength ifTrue: [rem _ rem growto: self digitLength + 1].	"makes a copy and shifts"	quo _ Integer new: l neg: ng.	dl _ div digitLength - 1.	"Last actual byte of data"	ql _ l.	dh _ div digitAt: dl.	dnh _ dl = 1				ifTrue: [0]				ifFalse: [div digitAt: dl - 1].	1 to: ql do: 		[:k | 		"maintain quo*arg+rem=self"		"Estimate rem/div by dividing the leading to bytes of rem by dh."		"The estimate is q = qhi*16+qlo, where qhi and qlo are nibbles."		j _ rem digitLength + 1 - k.		"r1 _ rem digitAt: j."		(rem digitAt: j)			= dh			ifTrue: [qhi _ qlo _ 15				"i.e. q=255"]			ifFalse: 				["Compute q = (r1,r2)//dh, t = (r1,r2)\\dh.  				Note that r1,r2 are bytes, not nibbles.  				Be careful not to generate intermediate results exceeding 13  				bits."				"r2 _ (rem digitAt: j - 1)."				t _ ((rem digitAt: j)							bitShift: 4)							+ ((rem digitAt: j - 1)									bitShift: -4).				qhi _ t // dh.				t _ (t \\ dh bitShift: 4)							+ ((rem digitAt: j - 1)									bitAnd: 15).				qlo _ t // dh.				t _ t \\ dh.				"Next compute (hi,lo) _ q*dnh"				hi _ qhi * dnh.				lo _ qlo * dnh + ((hi bitAnd: 15)								bitShift: 4).				hi _ (hi bitShift: -4)							+ (lo bitShift: -8).				lo _ lo bitAnd: 255.				"Correct overestimate of q.  				Max of 2 iterations through loop -- see Knuth vol. 2"				r3 _ j < 3							ifTrue: [0]							ifFalse: [rem digitAt: j - 2].				[(t < hi					or: [t = hi and: [r3 < lo]])					and: 						["i.e. (t,r3) < (hi,lo)"						qlo _ qlo - 1.						lo _ lo - dnh.						lo < 0							ifTrue: 								[hi _ hi - 1.								lo _ lo + 256].						hi >= dh]]					whileTrue: [hi _ hi - dh].				qlo < 0					ifTrue: 						[qhi _ qhi - 1.						qlo _ qlo + 16]].		"Subtract q*div from rem"		l _ j - dl.		a _ 0.		1 to: div digitLength do: 			[:i | 			hi _ (div digitAt: i)						* qhi.			lo _ a + (rem digitAt: l) - ((hi bitAnd: 15)							bitShift: 4) - ((div digitAt: i)							* qlo).			rem digitAt: l put: lo - (lo // 256 * 256).			"sign-tolerant form of (lo bitAnd: 255)"			a _ lo // 256 - (hi bitShift: -4).			l _ l + 1].		a < 0			ifTrue: 				["Add div back into rem, decrease q by 1"				qlo _ qlo - 1.				l _ j - dl.				a _ 0.				1 to: div digitLength do: 					[:i | 					a _ (a bitShift: -8)								+ (rem digitAt: l) + (div digitAt: i).					rem digitAt: l put: (a bitAnd: 255).					l _ l + 1]].		quo digitAt: quo digitLength + 1 - k put: (qhi bitShift: 4)				+ qlo].	rem _ rem				digitRshift: d				bytes: 0				lookfirst: dl.	^ Array with: quo with: rem! !!Integer methodsFor: 'private' stamp: 'sr 6/8/2000 01:30'!digitLshift: shiftCount 	| carry rShift mask len result digit byteShift bitShift highBit |	(highBit _ self highBitOfMagnitude) = 0 ifTrue: [^ 0].	len _ highBit + shiftCount + 7 // 8.	result _ Integer new: len neg: self negative.	byteShift _ shiftCount // 8.	bitShift _ shiftCount \\ 8.	bitShift = 0 ifTrue: ["Fast version for byte-aligned shifts"		^ result			replaceFrom: byteShift + 1			to: len			with: self			startingAt: 1].	carry _ 0.	rShift _ bitShift - 8.	mask _ 255 bitShift: 0 - bitShift.	1 to: byteShift do: [:i | result digitAt: i put: 0].	1 to: len - byteShift do: 		[:i | 		digit _ self digitAt: i.		result digitAt: i + byteShift put: (((digit bitAnd: mask)				bitShift: bitShift)				bitOr: carry).		carry _ digit bitShift: rShift].	^ result! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:46'!digitMultiply: arg neg: ng 	| prod prodLen carry digit k ab |	<primitive: 'primDigitMultiplyNegative' module:'LargeIntegers'>	(arg digitLength = 1 and: [(arg digitAt: 1)			= 0])		ifTrue: [^ 0].	(self digitLength = 1 and: [(self digitAt: 1)			= 0])		ifTrue: [^ 0].	prodLen _ self digitLength + arg digitLength.	prod _ Integer new: prodLen neg: ng.	"prod starts out all zero"	1 to: self digitLength do: [:i | (digit _ self digitAt: i) ~= 0			ifTrue: 				[k _ i.				carry _ 0.				"Loop invariant: 0<=carry<=0377, k=i+j-1"				1 to: arg digitLength do: 					[:j | 					ab _ (arg digitAt: j)								* digit + carry + (prod digitAt: k).					carry _ ab bitShift: -8.					prod digitAt: k put: (ab bitAnd: 255).					k _ k + 1].				prod digitAt: k put: carry]].	^ prod normalize! !!Integer methodsFor: 'private' stamp: 'sr 1/23/2000 05:46'!digitSubtract: arg 	| smaller larger z sum sl al ng |	<primitive: 'primDigitSubtract' module:'LargeIntegers'>	sl _ self digitLength.	al _ arg digitLength.	(sl = al		ifTrue: 			[[(self digitAt: sl)				= (arg digitAt: sl) and: [sl > 1]]				whileTrue: [sl _ sl - 1].			al _ sl.			(self digitAt: sl)				< (arg digitAt: sl)]		ifFalse: [sl < al])		ifTrue: 			[larger _ arg.			smaller _ self.			ng _ self negative == false.			sl _ al]		ifFalse: 			[larger _ self.			smaller _ arg.			ng _ self negative].	sum _ Integer new: sl neg: ng.	z _ 0.	"Loop invariant is -1<=z<=1"	1 to: sl do: 		[:i | 		z _ z + (larger digitAt: i) - (smaller digitAt: i).		sum digitAt: i put: z - (z // 256 * 256).		"sign-tolerant form of (z bitAnd: 255)"		z _ z // 256].	^ sum normalize! !!Integer methodsFor: 'private' stamp: 'sma 5/20/2000 17:00'!romanDigits: digits for: base on: aStream	| n |	n _ self \\ (base * 10) // base.	n = 9 ifTrue: [^ aStream nextPut: digits last; nextPut: digits first].	n = 4 ifTrue: [^ aStream nextPut: digits last; nextPut: digits second].	n > 4 ifTrue: [aStream nextPut: digits second].	n \\ 5 timesRepeat: [aStream nextPut: digits last]! !!Integer methodsFor: 'benchmarks' stamp: 'jm 11/20/1998 07:06'!benchFib  "Handy send-heavy benchmark"	"(result // seconds to run) = approx calls per second"	" | r t |	  t _ Time millisecondsToRun: [r _ 26 benchFib].	  (r * 1000) // t"	"138000 on a Mac 8100/100"	^ self < 2		ifTrue: [1] 		ifFalse: [(self-1) benchFib + (self-2) benchFib + 1]! !!Integer methodsFor: 'benchmarks' stamp: 'di 4/11/1999 11:20'!benchmark  "Handy bytecode-heavy benchmark"	"(500000 // time to run) = approx bytecodes per second"	"5000000 // (Time millisecondsToRun: [10 benchmark]) * 1000"	"3059000 on a Mac 8100/100"    | size flags prime k count |    size _ 8190.    1 to: self do:        [:iter |        count _ 0.        flags _ (Array new: size) atAllPut: true.        1 to: size do:            [:i | (flags at: i) ifTrue:                [prime _ i+1.                k _ i + prime.                [k <= size] whileTrue:                    [flags at: k put: false.                    k _ k + prime].                count _ count + 1]]].    ^ count! !!Integer methodsFor: 'benchmarks' stamp: 'dwh 11/21/1999 16:40'!tinyBenchmarks	"Report the results of running the two tiny Squeak benchmarks.	ar 9/10/1999: Adjusted to run at least 1 sec to get more stable results"	"0 tinyBenchmarks"	"On a 292 MHz G3 Mac: 22727272 bytecodes/sec; 984169 sends/sec"	"On a 400 MHz PII/Win98:  18028169 bytecodes/sec; 1081272 sends/sec"	| t1 t2 r n1 n2 |	n1 _ 1.	[t1 _ Time millisecondsToRun: [n1 benchmark].	t1 < 1000] whileTrue:[n1 _ n1 * 2]. "Note: #benchmark's runtime is about O(n)"	n2 _ 28.	[t2 _ Time millisecondsToRun: [r _ n2 benchFib].	t2 < 1000] whileTrue:[n2 _ n2 + 1]. 	"Note: #benchFib's runtime is about O(k^n),		where k is the golden number = (1 + 5 sqrt) / 2 = 1.618...."	^ ((n1 * 500000 * 1000) // t1) printString, ' bytecodes/sec; ',	  ((r * 1000) // t2) printString, ' sends/sec'! !!Integer class methodsFor: 'instance creation' stamp: 'tk 4/20/1999 14:18'!basicNew	self == Integer ifTrue: [		^ self error: 'Integer is an abstract class.  Make a concrete subclass.'].	^ super basicNew! !!Integer class methodsFor: 'instance creation' stamp: 'tk 4/18/1999 22:01'!new	self == Integer ifTrue: [		^ self error: 'Integer is an abstract class.  Make a concrete subclass.'].	^ super new! !!Integer class methodsFor: 'instance creation' stamp: 'ls 6/23/1999 20:37'!readFrom: aStream base: base 	"Answer an instance of one of my concrete subclasses. Initial minus sign 	accepted, and bases > 10 use letters A-Z. Embedded radix specifiers not 	allowed--use Number readFrom: for that. Answer zero (not an error) if 	there are no digits."	| digit value neg startPos |	neg _ aStream peekFor: $-.	neg ifFalse: [aStream peekFor: $+].	value _ 0.	startPos _ aStream position.	[aStream atEnd]		whileFalse: 			[digit _ aStream next digitValue.			(digit < 0 or: [digit >= base])				ifTrue: 					[aStream skip: -1.					aStream position = startPos ifTrue: [self error: 'At least one digit expected here'].					neg ifTrue: [^ value negated].					^ value]				ifFalse: [value _ value * base + digit]].	neg ifTrue: [^ value negated].	^ value! !IntegerArrays store 32bit signed Integer values.Negative values are stored as 2's complement.!!IntegerArray methodsFor: 'accessing'!at: index	| word |	word _ self basicAt: index.	word < 16r3FFFFFFF ifTrue:[^word]. "Avoid LargeInteger computations"	^word >= 16r80000000	"Negative?!!"		ifTrue:["word - 16r100000000"				(word bitInvert32 + 1) negated]		ifFalse:[word]! !!IntegerArray methodsFor: 'accessing' stamp: 'jm 3/19/1999 09:35'!at: index put: anInteger	| word |	anInteger < 0		ifTrue:["word _ 16r100000000 + anInteger"				word _ (anInteger + 1) negated bitInvert32]		ifFalse:[word _ anInteger].	self  basicAt: index put: word.	^anInteger! !!IntegerArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0! !!IntegerArray methodsFor: 'converting' stamp: 'ar 10/10/1998 16:18'!asIntegerArray	^self! !I represent a finite arithmetic progression.!!Interval methodsFor: 'accessing' stamp: 'rpj 11/30/1999 11:04'!includes: aNumber	"Determine if aNumber is an element of this interval."	^ (self rangeIncludes: aNumber) and: [ self valuesInclude: aNumber ]! !!Interval methodsFor: 'accessing' stamp: 'di 12/6/1999 11:00'!rangeIncludes: aNumber	"Return true if the number lies in the interval between start and stop."	step >= 0		ifTrue: [^ aNumber between: start and: stop]		ifFalse: [^ aNumber between: stop and: start]! !!Interval methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:38'!size	"Answer how many elements the receiver contains."	step < 0		ifTrue: [start < stop				ifTrue: [^ 0]				ifFalse: [^ stop - start // step + 1]]		ifFalse: [stop < start				ifTrue: [^ 0]				ifFalse: [^ stop - start // step + 1]]! !!Interval methodsFor: 'copying' stamp: 'sma 3/3/2000 13:18'!shallowCopy	"Without this method, #copy would return an array instead of a new interval.	The whole problem is burried in the class hierarchy and every fix will worsen	the problem, so once the whole issue is resolved one should come back to this 	method fix it."	^ self class from: start to: stop by: step! !!Interval methodsFor: 'printing' stamp: 'sma 6/1/2000 09:50'!printOn: aStream	aStream nextPut: $(;	 print: start;	 nextPutAll: ' to: ';	 print: stop.	step ~= 1 ifTrue: [aStream nextPutAll: ' by: '; print: step].	aStream nextPut: $)! !!Interval methodsFor: 'private' stamp: 'di 4/24/2000 13:56'!valuesInclude: aNumber	"Private - answer whether or not aNumber is one of the enumerated values in this interval."	| val |	val _ (aNumber - self first) asFloat / self increment.	^ val fractionPart abs < (step * 1.0e-10)! !JPEGMovieFile exploits the fast JPEG plugin to support a new, compressed movie format: JPEG movies.A JPEG movie file (usually ending in '.jmv') contains a header, the JPEG compressed frames of the movie, and possibly one or more sound tracks. JPEGMovieFile responds to a subset of the protocol for MPEGFile so that a JPEG movie can be played by MovieDisplayMorph as if it were an MPEG movie. JPEG movies can be created, manipulated, and edited using only Squeak, whereas other tools must be used to create an MPEG movie because there is no MPEG encoder for Squeak. On the other hand, JPEG movies tend to be 1.5 to 3.0 times the size of an MPEG movie of similar quality, excluding the soundtrack. The class JPEGMovieFile contains methods for converting both MPEG movies into JPEG movies.JPEG movies can have a monoaural soundtrack encoded using various simple audio compression schemes. Again, since there is no MP3 encoder for Squeak, the soundtracks of JPEG movies aresubstantially larger than that of MPEG movies. (For voice only narration, GSM provides better compression than MP3, but unfortunately GSM tends to distort music.)!!JPEGMovieFile methodsFor: 'initialization' stamp: 'jm 11/15/2001 08:13'!initialize	file _ nil.	frameOffsets _ #().	currentFrameIndex _ 1.! !!JPEGMovieFile methodsFor: 'access' stamp: 'jm 12/18/2003 11:49'!currentSeconds: streamIndex	"Answer the position of the stream with the given index in seconds."	^ (self videoGetFrame: streamIndex) asFloat / (self videoFrameRate: streamIndex)! !!JPEGMovieFile methodsFor: 'access' stamp: 'jm 11/21/2003 12:42'!duration: streamIndex	"Answer my duration in seconds. If I have audio, this is the duration of my audio track. Otherwise, it computed from my frame count and frame rate."	self hasAudio		ifTrue: [^ (self audioPlayerForChannel: streamIndex) duration]		ifFalse: [^ (self videoFrames: streamIndex) asFloat / (self videoFrameRate: streamIndex)].! !!JPEGMovieFile methodsFor: 'access' stamp: 'jm 11/24/2003 12:03'!jumpToSeconds: seconds stream: streamIndex	"Set the position of the stream with the given index to the given number of seconds since the start."	| player frameIndex |	seconds < 0 ifTrue: [^ self jumpToSeconds: 0 stream: streamIndex].	self hasAudio		ifTrue: [			player _ self audioPlayerForChannel: streamIndex.			player soundPosition: seconds / player duration]		ifFalse: [			frameIndex _ seconds * (self videoFrameRate: streamIndex).			self videoSetFrame: frameIndex stream: streamIndex].! !!JPEGMovieFile methodsFor: 'file ops' stamp: 'jm 3/16/2003 21:19'!closeFile	"Close my file stream."	file ifNotNil: [file finalize].	file _ nil.! !!JPEGMovieFile methodsFor: 'file ops' stamp: 'jm 11/14/2001 14:13'!fileHandle	"Answer my file, or nil if the file is not open."	file ifNil: [^ nil].	file closed ifTrue: [^ nil].	^ file! !!JPEGMovieFile methodsFor: 'file ops' stamp: 'jm 11/15/2001 07:59'!fileName	"Answer the name of my file."	file ifNil: [^ ''].	^ file fullName! !!JPEGMovieFile methodsFor: 'file ops' stamp: 'jm 2/11/2002 13:09'!openFile: fileName	"For compatability with MPEGFile."	self openFileNamed: fileName.! !!JPEGMovieFile methodsFor: 'file ops' stamp: 'jm 2/11/2002 13:30'!openFileNamed: fileName	"Open the JPEG movie file with the given name."	file ifNotNil: [file finalize].	file _ nil.	(FileDirectory default fileExists: fileName) ifFalse: [^ self].	file _ (FileStream readOnlyFileNamed: fileName) binary.	self readHeader.	currentFrameIndex _ 1.! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/20/2001 16:08'!hasVideo	"Answer true if I have one or more frames."	^ frameOffsets size > 1  "note: the empty movie still has one frameOffset"! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/14/2001 14:18'!videoDropFrames: skipCount stream: streamIndex	"Advance the index of the current frame by the given number of frames."	self videoSetFrame: currentFrameIndex + skipCount stream: streamIndex.! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/15/2001 08:08'!videoFrameHeight: ignored	"Answer the height of this movie."	^ movieExtent y! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/15/2001 07:37'!videoFrameRate: ignored	"Answer the frame rate of this movie."	^ frameRate! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/15/2001 08:08'!videoFrameWidth: ignored	"Answer the width of this movie."	^ movieExtent x! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/15/2001 07:34'!videoFrames: ignored	"Answer the number of video frames in this movie."	^ (frameOffsets size - 1) max: 0! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/14/2001 14:05'!videoGetFrame: ignored	"Answer the index of the current frame, or zero if the movie has no frames."	^ currentFrameIndex! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 10/27/2002 10:52'!videoReadFrameInto: aForm stream: aStream	"Read the next frame into the given 16-bit or 32-bit Form."	| compressedBytes |	compressedBytes _ self bytesForFrame: currentFrameIndex.	compressedBytes ifNil: [^ self].	FastJPEG uncompress: compressedBytes into: aForm.	currentFrameIndex _ (currentFrameIndex + 1) min: (frameOffsets size - 1).! !!JPEGMovieFile methodsFor: 'video' stamp: 'jm 11/15/2001 08:10'!videoSetFrame: newIndex stream: ignored	"Set the index of the current frame."	currentFrameIndex _ (newIndex asInteger max: 1) min: (frameOffsets size - 1).! !!JPEGMovieFile methodsFor: 'audio' stamp: 'jm 11/17/2001 09:49'!audioPlayerForChannel: anInteger	"Answer a streaming sound for playing the audio channel with the given index."	((anInteger >= 1) & (anInteger <= soundtrackOffsets size)) ifFalse: [^ nil].	^ StreamingMonoSound		onFileNamed: file fullName		headerStart: (soundtrackOffsets at: anInteger)! !!JPEGMovieFile methodsFor: 'audio' stamp: 'jm 11/16/2001 17:03'!hasAudio	"Answer true if this movie has at least one sound track."	^ soundtrackOffsets size > 0! !!JPEGMovieFile methodsFor: 'private' stamp: 'jm 11/15/2001 08:02'!bytesForFrame: frameIndex	"Answer a ByteArray containing the encoded bytes for the frame with the given index. Answer nil if the index is out of range or if my file is not open."	frameIndex < 1 ifTrue: [^ nil].	frameIndex >= frameOffsets size ifTrue: [^ nil].	file ifNil: [^ nil].	file closed ifTrue: [file ensureOpen; binary].	file position: (frameOffsets at: frameIndex).	^ file next: (frameOffsets at: frameIndex + 1) - (frameOffsets at: frameIndex)! !!JPEGMovieFile methodsFor: 'private' stamp: 'jm 11/16/2001 17:01'!readHeader	"Read a JPEG movie header file."	"Details: The file structures is:		<header, including sequence frame offsets>		<sequence of JPEG compressed images>		<optional soundtracks>"	| tag w h frameOffsetCount soundtrackCount |	file position: 0.	tag _ (file next: 10) asString.	tag = 'JPEG Movie' ifFalse: [self error: 'not a JPEG movie file'].	w _ file uint16.	h _ file uint16.	movieExtent _ w @ h.	frameRate _ file uint32 / 10000.0.	frameOffsetCount _ file uint32.	frameOffsets _ Array new: frameOffsetCount.	1 to: frameOffsetCount do: [:i | frameOffsets at: i put: file uint32].	soundtrackCount _ file uint16.	soundtrackOffsets _ Array new: soundtrackCount.	1 to: soundtrackCount do: [:i | soundtrackOffsets at: i put: file uint32].! !!JPEGMovieFile methodsFor: 'private' stamp: 'jm 12/13/2001 19:14'!soundtrackOffsets	"Answer the offsets for my soundtracks."	^ soundtrackOffsets! !!JPEGMovieFile methodsFor: 'private' stamp: 'jm 11/27/2001 10:23'!testPlay	"Performance benchmark. Decompress and display all my frames. Answer the frame rate achieved in frames/second. No sound is played."	| frameForm frameCount t |	frameForm _ Form extent: movieExtent depth: (Display depth max: 16).	frameCount _ self videoFrames: 0.	self videoSetFrame: 1 stream: 0.	t _ [		frameCount timesRepeat: [			self videoReadFrameInto: frameForm stream: 0.			frameForm display].	] timeToRun.	^ ((1000.0 * frameCount) / t) roundTo: 0.01! !!JPEGMovieFile class methodsFor: 'testing' stamp: 'jm 11/15/2001 14:56'!isJPEGMovieFile: fileName	"Answer true if the file with the given name appears to be a JPEG movie file."	| f tag |	(FileDirectory default fileExists: fileName) ifFalse: [^ false].	f _ (FileStream readOnlyFileNamed: fileName) binary.	tag _ (f next: 10) asString.	f close.	^ tag = 'JPEG Movie'! !!JPEGMovieFile class methodsFor: 'movie conversion' stamp: 'jm 1/25/2002 20:46'!convertFromFolderOfFramesNamed: folderName toJPEGMovieNamed: jpegFileName frameRate: frameRate quality: quality	"Convert a folder of frames into a JPEG movie. The named folder is assumed to contain only image files, all of the same size, and whose alphabetical order (case-insensitive) is the sequence in which they will appear in in the movie. A useful convention is to make the image files end in zero-padded frame numbers, for example 'frame0001.bmp', 'frame0002.bmp', etc. The image files can be any format readable by Form>fromFileNamed:. The movie frame extent is taken from the first frame file."	| jpegFile dir fileNames frameCount frameForm frameOffsets |	(FileDirectory default directoryExists: folderName)		ifFalse: [^ self inform: 'Folder not found: ', folderName].	jpegFile _ (FileStream newFileNamed: jpegFileName) binary.	dir _ FileDirectory default on: folderName.	fileNames _ self sortedByFrameNumber: dir fileNames.	frameCount _ fileNames size.	frameForm _ Form fromFileNamed: (dir fullNameFor: fileNames first).	"write header"	self writeHeaderExtent: frameForm extent		frameRate: frameRate		frameCount: frameCount		soundtrackCount: 0		on: jpegFile.	"convert and write frames"	frameOffsets _ Array new: frameCount + 1.	1 to: frameCount do: [:i |		frameOffsets at: i put: jpegFile position.		frameForm _ Form fromFileNamed: (dir fullNameFor: (fileNames at: i)).		self writeFrame: frameForm on: jpegFile quality: quality displayFlag: true].	frameOffsets at: (frameCount + 1) put: jpegFile position.	self updateFrameOffsets: frameOffsets on: jpegFile.	jpegFile close.	Display restore.! !!JPEGMovieFile class methodsFor: 'movie conversion' stamp: 'jm 12/13/2001 09:38'!convertMPEGFileNamed: mpegFileName toJPEGMovieNamed: jpegFileName quality: quality	"Convert the MPEG movie with the given file name into a JPEG movie with the given file name."	| mpegFile jpegFile soundtrackCount movieExtent frameOffsets soundTrackOffsets |	(FileDirectory default fileExists: mpegFileName)		ifFalse: [^ self inform: 'File not found: ', mpegFileName].	(MPEGFile isFileValidMPEG: mpegFileName)		ifFalse: [^ self inform: 'Not an MPEG file: ', mpegFileName].	mpegFile _ MPEGFile openFile: mpegFileName.	mpegFile fileHandle ifNil: [^ self inform: 'Could not open ', mpegFileName].	jpegFile _ (FileStream newFileNamed: jpegFileName) binary.	"write header"	soundtrackCount _ mpegFile hasAudio ifTrue: [1] ifFalse: [0].	mpegFile hasVideo		ifTrue: [			movieExtent _ (mpegFile videoFrameWidth: 0)@(mpegFile videoFrameHeight: 0).			self writeHeaderExtent: movieExtent				frameRate: (mpegFile videoFrameRate: 0)				frameCount: (mpegFile videoFrames: 0)				soundtrackCount: soundtrackCount				on: jpegFile]		ifFalse: [			self writeHeaderExtent: 0@0				frameRate: 0				frameCount: 0				soundtrackCount: soundtrackCount				on: jpegFile].	"convert and write frames"	frameOffsets _ self writeFramesFrom: mpegFile on: jpegFile quality: quality.	self updateFrameOffsets: frameOffsets on: jpegFile.	"convert and write sound tracks"	jpegFile position: frameOffsets last.  "store sound tracks after the last frame"	soundTrackOffsets _ self writeSoundTracksFrom: mpegFile on: jpegFile.	self updateSoundtrackOffsets: soundTrackOffsets frameOffsets: frameOffsets on: jpegFile.	mpegFile closeFile.	jpegFile close.	Display restore.! !!JPEGMovieFile class methodsFor: 'movie soundtracks' stamp: 'jm 6/4/2003 22:10'!addSoundtrack: soundFileName toJPEGMovieNamed: jpegFileName compressionType: compressionTypeString	"Append the given audio file as a soundtrack the given JPEG movie using the given compression type ('none', 'adpcm3', 'adpcm4', 'adpcm5', 'mulaw', or 'gsm')."	"Note: While the Squeak JPEG movie format supports multiple soundtracks, the player currently plays only the first soundtrack."	| snd jpegFile outFile frameCount newFrameOffsets buf inFile newSoundtrackOffsets oldMovieName |	snd _ StreamingMonoSound onFileNamed: soundFileName.	jpegFile _ JPEGMovieFile new openFileNamed: jpegFileName.	outFile _ (FileStream newFileNamed: 'movie.tmp') binary.	frameCount _ jpegFile videoFrames: 0.	"write new header"	self		writeHeaderExtent: ((jpegFile videoFrameWidth: 0)@(jpegFile videoFrameHeight: 0))		frameRate: (jpegFile videoFrameRate: 0)		frameCount: frameCount		soundtrackCount: (jpegFile soundtrackOffsets size + 1)		on: outFile.	"copy frames to new file"	newFrameOffsets _ Array new: frameCount + 1.	1 to: frameCount do: [:i |		newFrameOffsets at: i put: outFile position.		buf _ jpegFile bytesForFrame: i.		outFile nextPutAll: buf].	newFrameOffsets at: frameCount + 1 put: outFile position.	"copy existing soundtracks, if any, to new file"	jpegFile soundtrackOffsets size > 0 ifTrue: [		inFile _ jpegFile fileHandle.		inFile position: jpegFile soundtrackOffsets first.		buf _ ByteArray new: 10000.		[inFile atEnd] whileFalse: [			buf _ inFile next: buf size into: buf startingAt: 1.			outFile nextPutAll: buf]].	"adjust soundtrack offsets for header size increase and add new one:"	newSoundtrackOffsets _ jpegFile soundtrackOffsets collect: [:n | n + 4].	newSoundtrackOffsets _ newSoundtrackOffsets copyWith: outFile position.	snd storeSunAudioOn: outFile compressionType: compressionTypeString.	"update header:"	self updateFrameOffsets: newFrameOffsets on: outFile.	self updateSoundtrackOffsets: newSoundtrackOffsets frameOffsets: newFrameOffsets on: outFile.	"close files"	snd closeFile.	jpegFile closeFile.	outFile close.	"replace the old movie with the new version"	oldMovieName _ (jpegFileName copyFrom: 1 to: (jpegFileName size - 4)), '.old'.	FileDirectory default deleteFileNamed: oldMovieName.	FileDirectory default rename: jpegFileName toBe: oldMovieName.	FileDirectory default rename: 'movie.tmp' toBe: jpegFileName.! !!JPEGMovieFile class methodsFor: 'movie soundtracks' stamp: 'jm 12/13/2001 21:03'!removeSoundtrackFromJPEGMovieNamed: jpegFileName	"Remove all soundtracks from the JPEG movie with the given name."	| jpegFile outFile frameCount newFrameOffsets buf oldMovieName |	jpegFile _ JPEGMovieFile new openFileNamed: jpegFileName.	outFile _ (FileStream newFileNamed: 'movie.tmp') binary.	frameCount _ jpegFile videoFrames: 0.	"write new header"	self		writeHeaderExtent: ((jpegFile videoFrameWidth: 0)@(jpegFile videoFrameHeight: 0))		frameRate: (jpegFile videoFrameRate: 0)		frameCount: frameCount		soundtrackCount: 0		on: outFile.	"copy frames to new file"	newFrameOffsets _ Array new: frameCount + 1.	1 to: frameCount do: [:i |		newFrameOffsets at: i put: outFile position.		buf _ jpegFile bytesForFrame: i.		outFile nextPutAll: buf].	newFrameOffsets at: frameCount + 1 put: outFile position.	"update header:"	self updateFrameOffsets: newFrameOffsets on: outFile.	"close files"	jpegFile closeFile.	outFile close.	"replace the old movie with the new version"	oldMovieName _ (jpegFile fileName copyFrom: 1 to: (jpegFile fileName size - 4)), '.old'.	FileDirectory default deleteFileNamed: oldMovieName.	FileDirectory default rename: jpegFile fileName toBe: oldMovieName.	FileDirectory default rename: 'movie.tmp' toBe: jpegFile fileName.! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 1/25/2002 21:08'!extractFrameNumberFrom: aString	"Answer the integer frame number from the given file name string. The frame number is assumed to be the last contiguous sequence of digits in the given string. For example, 'take2 005.jpg' is frame 5 of the sequence 'take2'."	"Assume: The given string contains at least one digit."	| end start |	end _ aString size.	[(aString at: end) isDigit not] whileTrue: [end _ end - 1].	start _ end.	[(start > 1) and: [(aString at: start - 1) isDigit]] whileTrue: [start _ start - 1].	^ (aString copyFrom: start to: end) asNumber! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 2/3/2002 10:14'!sortedByFrameNumber: fileNames	"Sort the given collection of fileNames by frame number. The frame number is the integer value of the last contiguous sequence of digits in the file name. Omit filenames that do not contain at least one digit; this helps filter out extraneous non-frame files such as the invisible 'Icon' file that may be inserted by some file servers."	| filtered pairs |	"select the file names contain at least one digit"	filtered _ fileNames select: [:fn | fn anySatisfy: [:c | c isDigit]].	"make array of number, name pairs"	pairs _ filtered asArray collect: [:fn |		Array with: (self extractFrameNumberFrom: fn) with: fn].	"sort the pairs, then answer a collection containing the second element of every pair"	pairs sort: [:p1 :p2 | p1 first < p2 first].	^ pairs collect: [:p | p last].! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/17/2001 08:05'!updateFrameOffsets: frameOffsets on: aBinaryStream	"Update the JPEG movie file header on the given stream with the given collection of frame offsets."	aBinaryStream position: 22.	frameOffsets do: [:offset | aBinaryStream uint32: offset].! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/17/2001 07:40'!updateSoundtrackOffsets: soundtrackOffsetList frameOffsets: frameOffsets on: aBinaryStream	"Update the JPEG movie file header on the given stream with the given sequence of sound track offsets."	aBinaryStream position: 22 + (4 * frameOffsets size).	aBinaryStream uint16: soundtrackOffsetList size.	soundtrackOffsetList do: [:offset | aBinaryStream uint32: offset].! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 10/27/2002 10:51'!writeFrame: aForm on: aBinaryStream quality: quality displayFlag: displayFlag	"Compress and the given Form on the given stream and answer its offset. If displayFlag is true, show the result of JPEG compression on the display."	| offset compressed outForm |	offset _ aBinaryStream position.	compressed _ FastJPEG compress: aForm quality: quality.	displayFlag ifTrue: [  "show decompressed frame"		outForm _ FastJPEG uncompress: compressed doDithering: false.		outForm display].	aBinaryStream nextPutAll: compressed.	^ offset! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/25/2001 14:23'!writeFramesFrom: mpegFile on: aBinaryStream quality: quality	"Write the frames of the given MPEG movie on the given stream at the given JPEG quality level. Answer a collection of frame offsets. The size of this collection is one larger than the number of frames; it's final entry is the stream position just after the final frame. The byte count for any frame can thus be computed as the difference between two adjacent offsets."	| frameCount frameOffsets frameForm |	mpegFile hasVideo ifFalse: [^ Array with: aBinaryStream position].	frameCount _ mpegFile videoFrames: 0.	frameOffsets _ OrderedCollection new: frameCount + 1.	frameForm _ Form		extent: (mpegFile videoFrameWidth: 0)@(mpegFile videoFrameHeight: 0)		depth: 32.	[(mpegFile videoGetFrame: 0) < (mpegFile videoFrames: 0)] whileTrue: [		frameOffsets addLast: aBinaryStream position.		mpegFile videoReadFrameInto: frameForm stream: 0.		self writeFrame: frameForm on: aBinaryStream quality: quality displayFlag: true].	frameOffsets addLast: aBinaryStream position.  "add final offset"	^ frameOffsets! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/17/2001 08:01'!writeHeaderExtent: movieExtent frameRate: frameRate frameCount: frameCount soundtrackCount: soundtrackCount on: aBinaryStream	"Write a header on the given stream for a JPEG movie file with the given specifications. Leave the stream positioned at the start of the first movie frame."	| offsetCount |	aBinaryStream position: 0.	aBinaryStream nextPutAll: ('JPEG Movie') asByteArray.	aBinaryStream uint16: movieExtent x.	aBinaryStream uint16: movieExtent y.	aBinaryStream uint32: (frameRate * 10000) rounded.	offsetCount _ frameCount + 1.	aBinaryStream uint32: offsetCount.	aBinaryStream skip: (offsetCount * 4).  "leave room for frame offsets"	aBinaryStream uint16: soundtrackCount.	aBinaryStream skip: (soundtrackCount * 4).  "leave room for sound track offsets"! !!JPEGMovieFile class methodsFor: 'movie creation-private' stamp: 'jm 11/25/2001 16:55'!writeSoundTracksFrom: mpegFile on: aBinaryStream	"Convert and write the sound tracks from the given MPEG file to given stream. Answer a collection of sound track offsets."	"Details: Currently converts at most one sound track; only the left channel of a stereo movie will be converted."	| soundtrackCount soundTrackOffsets snd |	soundtrackCount _ mpegFile hasAudio ifTrue: [1] ifFalse: [0].	soundTrackOffsets _ Array new: soundtrackCount.	1 to: soundtrackCount do: [:i |		soundTrackOffsets at: i put: aBinaryStream position.		snd _ mpegFile audioPlayerForChannel: i.		snd storeSunAudioOn: aBinaryStream compressionType: 'mulaw'.		snd closeFile].	^ soundTrackOffsets! !I am a controller/simuator for a set of Color Kinetics computer-controlled lights. You can set the color of individual lights or to trigger fade, strobe, or similar actions which occur over some period of time. I keep track of each light's ongoing action (if any) and periodically update that light's color until the action is done. I also allow you to find out if a given light is busy doing some action or to stop that action.In the current design, each light keeps track of at most one ongoing action. The design could be extended to allow each light to keep a queue of light actions, but we'd prefer to do that sort of scheduling at the user-scripting level.Examples (copy following to a workspace):m _ CKLightsMorph new openInWorldm light: 3 color: Color whitem allColor: Color randomm fade: 1 from: Color green to: Color yellow in: 1.m strobe: 2 between: Color black and: Color white every: 0.5 for: 3m stop: 2"select and do all the following lines together:"lastColor _ Color black.m light: 1 color: lastColor.0 to: 360 by: 10 do: [:h |	nextColor _ Color h: h s: 1.0 v: 1.0.	1 to: m lightCount by: 2 do: [:i | m fade: i from: lastColor to: nextColor in: 0.1].	[m isDone: 1] whileFalse: [World doOneCycle].	lastColor _ nextColor]!!JohnsCKLightsMorph methodsFor: 'scratch viewer' stamp: 'jm 6/24/2003 23:11'!blocksFor: aCategory	"Create a bin of command blocks for this morph."	^ #().! !!JohnsCKLightsMorph methodsFor: 'scratch viewer' stamp: 'jm 6/24/2003 23:14'!isScriptable	^ false! !!JohnsCKLightsMorph methodsFor: 'scratch viewer' stamp: 'jm 6/24/2003 23:13'!objName	^ 'CK Lights'! !!JohnsCKLightsMorph methodsFor: 'scratch viewer' stamp: 'jm 6/24/2003 23:13'!objName: ignore	"Do nothing."! !!JohnsCKLightsMorph methodsFor: 'initialization' stamp: 'jm 7/2/2003 09:17'!createLightCount: lightCount	"Create the given number of lights."	| diameter space p corner |	lightActions _ Array new: lightCount.	self removeAllMorphs.	diameter _ 29.	space _ 5.	lights _ (1 to: lightCount) collect: [:i |		EllipseMorph new extent: diameter; color: Color black].	p _ self position + self borderWidth + space.	lights do: [:m |		m position: p.		self addMorphBack: m.		p _ p + ((m width + space)@0)].	corner _ lights last bottomRight + self borderWidth + space.	self bounds: (self position corner: corner).		! !!JohnsCKLightsMorph methodsFor: 'initialization' stamp: 'jm 7/2/2003 09:17'!initialize	super initialize.	self color: Color lightGray.	self createLightCount: 18.! !!JohnsCKLightsMorph methodsFor: 'light commands' stamp: 'jm 6/24/2003 10:00'!allColor: aColor	"Set all lights to the given color."	lights do: [:m | m color: aColor].! !!JohnsCKLightsMorph methodsFor: 'light commands' stamp: 'jm 6/24/2003 10:00'!allStop	"Stop all ongoing lights actions."	lightActions _ Array new: lights size.! !!JohnsCKLightsMorph methodsFor: 'light commands' stamp: 'jm 7/2/2003 09:15'!fade: lightNum to: stopColor in: durationSecs	"Start a fade action over the given number of seconds. This just creates an action for the light; the actual fading is done when the action is processed in my step method."	| startMSecs endMSecs action |	startMSecs _ Time millisecondClockValue.	endMSecs _ startMSecs + (durationSecs * 1000) asInteger.	action _ Array		with: #fade		with: startMSecs		with: endMSecs		with: (lights at: lightNum) color		with: stopColor.	lightActions at: lightNum put: action.! !!JohnsCKLightsMorph methodsFor: 'light commands' stamp: 'jm 6/24/2003 08:55'!isDone: n	"Answer true if the given light is currently idle."	^ (lightActions at: n) isNil! !!JohnsCKLightsMorph methodsFor: 'light commands' stamp: 'jm 6/24/2003 10:00'!light: lightNum color: aColor	"Set the given light to the given color."	(lights at: lightNum) color: aColor.! !!JohnsCKLightsMorph methodsFor: 'light commands' stamp: 'jm 6/24/2003 10:05'!lightCount	"Answer the number of lights."	^ lights size! !!JohnsCKLightsMorph methodsFor: 'light commands' stamp: 'jm 6/24/2003 08:55'!stop: n	"Stop any ongoing action on the given light."	lightActions at: n put: nil.! !!JohnsCKLightsMorph methodsFor: 'light commands' stamp: 'jm 7/2/2003 09:24'!strobe: lightNum between: startColor and: stopColor speed: flashesPerSec	"Start a strobe command that continues until stopped. This just creates an action for the light; the actual strobing is done when the action is processed in my step method."	| startMSecs endMSecs action |	flashesPerSec = 0 ifTrue: [^ self stop: lightNum].	startMSecs _ Time millisecondClockValue.	endMSecs _ nil.  "nil means repeat until stopped"	action _ Array		with: #strobe		with: startMSecs		with: endMSecs		with: startColor		with: stopColor		with: 1000 // flashesPerSec.	lightActions at: lightNum put: action.! !!JohnsCKLightsMorph methodsFor: 'light commands' stamp: 'jm 7/2/2003 09:25'!strobe: lightNum between: startColor and: stopColor speed: flashesPerSec for: durationSecs	"Start a strobe command over the given number of seconds. This just creates an action for the light; the actual strobing is done when the action is processed in my step method."	| startMSecs endMSecs action |	flashesPerSec = 0 ifTrue: [^ self stop: lightNum].	startMSecs _ Time millisecondClockValue.	endMSecs _ startMSecs + (durationSecs * 1000) asInteger.	action _ Array		with: #strobe		with: startMSecs		with: endMSecs		with: startColor		with: stopColor		with: flashesPerSec // 1000.	lightActions at: lightNum put: action.! !!JohnsCKLightsMorph methodsFor: 'stepping' stamp: 'jm 6/24/2003 09:33'!doFade: action lightNum: lightNum	"Process a fade action."	| currentMSecs startMSecs endMSecs startColor endColor fraction |	currentMSecs _ Time millisecondClockValue.	startMSecs _ action at: 2.	endMSecs _ action at: 3.	startColor _ action at: 4.	endColor _ action at: 5.	fraction _ (currentMSecs - startMSecs) asFloat / (endMSecs - startMSecs).	self light: lightNum color: (endColor mixed: fraction with: startColor).! !!JohnsCKLightsMorph methodsFor: 'stepping' stamp: 'jm 6/24/2003 09:30'!doStrobe: action lightNum: lightNum	"Process a strobe action."	| currentMSecs startMSecs color1 color2 cycleMSecs cycleFrac |	currentMSecs _ Time millisecondClockValue.	startMSecs _ action at: 2.	color1 _ action at: 4.	color2 _ action at: 5.	cycleMSecs _ action at: 6.	cycleFrac _ ((currentMSecs - startMSecs) \\ cycleMSecs) asFloat / cycleMSecs.	cycleFrac < 0.5		ifTrue: [self light: lightNum color: color1]		ifFalse: [self light: lightNum color: color2].! !!JohnsCKLightsMorph methodsFor: 'stepping' stamp: 'jm 6/24/2003 09:35'!step	"Process any light actions in progress."	| currentMSecs endTime |	currentMSecs _ Time millisecondClockValue.	lightActions doWithIndex: [:action :lightNum |		action ifNotNil: [			action first = #fade ifTrue: [self doFade: action lightNum: lightNum].			action first = #strobe ifTrue: [self doStrobe: action lightNum: lightNum].			endTime _ action at: 3.			(endTime notNil and: [endTime < currentMSecs]) ifTrue: [				"action is complete"				lightActions at: lightNum put: nil]]].! !!JohnsCKLightsMorph methodsFor: 'stepping' stamp: 'jm 6/24/2003 09:36'!stepTime	^ 50! !I am a virtual joystick that can report values in either Cartesian or Polar coordinates.!!JoystickMorph methodsFor: 'other' stamp: 'sw 5/11/1998 13:51'!handlesMouseDown: evt	self inPartsBin ifTrue: [^ false].	true ifTrue: [^ true].  "5/7/98 jhm temporary fix to allow use when rotated"	(handleMorph fullContainsPoint: evt cursorPoint)		ifTrue: [^ true]		ifFalse: [^ super handlesMouseDown: evt].! !!JoystickMorph methodsFor: 'stepping' stamp: 'sw 8/13/1999 14:03'!step	"Track the real joystick whose index is realJoystickIndex."	"Details:	  a. if realJoystickIndex is nil we're not tracking a joystick	  b. [-joyMax..joyMax] is nominal range of joystick in both X and Y	  c. [-threshold..threshold] is considered 0 to compensate for poor joystick centering"	| threshold joyMax joyPt m mCenter r scaledPt |	super step.  "Run ticking user-written scripts if any"	realJoystickIndex ifNil: [^ self].	threshold _ 30.	joyMax _ 350.	joyPt _ Sensor joystickXY: realJoystickIndex.	joyPt x abs < threshold ifTrue: [joyPt _ 0@joyPt y].	joyPt y abs < threshold ifTrue: [joyPt _ joyPt x@0].	lastRealJoystickValue = joyPt ifTrue: [^ self].	lastRealJoystickValue _ joyPt.	m _ handleMorph.	mCenter _ m center.	r _ m owner innerBounds insetBy:		((mCenter - m fullBounds origin) corner: (m fullBounds corner - mCenter)).	scaledPt _ r center + ((r extent * joyPt) / (joyMax * 2)) truncated.	m position: (scaledPt adhereTo: r) - (m extent // 2).! !!JoystickMorph methodsFor: 'stepping' stamp: 'sw 8/13/1999 14:00'!stepTime	^ realJoystickIndex		ifNil:			[0]  "fast as we can to track actual joystick"		ifNotNil:			[super stepTime]! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 6/22/1998 17:19'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'set X range' action: #setXRange.	aCustomMenu add: 'set Y range' action: #setYRange.	autoCenter		ifTrue: [aCustomMenu add: 'turn auto-center off' action: #toggleAutoCenter]		ifFalse: [aCustomMenu add: 'turn auto-center on' action: #toggleAutoCenter].	realJoystickIndex		ifNil: [aCustomMenu add: 'track real joystick' action: #trackRealJoystick]		ifNotNil: [aCustomMenu add: 'stop tracking joystick' action: #stopTrackingJoystick].! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 6/22/1998 17:24'!stopTrackingJoystick	realJoystickIndex _ nil.	self stopStepping.! !!JoystickMorph methodsFor: 'menu' stamp: 'jm 10/14/2002 19:04'!trackRealJoystick	| s |	s _ FillInTheBlank		request: 'Number of joystick to track?'		initialAnswer: '1'.	s isEmpty ifTrue: [^ self].	realJoystickIndex _ Number readFrom: (ReadStream on: s).	self startStepping.! !!JoystickMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:02'!includeInNewMorphMenu	^ true! !I am used by TextMorph to simulate an InputSensor when interfacing to an old MVC ParagraphEditor.!!KeyboardBuffer methodsFor: 'as yet unclassified' stamp: 'di 4/27/1999 21:49'!keyboardPressed	| evt |	eventUsed ifFalse: [^ true].	(evt _ event hand checkForMoreKeyboard) ifNil: [^ false].	event _ evt.	eventUsed _ false.	^ true! !This class adds state and controls to the basic PianoKeyboardMorph so that notes of reliable duration can be keyed into a score without the need for a real keyboard.To try this out, execute...	| n score | n _ 3.	score _ (MIDIScore new tracks: ((1 to: n) collect: [:i | Array new]);		trackInfo: ((1 to: n) collect: [:i | 'Instrument' , i printString]);		tempoMap: nil; ticksPerQuarterNote: 96).	ScorePlayerMorph openOn: score title: 'empty score'Then open a pianoRoll and, from that, open a keyboard.  The rule is that the keyboard will append after the current selection.  If the current selection is muted or nil, then input will go to the end of the first non-muted track.!!KeyboardMorphForInput methodsFor: 'initialization' stamp: 'di 6/20/1999 12:57'!addRecordingControls	| button switch playRow durRow articRow modRow |	button _ SimpleButtonMorph new target: self;		borderColor: #raised; borderWidth: 2; color: color.	switch _ SimpleSwitchMorph new target: self;		offColor: color; onColor: (Color r: 1.0 g: 0.6 b: 0.6); borderWidth: 2;		setSwitchState: false.	"Add chord, rest and delete buttons"	playRow _ AlignmentMorph newRow.	playRow color: color; borderWidth: 0; inset: 0.	playRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	playRow addMorphBack: (switch fullCopy label: 'chord'; actionSelector: #buildChord:).	playRow addMorphBack: (button fullCopy label: '          rest          '; actionSelector: #emitRest).	playRow addMorphBack: (button fullCopy label: 'del'; actionSelector: #deleteNotes).	self addMorph: playRow.	playRow align: playRow bounds topCenter			with: self bounds bottomCenter.	"Add note duration buttons"	durRow _ AlignmentMorph newRow.	durRow color: color; borderWidth: 0; inset: 0.	durRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	durRow addMorphBack: (switch fullCopy label: 'whole';				actionSelector: #duration:onOff:; arguments: #(1)).	durRow addMorphBack: (switch fullCopy label: 'half';				actionSelector: #duration:onOff:; arguments: #(2)).	durRow addMorphBack: (switch fullCopy label: 'quarter';				actionSelector: #duration:onOff:; arguments: #(4)).	durRow addMorphBack: (switch fullCopy label: 'eighth';				actionSelector: #duration:onOff:; arguments: #(8)).	durRow addMorphBack: (switch fullCopy label: 'sixteenth';				actionSelector: #duration:onOff:; arguments: #(16)).	self addMorph: durRow.	durRow align: durRow bounds topCenter			with: playRow bounds bottomCenter.	"Add note duration modifier buttons"	modRow _ AlignmentMorph newRow.	modRow color: color; borderWidth: 0; inset: 0.	modRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	modRow addMorphBack: (switch fullCopy label: 'dotted';				actionSelector: #durMod:onOff:; arguments: #(dotted)).	modRow addMorphBack: (switch fullCopy label: 'normal';				actionSelector: #durMod:onOff:; arguments: #(normal)).	modRow addMorphBack: (switch fullCopy label: 'triplets';				actionSelector: #durMod:onOff:; arguments: #(triplets)).	modRow addMorphBack: (switch fullCopy label: 'quints';				actionSelector: #durMod:onOff:; arguments: #(quints)).	self addMorph: modRow.	modRow align: modRow bounds topCenter			with: durRow bounds bottomCenter.	"Add articulation buttons"	articRow _ AlignmentMorph newRow.	articRow color: color; borderWidth: 0; inset: 0.	articRow hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	articRow addMorphBack: (switch fullCopy label: 'legato';				actionSelector: #articulation:onOff:; arguments: #(legato)).	articRow addMorphBack: (switch fullCopy label: 'normal';				actionSelector: #articulation:onOff:; arguments: #(normal)).	articRow addMorphBack: (switch fullCopy label: 'staccato';				actionSelector: #articulation:onOff:; arguments: #(staccato)).	self addMorph: articRow.	articRow align: articRow bounds topCenter			with: modRow bounds bottomCenter.	self bounds: (self fullBounds expandBy: (0@0 extent: 0@borderWidth))! !!KeyboardMorphForInput methodsFor: 'initialization' stamp: 'jm 10/31/2002 08:18'!initialize	super initialize.	buildingChord _ false.	self addRecordingControls.	self duration: 4 onOff: true.	self durMod: #normal onOff: true.	self articulation: #normal onOff: true.! !!KeyboardMorphForInput methodsFor: 'initialization' stamp: 'di 6/18/1999 15:52'!pianoRoll: prMorph	pianoRoll _ prMorph! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/19/1999 23:37'!articulation: artic onOff: ignored    "artic = eg, #legato, #normal, #staccato."	"Set the articulation of notes to be emitted when a key is pressed."	self allMorphsDo:		[:m | ((m isMemberOf: SimpleSwitchMorph)				and: [m actionSelector == #articulation:onOff:])				ifTrue: [m setSwitchState: m arguments first == artic]].	articulation _ artic! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/18/1999 15:50'!buildChord: onOff! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/20/1999 00:20'!deleteNotes	pianoRoll deleteSelection! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/20/1999 12:55'!durMod: durMod onOff: ignored    "durMod = eg, #dotted, #normal, #triplets, #quints"	"Set the duration of notes to be emitted when a key is pressed."	self allMorphsDo:		[:m | ((m isMemberOf: SimpleSwitchMorph)				and: [m actionSelector == #durMod:onOff:])				ifTrue: [m setSwitchState: m arguments first = durMod]].	durationModifier _ durMod! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/20/1999 18:31'!duration: denom onOff: ignored    "denom = eg, 1, 2, 4, 8, 16"	"Set the duration of notes to be emitted when a key is pressed."	self allMorphsDo:		[:m | ((m isMemberOf: SimpleSwitchMorph)				and: [m actionSelector == #duration:onOff:])				ifTrue: [m setSwitchState: m arguments first = denom]].	duration _ denom.	self durMod: #normal onOff: true! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'jm 10/31/2002 08:17'!emitRest	"Note: All this selection logic should be shared with turnOnNote:..."	| sel noteEvent |	(sel _ pianoRoll selection) ifNil: [^ self].	sel = prevSelection ifFalse:		["This is a new selection -- need to determine start time"		sel third = 0			ifTrue: [startOfNextNote _ 0]			ifFalse: [startOfNextNote _ ((pianoRoll score tracks at: sel first)										at: sel third) endTime.					startOfNextNote _ startOfNextNote + self fullDuration - 1										truncateTo: self fullDuration]].	noteEvent _ NoteEvent new time: startOfNextNote; duration: self noteDuration;			key: -1 "my flag for rest" velocity: self velocity channel: 1.	pianoRoll appendEvent: noteEvent fullDuration: self fullDuration.	soundPlaying ifNotNil: [soundPlaying stopGracefully].	prevSelection _ pianoRoll selection.	startOfNextNote _ startOfNextNote + self fullDuration.! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/20/1999 13:03'!fullDuration	| num denom |	num _ denom _ 1.	durationModifier == #dotted ifTrue: [num _ 3.  denom _ 2].	durationModifier == #triplets ifTrue: [num _ 2.  denom _ 3].	durationModifier == #quints ifTrue: [num _ 2.  denom _ 5].	^ pianoRoll score ticksPerQuarterNote * 4 * num // duration // denom! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/20/1999 00:27'!noteDuration	articulation == #staccato ifTrue: [^ (self fullDuration * 0.65) asInteger].	articulation == #normal ifTrue: [^ (self fullDuration * 0.8) asInteger].	articulation == #legato ifTrue: [^ (self fullDuration * 0.95) asInteger].! !!KeyboardMorphForInput methodsFor: 'note controls' stamp: 'di 6/19/1999 23:13'!velocity	^ 80  "Later put a slider on the keyboard control"! !!KeyboardMorphForInput methodsFor: 'events' stamp: 'di 6/20/1999 15:53'!soundForEvent: noteEvent inTrack: trackIndex	| sound player |	player _ pianoRoll scorePlayer.	sound _ MixedSound new.	sound add: ((player instrumentForTrack: trackIndex)					soundForMidiKey: noteEvent midiKey					dur: noteEvent duration / (pianoRoll scorePlayer ticksForMSecs: 1000)					loudness: (noteEvent velocity asFloat / 127.0))			pan: (player panForTrack: trackIndex)			volume: player overallVolume *						(player volumeForTrack: trackIndex).	^ sound! !!KeyboardMorphForInput methodsFor: 'events' stamp: 'jm 10/31/2002 08:17'!turnOnNote: midiKey	| sel noteEvent |	(sel _ pianoRoll selection) ifNil: [^ self].	sel = prevSelection ifFalse:		["This is a new selection -- need to determine start time"		sel third = 0			ifTrue: [startOfNextNote _ 0]			ifFalse: [startOfNextNote _ ((pianoRoll score tracks at: sel first)										at: sel third) endTime.					startOfNextNote _ startOfNextNote + self fullDuration - 1										truncateTo: self fullDuration]].	noteEvent _ NoteEvent new		time: startOfNextNote;		duration: self noteDuration;		key: midiKey velocity: self velocity channel: 1.	pianoRoll appendEvent: noteEvent fullDuration: self fullDuration.	soundPlaying ifNotNil: [soundPlaying stopGracefully].	(soundPlaying _ self soundForEvent: noteEvent inTrack: sel first) play.	prevSelection _ pianoRoll selection.	startOfNextNote _ startOfNextNote + self fullDuration.! !Just like LargePositiveInteger, but represents a negative number.!!LargeNegativeInteger methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:10'!highBit	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to  	get the highest bit of the magnitude."	^ self shouldNotImplement! !!LargeNegativeInteger methodsFor: 'converting' stamp: 'ar 5/17/2000 16:10'!normalize	"Check for leading zeroes and return shortened copy if so"	| sLen val len oldLen minVal |	<primitive: 'primNormalizeNegative' module:'LargeIntegers'>	"First establish len = significant length"	len _ oldLen _ self digitLength.	[len = 0 ifTrue: [^0].	(self digitAt: len) = 0]		whileTrue: [len _ len - 1].	"Now check if in SmallInteger range"	sLen _ 4  "SmallInteger minVal digitLength".	len <= sLen ifTrue:		[minVal _ SmallInteger minVal.		(len < sLen			or: [(self digitAt: sLen) < minVal lastDigit])			ifTrue: ["If high digit less, then can be small"					val _ 0.					len to: 1 by: -1 do:						[:i | val _ (val *256) - (self digitAt: i)].					^ val].		1 to: sLen do:  "If all digits same, then = minVal"			[:i | (self digitAt: i) = (minVal digitAt: i)					ifFalse: ["Not so; return self shortened"							len < oldLen								ifTrue: [^ self growto: len]								ifFalse: [^ self]]].		^ minVal].	"Return self, or a shortened copy"	len < oldLen		ifTrue: [^ self growto: len]		ifFalse: [^ self]! !I represent positive integers of more than 30 bits (ie, >= 1073741824).  These values are beyond the range of SmallInteger, and are encoded here as an array of 8-bit digits.  Care must be taken, when new values are computed, that any result that COULD BE a SmallInteger IS a SmallInteger (see normalize).Note that the bit manipulation primitives, bitAnd:, bitShift:, etc., = and ~= run without failure (and therefore fast) if the value fits in 32 bits.  This is a great help to the simulator.!!LargePositiveInteger methodsFor: 'arithmetic' stamp: 'RAA 5/31/2000 13:21'!\\\ anInteger 	"a faster modulo method for use in DSA. Be careful if you try to use this elsewhere"	^(self digitDiv: anInteger neg: false) second! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:11'!highBit	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to  	get the highest bit of the magnitude."	^ self highBitOfMagnitude! !!LargePositiveInteger methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:15'!highBitOfMagnitude	"Answer the index of the high order bit of the magnitude of the  	receiver, or zero if the receiver is zero.  	This method is used for LargeNegativeIntegers as well,  	since Squeak's LargeIntegers are sign/magnitude."	| realLength lastDigit |	realLength _ self digitLength.	[(lastDigit _ self digitAt: realLength) = 0]		whileTrue: [(realLength _ realLength - 1) = 0 ifTrue: [^ 0]].	^ lastDigit highBitOfPositiveReceiver + (8 * (realLength - 1))! !!LargePositiveInteger methodsFor: 'converting' stamp: 'ar 5/17/2000 16:09'!normalize	"Check for leading zeroes and return shortened copy if so"	| sLen val len oldLen |	<primitive: 'primNormalizePositive' module:'LargeIntegers'>	"First establish len = significant length"	len _ oldLen _ self digitLength.	[len = 0 ifTrue: [^0].	(self digitAt: len) = 0]		whileTrue: [len _ len - 1].	"Now check if in SmallInteger range"	sLen _ SmallInteger maxVal digitLength.	(len <= sLen		and: [(self digitAt: sLen) <= (SmallInteger maxVal digitAt: sLen)])		ifTrue: ["If so, return its SmallInt value"				val _ 0.				len to: 1 by: -1 do:					[:i | val _ (val *256) + (self digitAt: i)].				^ val].	"Return self, or a shortened copy"	len < oldLen		ifTrue: [^ self growto: len]		ifFalse: [^ self]! !!LargePositiveInteger methodsFor: 'system primitives' stamp: 'tk 3/24/1999 20:28'!digitAt: index 	"Primitive. Answer the value of an indexable field in the receiver.   LargePositiveInteger uses bytes of base two number, and each is a 'digit' base 256.  Fail if the argument (the index) is not an Integer or is out of bounds. Essential.  See Object documentation whatIsAPrimitive."	<primitive: 60>	self digitLength < index		ifTrue: [^0]		ifFalse: [^super at: index]! !!LargePositiveInteger class methodsFor: 'testing' stamp: 'sr 6/10/2000 18:24'!testTwoComplementRightShift	"self testTwoComplementRightShift"	| large small |	small _ 2 << 16.	large _ 2 << 32.	"2-complement test"	(small negated bitShift: -1) ~= ((small + 1) negated bitShift: -1)		== ((large negated bitShift: -1) ~= ((large + 1) negated bitShift: -1))		ifFalse: [^ self inform: 'ERROR: Two-complement shifts of negative Integers are NOT consistent!!'].	(small bitShift: -1) ~= (small + 1 bitShift: -1)		== ((large bitShift: -1) ~= (large + 1 bitShift: -1))		ifFalse: [^ self inform: 'ERROR: Two-complement shifts of negative Integers are NOT consistent!!'].	^ self inform: 'OK: Two-complement shifts of negative Integers are consistent!!'.! !I represent a leaf node of the compiler parse tree. I am abstract.	Types (defined in class ParseNode):	1 LdInstType (which uses class VariableNode)	2 LdTempType (which uses class VariableNode)	3 LdLitType (which uses class LiteralNode)	4 LdLitIndType (which uses class VariableNode)	5 SendType (which uses class SelectorNode).Note that Squeak departs slightly from the Blue Book bytecode spec.In order to allow access to more than 63 literals and instance variables,bytecode 132 has been redefined as DoubleExtendedDoAnything:		byte2				byte3			Operation(hi 3 bits)  (lo 5 bits)	0		nargs			lit index			Send Literal Message 0-255	1		nargs			lit index			Super-Send Lit Msg 0-255	2		ignored			rcvr index		Push Receiver Variable 0-255	3		ignored			lit index			Push Literal Constant 0-255	4		ignored			lit index			Push Literal Variable 0-255	5		ignored			rcvr index		Store Receiver Variable 0-255	6		ignored			rcvr index		Store-pop Receiver Variable 0-255	7		ignored			lit index			Store Literal Variable 0-255	This has allowed bytecode 134 also to be redefined as a second extended send	that can access literals up to 64 for nargs up to 3 without needing three bytes.	It is just like 131, except that the extension byte is aallllll instead of aaalllll,	where aaa are bits of argument count, and lll are bits of literal index.!I am a 7-segment LED that can display a decimal digit.!!LedDigitMorph methodsFor: 'initialization' stamp: 'tao 5/18/1998 17:01'!initialize	super initialize.	color _ Color green.	highlighted _ false.	digit _ 0.! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:00'!digit	^ digit! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:00'!digit: anInteger	digit _ anInteger \\ 10	"make sure it stays between 0 and 9"! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 17:00'!highlighted	^ highlighted! !!LedDigitMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:43'!highlighted: aBoolean	highlighted _ aBoolean.	self changed.! !!LedDigitMorph methodsFor: 'drawing' stamp: 'rjf 5/25/2000 00:16'!drawOn: aCanvas	| foregroundColor backgroundColor thickness hThickness vThickness hOffset vOffset |	foregroundColor _ highlighted ifTrue: [Color white] ifFalse: [color].	backgroundColor _ color darker darker darker.	hThickness _ self height * 0.1.	vThickness _ self width * 0.1.	thickness _ hThickness min: vThickness.	vOffset _ ((hThickness - thickness) // 2) max: 0.	hOffset _ ((vThickness - thickness) // 2) max: 0.	aCanvas fillRectangle: self bounds color: backgroundColor.	"added to show the minus sign"	(digit asString = '-') ifTrue: [digit _ 10].	HSegmentOrigins with: (HSegments at: digit+1) do:		[:o :isLit |		aCanvas			fillRectangle: (Rectangle				origin: (self position + (0@vOffset) + (o * self extent)) rounded				extent: ((self width * 0.6) @ thickness) rounded)			color: (isLit ifTrue: [foregroundColor] ifFalse: [backgroundColor])].	VSegmentOrigins with: (VSegments at: digit+1) do:		[:o :isLit |		aCanvas			fillRectangle: (Rectangle				origin: (self position + (hOffset@0) + (o * self extent)) rounded				extent: (thickness @ (self height * 0.25)) rounded)			color: (isLit ifTrue: [foregroundColor] ifFalse: [backgroundColor])].! !!LedDigitMorph methodsFor: 'drawing' stamp: 'tao 5/18/1998 13:58'!drawOnFills: aRectangle	^ true! !!LedDigitMorph class methodsFor: 'initialization' stamp: 'rjf 5/25/2000 00:16'!initialize	HSegmentOrigins _ {0.2@0.1. 0.2@0.45. 0.2@0.8}.	VSegmentOrigins _ {0.1@0.2. 0.1@0.55. 0.8@0.2. 0.8@0.55}.	HSegments _ {		{true. false. true}.		{false. false. false}.		{true. true. true}.		{true. true. true}.		{false. true. false}.		{true. true. true}.		{true. true. true}.		{true. false. false}.		{true. true. true}.		{true. true. true}.		{false. true. false}}.	VSegments _ {		{true. true. true. true}.		{false. false. true. true}.		{false. true. true. false}.		{false. false. true. true}.		{true. false. true. true}.		{true. false. false. true}.		{true. true. false. true}.		{false. false. true. true}.		{true. true. true. true}.		{true. false. true. true}.		{false. false. false. false}}.! !I am a collection of LED digits that can display a decimal value. The display can be set to flash by sending flash: true.!!LedMorph methodsFor: 'initialization' stamp: 'tao 5/18/1998 20:38'!initialize	super initialize.	flashing _ false.	flash _ false.	self digits: 2.	self value: 0.	self color: Color green.! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:51'!color: aColor	color _ aColor.	self submorphsDo: [:m | m color: aColor]! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:42'!digits	^ digits! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:46'!digits: aNumber	digits _ aNumber.	self removeAllMorphs.	1 to: digits do: [:i | self addMorph: (LedDigitMorph new color: color)].	self layoutChanged.	self changed.! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:26'!flash	^ flash! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 18:26'!flash: aBoolean	flash _ aBoolean.! !!LedMorph methodsFor: 'accessing' stamp: 'djp 11/29/1999 17:27'!highlighted: aBoolean	self submorphsDo: [:m | m highlighted: aBoolean]! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:42'!value	^ value! !!LedMorph methodsFor: 'accessing' stamp: 'tao 5/18/1998 13:47'!value: aNumber	| val |	value _ aNumber.	val _ value.	submorphs reverseDo:		[:m |		m digit: val \\ 10.		val _ val // 10].	self changed.! !!LedMorph methodsFor: 'drawing' stamp: 'tao 5/18/1998 14:00'!drawOn: aCanvas	aCanvas fillRectangle: self bounds color: color darker darker.! !!LedMorph methodsFor: 'change reporting' stamp: 'tao 5/18/1998 13:53'!layoutChanged	super layoutChanged.	submorphs withIndexDo:		[:m :i |		m			position: self position + (((i-1) * self width / digits) rounded @ 0);			extent: (self width / digits) rounded @ self height]! !!LedMorph methodsFor: 'stepping' stamp: 'djp 11/29/1999 17:27'!step	(flash or: [flashing])		ifTrue:			[flashing _ flashing not.			self highlighted: flashing]! !!LedMorph methodsFor: 'stepping' stamp: 'tao 5/18/1998 18:44'!stepTime	^ 500! !A LimitedWriteStream is a specialized WriteStream that has a maximum size of the collection it streams over. When this limit is reached a special limitBlock is executed. This can for example be used to "bail out" of lengthy streaming operations before they have finished.  For a simple example take a look at the universal Object printString.The message SequenceableCollection class streamContents:limitedTo: creates a LimitedWriteStream. In this case it prevents very large (or possibly recursive) object structures to "overdo" their textual representation. !]style[(323 18 15 54 151)f1,f1LObject printString;,f1,f1LSequenceableCollection class streamContents:limitedTo:;,f1!An instance of me is a simple record of a pointer to another Link. I am an abstract class; my concrete subclasses, for example, Process, can be stored in a LinkedList structure.!I represent a collection of links, which are containers for other objects. Using the message sequence addFirst:/removeLast causes the receiver to behave as a stack; using addLast:/removeFirst causes the receiver to behave as a queue.!An instance of me holds a list of methods (or class comment, class defintion, class hierarchy).  When a user clicks on a HyperText link, the place referred to is displayed in me.  The non-method contents are not meant to be edited and accepted.To create a link to a class comment:In any piece of text, type the name of a class.Select it.Command-6.Choose 'go to comment of class'Then a user can click on that text later and she will be transported to the class's comment.To create a link to a method, class definition, or class hierarchy: Do the same as above, but choose the appropriate menu item. !!LinkedMessageSet methodsFor: 'as yet unclassified' stamp: 'sw 11/9/1999 18:15'!selectedMessage	"Answer the source method for the currently selected message.  Allow class comment, definition, and hierarchy."	| source |	self setClassAndSelectorIn: [:class :selector | 		selector first isUppercase ifFalse:			[source _ class sourceMethodAt: selector.			currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil]..			^ source asText makeSelectorBoldIn: self selectedClassOrMetaClass].		selector = #Comment ifTrue: [^ class comment].		selector = #Definition ifTrue: [^ class definition].		selector = #Hierarchy ifTrue: [^ class printHierarchy].		source _ class sourceMethodAt: selector.		currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil].		Preferences browseWithPrettyPrint ifTrue:			[source _ class compilerClass new				format: source in: class notifying: nil decorated: Preferences colorWhenPrettyPrinting].		^ source asText makeSelectorBoldIn: self selectedClassOrMetaClass]! !I am a kind of ScrollController that assumes that the view is a kind of ListView. Therefore, scrolling means moving the items in a textual list (menu) up or down. In addition, I provide the red button activity of determining when the red button is selecting an item in the list.!!ListController methodsFor: 'control defaults' stamp: 'bf 4/14/1999 12:41'!controlActivity	self scrollByKeyboard ifTrue: [^self].	self processKeyboard.	super controlActivity.! !!ListController methodsFor: 'menu messages' stamp: 'acg 9/18/1999 14:09'!processKeyboard	"Derived from a Martin Pammer submission, 02/98"     | keyEvent oldSelection nextSelection max min howMany |	sensor keyboardPressed ifFalse: [^ self].     keyEvent := sensor keyboard asciiValue.     oldSelection := view selection.     nextSelection := oldSelection.     max := view maximumSelection.     min := view minimumSelection.     howMany := view clippingBox height // view list lineGrid.     keyEvent == 31 ifTrue:		["down-arrow; move down one, wrapping to top if needed"		nextSelection := oldSelection + 1.		nextSelection > max ifTrue: [nextSelection _ 1]].     keyEvent == 30 ifTrue:		["up arrow; move up one, wrapping to bottom if needed"		nextSelection := oldSelection - 1.		nextSelection < 1 ifTrue: [nextSelection _ max]].     keyEvent == 1  ifTrue: [nextSelection := 1].  "home"     keyEvent == 4  ifTrue: [nextSelection := max].   "end"     keyEvent == 11 ifTrue: [nextSelection := min max: (oldSelection -howMany)].  "page up"     keyEvent == 12  ifTrue: [nextSelection := (oldSelection + howMany)min: max].  "page down"     nextSelection = oldSelection  ifFalse:		[model okToChange			ifTrue:				[self changeModelSelection: nextSelection.				self moveMarker]]			! !I represent a special type of Paragraph that is used in the list panes of a browser.  I  avoid all the composition done by more general Paragraphs, because I know the structure of my Text.!!ListParagraph class methodsFor: 'instance creation' stamp: 'jm 9/20/1998 17:10'!withArray: anArray style: aTextStyleOrNil	"Convert an array of strings into a ListParagraph using the given TextStyle."	aTextStyleOrNil		ifNil: [^ (super withText: Text new style: ListStyle) withArray: anArray]		ifNotNil: [^ (super withText: Text new style: aTextStyleOrNil) withArray: anArray].! !!ListParagraph class methodsFor: 'initialization' stamp: 'sw 12/10/1999 10:37'!initialize 	"ListParagraph initialize"	| aFont |	"Allow different line spacing for lists"	aFont _ Preferences standardListFont.	ListStyle _ aFont textStyle copy consistOnlyOf: aFont.	ListStyle gridForFont: 1 withLead: 1! !!ListParagraph class methodsFor: 'style' stamp: 'sw 12/10/1999 10:43'!standardListStyle	^ ListStyle! !I am an abstract View of a list of items. I provide support for storing a selection of one item, as well as formatting the list for presentation on the screen. My instances' default controller is ListController.!!ListView methodsFor: 'font access' stamp: 'sw 12/9/1999 18:07'!font	^ self assuredTextStyle fontNamed: textStyle fontNames first! !!ListView methodsFor: 'font access' stamp: 'jm 9/20/1998 19:44'!font: aFontOrNil	aFontOrNil		ifNil: [textStyle _ nil]		ifNotNil: [			textStyle _ TextStyle fontArray: (Array with: aFontOrNil).			textStyle gridForFont: 1 withLead: 1].	self changed: #list.  "update display"! !!ListView methodsFor: 'list access' stamp: 'sw 12/10/1999 10:43'!assuredTextStyle	^ textStyle ifNil:		[textStyle _  ListParagraph standardListStyle]! !!ListView methodsFor: 'list access' stamp: 'sw 12/9/1999 18:06'!list: anArray 	"Set the list of items the receiver displays to be anArray."	| arrayCopy i |	isEmpty _ anArray isEmpty.	arrayCopy _ Array new: (anArray size + 2).	arrayCopy at: 1 put: topDelimiter.	arrayCopy at: arrayCopy size put: bottomDelimiter.	i _ 2.	anArray do: [:el | arrayCopy at: i put: el. i _ i+1].	arrayCopy _ arrayCopy copyWithout: nil.	list _ ListParagraph withArray: arrayCopy style: self assuredTextStyle.	selection _ 0.	self positionList.! !!ListView methodsFor: 'display box access' stamp: 'mkd 11/4/1999 14:31'!isSelectionBoxClipped        "Answer whether there is a selection and whether the selection is visible         on the screen."        ^ selection ~= 0 and:			[(self selectionBox intersects:                        (self clippingBox insetBy: (Rectangle left: 0 right: 0 top: 1 bottom: 0))) not]! !A LiteralDictionary, like an IdentityDictionary, has a special test for equality.  In this case it is simple equality between objects of like class.  This allows equal Float or String literals to be shared without the possibility of erroneously sharing, say, 1 and 1.0!I am a parse tree leaf representing a literal string or number.!!LiteralNode methodsFor: 'printing' stamp: 'sw 11/16/1999 16:42'!printOn: aStream indent: level	(key isMemberOf: Association)		ifTrue:			[key key isNil				ifTrue:					[aStream nextPutAll: '###';					 	nextPutAll: key value soleInstance name]				ifFalse:					[aStream nextPutAll: '##';						nextPutAll: key key]]		ifFalse:			[aStream withAttributes: (Preferences syntaxAttributesFor: #literal) do:  [key storeOn: aStream]]! !!LiteralNode methodsFor: 'evaluation' stamp: 'tk 8/4/1999 17:35'!eval	"When everything in me is a constant, I can produce a value.  This is only used by the Scripting system (TilePadMorph tilesFrom:in:)"	^ key! !!LogoSimulatorClient methodsFor: 'initialization' stamp: 'jm 2/22/2003 14:17'!initialize	hostAddress _ #(127 0 0 1) asByteArray.	socket _ nil.	"compiler on empty source allows evaluation even when no file has been loaded:"	compiler _ NTagLogoCompiler new.	compiler compile: '' at: 0.! !!LogoSimulatorClient methodsFor: 'accessing' stamp: 'jm 2/10/2003 14:21'!compiler	^ compiler! !!LogoSimulatorClient methodsFor: 'accessing' stamp: 'jm 2/21/2003 10:32'!hostAddress: aByteArrayOrString	(aByteArrayOrString isKindOf: String)		ifTrue: [hostAddress _ NetNameResolver addressFromString: aByteArrayOrString]		ifFalse: [hostAddress _ aByteArrayOrString].! !!LogoSimulatorClient methodsFor: 'ntag memory access' stamp: 'jm 3/1/2003 16:28'!consoleMessage: aString	socket sendData:		'M', (ByteArray with: aString size), aString.! !!LogoSimulatorClient methodsFor: 'ntag memory access' stamp: 'jm 3/9/2003 21:32'!dumpLogFilesToFile: fileName	| logiAddr msg |	logiAddr _ 16r300 + (2 * ((compiler globalNames indexOf: 'logi') - 1)).	msg _ 'U', (ByteArray with: fileName size), fileName,		(self numToBytes: (compiler constantValue: '&log')),		(self numToBytes: logiAddr),		(self numToBytes: (compiler constantValue: 'logelsize')).	self flushData.	socket sendData: msg.	self readByteCount: 1. "wait for reply byte"! !!LogoSimulatorClient methodsFor: 'ntag memory access' stamp: 'jm 2/23/2003 08:21'!dumpTagDataToFile: fileName	| msg |	msg _ 'W', (ByteArray with: fileName size), fileName.	self flushData.	socket sendData: msg.	self readByteCount: 1. "wait for reply byte"! !!LogoSimulatorClient methodsFor: 'ntag memory access' stamp: 'jm 3/1/2003 15:34'!globalVars: tagNum	| varNames globalsAddr buf in out low hi |	varNames _ compiler globalNames.	varNames size = 0 ifTrue: [^ 'no global variables'].	globalsAddr _ 16r300.  "from LogoVM.java 'globals' class variable"	buf _ self readBytes: (varNames size * 2) at: globalsAddr tag: tagNum.	in _ ReadStream on: buf.	out _ WriteStream on: String new.	varNames do: [:n |		low _ in next. hi _ in next.		out nextPutAll: n, ': ', ((hi * 256) + low) printString; cr].	^ out contents! !!LogoSimulatorClient methodsFor: 'ntag memory access' stamp: 'jm 3/1/2003 15:28'!readBytes: count at: address tag: tagNum	| msg |	socket ifNil: [^ self inform: 'not connected'].	msg _ '>' asByteArray,		(self numToBytes: tagNum),		(self numToBytes: address),		(self numToBytes: count).	socket sendData: msg.	^ self readByteCount: count! !!LogoSimulatorClient methodsFor: 'ntag memory access' stamp: 'jm 3/1/2003 15:24'!readExtWords: count at: address tag: tagNum	| msg bytes result j |	socket ifNil: [^ self inform: 'not connected'].	msg _ ']' asByteArray,		(self numToBytes: tagNum),		(self numToBytes: address),		(self numToBytes: count).	socket sendData: msg.	bytes _ self readByteCount: 2 * count.	result _ Array new: count.	1 to: count do: [:i |		j _ 2 * i.		result at: i put: ((bytes at: j) * 256) + (bytes at: j - 1)].	^ result! !!LogoSimulatorClient methodsFor: 'ntag memory access' stamp: 'jm 3/1/2003 15:24'!writeBytes: aByteArray at: address tag: tagNum	| msg |	socket ifNil: [^ self inform: 'not connected'].	msg _ '<' asByteArray,		(self numToBytes: tagNum),		(self numToBytes: address),		(self numToBytes: aByteArray size),		aByteArray asByteArray.	socket sendData: msg.! !!LogoSimulatorClient methodsFor: 'ntag memory access' stamp: 'jm 3/1/2003 15:28'!writeExtWords: anArray at: address tag: tagNum	| msg |	socket ifNil: [^ self inform: 'not connected'].	msg _ '[' asByteArray,		(self numToBytes: tagNum),		(self numToBytes: address),		(self numToBytes: anArray size),		(self wordsToBytes: anArray).	socket sendData: msg.! !!LogoSimulatorClient methodsFor: 'ntag ui' stamp: 'jm 2/21/2003 18:09'!displayLightsTag: tagNum at: aPoint	"Display the red and green LED's of the given tag at the given point."	| lights c |	self isConnected ifFalse: [		Display fill: (aPoint extent: 20@10) fillColor: Color black.		^ self].	lights _ self readLightsTag: tagNum.	c _ (lights bitAnd: 1) > 0 ifTrue: [Color green] ifFalse: [Color gray].	Display fill: (aPoint extent: 10) fillColor: c.	c _ (lights bitAnd: 2) > 0 ifTrue: [Color red] ifFalse: [Color gray].	Display fill: ((aPoint + (10@0)) extent: 10) fillColor: c.! !!LogoSimulatorClient methodsFor: 'ntag ui' stamp: 'jm 2/21/2003 10:35'!readDisplayOrNilTag: tagNum	"Get the display pixels for the given ntag. If the display has not changed, answer nil. Otherwise, answer a ByteArray of 1024 bytes that represents the pixels of the ntag display."	| flag |	self isConnected ifFalse: [^ nil].	self flushData.	socket sendData: 'D', (self numToBytes: tagNum).	flag _ self readByteCount: 1.	flag first = 0		ifTrue: [^ nil]  "no display change since last time"		ifFalse: [^ self readByteCount: 1024].! !!LogoSimulatorClient methodsFor: 'ntag ui' stamp: 'jm 2/27/2003 17:32'!readLightsTag: tagNum	"Read the LED lights state for the given ntag. The ntag's two LED's are in the least significant two bits of the result as: <...14-bits...><redLight><greenLight>."	| msg reply |	self isConnected ifFalse: [^ 0].	self flushData.	msg _ 'L' asByteArray, (self numToBytes: tagNum).	socket sendData: msg.	reply _ self readByteCount: 1.	^ reply first! !!LogoSimulatorClient methodsFor: 'ntag ui' stamp: 'jm 2/21/2003 10:39'!setButtons: buttonWord tag: tagNum	"Set the button state word for the given ntag. The ntag's three buttons are in the least significant three bits of the button word as follow: <...13-bits reserved...><button-3><button-2><button-1>."	| msg |	self isConnected ifFalse: [^ self inform: 'not connected'].	msg _ 'B' asByteArray,		(self numToBytes: tagNum),		(self numToBytes: buttonWord).	socket sendData: msg.! !!LogoSimulatorClient methodsFor: 'ntag ui' stamp: 'jm 2/21/2003 17:54'!showDisplayTag: tagNum	"Draw the display of the given ntag on the screen. Do nothing if the ntag display has not changed since the last request."	self showDisplayTag: tagNum at: 0@0.! !!LogoSimulatorClient methodsFor: 'ntag ui' stamp: 'jm 2/21/2003 18:10'!showDisplayTag: tagNum at: aPoint	"Draw the display of the given ntag on the screen. Do nothing if the ntag display has not changed since the last request."	| buf buf2 byte f |	buf _ self readDisplayOrNilTag: tagNum.	buf ifNotNil: [		buf2 _ buf copy.		0 to: 7 do: [:r |			0 to: 127 do: [:c |				byte _ buf at: (r * 128) + c + 1.				buf2 at: (c * 8) + (7 - r) + 1 put: byte]].		f _ Form extent: 64@128 depth: 1 bits: buf2.		((f rotateBy: #left centerAt: 0@0) magnifyBy: 2) displayAt: aPoint].	self displayLightsTag: tagNum at: aPoint + (0@128).! !!LogoSimulatorClient methodsFor: 'ntag execution' stamp: 'jm 2/11/2003 13:26'!createTags: tagCount	"Create the given number of ntags. All existing tags will be destroyed."	| msg |	socket ifNil: [^ self inform: 'not connected'].	msg _ 'C' asByteArray, (self numToBytes: tagCount), (self numToBytes: 1).	socket sendData: msg.! !!LogoSimulatorClient methodsFor: 'ntag execution' stamp: 'jm 3/1/2003 15:26'!loadFile: aFileName	"Compile and load the given file. The file is compiled for a specific target address. The compiler state is retained to allow compiling commands the call functions defined in the file."	| targetAddr bytecodes startAddr |	targetAddr _ 16r3000.	compiler ifNil: [compiler _ NTagLogoCompiler new].	bytecodes _ compiler compileFileNamed: aFileName at: targetAddr.	startAddr _ compiler addressOfFunction: 'startup'.	socket		ifNil: [self inform: 'not connected']		ifNotNil: [			self writeBytes: bytecodes at: targetAddr tag: 0.			startAddr ifNotNil: [self startPC: startAddr + 2 tag: 0]].	^ bytecodes asArray! !!LogoSimulatorClient methodsFor: 'ntag execution' stamp: 'jm 4/11/2003 23:50'!loadFile: aFileName at: targetAddr	"Compile and load the given file. The file is compiled for a specific target address. The compiler state is retained to allow compiling commands the call functions defined in the file."	| bytecodes startAddr |	compiler ifNil: [compiler _ NTagLogoCompiler new].	bytecodes _ compiler compileFileNamed: aFileName at: targetAddr.	startAddr _ compiler addressOfFunction: 'startup'.	socket		ifNil: [self inform: 'not connected']		ifNotNil: [			self writeBytes: bytecodes at: targetAddr tag: 0.			startAddr ifNotNil: [self startPC: startAddr + 2 tag: 0]].	^ bytecodes asArray! !!LogoSimulatorClient methodsFor: 'ntag execution' stamp: 'jm 3/1/2003 15:27'!runCommand: aString tag: tagNum	"Compile, download, and run the given command. Return the generated bytecodes."	| bytecodes |	compiler ifNil: [  "create a dummy compiler if no file has been loaded"		compiler _ NTagLogoCompiler new.		compiler compile: ' ' at: 0].	bytecodes _ compiler compileCommand: aString.	socket		ifNil: [self inform: 'not connected']		ifNotNil: [			self writeBytes: bytecodes at: 16r220 tag: tagNum.			self startPC: 16r220 tag: tagNum.			self runTags: (Array with: tagNum) doIR: false reader: 0 mSecs: 60000].	^ bytecodes asArray! !!LogoSimulatorClient methodsFor: 'ntag execution' stamp: 'jm 2/23/2003 08:09'!runTag: tag1 withTag: tag2 mSecs: mSecs	self runTags: (Array with: tag1 with: tag2) doIR: true reader: 0 mSecs: mSecs.! !!LogoSimulatorClient methodsFor: 'ntag execution' stamp: 'jm 3/10/2003 09:44'!runTags: tagArray doIR: doIRFlag reader: tagReaderIndex mSecs: mSecs	| msg |	socket ifNil: [^ self inform: 'not connected'].	msg _ WriteStream on: (ByteArray new: 100).	msg nextPut: $R asciiValue.	msg nextPutAll: (self numToBytes: tagArray size).	tagArray do: [:tagIndex | msg nextPutAll: (self numToBytes: tagIndex)].	msg nextPut: (doIRFlag ifTrue: [1] ifFalse: [0]).	msg nextPut: tagReaderIndex.	msg nextPutAll: (self numToBytes: mSecs).	self flushData.	socket sendData: msg contents.	self readByteCount: 1.! !!LogoSimulatorClient methodsFor: 'ntag execution' stamp: 'jm 2/2/2003 09:26'!startPC: address tag: tagNum	"Set the starting address of the given tag. A zero tag number sets the starting address of all tags."	| msg |	msg _ 'P' asByteArray,		(self numToBytes: tagNum),		(self numToBytes: address).	socket sendData: msg.! !!LogoSimulatorClient methodsFor: 'ntag execution' stamp: 'jm 2/25/2003 10:15'!status	"Ask the tag for its current status"	| length |	self isConnected ifFalse:  [self inform: 'not connected'. ^ 'not connected'].	self flushData.	socket sendData: '?'.	length _ (self readByteCount: 1) first.	^ (self readByteCount: length) asString! !!LogoSimulatorClient methodsFor: 'ntag execution' stamp: 'jm 3/2/2003 19:07'!watchTag: tag1 withTag: tag2 mSecs: mSecs	| delta remaining |	delta _ 1000.	remaining _ mSecs.	[remaining > delta] whileTrue: [		self runTag: tag1 withTag: tag2 mSecs: delta.		self showDisplayTag: tag1 at: 0@0.		self showDisplayTag: tag2 at: 260@0.		remaining _ remaining - delta].	self runTag: tag1 withTag: tag2 mSecs: remaining.! !!LogoSimulatorClient methodsFor: 'ntag execution' stamp: 'jm 3/10/2003 09:18'!zoomTags: tagArray runMSecs: runMSecs skipMSecs: skipMSecs totalMSecs: totalMSecs	"Zoom forward in time by running the given tags by alternately running the tags and jumping forward in time."	| msg |	socket ifNil: [^ self inform: 'not connected'].	msg _ WriteStream on: (ByteArray new: 100).	msg nextPut: $Z asciiValue.	msg nextPutAll: (self numToBytes: tagArray size).	tagArray do: [:tagIndex | msg nextPutAll: (self numToBytes: tagIndex)].	msg nextPutAll: (self numToBytes: runMSecs).	msg nextPutAll: (self numToBytes: skipMSecs).	msg nextPutAll: (self numToBytes: totalMSecs).	socket sendData: msg contents.	self readByteCount: 1.! !!LogoSimulatorClient methodsFor: 'batch sessions' stamp: 'jm 2/25/2003 10:15'!attachToSession	self isConnected ifFalse:  [^ self inform: 'not connected'].	socket sendData: 'A'.! !!LogoSimulatorClient methodsFor: 'batch sessions' stamp: 'jm 2/25/2003 10:00'!doneFraction	"Ask for the fraction done for the current batch session. Result is 0 to 10000."	| buf |	self isConnected ifFalse:  [^ self inform: 'not connected'].	self flushData.	socket sendData: '%'.	buf _ (self readByteCount: 2).	^ ((buf at: 2) << 8) + (buf at: 1)! !!LogoSimulatorClient methodsFor: 'batch sessions' stamp: 'jm 2/23/2003 23:05'!forkAndRunCommandFile: fName	| msg |	socket ifNil: [^ self inform: 'not connected'].	msg _ 'F', (ByteArray with: fName size), fName.	socket sendData: msg.! !!LogoSimulatorClient methodsFor: 'batch sessions' stamp: 'jm 2/25/2003 10:15'!killSession	self isConnected ifFalse:  [^ self inform: 'not connected'].	socket sendData: 'K'.! !!LogoSimulatorClient methodsFor: 'batch sessions' stamp: 'jm 2/25/2003 10:15'!resumeSession	self isConnected ifFalse:  [^ self inform: 'not connected'].	socket sendData: 'G'.! !!LogoSimulatorClient methodsFor: 'file creation' stamp: 'jm 2/23/2003 22:49'!addCreateTags: tagCount tagReaders: readerCount to: aStream	"Create the given number of ntags. All existing tags will be destroyed."	aStream nextPutAll:		('C' asByteArray, (self numToBytes: tagCount), (self numToBytes: readerCount)).! !!LogoSimulatorClient methodsFor: 'file creation' stamp: 'jm 3/10/2003 16:34'!addDumpLogsToFile: fileName to: aStream	| logiAddr msg |	logiAddr _ 16r300 + (2 * ((compiler globalNames indexOf: 'logi') - 1)).	msg _ 'U', (ByteArray with: fileName size), fileName,		(self numToBytes: (compiler constantValue: '&log')),		(self numToBytes: logiAddr),		(self numToBytes: (compiler constantValue: 'logelsize')).	aStream nextPutAll: msg.! !!LogoSimulatorClient methodsFor: 'file creation' stamp: 'jm 2/23/2003 22:54'!addDumpTagDataToFile: fileName to: aStream	aStream nextPutAll: ('W', (ByteArray with: fileName size), fileName).! !!LogoSimulatorClient methodsFor: 'file creation' stamp: 'jm 3/1/2003 18:29'!addMessage: aString to: aStream	aStream nextPutAll: 'M', (ByteArray with: aString size), aString.! !!LogoSimulatorClient methodsFor: 'file creation' stamp: 'jm 2/23/2003 22:51'!addRunTags: tagArray doIR: doIRFlag reader: tagReaderIndex mSecs: mSecs to: aStream	| msg |	msg _ WriteStream on: (ByteArray new: 100).	msg nextPut: $R asciiValue.	msg nextPutAll: (self numToBytes: tagArray size).	tagArray do: [:tagIndex | msg nextPutAll: (self numToBytes: tagIndex)].	msg nextPut: (doIRFlag ifTrue: [1] ifFalse: [0]).	msg nextPut: tagReaderIndex.	msg nextPutAll: (self numToBytes: mSecs).	aStream nextPutAll: msg contents.! !!LogoSimulatorClient methodsFor: 'file creation' stamp: 'jm 2/23/2003 22:52'!addStartPC: address tag: tagNum to: aStream	"Set the starting address of the given tag. A zero tag number sets the starting address of all tags."	aStream nextPutAll:		('P' asByteArray, (self numToBytes: tagNum), (self numToBytes: address)).! !!LogoSimulatorClient methodsFor: 'file creation' stamp: 'jm 3/10/2003 15:42'!addZoomTags: tagArray runMSecs: runMSecs skipMSecs: skipMSecs totalMSecs: totalMSecs to: aStream	aStream nextPut: $Z asciiValue.	aStream nextPutAll: (self numToBytes: tagArray size).	tagArray do: [:tagIndex | aStream nextPutAll: (self numToBytes: tagIndex)].	aStream nextPutAll: (self numToBytes: runMSecs).	aStream nextPutAll: (self numToBytes: skipMSecs).	aStream nextPutAll: (self numToBytes: totalMSecs).! !!LogoSimulatorClient methodsFor: 'file creation' stamp: 'jm 3/1/2003 19:52'!generateFullMatrix: n	"LogoSimulatorClient new generateFullMatrix: 500"	| simName s |	simName _ 'fullMatrix', n printString.	s _ FileStream newFileNamed: simName, '.sim'.	self addCreateTags: 1 tagReaders: 0 to: s.	self addDumpTagDataToFile: simName, '.begin.dmp' to: s.	self addCreateTags: n tagReaders: 0 to: s.	1 to: n do: [:i |		self addMessage: 'Tag ', i printString, ' of ', n printString to: s.		1 to: n do: [:j |			i = j ifFalse: [				self addRunTags: (Array with: i with: j) doIR: true reader: 0 mSecs: 5000 to: s]]].	self addDumpTagDataToFile: simName, '.final.dmp' to: s.	s close.! !!LogoSimulatorClient methodsFor: 'file creation' stamp: 'jm 3/30/2003 12:02'!generateFullTest: n seconds: totalSeconds sourceFile: srcFileName	"LogoSimulatorClient new generateFullTest: 1000 seconds: 175000 sourceFile: 'cisco18bis2jhm.txt'"	| simName s rand mSecs sched elapsedSecs interactionProb msecsPerRound rounds indices tagPair |	n odd ifTrue: [self error: 'n must be even'].	simName _ 'fullconf', n printString.	s _ (FileStream newFileNamed: simName, '.sim') binary.	self addCreateTags: 1 tagReaders: 0 to: s.	self loadCodeFromFile: srcFileName to: s.	self addCreateTags: n tagReaders: 0 to: s.	"simulate clock jitter by running each tag a random of seconds (0 to 60)"	rand _ Random new.	1 to: n do: [:i |		mSecs _ (rand next * 60000) asInteger.		self addZoomTags: (Array with: i) runMSecs: 1 skipMSecs: 10 totalMSecs: mSecs to: s].	sched _ self interactionProbabilitySchedule.	elapsedSecs _ 0.	interactionProb _ 0.1.  "default"	msecsPerRound _ 13300.	rounds _ ((totalSeconds * 1000) / msecsPerRound) truncated + 1.	indices _ (1 to: n) asArray.	1 to: rounds do: [:r |		(sched size > 0 and: [elapsedSecs >= sched first first]) ifTrue: [			interactionProb _ sched removeFirst last].		(r \\ 100) = 1 ifTrue: [self addMessage: 'Round ', r printString, ' of ', rounds printString to: s].		(r \\ 1000) = 1 ifTrue: [self addDumpLogsToFile: simName, '.r', (r - 1) printString, '.log.txt' to: s].		indices _ indices shuffled.		1 to: n by: 2 do: [:i |			tagPair _ Array with: (indices at: i) with: (indices at: i + 1).			rand next < interactionProb				ifTrue: [					mSecs _ (rand next * msecsPerRound) asInteger.					self addZoomTags: tagPair runMSecs: 5 skipMSecs: 95 totalMSecs: mSecs to: s.					self addRunTags: tagPair doIR: true reader: 0 mSecs: (msecsPerRound - mSecs) to: s]				ifFalse: [					self addZoomTags: tagPair runMSecs: 5 skipMSecs: 95 totalMSecs: msecsPerRound to: s]].		elapsedSecs _ elapsedSecs + (msecsPerRound / 1000.0)].	self addDumpLogsToFile: simName, '.logs.txt' to: s.	self addDumpTagDataToFile: simName, '.final.dmp' to: s.	s close.! !!LogoSimulatorClient methodsFor: 'file creation' stamp: 'jm 3/29/2003 22:18'!generateOldFullTest: n seconds: totalSeconds sourceFile: srcFileName	"LogoSimulatorClient new generateFullTest: 10 seconds: 174000 sourceFile: 'cisco18bis2jhm.txt'"	| simName s rand mSecs msecsPerRound rounds indices tagPair |	n odd ifTrue: [self error: 'n must be even'].	simName _ 'full', n printString.	s _ (FileStream newFileNamed: simName, '.sim') binary.	self addCreateTags: 1 tagReaders: 0 to: s.	self loadCodeFromFile: srcFileName to: s.	self addDumpTagDataToFile: simName, '.begin.dmp' to: s.	self addCreateTags: n tagReaders: 0 to: s.	"simulate clock jitter by running each tag a random of seconds (0 to 60)"	rand _ Random new.	1 to: n do: [:i |		mSecs _ (rand next * 60000) asInteger.		self addZoomTags: (Array with: i) runMSecs: 1 skipMSecs: 10 totalMSecs: mSecs to: s].	msecsPerRound _ 13300.	rounds _ ((totalSeconds * 1000) / msecsPerRound) truncated + 1.	indices _ (1 to: n) asArray.	1 to: rounds do: [:r |		(r \\ 100) = 1 ifTrue: [self addMessage: 'Round ', r printString, ' of ', rounds printString to: s].		indices _ indices shuffled.		1 to: n by: 2 do: [:i |			tagPair _ Array with: (indices at: i) with: (indices at: i + 1).			rand next < 0.1  "20% chance of communicating"				ifTrue: [					mSecs _ (rand next * msecsPerRound) asInteger.					self addZoomTags: tagPair runMSecs: 5 skipMSecs: 95 totalMSecs: mSecs to: s.					self addRunTags: tagPair doIR: true reader: 0 mSecs: (msecsPerRound - mSecs) to: s]				ifFalse: [					self addZoomTags: tagPair runMSecs: 5 skipMSecs: 95 totalMSecs: msecsPerRound to: s]]].	self addDumpLogsToFile: simName, '.logs.txt' to: s.	self addDumpTagDataToFile: simName, '.final.dmp' to: s.	s close.! !!LogoSimulatorClient methodsFor: 'file creation' stamp: 'jm 3/10/2003 16:39'!generateShuffledTest: n rounds: rounds sourceFile: srcFileName	"LogoSimulatorClient new generateShuffledTest: 10 rounds: 30 sourceFile: 'cisco12brian.txt'"	| simName s totalMSecs rand indices talkTime tagPair |	n odd ifTrue: [self error: 'n must be even'].	simName _ 'shuffled', n printString.	s _ (FileStream newFileNamed: simName, '.sim') binary.	self addCreateTags: 1 tagReaders: 0 to: s.	self loadCodeFromFile: srcFileName to: s.	self addDumpTagDataToFile: simName, '.begin.dmp' to: s.	self addCreateTags: n tagReaders: 0 to: s.	totalMSecs _ 12000.	rand _ Random new.	indices _ (1 to: n) asArray.	1 to: rounds do: [:r |		self addMessage: 'Round ', r printString, ' of ', rounds printString to: s.		indices _ indices shuffled.		1 to: n by: 2 do: [:i |			tagPair _ Array with: (indices at: i) with: (indices at: i + 1).			rand next < 0.50  "50% chance of communicating"				ifTrue: [					talkTime _ (rand next * totalMSecs) asInteger roundTo: 100.					self addRunTags: tagPair doIR: true reader: 0 mSecs: talkTime to: s]				ifFalse: [talkTime _ 0].			self addZoomTags: tagPair runMSecs: 10 skipMSecs: 90 totalMSecs: (totalMSecs - talkTime) to: s]].	self addDumpLogsToFile: simName, '.logs.txt' to: s.	self addDumpTagDataToFile: simName, '.final.dmp' to: s.	s close.! !!LogoSimulatorClient methodsFor: 'file creation' stamp: 'jm 3/29/2003 22:25'!interactionProbabilitySchedule	"Answer a collection of pairs where the first entry in each pair is the elapsed time in seconds and the second entry is the probability of two tags interacting in a given 13.3 second epoch."	"Note: Array below is pairs of <duration in minutes><interaction level mnemonic>."	"LogoSimulatorClient new interactionProbabilitySchedule"	| result elapsed p |	result _ OrderedCollection new.	elapsed _ 0.	#(	"Day 1:"		(30 vlow)		(60 hi)		(90 med)		(60 hi)		(120 low)	"Day 2:"		(420 vlow)		(60 hi)		(135 med)		(30 hi)		(90 med)		(75 med) "lunch"		(480 hi)		(150 low)	"Day 3:"		(420 vlow)		(60 hi)		(135 med)		(30 hi)		(45 med)		(60 med) "lunch"		(240 hi)		(60 med)		(45 hi)	) do: [:e |		'vlow' = e last ifTrue: [p _ 0.002].		'low' = e last ifTrue: [p _ 0.01].		'med' = e last ifTrue: [p _ 0.05].		'hi' = e last ifTrue: [p _ 0.4].		result addLast: (Array with: elapsed with: p).		elapsed _ elapsed + (e first * 60)].	^ result! !!LogoSimulatorClient methodsFor: 'file creation' stamp: 'jm 3/10/2003 16:28'!loadCodeFromFile: inFileName outFile: outFileName	"Compile and load the given file. The file is compiled for a specific target address. The compiler state is retained to allow compiling commands the call functions defined in the file."	"LogoSimulatorClient new loadCodeFromFile: 'cisco12.txt' outFile: 'cisco12.sim'"	| s |	s _ FileStream newFileNamed: outFileName.	self loadCodeFromFile: inFileName to: s.	s close.! !!LogoSimulatorClient methodsFor: 'file creation' stamp: 'jm 3/10/2003 16:28'!loadCodeFromFile: inFileName to: s	"Compile and load the given file. The file is compiled for a specific target address. The compiler state is retained to allow compiling commands the call functions defined in the file."	"LogoSimulatorClient new loadCodeFromFile: 'cisco12.txt' outFile: 'cisco12.sim'"	| tagNum targetAddr bytecodes startAddr |	tagNum _ 0.	targetAddr _ 16r3000.	compiler ifNil: [compiler _ NTagLogoCompiler new].	bytecodes _ compiler compileFileNamed: inFileName at: targetAddr.	s nextPutAll: '<' asByteArray,		(self numToBytes: tagNum), (self numToBytes: targetAddr), (self numToBytes: bytecodes size).	s nextPutAll: bytecodes.	startAddr _ compiler addressOfFunction: 'startup'.	startAddr ifNotNil: [		s nextPutAll: ('P' asByteArray, (self numToBytes: tagNum), (self numToBytes: startAddr + 2))].! !!LogoSimulatorClient methodsFor: 'socket stuff' stamp: 'jm 2/21/2003 10:33'!connect	| portNum |	portNum _ 6824.	Socket initializeNetwork.	self disconnect.	socket _ Socket new.	socket connectTo: hostAddress port: portNum.	socket waitForConnectionUntil: (Socket deadlineSecs: 5).	(socket isConnected) ifFalse: [		self disconnect.		self inform: 'connection attempt failed'].! !!LogoSimulatorClient methodsFor: 'socket stuff' stamp: 'jm 1/26/2003 21:16'!disconnect	socket ifNotNil: [		socket destroy.		socket _ nil].! !!LogoSimulatorClient methodsFor: 'socket stuff' stamp: 'jm 2/21/2003 10:34'!flushData	"Read and discard all data that has arrived on the socket. Assume the socket is connected."	| buf |	buf _ ByteArray new: 100.	[(socket readInto: buf startingAt: 1) > 0] whileTrue.! !!LogoSimulatorClient methodsFor: 'socket stuff' stamp: 'jm 2/21/2003 10:34'!isConnected	^ socket notNil and: [socket isConnected]! !!LogoSimulatorClient methodsFor: 'socket stuff' stamp: 'jm 2/2/2003 18:24'!readByteCount: byteCount	"Answer a buffer containing the given number bytes of data. Wait indefinitely for the data to arrive."	| buf i n |	buf _ ByteArray new: byteCount.	i _ 1.	[i <= byteCount] whileTrue: [		(n _ socket readInto: buf startingAt: i) > 0			ifTrue: [i _ i + n]			ifFalse: [(Delay forMilliseconds: 10) wait]].	^ buf! !!LogoSimulatorClient methodsFor: 'private' stamp: 'jm 2/2/2003 18:12'!numToBytes: anInteger	"Answer a two-byte ByteArray containing the given 16-bit integer, least significant byte first."	^ ByteArray with: (anInteger bitAnd: 255) with: ((anInteger >> 8) bitAnd: 255)! !!LogoSimulatorClient methodsFor: 'private' stamp: 'jm 2/1/2003 19:49'!wordsToBytes: aCollection	"Serialize the given collection of 16-bit integers into a ByteArray."	| result |	result _ WriteStream on: (ByteArray new: 2 * aCollection size).	aCollection do: [:n |		result nextPut: (n bitAnd: 255).		result nextPut: ((n bitShift: -8) bitAnd: 255)].	^ result contents! !I represent a key for looking up entries in a data structure. Subclasses of me, such as Association, typically represent dictionary entries.!I respresent a sequence of sound samples, often used to record a single note played by a real instrument. I can be pitch-shifted up or down, and can include a looped portion to allow a sound to be sustained indefinitely.!!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 10/14/1998 16:04'!addReleaseEnvelope	"Add a simple release envelope to this sound."	| p env |	p _ OrderedCollection new.	p add: 0@1.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	env _ (VolumeEnvelope points: p loopStart: 2 loopEnd: 3) target: self.	envelopes size > 0 ifTrue: [  "remove any existing volume envelopes"		envelopes copy do: [:e |			(e isKindOf: VolumeEnvelope) ifTrue: [self removeEnvelope: e]]].	self addEnvelope: env.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 11:48'!computeSampleCountForRelease	"Calculate the number of samples before the end of the note after which looping back will be be disabled. The units of this value, sampleCountForRelease, are samples at the original sampling rate. When playing a specific note, this value is converted to releaseCount, which is number of samples to be computed at the current pitch and sampling rate."	"Details: For short loops, set the sampleCountForRelease to the loop length plus the number of samples between loopEnd and lastSample. Otherwise, set it to 1/10th of a second worth of samples plus the number of samples between loopEnd and lastSample. In this case, the trailing samples will be played only if the last loop-back occurs within 1/10th of a second of the total note duration, and the note may be shortened by up to 1/10th second. For long loops, this is the best we can do."	(scaledLoopLength > 0 and: [lastSample > loopEnd])		ifTrue: [			sampleCountForRelease _ (lastSample - loopEnd) +				(self loopLength min: (originalSamplingRate / 10.0)) asInteger]		ifFalse: [sampleCountForRelease _ 0].	releaseCount _ sampleCountForRelease.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 5/5/1999 20:59'!fromAIFFFileNamed: fileName mergeIfStereo: mergeFlag	"Initialize this sound from the data in the given AIFF file. If mergeFlag is true and the file is stereo, its left and right channels are mixed together to produce a mono sampled sound."	| aiffFileReader |	aiffFileReader _ AIFFFileReader new.	aiffFileReader readFromFile: fileName		mergeIfStereo: mergeFlag		skipDataChunk: false.	aiffFileReader isLooped		ifTrue: [			self samples: aiffFileReader leftSamples				loopEnd: aiffFileReader loopEnd				loopLength: aiffFileReader loopLength				pitch: aiffFileReader pitch				samplingRate: aiffFileReader samplingRate]		ifFalse: [			self unloopedSamples: aiffFileReader leftSamples				pitch: aiffFileReader pitch				samplingRate: aiffFileReader samplingRate].	"the following must be done second, since the initialization above sets	 leftSamples and rightSamples to the same sample data"	aiffFileReader isStereo		ifTrue: [rightSamples _ aiffFileReader rightSamples].	initialCount _ (leftSamples size * self samplingRate) // originalSamplingRate.	self loudness: 1.0.	self addReleaseEnvelope.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 8/18/1998 07:43'!initialize	"This default initialization creates a loop consisting of a single cycle of a sine wave."	"(LoopedSampledSound pitch: 440.0 dur: 1.0 loudness: 0.4) play"	| samples |	super initialize.	samples _ FMSound sineTable.	self samples: samples		loopEnd: samples size		loopLength: samples size		pitch: 1.0		samplingRate: samples size.	self addReleaseEnvelope.	self setPitch: 440.0 dur: 1.0 loudness: 0.5.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 7/9/1999 22:28'!samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound use the given samples array with a loop of the given length starting at the given index. The loop length may have a fractional part; this is necessary to achieve pitch accuracy for short loops."	| loopStartIndex |	super initialize.	loopStartIndex _ (loopEndIndex - loopSampleCount) truncated + 1.	((1 <= loopStartIndex) and:	 [loopStartIndex < loopEndIndex and:	 [loopEndIndex <= aSoundBuffer size]])		ifFalse: [self error: 'bad loop parameters'].	leftSamples _ rightSamples _ aSoundBuffer.	originalSamplingRate _ samplingRateInHz asFloat.	perceivedPitch _ perceivedPitchInHz asFloat.	gain _ 1.0.	firstSample _ 1.	lastSample _ leftSamples size.	lastSample >= (SmallInteger maxVal // LoopIndexScaleFactor) ifTrue: [		self error: 'cannot handle more than ',			(SmallInteger maxVal // LoopIndexScaleFactor) printString, ' samples'].	loopEnd _ loopEndIndex.	scaledLoopLength _ (loopSampleCount * LoopIndexScaleFactor) asInteger.	scaledIndexIncr _ (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.	self computeSampleCountForRelease.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:09'!setPitch: pitchNameOrNumber dur: d loudness: vol	"(LoopedSampledSound pitch: 440.0 dur: 2.5 loudness: 0.4) play"	super setPitch: pitchNameOrNumber dur: d loudness: vol.	self pitch: (self nameOrNumberToPitch: pitchNameOrNumber).	self reset.! !!LoopedSampledSound methodsFor: 'initialization' stamp: 'jm 7/9/1999 22:28'!unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"Make this sound play the given samples unlooped. The samples have the given perceived pitch when played at the given sampling rate. By convention, unpitched sounds such as percussion sounds should specify a pitch of nil or 100 Hz."	super initialize.	leftSamples _ rightSamples _ aSoundBuffer.	originalSamplingRate _ samplingRateInHz asFloat.	perceivedPitchInHz		ifNil: [perceivedPitch _ 100.0]		ifNotNil: [perceivedPitch _ perceivedPitchInHz asFloat].	gain _ 1.0.	firstSample _ 1.	lastSample _ leftSamples size.	lastSample >= (SmallInteger maxVal // LoopIndexScaleFactor) ifTrue: [		self error: 'cannot handle more than ',			(SmallInteger maxVal // LoopIndexScaleFactor) printString, ' samples'].	loopEnd _ leftSamples size.	scaledLoopLength _ 0.  "zero length means unlooped"	scaledIndexIncr _ (samplingRateInHz * LoopIndexScaleFactor) // self samplingRate.	self computeSampleCountForRelease.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 5/31/1999 14:09'!beUnlooped	scaledLoopLength _ 0.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:26'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate asFloat! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:36'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:25'!firstSample	^ firstSample! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:25'!firstSample: aNumber	firstSample _ (aNumber asInteger max: 1) min: lastSample.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/3/1998 18:52'!gain	^ gain! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/3/1998 18:52'!gain: aNumber	gain _ aNumber asFloat.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 07:26'!isLooped	^ scaledLoopLength ~= 0.  "zero loop length means unlooped"! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:14'!isStereo	^ leftSamples ~~ rightSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!leftSamples	^ leftSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!leftSamples: aSampleBuffer	leftSamples _ aSampleBuffer.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 09:35'!loopEnd	^ loopEnd! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:12'!loopLength	^ scaledLoopLength / FloatLoopIndexScaleFactor! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 10/14/1998 16:26'!originalSamplingRate	^ originalSamplingRate! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 2/2/1999 09:54'!perceivedPitch	^ perceivedPitch! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 09:08'!pitch	^ (scaledIndexIncr asFloat * perceivedPitch * self samplingRate asFloat) /	  (originalSamplingRate * FloatLoopIndexScaleFactor)! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 8/18/1998 11:38'!pitch: p	scaledIndexIncr _		((p asFloat * originalSamplingRate * FloatLoopIndexScaleFactor) /		 (perceivedPitch * self samplingRate asFloat)) asInteger.	sampleCountForRelease > 0		ifTrue: [releaseCount _ (sampleCountForRelease * LoopIndexScaleFactor) // scaledIndexIncr]		ifFalse: [releaseCount _ 0].! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!rightSamples	^ rightSamples! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 7/13/1998 11:46'!rightSamples: aSampleBuffer	rightSamples _ aSampleBuffer.! !!LoopedSampledSound methodsFor: 'accessing' stamp: 'jm 3/15/1999 08:01'!samples	"For compatability with SampledSound. Just return my left channel (which is the only channel if I am mono)."	^ leftSamples! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/19/1998 10:43'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play samples from a wave table by stepping a fixed amount through the table on every sample. The table index and increment are scaled to allow fractional increments for greater pitch accuracy.  If a loop length is specified, then the index is looped back when the loopEnd index is reached until count drops below releaseCount. This allows a short sampled sound to be sustained indefinitely."	"(LoopedSampledSound pitch: 440.0 dur: 5.0 loudness: 0.5) play"	| lastIndex sampleIndex i s compositeLeftVol compositeRightVol nextSampleIndex m isInStereo rightVal leftVal |	<primitive: 184>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #leftSamples declareC: 'short int *leftSamples'.	self var: #rightSamples declareC: 'short int *rightSamples'.	isInStereo _ leftSamples ~~ rightSamples.	compositeLeftVol _ (leftVol * scaledVol) // ScaleFactor.	compositeRightVol _  (rightVol * scaledVol) // ScaleFactor.	i _ (2 * startIndex) - 1.	lastIndex _ (startIndex + n) - 1.	startIndex to: lastIndex do: [:sliceIndex |		sampleIndex _ (scaledIndex _ scaledIndex + scaledIndexIncr) // LoopIndexScaleFactor.		((sampleIndex > loopEnd) and: [count > releaseCount]) ifTrue: [			"loop back if not within releaseCount of the note end"			"note: unlooped sounds will have loopEnd = lastSample"			sampleIndex _ (scaledIndex _ scaledIndex - scaledLoopLength) // LoopIndexScaleFactor].		(nextSampleIndex _ sampleIndex + 1) > lastSample ifTrue: [			sampleIndex > lastSample ifTrue: [count _ 0. ^ nil].  "done!!"			scaledLoopLength = 0				ifTrue: [nextSampleIndex _ sampleIndex]				ifFalse: [nextSampleIndex _ ((scaledIndex - scaledLoopLength) // LoopIndexScaleFactor) + 1]].		m _ scaledIndex bitAnd: LoopIndexFractionMask.		rightVal _ leftVal _			(((leftSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +			 ((leftSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor.		isInStereo ifTrue: [			rightVal _				(((rightSamples at: sampleIndex) * (LoopIndexScaleFactor - m)) +				 ((rightSamples at: nextSampleIndex) * m)) // LoopIndexScaleFactor].		leftVol > 0 ifTrue: [			s _ (aSoundBuffer at: i) + ((compositeLeftVol * leftVal) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i _ i + 1.		rightVol > 0 ifTrue: [			s _ (aSoundBuffer at: i) + ((compositeRightVol * rightVal) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		i _ i + 1.		scaledVolIncr ~= 0 ifTrue: [  "update volume envelope if it is changing"			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0].			compositeLeftVol _ (leftVol * scaledVol) // ScaleFactor.			compositeRightVol _  (rightVol * scaledVol) // ScaleFactor]].	count _ count - n.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/17/1998 09:38'!reset	super reset.	count _ initialCount.	scaledIndex _ firstSample * LoopIndexScaleFactor.! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 8/18/1998 09:31'!samplesRemaining	"Answer the number of samples remaining until the end of this sound."	^ count! !!LoopedSampledSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:57'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 08:19'!copyDownSampledLowPassFiltering: doFiltering	"Answer a copy of the receiver at half its sampling rate. The result consumes half the memory space, but has only half the frequency range of the original. If doFiltering is true, the original sound buffers are low-pass filtered before down-sampling. This is slower, but prevents aliasing of any high-frequency components of the original signal. (While it may be possible to avoid low-pass filtering when down-sampling from 44.1 kHz to 22.05 kHz, it is probably essential when going to lower sampling rates.)"	^ self copy downSampleLowPassFiltering: doFiltering! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 09:30'!edit	"Open a WaveEditor on this sound."	| loopLen ed |	loopLen _ scaledLoopLength asFloat / LoopIndexScaleFactor.	ed _ WaveEditor new		data: leftSamples;		samplingRate: originalSamplingRate;		loopEnd: loopEnd;		loopLength: loopLen;		loopCycles: (loopLen / (originalSamplingRate asFloat / perceivedPitch)) rounded.	ed openInWorld.! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 07:49'!fftAt: startIndex	"Answer the Fast Fourier Transform (FFT) of my samples (only the left channel, if stereo) starting at the given index."	| availableSamples fftWinSize |	availableSamples _ (leftSamples size - startIndex) + 1.	fftWinSize _ 2 raisedTo: (((availableSamples - 1) log: 2) truncated + 1).	fftWinSize _ fftWinSize min: 4096.	fftWinSize > availableSamples ifTrue: [fftWinSize _ fftWinSize / 2].	^ self fftWindowSize: fftWinSize startingAt: startIndex! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 5/29/1999 18:56'!findStartPointAfter: index	"Answer the index of the last zero crossing sample before the given index."	| i |	i _ index min: lastSample.	"scan backwards to the last zero-crossing"	(leftSamples at: i) > 0		ifTrue: [			[i > 1 and: [(leftSamples at: i) > 0]] whileTrue: [i _ i - 1]]		ifFalse: [			[i > 1 and: [(leftSamples at: i) < 0]] whileTrue: [i _ i - 1]].	^ i! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 09:29'!findStartPointForThreshold: threshold	"Answer the index of the last zero crossing sample before the first sample whose absolute value (in either the right or left channel) exceeds the given threshold."	| i |	i _ self indexOfFirstPointOverThreshold: threshold.	i >= lastSample ifTrue: [^ self error: 'no sample exceeds the given threshold'].	"scan backwards to the last zero-crossing"	(leftSamples at: i) > 0		ifTrue: [			[i > 1 and: [(leftSamples at: i) > 0]] whileTrue: [i _ i - 1]]		ifFalse: [			[i > 1 and: [(leftSamples at: i) < 0]] whileTrue: [i _ i - 1]].	^ i! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/18/1998 09:26'!highestSignificantFrequencyAt: startIndex	"Answer the highest significant frequency in the sample window starting at the given index. The a frequency is considered significant if it's power is at least 1/50th that of the maximum frequency component in the frequency spectrum."	| fft powerArray threshold indices |	fft _ self fftAt: startIndex.	powerArray _ self normalizedResultsFromFFT: fft.	threshold _ powerArray max / 50.0.	indices _ (1 to: powerArray size) select: [:i | (powerArray at: i) > threshold].	^ originalSamplingRate / (fft samplesPerCycleForIndex: indices last)! !!LoopedSampledSound methodsFor: 'other' stamp: 'jm 8/17/1998 09:22'!indexOfFirstPointOverThreshold: threshold	"Answer the index of the first sample whose absolute value exceeds the given threshold."	| s |	leftSamples == rightSamples		ifTrue: [			1 to: lastSample do: [:i |				s _ leftSamples at: i.				s < 0 ifTrue: [s _ 0 - s].				s > threshold ifTrue: [^ i]]]		ifFalse: [			1 to: lastSample do: [:i |				s _ leftSamples at: i.				s < 0 ifTrue: [s _ 0 - s].				s > threshold ifTrue: [^ i].				s _ rightSamples at: i.				s < 0 ifTrue: [s _ 0 - s].				s > threshold ifTrue: [^ i]]].	^ lastSample + 1! !!LoopedSampledSound methodsFor: 'private' stamp: 'jm 8/18/1998 08:11'!downSampleLowPassFiltering: doFiltering	"Cut my sampling rate in half. Use low-pass filtering (slower) if doFiltering is true."	"Note: This operation loses information, and modifies the receiver in place."	| stereo newLoopLength |	stereo _ self isStereo.	leftSamples _ leftSamples downSampledLowPassFiltering: doFiltering.	stereo		ifTrue: [rightSamples _ rightSamples downSampledLowPassFiltering: doFiltering]		ifFalse: [rightSamples _ leftSamples].	originalSamplingRate _ originalSamplingRate / 2.0.	loopEnd odd		ifTrue: [newLoopLength _ (self loopLength / 2.0) + 0.5]		ifFalse: [newLoopLength _ self loopLength / 2.0].	firstSample _ (firstSample + 1) // 2.	lastSample _ (lastSample + 1) // 2.	loopEnd _ (loopEnd + 1) // 2.	scaledLoopLength _ (newLoopLength * LoopIndexScaleFactor) asInteger.	scaledIndexIncr _ scaledIndexIncr // 2.! !!LoopedSampledSound methodsFor: 'private' stamp: 'jm 8/18/1998 07:48'!fftWindowSize: windowSize startingAt: startIndex	"Answer a Fast Fourier Transform (FFT) of the given number of samples starting at the given index (the left channel only, if stereo). The window size will be rounded up to the nearest power of two greater than the requested size. There must be enough samples past the given starting index to accomodate this window size."	| nu n fft |	nu _ ((windowSize - 1) log: 2) truncated + 1.	n _ 2 raisedTo: nu.	fft _ FFT new nu: nu.	fft realData: ((startIndex to: startIndex + n - 1) collect: [:i | leftSamples at: i]).	^ fft transformForward: true.! !!LoopedSampledSound methodsFor: 'private' stamp: 'jm 8/16/1998 17:48'!normalizedResultsFromFFT: fft	"Answer an array whose size is half of the FFT window size containing power in each frequency band, normalized to the average power over the entire FFT. A value of 10.0 in this array thus means that the power at the corresponding frequences is ten times the average power across the entire FFT."	| r avg |	r _ (1 to: fft realData size // 2) collect:		[:i | ((fft realData at: i) squared + (fft imagData at: i) squared) sqrt].	avg _ r sum / r size.	^ r collect: [:v | v / avg].! !!LoopedSampledSound methodsFor: 'file i/o' stamp: 'jm 12/3/2003 17:25'!storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files)."	(self isStereo or: [self samplingRate ~= originalSamplingRate]) ifTrue: [		^ super storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream].	"optimization: if I'm not stereo and sampling rates match, just store my buffer"	leftSamples storeOn: aBinaryStream bigEndian: bigEndianFlag stereo: false.! !!LoopedSampledSound class methodsFor: 'class initialization' stamp: 'jm 8/13/1998 12:54'!initialize	"LoopedSampledSound initialize"	LoopIndexScaleFactor _ 512.	FloatLoopIndexScaleFactor _ LoopIndexScaleFactor asFloat.	LoopIndexFractionMask _ LoopIndexScaleFactor - 1.! !!LoopedSampledSound class methodsFor: 'instance creation' stamp: 'jm 8/18/1998 07:40'!samples: aSoundBuffer loopEnd: loopEndIndex loopLength: loopSampleCount pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"See the comment in the instance method of this name."	^ self basicNew		samples: aSoundBuffer		loopEnd: loopEndIndex		loopLength: loopSampleCount		pitch: perceivedPitchInHz		samplingRate: samplingRateInHz! !!LoopedSampledSound class methodsFor: 'instance creation' stamp: 'jm 8/18/1998 07:41'!unloopedSamples: aSoundBuffer pitch: perceivedPitchInHz samplingRate: samplingRateInHz	"See the comment in the instance method of this name."	^ self basicNew		unloopedSamples: aSoundBuffer		pitch: perceivedPitchInHz		samplingRate: samplingRateInHz! !I am used to send a MIDI controller value.!!MIDIControllerMorph methodsFor: 'initialization' stamp: 'jm 9/28/1998 22:38'!initialize	| slider |	super initialize.	orientation _ #vertical.	centering _ #center.	hResizing _ vResizing _ #shrinkWrap.	self color: (Color r: 0.484 g: 0.613 b: 0.0).	self borderWidth: 1.	channel _ 0.	controller _ 7.  "channel volume"	slider _ SimpleSliderMorph new		target: self;		actionSelector: #newSliderValue:;		minVal: 0;		maxVal: 127;		extent: 128@10.	self addMorphBack: slider.	self addMorphBack: (StringMorph contents: 'Midi Controller').	self updateLabel.! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:35'!channel	^ channel! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:40'!channel: anInteger	channel _ anInteger.	lastValue _ nil.	self updateLabel.! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:35'!controller	^ controller! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:40'!controller: anInteger	controller _ anInteger.	lastValue _ nil.	self updateLabel.! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:54'!midiPort	^ midiPort! !!MIDIControllerMorph methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:55'!midiPort: anInteger	midiPort _ anInteger.! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/28/1998 22:47'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'set channel' action: #setChannel:.	aCustomMenu add: 'set controller' action: #setController:.! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/29/1998 09:06'!controllerList	"Answer a list of controller name, number pairs to be used in the menu."	^ #((1 modulation)		(2 'breath control')		(7 volume)		(10 pan)		(11 expression)		(92 'tremolo depth')		(93 'chorus depth')		(94 'celeste depth')		(95 'phaser depth'))! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'jm 9/29/1998 09:09'!controllerName: controllerNumber	"Answer a name for the given controller. If no name is available, use the form 'CC5' (CC is short for 'continuous controller')."	self controllerList do: [:pair |		pair first = controllerNumber ifTrue: [^ pair last]].	^ 'CC', controllerNumber asString! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'sma 6/5/2000 13:29'!setChannel: evt	| menu |	menu _ MenuMorph new.	1 to: 16 do: [:chan |		menu add: chan printString			target: self			selector: #channel:			argumentList: (Array with: chan - 1)].	menu popUpEvent: evt! !!MIDIControllerMorph methodsFor: 'menu' stamp: 'sma 6/5/2000 13:29'!setController: evt	| menu |	menu _ MenuMorph new.	self controllerList do: [:pair |		menu add: (pair last)			target: self			selector: #controller:			argumentList: (Array with: pair first)].	menu popUpEvent: evt! !!MIDIControllerMorph methodsFor: 'other' stamp: 'jm 10/12/1998 16:02'!newSliderValue: newValue	"Send a control command out the MIDI port."	| val |	midiPort ifNil: [^ self].	val _ newValue asInteger.	lastValue = val ifTrue: [^ self].	lastValue _ val.	midiPort midiCmd: 16rB0 channel: channel byte: controller byte: val.! !!MIDIControllerMorph methodsFor: 'other' stamp: 'jm 9/29/1998 09:10'!updateLabel	| label |	(label _ self findA: StringMorph) ifNil: [^ self].	label contents: (self controllerName: controller), ', ch: ', (channel + 1) printString.! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 9/27/1998 21:44'!readHeaderChunk	| chunkType chunkSize division |	chunkType _ self readChunkType.	chunkType = 'RIFF' ifTrue:[chunkType _ self riffSkipToMidiChunk].	chunkType = 'MThd' ifFalse: [self scanForMIDIHeader].	chunkSize _ self readChunkSize.	fileType _ self next16BitWord.	trackCount _ self next16BitWord.	division _ self next16BitWord.	(division anyMask: 16r8000)		ifTrue: [self error: 'SMPTE time formats are not yet supported']		ifFalse: [ticksPerQuarter _ division].	maxNoteTicks _ 12 * 4 * ticksPerQuarter.		"longest acceptable note; used to detect stuck notes"	"sanity checks"	((chunkSize < 6) or: [chunkSize > 100])		ifTrue: [self error: 'unexpected MIDI header size ', chunkSize printString].	(#(0 1 2) includes: fileType)		ifFalse: [self error: 'unknown MIDI file type ', fileType printString].	Transcript		show: 'Reading Type ', fileType printString, ' MIDI File (';		show: trackCount printString, ' tracks, ';		show: ticksPerQuarter printString, ' ticks per quarter note)';		cr.! !!MIDIFileReader methodsFor: 'chunk reading' stamp: 'jm 9/12/1998 19:08'!readMIDIFrom: aBinaryStream	"Read one or more MIDI tracks from the given binary stream."	stream _ aBinaryStream.	tracks _ OrderedCollection new.	trackInfo _ OrderedCollection new.	self readHeaderChunk.	trackCount timesRepeat: [self readTrackChunk].	stream atEnd ifFalse: [self report: 'data beyond final track'].	fileType = 0 ifTrue: [self splitIntoTracks].	self guessMissingInstrumentNames.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/27/1998 22:15'!metaEventAt: ticks	"Read a meta event. Event types appear roughly in order of expected frequency."	| type length tempo |	type _ trackStream next.	length _ self readVarLengthIntFrom: trackStream.	type = 16r51 ifTrue: [  "tempo"		tempo _ 0.		length timesRepeat: [tempo _ (tempo bitShift: 8) + trackStream next].		track add: (TempoEvent new tempo: tempo; time: ticks).		^ self].	type = 16r2F ifTrue: [  "end of track"		length = 0 ifFalse: [self error: 'length of end-of-track chunk should be zero'].		self endAllNotesAt: ticks.		trackStream skip: length.		^ self].	type = 16r58 ifTrue: [  "time signature"		length = 4 ifFalse: [self error: 'length of time signature chunk should be four'].		trackStream skip: length.		^ self].	type = 16r59 ifTrue: [  "key signature"		length = 2 ifFalse: [self error: 'length of key signature chunk should be two'].		trackStream skip: length.		^ self].	((type >= 1) and: [type <= 7]) ifTrue: [  "string"		strings add: (trackStream next: length) asString.		^ self].	(  type = 16r21 or:   "mystery; found in MIDI files but not in MIDI File 1.0 Spec"	 [(type = 16r7F) or:  "sequencer specific meta event"	 [(type = 16r00) or:  "sequence number"	 [(type = 16r20)]]])  "MIDI channel prefix"		ifTrue: [			trackStream skip: length.			^ self].	type = 16r54 ifTrue: [		"SMPTE offset"		self report: 'Ignoring SMPTE offset'.		trackStream skip: length.		^ self].	"skip unrecognized meta event"	self report:		'skipping unrecognized meta event: ', (type printStringBase: 16),		' (', length printString, ' bytes)'.	trackStream skip: length.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/12/1998 17:10'!readTrackContents: byteCount	| info |	strings _ OrderedCollection new.	track _ OrderedCollection new.	trackStream _ ReadStream on: (stream next: byteCount).	activeEvents _ OrderedCollection new.	self readTrackEvents.	(tracks isEmpty and: [self isTempoTrack: track])		ifTrue: [tempoMap _ track asArray]		ifFalse: [			"Note: Tracks without note events are currently not saved to			 eliminate clutter in the score player. In control applications,			 this can be easily changed by modifying the following test."			(self trackContainsNotes: track) ifTrue: [				tracks add: track asArray.				info _ WriteStream on: (String new: 100).				strings do: [:s | info nextPutAll: s; cr].				trackInfo add: info contents]].	strings _ track _ trackStream _ activeEvents _ nil.! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/10/1998 09:57'!readTrackEvents	"Read the events of the current track."	| cmd chan key vel ticks byte length evt |	cmd _ #unknown.	chan _ key _ vel _ 0.	ticks _ 0.	[trackStream atEnd] whileFalse: [		ticks _ ticks + (self readVarLengthIntFrom: trackStream).		byte _ trackStream next.		byte >= 16rF0			ifTrue: [  "meta or system exclusive event"				byte = 16rFF ifTrue: [self metaEventAt: ticks].				((byte = 16rF0) or: [byte = 16rF7]) ifTrue: [  "system exclusive data"					length _ self readVarLengthIntFrom: trackStream.					trackStream skip: length].				cmd _ #unknown]			ifFalse: [  "channel message event"				byte >= 16r80					ifTrue: [  "new command"						cmd _ byte bitAnd: 16rF0.						chan _ byte bitAnd: 16r0F.						key _ trackStream next]					ifFalse: [  "use running status"						cmd == #unknown							ifTrue: [self error: 'undefined running status; bad MIDI file?'].						key _ byte].				((cmd = 16rC0) or: [cmd = 16rD0]) ifFalse: [					"all but program change and channel pressure have two data bytes"					vel _ trackStream next].				cmd = 16r80 ifTrue: [  "note off"					self endNote: key chan: chan at: ticks].				cmd = 16r90 ifTrue: [  "note on"					vel = 0						ifTrue: [self endNote: key chan: chan at: ticks]						ifFalse: [self startNote: key vel: vel chan: chan at: ticks]].				"cmd = 16A0 -- polyphonic key pressure; skip"				cmd = 16rB0 ifTrue: [					evt _ ControlChangeEvent new control: key value: vel channel: chan.					evt time: ticks.					track add: evt].				cmd = 16rC0 ifTrue: [					evt _ ProgramChangeEvent new program: key channel: chan.					evt time: ticks.					track add: evt].				"cmd = 16D0 -- channel aftertouch pressure; skip"				cmd = 16rE0 ifTrue: [					evt _ PitchBendEvent new bend: key + (vel bitShift: 7) channel: chan.					evt time: ticks.					track add: evt]	]].! !!MIDIFileReader methodsFor: 'track reading' stamp: 'jm 9/12/1998 17:15'!trackContainsNotes: eventList	"Answer true if the given track contains at least one note event."	eventList do: [:e | e isNoteEvent ifTrue: [^ true]].	^ false! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 20:00'!guessMissingInstrumentNames	"Attempt to guess missing instrument names from the first program change in that track."	| progChange instrIndex instrName |	1 to: tracks size do: [:i |		(trackInfo at: i) isEmpty ifTrue: [			progChange _ (tracks at: i) detect: [:e | e isProgramChange] ifNone: [nil].			progChange ifNotNil: [				instrIndex _ progChange program + 1.				instrName _ self class standardMIDIInstrumentNames at: instrIndex.				trackInfo at: i put: instrName]]].! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 17:32'!readChunkType	"Read a chunk ID string from the next 4 bytes."	"Assume: Stream has at least four bytes left."	| s |	s _ String new: 4.	1 to: 4 do: [:i | s at: i put: (stream next) asCharacter].	^ s! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 19:19'!scanForMIDIHeader	"Scan the first part of this file in search of the MIDI header string 'MThd'. Report an error if it is not found. Otherwise, leave the input stream positioned to the first byte after this string."	| asciiM p lastSearchPosition byte restOfHeader |	asciiM _ $M asciiValue.	stream skip: -3.	p _ stream position.	lastSearchPosition _ p + 10000.  "search only the first 10000 bytes of the file"	[p < lastSearchPosition and: [stream atEnd not]] whileTrue: [		[(byte _ stream next) ~= asciiM and: [byte ~~ nil]] whileTrue.  "find the next 'M' or file end"		restOfHeader _ (stream next: 3) asString.		restOfHeader = 'Thd'			ifTrue: [^ self]			ifFalse: [restOfHeader size = 3 ifTrue: [stream skip: -3]].		p _ stream position].	self error: 'MIDI header chunk not found'.! !!MIDIFileReader methodsFor: 'private' stamp: 'jm 9/12/1998 20:10'!splitIntoTracks	"Split a type zero MIDI file into separate tracks by channel number."	| newTempoMap newTracks |	tracks size = 1 ifFalse: [self error: 'expected exactly one track in type 0 file'].	tempoMap ifNotNil: [self error: 'did not expect a tempo map in type 0 file'].	newTempoMap _ OrderedCollection new.	newTracks _ (1 to: 16) collect: [:i | OrderedCollection new].	tracks first do: [:e |		e isTempoEvent			ifTrue: [newTempoMap addLast: e]			ifFalse: [(newTracks at: e channel + 1) addLast: e]].	newTempoMap size > 0 ifTrue: [tempoMap _ newTempoMap asArray].	newTracks _ newTracks select: [:t | self trackContainsNotes: t].	tracks _ newTracks collect: [:t | t asArray].	trackInfo _ trackInfo, ((2 to: tracks size) collect: [:i | '']).! !!MIDIFileReader class methodsFor: 'as yet unclassified' stamp: 'ls 8/8/1998 03:14'!playStream: binaryStream	ScorePlayerMorph		openOn: (self scoreFromStream: binaryStream)		title: 'a MIDI stream'! !!MIDIFileReader class methodsFor: 'as yet unclassified' stamp: 'jm 5/29/1998 17:12'!playURLNamed: urlString	| titleString |	titleString _ urlString		copyFrom: (urlString findLast: [:c | c=$/]) + 1		to: urlString size.	ScorePlayerMorph		openOn: (self scoreFromURL: urlString)		title: titleString.! !!MIDIFileReader class methodsFor: 'as yet unclassified' stamp: 'ls 8/8/1998 03:14'!scoreFromStream: binaryStream	|  score |	score _ (self new readMIDIFrom: binaryStream) asScore.	^ score! !!MIDIFileReader class methodsFor: 'as yet unclassified' stamp: 'jm 9/12/1998 19:57'!standardMIDIInstrumentNames	"Answer an array of Standard MIDI instrument names."	^ #(		'Grand Piano'		'Bright Piano'		'Electric Grand Piano'		'Honky-tonk Piano'		'Electric Piano 1'		'Electric Piano 2'		'Harpsichord'		'Clavichord'		'Celesta'		'Glockenspiel'		'Music Box'		'Vibraphone'		'Marimba'		'Xylophone'		'Tubular Bells'		'Duclimer'		'Drawbar Organ'		'Percussive Organ'		'Rock Organ'		'Church Organ'		'Reed Organ'		'Accordion'		'Harmonica'		'Tango Accordion'		'Nylon Guitar'		'Steel Guitar'		'Electric Guitar 1'		'Electric Guitar 2'		'Electric Guitar 3'		'Overdrive Guitar'		'Distorted Guitar'		'Guitar Harmonics'		'Acoustic Bass'		'Electric Bass 1'		'Electric Bass 2'		'Fretless Bass'		'Slap Bass 1'		'Slap Bass 2'		'Synth Bass 1'		'Synth Bass 2'		'Violin'		'Viola'		'Cello'		'Contrabass'		'Tremolo Strings'		'Pizzicato Strings'		'Orchestral Harp'		'Timpani'		'String Ensemble 1'		'String Ensemble 2'		'Synth Strings 1'		'Synth Strings 2'		'Choir Ahhs'		'Choir Oohs'		'Synth Voice'		'Orchestra Hit'		'Trumpet'		'Trombone'		'Tuba'		'Muted Trumpet'		'French Horn'		'Brass Section'		'Synth Brass 1'		'Synth Brass 2'		'Soprano Sax'		'Alto Sax'		'Tenor Sax'		'Baritone Sax'		'Oboe'		'English Horn'		'Bassoon'		'Clarinet'		'Piccolo'		'Flute'		'Recorder'		'Pan Flute'		'Blown Bottle'		'Shakuhachi'		'Whistle'		'Ocarina'		'Lead 1 (square)'		'Lead 2 (sawtooth)'		'Lead 3 (calliope)'		'Lead 4 (chiff)'		'Lead 5 (charang)'		'Lead 6 (voice)'		'Lead 7 (fifths)'		'Lead 8 (bass+lead)'		'Pad 1 (new age)'		'Pad 2 (warm)'		'Pad 3 (polysynth)'		'Pad 4 (choir)'		'Pad 5 (bowed)'		'Pad 6 (metallic)'		'Pad 7 (halo)'		'Pad 8 (sweep)'		'FX 1 (rain)'		'FX 2 (soundtrack)'		'FX 3 (crystals)'		'FX 4 (atmosphere)'		'FX 5 (brightness)'		'FX 6 (goblins)'		'FX 7 (echoes)'		'FX 8 (sci-fi)'		'Sitar'		'Banjo'		'Shamisen'		'Koto'		'Kalimba'		'Bagpipe'		'Fiddle'		'Shanai'		'Tinkle Bell'		'Agogo'		'Steel Drum'		'Woodblock'		'Taiko Drum'		'Melodic Tom'		'Synth Drum'		'Reverse Cymbal'		'Guitar Fret Noise'		'Breath Noise'		'Seashore'		'Bird Tweet'		'Telephone Ring'		'Helicopter'		'Applause'		'Gunshot')! !I am a parser for a MIDI data stream. I support:	real-time MIDI recording,	overdubbing (recording while playing),	monitoring incoming MIDI, and	interactive MIDI performances.Note: MIDI controllers such as pitch benders and breath controllers generate large volumes of data which consume processor time. In cases where this information is not of interest to the program using it, it is best to filter it out as soon as possible. I support various options for doing this filtering, including filtering by MIDI channel and/or by command type.!!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:39'!ignoreChannel: channel	"Don't record any events arriving on the given MIDI channel (in the range 1-16)."	((channel isInteger not) | (channel < 1) | (channel > 16))		ifTrue: [^ self error: 'bad MIDI channel number', channel printString].	"two-arg channel messages"	#(128 144 160 176 224) do: [:i | cmdActionTable at: (i bitOr: channel - 1) put: #ignoreTwo:].	"one-arg channel messages"	#(192 208) do: [:i | cmdActionTable at: (i bitOr: channel - 1) put: #ignoreOne:].! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:40'!ignoreCommand: midiCmd	"Don't record the given MIDI command on any channel."	| cmd sel | 	((midiCmd isInteger not) | (midiCmd < 128) | (midiCmd > 255))		ifTrue: [^ self error: 'bad MIDI command'].	midiCmd < 240 ifTrue: [  "channel commands; ignore on all channels"		cmd _ midiCmd bitAnd: 2r11110000.		sel _ (#(128 144 160 176 224) includes: cmd)			ifTrue: [#ignoreTwo:]			ifFalse: [#ignoreOne:].		 1 to: 16 do: [:ch | cmdActionTable at: (cmd bitOr: ch - 1) put: sel].		^ self].	(#(240 241 244 245 247 249 253) includes: midiCmd) ifTrue: [		^ self error: 'You can''t ignore the undefined MIDI command: ', midiCmd printString].	midiCmd = 242 ifTrue: [  "two-arg command"		cmdActionTable at: midiCmd put: #ignoreTwo:.		 ^ self].	midiCmd = 243 ifTrue: [  "one-arg command"		cmdActionTable at: midiCmd put: #ignoreOne:.		^ self].	(#(246 248 250 251 252 254 255) includes: midiCmd) ifTrue:	[  "zero-arg command"		cmdActionTable at: midiCmd put: #ignore.		 ^ self].	"we should not get here"	self error: 'implementation error'.! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:38'!ignoreSysEx: aBoolean	"If the argument is true, then ignore incoming system exclusive message."	ignoreSysEx _ aBoolean.! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/9/1998 07:46'!ignoreTuneAndRealTimeCommands	"Ignore tuning requests and real-time commands."	cmdActionTable at: 246 put: #ignoreZero:.	"tune request"	cmdActionTable at: 248 put: #ignoreZero:.	"timing clock"	cmdActionTable at: 250 put: #ignoreZero:.	"start"	cmdActionTable at: 251 put: #ignoreZero:.		"continue"	cmdActionTable at: 252 put: #ignoreZero:.	"stop/Clock"	cmdActionTable at: 254 put: #ignoreZero:.	"active sensing"	cmdActionTable at: 255 put: #ignoreZero:.	"system reset"! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/8/1998 20:37'!noFiltering	"Revert to accepting all MIDI commands on all channels. This undoes any earlier request to filter the incoming MIDI stream."	cmdActionTable _ DefaultMidiTable deepCopy.	ignoreSysEx _ false.! !!MIDIInputParser methodsFor: 'midi filtering' stamp: 'jm 10/9/1998 07:50'!recordOnlyChannels: channelList	"Record only MIDI data arriving on the given list of channel numbers (in the range 1-16)."	channelList do: [:ch |		((ch isInteger not) | (ch < 1) | (ch > 16))			ifTrue: [^ self error: 'bad Midi channel specification: ', ch printString]].	1 to: 16 do: [:ch | (channelList includes: ch) ifFalse: [self ignoreChannel: ch]].! !!MIDIInputParser methodsFor: 'recording' stamp: 'jm 1/6/1999 08:24'!clearBuffers	"Clear the MIDI record buffers. This should be called at the start of recording or real-time MIDI processing."		received _ received species new: 5000.	rawDataBuffer _ ByteArray new: 1000.	sysExBuffer _ WriteStream on: (ByteArray new: 100).	midiPort ifNotNil: [midiPort ensureOpen; flushInput].	startTime _ Time millisecondClockValue.	state _ #idle.! !!MIDIInputParser methodsFor: 'recording' stamp: 'jm 10/8/1998 21:06'!processMIDIData	"Process all MIDI data that has arrived since the last time this method was executed. This method should be called frequently to process, filter, and timestamp MIDI data as it arrives."	| bytesRead |	[(bytesRead _ midiPort readInto: rawDataBuffer) > 0] whileTrue: [		timeNow _ (midiPort bufferTimeStampFrom: rawDataBuffer) - startTime.		5 to: bytesRead do: [:i | self processByte: (rawDataBuffer at: i)]].! !!MIDIInputParser methodsFor: 'recording' stamp: 'jm 10/8/1998 20:24'!received	"Answer my current collection of all MIDI commands received. Items in this list have the form (<time><cmd byte>[<arg1>[<arg2>]]). Note that the real-time processing facility, midiDo:, removes items from this list as it processes them."	^ received! !!MIDIInputParser methodsFor: 'real-time processing' stamp: 'jm 10/9/1998 07:53'!midiDo: aBlock	"Poll the incoming MIDI stream in real time and call the given block for each complete command that has been received. The block takes one argument, which is an array of the form (<time><cmd byte>[<arg1>[<arg2>]]). The number of arguments depends on the command byte. For system exclusive commands, the argument is a ByteArray containing the system exclusive message."	self processMIDIData.	[received isEmpty] whileFalse:		[aBlock value: received removeFirst].! !!MIDIInputParser methodsFor: 'real-time processing' stamp: 'jm 10/8/1998 21:21'!midiDoUntilMouseDown: midiActionBlock	"Process the incoming MIDI stream in real time by calling midiActionBlock for each MIDI event. This block takes three arguments: the MIDI command byte and two argument bytes. One or both argument bytes may be nil, depending on the MIDI command. If not nil, evaluatue idleBlock regularly whether MIDI data is available or not. Pressing any mouse button terminates the interaction."	| time cmd arg1 arg2 |	self clearBuffers.	[Sensor anyButtonPressed] whileFalse: [		self midiDo: [:item |			time _ item at: 1.			cmd _ item at: 2.			arg1 _ arg2 _ nil.			item size > 2 ifTrue: [				arg1 _ item at: 3.				item size > 3 ifTrue: [arg2 _ item at: 4]].				midiActionBlock value: cmd value: arg1 value: arg2]].! !!MIDIInputParser methodsFor: 'midi monitor' stamp: 'jm 10/8/1998 21:22'!monitor	"Print MIDI messages to the transcript until any mouse button is pressed."	self midiDoUntilMouseDown: [:cmd :arg1 :arg2 |		self printCmd: cmd with: arg1 with: arg2].! !!MIDIInputParser methodsFor: 'midi monitor' stamp: 'jm 10/9/1998 10:19'!printCmd: cmdByte with: arg1 with: arg2	"Print the given MIDI command."	| cmd ch bend |	cmdByte < 240		ifTrue: [  "channel message" 			cmd _ cmdByte bitAnd: 2r11110000.			ch _ (cmdByte bitAnd: 2r00001111) + 1]		ifFalse: [cmd _ cmdByte].  "system message"	cmd = 128 ifTrue: [		^ Transcript show: ('key up ', arg1 printString, ' vel: ', arg2 printString, ' chan: ', ch printString); cr].	cmd = 144 ifTrue: [		^ Transcript show: ('key down: ', arg1 printString, ' vel: ', arg2 printString, ' chan: ', ch printString); cr].	cmd = 160 ifTrue: [		^ Transcript show: ('key pressure: ', arg1 printString, ' val: ', arg2 printString, ' chan: ', ch printString); cr].	cmd = 176 ifTrue: [		^ Transcript show: ('CC', arg1 printString, ': val: ', arg2 printString, ' chan: ', ch printString); cr].	cmd = 192 ifTrue: [		^ Transcript show: ('prog: ', (arg1 + 1) printString, ' chan: ', ch printString); cr].	cmd = 208 ifTrue: [		^ Transcript show: ('channel pressure ', arg1 printString, ' chan: ', ch printString); cr].	cmd = 224 ifTrue: [		bend _ ((arg2 bitShift: 7) + arg1) - 8192.		^ Transcript show: ('bend: ', bend printString, ' chan: ', ch printString); cr].	cmd = 240 ifTrue: [		^ Transcript show: ('system exclusive: ', (arg1 at: 1) printString, ' (', arg1 size printString, ' bytes)'); cr].	Transcript show: 'cmd: ', cmd printString, ' arg1: ', arg1 printString, ' arg2: ', arg2 printString; cr.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 18:34'!endSysExclusive: cmdByte	"Error!! Received 'end system exclusive' command when not receiving system exclusive data."	self error: 'unexpected ''End of System Exclusive'' command'.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!ignoreOne: cmdByte	"Ignore a one argument command."		lastCmdByte _ cmdByte.	lastSelector _ #ignoreOne:.	state _ #ignore1.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!ignoreTwo: cmdByte	"Ignore a two argument command."		lastCmdByte _ cmdByte.	lastSelector _ #ignoreTwo:.	state _ #ignore2.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 07:45'!ignoreZero: cmdByte	"Ignore a zero argument command, such as tune request or a real-time message. Stay in the current and don't change active status. Note that real-time messages can arrive between data bytes without disruption."		"do nothing"! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 09:36'!processByte: aByte	"Process the given incoming MIDI byte and record completed commands."	"Details: Because this must be fast, it has been hand-tuned. Be careful!!"	aByte > 247 ifTrue: [  "real-time message; can arrive at any time"		^ self perform: (cmdActionTable at: aByte) with: aByte].	#idle = state ifTrue: [		aByte >= 128			ifTrue: [  "command byte in idle state: start new command"				^ self perform: (cmdActionTable at: aByte) with: aByte]			ifFalse: [  "data byte in idle state: use running status if possible"				lastCmdByte ifNil: [^ self].  "running status unknown; skip byte"				"process this data as if it had the last command byte in front of it"				 self perform: lastSelector with: lastCmdByte.				"the previous line put us into a new state; we now 'fall through'				 to process the data byte given this new state."]].	#ignore1 = state ifTrue: [^ state _ #idle].	#ignore2 = state ifTrue: [^ state _ #ignore1].	#want1of2 = state ifTrue: [		argByte1 _ aByte.		^ state _ #want2of2].	#want2of2 = state ifTrue: [		argByte2 _ aByte.		received addLast: (Array with: timeNow with: lastCmdByte with: argByte1 with: argByte2).		^ state _ #idle].	#want1only = state ifTrue: [		argByte1 _ aByte.		received addLast: (Array with: timeNow with: lastCmdByte with: argByte1).		^ state _ #idle].	#sysExclusive = state ifTrue: [		aByte < 128 ifTrue: [			"record a system exclusive data byte"			ignoreSysEx ifFalse: [sysExBuffer nextPut: aByte].			^ self]		ifFalse: [			aByte < 248 ifTrue: [				"a system exclusive message is terminated by any non-real-time command byte"				ignoreSysEx ifFalse: [					received addLast: (Array with: timeNow with: lastCmdByte with: sysExBuffer contents)].				state _ #idle.				aByte = 247					ifTrue: [^ self]							"endSysExclusive command, nothing left to do"					ifFalse: [^ self processByte: aByte]]]].  	"no endSysExclusive; just start the next command"! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!recordOne: cmdByte	"Record a one argument command at the current time."		lastCmdByte _ cmdByte.	lastSelector _ #recordOne:.	state _ #want1only.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 19:24'!recordTwo: cmdByte	"Record a two argument command at the current time."		lastCmdByte _ cmdByte.	lastSelector _ #recordTwo:.	state _ #want1of2.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 07:43'!recordZero: cmdByte	"Record a zero-byte message, such as tune request or a real-time message. Don't change active status. Note that real-time messages can arrive between data bytes without disruption."		received addLast: (Array with: timeNow with: cmdByte).! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/9/1998 09:38'!startSysExclusive: cmdByte	"The beginning of a variable length 'system exclusive' command."	sysExBuffer resetContents.	lastCmdByte _ nil.  "system exclusive commands clear running status"	lastSelector _ nil.	state _ #sysExclusive.! !!MIDIInputParser methodsFor: 'private-state machine' stamp: 'jm 10/8/1998 17:12'!undefined: cmdByte	"We have received an unexpected MIDI byte (e.g., a data byte when we were expecting a command). This should never happen."	self error: 'unexpected MIDI byte ', cmdByte printString.! !!MIDIInputParser methodsFor: 'private-other' stamp: 'jm 10/9/1998 07:56'!setMIDIPort: aMIDIPort	"Initialize this instance for recording from the given MIDI port. Tune and real-time commands are filtered out by default; the client can send noFiltering to receive these messages."	midiPort _ aMIDIPort.	received _ OrderedCollection new.	self noFiltering.  "initializes cmdActionTable"	self ignoreTuneAndRealTimeCommands.! !!MIDIInputParser methodsFor: 'accessing' stamp: 'jm 1/6/1999 08:25'!midiPort	^ midiPort! !!MIDIInputParser methodsFor: 'accessing' stamp: 'jm 1/6/1999 08:24'!midiPort: aMIDIPort	"Use the given MIDI port."	midiPort _ aMIDIPort.	self clearBuffers.! !!MIDIInputParser class methodsFor: 'class initialization' stamp: 'jm 10/9/1998 07:35'!initialize	"Build the default MIDI command-byte action table. This table maps MIDI command bytes to the action to be performed when that is received. Note that MIDI data bytes (bytes whose value is < 128) are never used to index into this table."	"MIDIInputParser initialize"	DefaultMidiTable _ Array new: 255 withAll: #undefined:.	128 to: 143 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"key off"	144 to: 159 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"key on"	160 to: 175 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"polyphonic after-touch"	176 to: 191 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"control change"	192 to: 207 do: [:i | DefaultMidiTable at: i put: #recordOne:].		"program change"	208 to: 223 do: [:i | DefaultMidiTable at: i put: #recordOne:].		"channel after-touch"	224 to: 239 do: [:i | DefaultMidiTable at: i put: #recordTwo:].		"pitch bend"	DefaultMidiTable at: 240 put: #startSysExclusive:.		"start a system exclusive block"	DefaultMidiTable at: 241 put: #recordOne:.			"MIDI time code quarter frame"	DefaultMidiTable at: 242 put: #recordTwo:.			"song position select"	DefaultMidiTable at: 243 put: #recordOne:.			"song select"	DefaultMidiTable at: 244 put: #undefined:.	DefaultMidiTable at: 245 put: #undefined:.	DefaultMidiTable at: 246 put: #recordZero:.			"tune request"	DefaultMidiTable at: 247 put: #endSysExclusive:.		"end a system exclusive block"	DefaultMidiTable at: 248 put: #recordZero:.			"timing clock"	DefaultMidiTable at: 249 put: #undefined:.	DefaultMidiTable at: 250 put: #recordZero:.			"start"	DefaultMidiTable at: 251 put: #recordZero:.			"continue"	DefaultMidiTable at: 252 put: #recordZero:.			"stop/Clock"	DefaultMidiTable at: 253 put: #undefined:.	DefaultMidiTable at: 254 put: #recordZero:.			"active sensing"	DefaultMidiTable at: 255 put: #recordZero:.			"system reset"! !!MIDIInputParser class methodsFor: 'instance creation' stamp: 'jm 10/8/1998 20:29'!on: aSimpleMIDIPort	"Answer a new MIDI parser on the given port."	^ super new setMIDIPort: aSimpleMIDIPort! !A MIDIScore is a container for a number of MIDI tracks as well as an ambient track for such things as sounds, book page triggers and other related events.!!MIDIScore methodsFor: 'accessing' stamp: 'di 6/15/1999 11:35'!durationInTicks		| t |	t _ 0.	tracks do:		[:track |		track do:			[:n | (n isNoteEvent) ifTrue: [t _ t max: n endTime]]].	^ t! !!MIDIScore methodsFor: 'editing' stamp: 'di 6/20/1999 00:08'!appendEvent: noteEvent fullDuration: fullDuration at: selection	"It is assumed that the noteEvent already has the proper time"	| track noteLoc |	track _ tracks at: selection first.	noteLoc _ selection third + 1.	noteEvent midiKey = -1		ifTrue: [noteLoc _ noteLoc - 1]		ifFalse: ["If not a rest..."				track _ track copyReplaceFrom: noteLoc to: noteLoc - 1								with: (Array with: noteEvent)].	track size >= (noteLoc + 1) ifTrue:		["Adjust times of following events"		noteLoc + 1 to: track size do:			[:i | (track at: i) adjustTimeBy: fullDuration]].	tracks at: selection first put: track! !!MIDIScore methodsFor: 'editing' stamp: 'di 6/17/1999 15:12'!cutSelection: selection	| track selStartTime delta |	track _ tracks at: selection first.	selStartTime _ (track at: selection second) time.	track _ track copyReplaceFrom: selection second to: selection third with: Array new.	track size >=  selection second ifTrue:		["Adjust times of following events"		delta _ selStartTime - (track at: selection second) time.		selection second to: track size do:			[:i | (track at: i) adjustTimeBy: delta]].	tracks at: selection first put: track! !!MIDIScore methodsFor: 'editing' stamp: 'jm 9/10/1998 17:22'!eventForTrack: trackIndex after: eventIndex ticks: scoreTick	| track evt |	track _ tracks at: trackIndex.	eventIndex > track size ifTrue: [^ nil].	evt _ track at: eventIndex.	evt time > scoreTick ifTrue: [^ nil].	^ evt! !!MIDIScore methodsFor: 'editing' stamp: 'di 6/17/1999 16:06'!gridToNextQuarterNote: tickTime	^ self gridToQuarterNote: tickTime + ticksPerQuarterNote! !!MIDIScore methodsFor: 'editing' stamp: 'di 6/17/1999 14:55'!gridToQuarterNote: tickTime	^ tickTime truncateTo: ticksPerQuarterNote! !!MIDIScore methodsFor: 'editing' stamp: 'di 6/17/1999 16:14'!gridTrack: trackIndex toQuarter: quarterDelta at: indexInTrack	| track selStartTime delta |	track _ tracks at: trackIndex.	selStartTime _ (track at: indexInTrack) time.	delta _ (self gridToQuarterNote: selStartTime + (quarterDelta*ticksPerQuarterNote))				- selStartTime.	indexInTrack to: track size do:		[:i | (track at: i) adjustTimeBy: delta].! !!MIDIScore methodsFor: 'editing' stamp: 'di 6/21/1999 10:56'!insertEvents: events at: selection	| track selStartTime delta |	track _ tracks at: selection first.	selection second = 0		ifTrue: [selStartTime _ 0.				selection at: 2 put: 1]		ifFalse: [selStartTime _ (track at: selection second) time].	track _ track copyReplaceFrom: selection second to: selection second - 1				with: (events collect: [:e | e copy]).	track size >=  (selection second + events size) ifTrue:		["Adjust times of following events"		delta _ selStartTime - (track at: selection second) time.		selection second to: selection second + events size - 1 do:			[:i | (track at: i) adjustTimeBy: delta].		delta _ (self gridToNextQuarterNote: (track at: selection second + events size - 1) endTime)					- (track at: selection second + events size) time.		selection second + events size to: track size do:			[:i | (track at: i) adjustTimeBy: delta].		].	tracks at: selection first put: track! !!MIDIScore methodsFor: 'editing' stamp: 'jm 8/6/1998 21:16'!jitterStartAndEndTimesBy: mSecs	| r range halfRange oldEnd newEnd newStart |	r _ Random new.	range _ 2.0 * mSecs.	halfRange _ mSecs.	tracks do: [:t |		t do: [:e |			e isNoteEvent ifTrue: [				oldEnd _ e time + e duration.				newEnd _ oldEnd + ((r next * range) asInteger - halfRange).				newStart _ e time + ((r next * range) asInteger - halfRange).				e time: newStart.				e duration: (newEnd - newStart)]]].				! !I implement a simple real-time MIDI synthesizer on platforms that support MIDI input. I work best on platforms that allow the sound buffer to be made very short--under 50 milliseconds is good and under 20 milliseconds is preferred (see below). The buffer size is changed by modifying the class initialization method of SoundPlayer and executing the do-it there to re-start the sound player.Each instance of me takes input from a single MIDI input port. Multiple instances of me can be used to handle multiple MIDI input ports. I distribute incoming commands among my sixteen MIDISynthChannel objects. Most of the interpretation of the MIDI commands is done by these channel objects. Buffer size notes: At the moment, most fast PowerPC Macintosh computers can probably work with buffer sizes down to 50 milliseconds, and the Powerbook G3 works down to about 15 milliseconds. You will need to experiment to discover the minimum buffer size that does not result in clicking during sound output. (Hint: Be sure to turn off power cycling on your Powerbook. Other applications and extensions can steal cycles from Squeak, causing intermittent clicking. Experimentation may be necessary to find a configuration that works for you.)!!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 10/14/1998 22:16'!channel: i	^ channels at: i! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 10:50'!closeMIDIPort	midiParser midiPort ifNil: [^ self].	midiParser midiPort close.	midiParser midiPort: nil.! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 08:29'!initialize	midiParser _ MIDIInputParser on: nil.	channels _ (1 to: 16) collect: [:ch | MIDISynthChannel new initialize].! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 08:13'!instrumentForChannel: channelIndex	^ (channels at: channelIndex) instrument! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 08:14'!instrumentForChannel: channelIndex put: aSoundProto	(channels at: channelIndex) instrument: aSoundProto.! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 10:27'!isOn	^ process notNil! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 10/14/1998 21:52'!midiParser	^ midiParser! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 08:26'!midiPort	^ midiParser midiPort! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 16:32'!midiPort: aMIDIPortOrNil	midiParser midiPort: aMIDIPortOrNil.! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 10/13/1998 12:09'!midiTrackingLoop	midiParser clearBuffers.	[true] whileTrue: [		self processMIDI ifFalse: [(Delay forMilliseconds: 5) wait]].! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 20:12'!mutedForChannel: channelIndex put: aBoolean	^ (channels at: channelIndex) muted: aBoolean! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 19:45'!panForChannel: channelIndex	^ (channels at: channelIndex) pan! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 19:45'!panForChannel: channelIndex put: newPan	(channels at: channelIndex) pan: newPan.! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 10/14/1998 14:13'!processMIDI	"Process some MIDI commands. Answer true if any commands were processed."	| didSomething cmdByte byte1 byte2 cmd chan |	didSomething _ false.	midiParser midiDo: [:item |		didSomething _ true.		cmdByte _ item at: 2.		byte1 _ byte2 _ nil.		item size > 2 ifTrue: [			byte1 _ item at: 3.			item size > 3 ifTrue: [byte2 _ item at: 4]].		cmdByte < 240			ifTrue: [  "channel message" 				cmd _ cmdByte bitAnd: 2r11110000.				chan _ (cmdByte bitAnd: 2r00001111) + 1.				(channels at: chan) doChannelCmd: cmd byte1: byte1 byte2: byte2]			ifFalse: [  "system message"				"process system messages here"			]].	^ didSomething! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 10/14/1998 14:14'!processMIDIUntilMouseDown	"Used for debugging. Do MIDI processing until the mouse is pressed."	midiParser clearBuffers.	[Sensor anyButtonPressed] whileFalse: [self processMIDI].! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 16:36'!setAllChannelMasterVolumes: aNumber	| vol |	vol _ (aNumber asFloat min: 1.0) max: 0.0.	channels do: [:ch | ch masterVolume: vol].! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/13/1999 08:16'!startMIDITracking	midiParser ifNil: [^ self].	midiParser midiPort ifNil: [^ self].	midiParser midiPort ensureOpen.	self stopMIDITracking.	SoundPlayer useShortBuffer.	process _ [self midiTrackingLoop] newProcess.	process priority: Processor userInterruptPriority.	process resume.! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 10:34'!stopMIDITracking	process ifNotNil: [		process terminate.		process _ nil].	SoundPlayer shutDown; initialize.  "revert to normal buffer size"! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 16:40'!volumeForChannel: channelIndex	^  (channels at: channelIndex) masterVolume! !!MIDISynth methodsFor: 'as yet unclassified' stamp: 'jm 1/6/1999 16:40'!volumeForChannel: channelIndex put: newVolume	(channels at: channelIndex) masterVolume: newVolume.! !!MIDISynth class methodsFor: 'examples' stamp: 'jm 1/6/1999 16:39'!example	"Here's one way to run the MIDI synth. It will get a nice Morphic UI later. Click the mouse to stop running it. (Mac users note: be sure you have MIDI interface adaptor plugged in, or Squeak will hang waiting for the external clock signal.)."	"MIDISynth example"	| portNum synth |	portNum _ SimpleMIDIPort inputPortNumFromUser.	portNum ifNil: [^ self].	SoundPlayer useShortBuffer.	synth _ MIDISynth new		midiPort: (SimpleMIDIPort openOnPortNumber: portNum).	synth midiParser ignoreCommand: 224.  "filter out pitch bends"	1 to: 16 do: [:i |		(synth channel: i) instrument: 			 (AbstractSound soundNamed: 'oboe1')].	1 to: 16 do: [:ch | synth volumeForChannel: ch put: 0.2].	synth processMIDIUntilMouseDown.	SoundPlayer shutDown; initialize.  "revert to normal buffer size"! !I implement one polyphonic channel of a 16-channel MIDI synthesizer. Many MIDI commands effect all the notes played on a particular channel, so I record the state for a single channel, including a list of notes currently playing.This initial implementation is extremely spartan, having just enough functionality to play notes. Things that are not implemented include:  1. program changes  2. sustain pedal  3. aftertouch (either kind)  4. most controllers  5. portamento  6. mono-mode!!MIDISynthChannel methodsFor: 'initialization' stamp: 'jm 1/6/1999 20:10'!initialize	instrument _ FMSound default.	muted _ false.	masterVolume _ 0.5.	channelVolume _ 1.0.	pan _ 0.5.	pitchBend _ 0.0.	activeSounds _ OrderedCollection new.! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 09:45'!instrument	^ instrument! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 09:45'!instrument: aSound	instrument _ aSound.! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 09:47'!masterVolume	^ masterVolume! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 10/13/1998 11:49'!masterVolume: aNumber	"Set the master volume the the given value (0.0 to 1.0)."	masterVolume _ aNumber asFloat.! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 1/6/1999 20:10'!muted	^ muted! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 1/6/1999 20:11'!muted: aBoolean	muted _ aBoolean.! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 1/6/1999 19:43'!pan	^ pan! !!MIDISynthChannel methodsFor: 'accessing' stamp: 'jm 1/6/1999 19:43'!pan: aNumber	"Set the left-right pan to the given value (0.0 to 1.0)."	pan _ aNumber asFloat.! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 15:40'!channelPressure: newPressure	"Handle a channel pressure (channel aftertouch) change."	self newVolume: newPressure.! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:48'!control: control value: newValue	"Handle a continuous controller change."	control = 2 ifTrue: [self newVolume: newValue].  "breath controller"! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:44'!doChannelCmd: cmdByte byte1: byte1 byte2: byte2	"Dispatch a channel command with the given arguments."	"Details: Cases appear in order of expected frequency, most frequent cases first."	cmdByte = 144 ifTrue: [		byte2 = 0			ifTrue: [^ self keyUp: byte1 vel: 0]			ifFalse: [^ self keyDown: byte1 vel: byte2]].	cmdByte = 128 ifTrue: [^ self keyUp: byte1 vel: byte2].	cmdByte = 224 ifTrue: [^ self pitchBend: ((byte2 bitShift: 7) + byte1) - 8192].	cmdByte = 176 ifTrue: [^ self control: byte1 value: byte2].	cmdByte = 208 ifTrue: [^ self channelPressure: byte1].	cmdByte = 160 ifTrue: [^ self key: byte1 pressure: byte2].	cmdByte = 192 ifTrue: [^ self programChange: byte1].! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:49'!key: key pressure: press	"Handle a key pressure (polyphonic aftertouch) change. Rarely implemented."	"Do nothing for now."! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 1/10/1999 08:42'!keyDown: key vel: vel	"Handle a key down event with non-zero velocity."	| pitch snd |	muted ifTrue: [^ self].	pitch _ AbstractSound pitchForMIDIKey: key.	snd _ instrument		soundForPitch: pitch		dur: 10000.0  "sustain a long time, or until turned off"		loudness: masterVolume * channelVolume * (self convertVelocity: vel).	snd _ (MixedSound new add: snd pan: pan) reset.	SoundPlayer resumePlaying: snd quickStart: false.	activeSounds add: (Array with: key with: snd with: pitch).! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:49'!keyUp: key vel: vel	"Handle a key up event."	| snd |	activeSounds copy do: [:entry |		(entry at: 1) = key ifTrue: [			snd _ entry at: 2.			snd stopGracefully.			activeSounds remove: entry]].! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 1/11/1999 11:32'!pitchBend: bend	"Handle a pitch-bend change."	self adjustPitch: bend.! !!MIDISynthChannel methodsFor: 'midi dispatching' stamp: 'jm 10/14/1998 13:50'!programChange: newProgram	"Handle a program (instrument) change."	"Do nothing for now."! !!MIDISynthChannel methodsFor: 'other' stamp: 'jm 10/14/1998 21:45'!adjustPitch: bend	"Handle a pitch-bend change."	| snd pitchAdj centerPitch |	pitchBend _ bend.	pitchAdj _ 2.0 raisedTo: (bend asFloat / 8192.0) / 6.0.	activeSounds copy do: [:entry |		snd _ entry at: 2.		centerPitch _ entry at: 3.		snd pitch: pitchAdj * centerPitch.		snd internalizeModulationAndRatio].! !!MIDISynthChannel methodsFor: 'other' stamp: 'jm 10/14/1998 15:43'!convertVelocity: valueByte	"Map a value in the range 0..127 to a volume in the range 0.0..1.0."	"Details: A quadratic function seems to give a good keyboard feel."	| r |	r _ (valueByte * valueByte) / 12000.0.	r > 1.0 ifTrue: [^ 1.0].	r < 0.08 ifTrue: [^ 0.08].	^ r! !!MIDISynthChannel methodsFor: 'other' stamp: 'jm 10/14/1998 15:41'!newVolume: valueByte	"Set the channel volume to the level given by the given number in the range 0..127."	| snd newVolume |	channelVolume _ valueByte asFloat / 127.0.	newVolume _ masterVolume * channelVolume.	activeSounds do: [:entry |		snd _ entry at: 2.		snd adjustVolumeTo: newVolume overMSecs: 10].! !I represent a MIME object, along with its type and its URL (if any).!!MIMEDocument methodsFor: 'accessing' stamp: 'sma 4/28/2000 14:49'!content	"Answer the receiver's raw data."	^ content! !!MIMEDocument methodsFor: 'accessing' stamp: 'sma 4/28/2000 14:48'!contentType	"Answer the MIME contents type."	^ self mainType , '/' , self subType! !!MIMEDocument methodsFor: 'accessing' stamp: 'sma 4/28/2000 14:47'!mainType	^ mainType! !!MIMEDocument methodsFor: 'accessing' stamp: 'sma 4/28/2000 14:47'!subType	^ subType! !!MIMEDocument methodsFor: 'accessing' stamp: 'sma 4/28/2000 14:48'!type	"Deprecated. Use contentType instead."	^ self contentType! !!MIMEDocument methodsFor: 'accessing' stamp: 'sma 4/28/2000 14:48'!url	"Answer the URL the receiver was downloaded from.  It may legitimately be nil."	^ url! !!MIMEDocument methodsFor: 'printing' stamp: 'ls 7/23/1998 20:12'!printOn: aStream	aStream nextPutAll: self class name;		nextPutAll: ' (';		nextPutAll: self contentType;		nextPutAll: ', ';		nextPutAll: self content size printString;		nextPutAll: ' bytes)'.! !!MIMEDocument methodsFor: 'private' stamp: 'ls 7/23/1998 20:11'!privateContent: aString	content _ aString! !!MIMEDocument methodsFor: 'private' stamp: 'ls 7/23/1998 20:06'!privateMainType: aString	mainType _ aString! !!MIMEDocument methodsFor: 'private' stamp: 'ls 7/23/1998 20:06'!privateSubType: aString	subType _ aString! !!MIMEDocument methodsFor: 'private' stamp: 'ls 8/12/1998 00:25'!privateUrl: aUrl	url _ aUrl! !!MIMEDocument class methodsFor: 'instance creation' stamp: 'jm 5/12/2003 21:08'!contentType: aString  content: content url: aUrl	"Create an instance of me with the given content-type and content"	"MIMEDocument contentType: 'text/plain' content: 'This is a test' url: nil"		| ans idx |	ans _ self new.	ans privateContent: content.	"parse the content-type"	(aString isNil or: [		idx _ aString indexOf: $/.		idx = 0]) 	ifTrue: [ 		ans privateMainType: 'application'.  		ans privateSubType: 'octet-stream' ]	ifFalse: [ 		ans privateMainType: (aString copyFrom: 1 to: idx-1).		ans privateSubType: (aString copyFrom: idx+1 to: aString size) ].	ans privateUrl: aUrl.	^ans! !* An interface to LibMPEG3 * Author: Adam Williams <broadcast@earthling.net> * Page: heroine.linuxbox.com * * Modified to work with Squeak and on the Macintosh in Sept 2000 * by John M McIntosh johnmci@smalltalkconsulting.com * The smalltalk code and the C code it produces is released under the  * Squeak licence. The libmpeg3 C code is co-licenced under either the Squeak * licence or the GNU LGPL by permission of Adam Williams.!!MPEGFile methodsFor: 'initialize-release' stamp: 'jm 12/3/2003 11:31'!finalize	self closeFile.! !!MPEGFile methodsFor: 'initialize-release' stamp: 'jm 12/3/2003 11:15'!initialize	pathToFile _ fileBits _ fileIndex _ isBigEndian _ nil.! !!MPEGFile methodsFor: 'file ops' stamp: 'jm 12/3/2003 11:30'!closeFile	self fileHandle notNil ifTrue: [self primFileClose: self fileHandle].	self fileHandle = fileBits ifTrue: [Smalltalk unregisterExternalObject: fileIndex].	fileBits _ nil.		fileIndex _ 0.! !!MPEGFile methodsFor: 'file ops' stamp: 'jm 12/3/2003 11:26'!openFile: aPath	pathToFile _ aPath.	fileBits _ self primFileOpen: aPath.	fileBits notNil ifTrue: [		fileIndex _ Smalltalk registerExternalObject: fileBits.		self class register: self].	isBigEndian _ nil.  "clear endian cache"! !!MPEGFile methodsFor: 'access' stamp: 'jm 12/18/2003 11:49'!currentSeconds: streamIndex	"Answer the position of the stream with the given index in seconds."	self hasAudio		ifTrue: [^ (self audioGetSample: streamIndex) asFloat / (self audioSampleRate: streamIndex)]		ifFalse: [^ (self videoGetFrame: streamIndex) asFloat / (self videoFrameRate: streamIndex)].! !!MPEGFile methodsFor: 'access' stamp: 'jm 11/21/2003 12:40'!duration: streamIndex	"Answer my duration in seconds. If I have audio, this is the duration of my audio track. Otherwise, it computed from my frame count and frame rate."	self hasAudio		ifTrue: [^ (self audioSamples: streamIndex) asFloat / (self audioSampleRate: streamIndex)]		ifFalse: [^ (self videoFrames: streamIndex) asFloat / (self videoFrameRate: streamIndex)].! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/20/2000 19:04'!fileHandle	(Smalltalk externalObjects at: fileIndex ifAbsent: [^nil]) == fileBits 		ifTrue: [^fileBits]		ifFalse: [^nil].! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/18/2000 18:38'!fileName	^pathToFile! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/20/2000 01:54'!getPercentage	"Return current location by percentage, 0.0-1.0"	^self primGetPercentage: self fileHandle ! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/29/2000 19:28'!getTOC: timecode doStreams: streams	| buffer |		buffer _ String new: 64*1024+1.	self primGenerateToc: self fileHandle useSearch: timecode doStreams: streams buffer: buffer.	^buffer! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/20/2000 01:56'!getTimeCode	"Return time code, (float) "	^self primGetTime: self fileHandle! !!MPEGFile methodsFor: 'access' stamp: 'jm 11/24/2003 12:08'!jumpToSeconds: seconds stream: streamIndex	"Set the position of the stream with the given index to the given number of seconds since the start."	| index |	seconds < 0 ifTrue: [^ self jumpToSeconds: 0 stream: streamIndex].	self hasAudio		ifTrue: [			index _ (seconds * (self audioSampleRate: streamIndex)) truncated.			index _ (index max: 0) min: (self audioSamples: streamIndex) - 1.			self audioSetSample: index stream: streamIndex]		ifFalse: [			index _ (seconds * (self videoFrameRate: streamIndex)) truncated.			index _ (index max: 0) min: (self videoFrames: streamIndex) - 1.			self videoSetFrame: index stream: streamIndex].! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/20/2000 01:53'!seekPercentage: aFloat	self primSeekPercentage: self fileHandle percentage: aFloat asFloat ! !!MPEGFile methodsFor: 'access' stamp: 'JMM 9/20/2000 01:56'!setMMX: aValue	" true is set, false is off. May not be supported "	self primSetMMX: self fileHandle useMMX: aValue  ! !!MPEGFile methodsFor: 'audio' stamp: 'jm 5/23/2003 11:26'!audioChannels: aStream	"Returns -1 if error, otherwise returns audioChannels for stream aStream"	self hasAudio ifFalse: [^ 0].	^[self primAudioChannels: self fileHandle stream: aStream] ifError: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'jm 5/23/2003 11:26'!audioGetSample: aStream	"Returns number of current sample, or -1 if error"	self hasAudio ifFalse: [^-1].	^[(self primGetSample: self fileHandle stream: aStream) asInteger] ifError: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'jm 11/17/2001 09:36'!audioPlayerForChannel: channelNumber	"Answer a streaming sound for playing the audio channel with the given index."	"Note: The MP3 player can not yet isolate a single channel from a multi-channel audio stream."	^ StreamingMP3Sound new initMPEGFile: self streamIndex: 0! !!MPEGFile methodsFor: 'audio' stamp: 'jm 5/23/2003 11:26'!audioReReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber	"Used to read other channels after first ReadBuffer 	Returns -1 if error, otherwise 0"	self hasAudio ifFalse: [^-1].	^[self audioReReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber samples: (aBuffer size * aBuffer bytesPerElement // 2)] ifError: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'jm 5/23/2003 11:26'!audioReReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber samples: aSampleNumber	"Used to read other channels after first ReadBuffer 	Returns -1 if error, otherwise 0	Note this call requires passing in the samples to read, ensure you get the number right"	self hasAudio ifFalse: [^-1].	^[self primAudioReReadBuffer: self fileHandle  buffer: aBuffer channel: aChannelNumber samples: aSampleNumber stream: aStreamNumber] ifError: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'jm 5/23/2003 11:26'!audioReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber 	"Returns -1 if error, otherwise 0"	self hasAudio ifFalse: [^-1].	^[self audioReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber samples: (aBuffer size* aBuffer bytesPerElement)//2] ifError: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'jm 5/23/2003 11:26'!audioReadBuffer: aBuffer stream: aStreamNumber channel: aChannelNumber samples: aSampleNumber	"Returns -1 if error, otherwise 0	Note this call requires passing in the samples to read, ensure you get the number right"	self hasAudio ifFalse: [^-1].	^[self primAudioReadBuffer: self fileHandle  buffer: aBuffer channel: aChannelNumber samples: aSampleNumber stream: aStreamNumber] ifError: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'jm 5/23/2003 11:26'!audioSampleRate: aStream	"Returns sample rate, or -1 if error"	self hasAudio ifFalse: [^-1].	^[self primSampleRate: self fileHandle stream: aStream] ifError: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'jm 5/23/2003 11:26'!audioSamples: aStream	"Returns -1 if error, 	otherwise returns audioSamples for stream aStream"	self hasAudio ifFalse: [^-1].	^[(self primAudioSamples: self fileHandle stream: aStream) asInteger] ifError: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'jm 5/23/2003 11:26'!audioSetSample: aNumber stream: aStream	"Set number of targeted sample, returns 0 if ok, -1 if failure"	self hasAudio ifFalse: [^-1].	^[self primSetSample: self fileHandle sample: aNumber asFloat stream: aStream] ifError: [-1]! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 9/20/2000 01:57'!endOfAudio: aStream	"Returns true if end of Audio"	self hasAudio ifFalse: [^true].	^self primEndOfAudio: self fileHandle stream: aStream! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 9/20/2000 01:56'!hasAudio	"Returns true if file has audio"	^self primHasAudio: self fileHandle ! !!MPEGFile methodsFor: 'audio' stamp: 'JMM 9/20/2000 01:53'!totalAudioStreams	"Returns total number of audio streams"	^self primTotalAudioStreams: self fileHandle ! !!MPEGFile methodsFor: 'video' stamp: 'JMM 9/20/2000 01:54'!endOfVideo: aStream	"Returns true if end of video"	self hasVideo ifFalse: [^true].	^self primEndOfVideo: self fileHandle stream: aStream! !!MPEGFile methodsFor: 'video' stamp: 'JMM 9/20/2000 01:54'!hasVideo	"Returns true if file has video"	^self primHasVideo: self fileHandle ! !!MPEGFile methodsFor: 'video' stamp: 'JMM 9/20/2000 01:59'!totalVideoStreams	"Returns total number of video streams"	^self primTotalVideoStreams: self fileHandle ! !!MPEGFile methodsFor: 'video' stamp: 'jm 5/23/2003 11:25'!videoDropFrames: aNumberOfFrames stream: aStream	"Returns -1 if setFrame failed"	self hasVideo ifFalse: [^-1].	^[self primDropFrame: self fileHandle frame: aNumberOfFrames stream: aStream] ifError: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'jm 5/23/2003 11:25'!videoFrameHeight: aStream	"Returns video frame height, -1 if error "	self hasVideo ifFalse: [^-1].	^[self primVideoHeight: self fileHandle stream: aStream] ifError: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'jm 5/23/2003 11:25'!videoFrameRate: aStream	"Returns video frame rate (float), -1 if error"	self hasVideo ifFalse: [^-1].	^[self primFrameRate: self fileHandle stream: aStream] ifError: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'jm 5/23/2003 11:25'!videoFrameWidth: aStream	"Returns video frame width, -1 if error"	self hasVideo ifFalse: [^-1].	^[self primVideoWidth: self fileHandle stream: aStream] ifError: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'JMM 9/20/2000 01:58'!videoFrames: aStream	"Total number of frames" 	^(self primVideoFrames: self fileHandle stream: aStream) asInteger! !!MPEGFile methodsFor: 'video' stamp: 'jm 5/23/2003 11:25'!videoGetFrame: aStream	"Returns frame number, or -1 if error"	self hasVideo ifFalse: [^-1].	^[(self primGetFrame: self fileHandle stream: aStream) asInteger] ifError: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'jm 5/23/2003 11:25'!videoPreviousFrame: aStream	"Returns 0 if ok"	self hasVideo ifFalse: [^-1].	^[self primPreviousFrame: self fileHandle stream: aStream] ifError: [-1]! !!MPEGFile methodsFor: 'video' stamp: 'jm 12/3/2003 11:15'!videoReadFrameInto: aForm stream: aStream	"Read the next video frame from the given stream into the given 16- or 32-bit Form. The movie frame will be scaled to fit the Form if necessary."	| colorModel bytesPerRow |	((aForm depth = 16) | (aForm depth = 32)) ifFalse: [self error: 'must use 16- or 32-bit Form'].	isBigEndian ifNil: [isBigEndian _ Smalltalk isBigEndian].  "cache for speed"	aForm depth = 16		ifTrue: [			colorModel _ isBigEndian ifTrue: [14] ifFalse: [16].			bytesPerRow _ 2 * (aForm width roundUpTo: 2)]		ifFalse: [			colorModel _ isBigEndian ifTrue: [13] ifFalse: [1].			bytesPerRow _ 4 * aForm width]. 	^ self		videoReadNextFrameInto: aForm bits		x: 0 y: 0		width: (self videoFrameWidth: aStream)		height: (self videoFrameHeight: aStream)		outWidth: aForm width		outHeight: aForm height		colorModel: colorModel		stream: aStream		bytesPerRow: bytesPerRow! !!MPEGFile methodsFor: 'video' stamp: 'jm 5/23/2003 11:25'!videoReadNextFrameInto: aFormBuffer x: x y: y width: width height: height outWidth: aTargetWidth outHeight: aTargetHeight colorModel: colorModel stream: aStream bytesPerRow: aByteCount	"return nonZero if failure "	self hasVideo ifFalse: [^-1].	^[self primVideoReadNextFrameFor: self fileHandle into: aFormBuffer x: x y: y width: width height: height outWidth: aTargetWidth outHeight: aTargetHeight colorModel: colorModel stream: aStream bytesPerRow: aByteCount] ifError: [-1]"/* Supported color models for mpeg3_read_frame */#define MPEG3_RGB565 2#define MPEG3_RGB555 14  //JMM for mac#define MPEG3_RGBI555 16  //SVP for intel#define MPEG3_BGR888 0#define MPEG3_BGRA8888 1#define MPEG3_RGB888 3#define MPEG3_RGBA8888 4  #define MPEG3_ARGB8888 13  //JMM for mac#define MPEG3_RGBA16161616 5/* Color models for the 601 to RGB conversion *//* 601 not implemented for scalar code */#define MPEG3_601_RGB565 11#define MPEG3_601_RGB555 15 //JMM for Squeak#define MPEG3_601_RGBI555 17 //SVP for intel#define MPEG3_601_BGR888 7#define MPEG3_601_BGRA8888 8#define MPEG3_601_RGB888 9#define MPEG3_601_RGBA8888 10#define MPEG3_601_ARGB8888 12 //JMM for Squeak"! !!MPEGFile methodsFor: 'video' stamp: 'JMM 9/20/2000 01:58'!videoSetCPUs: aNumber	self primSetCPUs: self fileHandle number: aNumber! !!MPEGFile methodsFor: 'video' stamp: 'jm 5/23/2003 11:25'!videoSetFrame: aFrameNumber stream: aStream	"Returns -1 if setFrame failed"	self hasVideo ifFalse: [^-1].	^[self primSetFrame: self fileHandle frame: aFrameNumber asFloat stream: aStream] ifError: [-1]! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:19'!primAudioChannels: aHandle stream: aStream	<primitive: 'primitiveMPEG3AudioChannels' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/19/2000 13:35'!primAudioReReadBuffer: aFileHandle  buffer: aBuffer channel: aChannel samples: aSampleNumber stream: aStreamNumber	<primitive: 'primitiveMPEG3ReReadAudio' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/19/2000 13:31'!primAudioReadBuffer: aFileHandle  buffer: aBuffer channel: aChannel samples: aSampleNumber stream: aStreamNumber	<primitive: 'primitiveMPEG3ReadAudio' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:23'!primAudioSamples: aHandle stream: aStream	<primitive: 'primitiveMPEG3AudioSamples' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 17:54'!primDropFrame: aHandle frame: aNumberOfFrames stream: aStream	<primitive: 'primitiveMPEG3DropFrames' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:50'!primEndOfAudio: aHandle stream: aStream	<primitive: 'primitiveMPEG3EndOfAudio' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:51'!primEndOfVideo: aHandle stream: aStream	<primitive: 'primitiveMPEG3EndOfVideo' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 13:58'!primFileClose: aHandle	"Close the file"	<primitive: 'primitiveMPEG3Close' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 03:56'!primFileOpen: aPath	"Open the file"	<primitive: 'primitiveMPEG3Open' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:52'!primFrameRate: aHandle stream: aStream	<primitive: 'primitiveMPEG3FrameRate' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/29/2000 17:29'!primGenerateToc: fileHandle useSearch: timecode doStreams: streams buffer: aString	<primitive: 'primitiveMPEG3GenerateToc' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:11'!primGetFrame: aHandle stream: aStream	<primitive: 'primitiveMPEG3GetFrame' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:37'!primGetPercentage: aHandle	<primitive: 'primitiveMPEG3TellPercentage' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:12'!primGetSample: aHandle stream: aStream	<primitive: 'primitiveMPEG3GetSample' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:15'!primGetTime: aFileHandle	<primitive: 'primitiveMPEG3GetTime' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:59'!primHasAudio: aHandle	<primitive: 'primitiveMPEG3HasAudio' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 14:59'!primHasVideo: aHandle	<primitive: 'primitiveMPEG3HasVideo' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:17'!primPreviousFrame: aHandle stream: aStream	<primitive: 'primitiveMPEG3PreviousFrame' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:19'!primSampleRate: aHandle stream: aStream	<primitive: 'primitiveMPEG3SampleRate' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:23'!primSeekPercentage: aHandle percentage: aNumber	<primitive: 'primitiveMPEG3SeekPercentage' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:27'!primSetCPUs: aHandle number: aNumber	"Not support on the macintosh below OS X"	<primitive: 'primitiveMPEG3SetCpus' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:29'!primSetFrame: aHandle frame: aFrameNumber stream: aStream	<primitive: 'primitiveMPEG3SetFrame' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:31'!primSetMMX: aFileHandle useMMX: aValue  	<primitive: 'primitiveMPEG3SetMmx' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:35'!primSetSample: aHandle sample: aSampleNumber stream: aStream	<primitive: 'primitiveMPEG3SetSample' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:39'!primTotalAudioStreams: aFileHandle 	<primitive: 'primitiveMPEG3TotalAStreams' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:40'!primTotalVideoStreams: aFileHandle 	<primitive: 'primitiveMPEG3TotalVStreams' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:41'!primVideoFrames: aFileHandle  stream: aStream	<primitive: 'primitiveMPEG3VideoFrames' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 15:41'!primVideoHeight: aFileHandle  stream: aStream	<primitive: 'primitiveMPEG3VideoHeight' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/19/2000 13:28'!primVideoReadNextFrameFor: aFileHandle into: aFormBuffer x: x y: y width: width height: height outWidth: aTargetWidth outHeight: aTargetHeight colorModel: colorModel stream: aStream bytesPerRow: aByteCount	<primitive: 'primitiveMPEG3ReadFrame' module: 'Mpeg3Plugin'>! !!MPEGFile methodsFor: 'primitives' stamp: 'JMM 9/18/2000 16:35'!primVideoWidth: aFileHandle  stream: aStream	<primitive: 'primitiveMPEG3VideoWidth' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MPEGFile class methodsFor: 'registry' stamp: 'JMM 9/17/2000 23:56'!register: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry add: anObject! !!MPEGFile class methodsFor: 'registry' stamp: 'JMM 9/17/2000 23:56'!registry	WeakArray isFinalizationSupported ifFalse:[^nil].	^Registry isNil		ifTrue:[Registry := WeakRegistry new]		ifFalse:[Registry].! !!MPEGFile class methodsFor: 'registry' stamp: 'JMM 9/17/2000 23:56'!unregister: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry remove: anObject ifAbsent:[]! !!MPEGFile class methodsFor: 'instance creation' stamp: 'JMM 9/18/2000 03:27'!openFile: aPath	^self new initialize openFile: aPath.! !!MPEGFile class methodsFor: 'testing' stamp: 'jm 12/3/2003 11:20'!isFileValidMPEG: path	"Answer true if this file is in an MPEG format I can read."	<primitive: 'primitiveMPEG3CheckSig' module: 'Mpeg3Plugin'>	self primitiveFailed! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'sma 4/30/2000 10:40'!displayAt: aPoint during: aBlock	"Add this menu to the Morphic world during the execution of the given block."	Smalltalk isMorphic ifFalse: [^ self].	World addMorph: self centeredNear: aPoint.	self world displayWorld.  "show myself"	aBlock value.	self delete! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'jm 10/13/2002 18:21'!informUserAt: aPoint during: aBlock	"Add this menu to the Morphic world during the execution of the given block."	| title |	Smalltalk isMorphic ifFalse: [^ self].	title _ submorphs first submorphs first.	self isHidden: true.	aBlock value: [:string |		self isHidden ifTrue: [			World addMorph: self centeredNear: aPoint.			self isHidden: false].		title contents: string.		self setConstrainedPositionFrom: Sensor cursorPoint.		self changed.		World displayWorld].  "show myself"	self delete.	World displayWorld! !!MVCMenuMorph methodsFor: 'invoking' stamp: 'di 6/7/1999 15:45'!invokeAt: aPoint in: aWorld	"Add this menu to the given world centered at the given point. Wait for the user to make a selection and answer it. The selection value returned is an integer in keeping with PopUpMenu, if the menu is converted from an MVC-style menu."	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop." 	self popUpAt: aPoint forHand: aWorld primaryHand.	done _ false.	[self isInWorld & done not] whileTrue: [aWorld doOneSubCycle].	self delete.	^ selectedItem! !!MVCMenuMorph methodsFor: 'private' stamp: 'di 3/14/1999 13:12'!invokeItem: aMenuItem event: evt	"Called by the MenuItemMorph that the user selects.	Record the selection and set the done flag to end this interaction."	selectedItem _ aMenuItem selector.	done _ true.! !!MVCMenuMorph class methodsFor: 'instance creation' stamp: 'di 4/13/1999 17:08'!from: aPopupMenu title: titleStringOrNil	"Answer a MenuMorph constructed from the given PopUpMenu. Used to simulate MVC-style menus in a Morphic-only world."	| menu items lines selections labelString j emphasis |	menu _ self new.	titleStringOrNil ifNotNil: [		titleStringOrNil isEmpty ifFalse: [menu addTitle: titleStringOrNil]].	labelString _ aPopupMenu labelString.	items _ labelString asString findTokens: String cr.	labelString isText ifTrue:		["Pass along text emphasis if present"		j _ 1.		items _ items collect:			[:item | j _ labelString asString findString: item startingAt: j.			emphasis _ TextEmphasis new emphasisCode: (labelString emphasisAt: j).			item asText addAttribute: emphasis]].	lines _ aPopupMenu lineArray.	lines ifNil: [lines _ #()].	menu cancelValue: 0.	selections _ (1 to: items size) asArray.	1 to: items size do: [:i |		menu add: (items at: i) action: (selections at: i).		(lines includes: i) ifTrue: [menu addLine]].	^ menu! !A subclass of WiWPasteUpMorph that supports Morphic worlds embedded in MVC Views.!!MVCWiWPasteUpMorph methodsFor: 'initialization' stamp: 'RAA 11/25/1999 10:10'!viewBox: newViewBox	| vb |	self damageRecorder reset.	"since we may have moved, old data no longer valid"	((vb _ self viewBox) == nil or: [vb ~= newViewBox])		ifTrue: [self canvas: nil].	worldState viewBox: newViewBox.	self bounds: newViewBox.		"works better here than simply storing into bounds"	self assuredCanvas.	"Paragraph problem workaround; clear selections to avoid screen droppings:"	self handsDo: [:h | h newKeyboardFocus: nil].	self fullRepaintNeeded.! !!MVCWiWPasteUpMorph methodsFor: 'activation' stamp: 'jm 10/5/2002 06:38'!becomeTheActiveWorldWith: evt	self canvas: nil.	"safer to start from scratch"! !!MVCWiWPasteUpMorph methodsFor: 'activation' stamp: 'RAA 11/25/1999 10:09'!revertToParentWorldWithEvent: evt">>unused, but we may want some of this later	self damageRecorder reset.	World _ parentWorld.	World assuredCanvas.	World installFlaps.	owner changed.	hostWindow setStripeColorsFrom: Color red.	World restartWorldCycleWithEvent: evt.<<<"! !!MVCWiWPasteUpMorph methodsFor: 'drawing' stamp: 'RAA 11/25/1999 09:12'!invalidRect: damageRect	self damageRecorder ifNotNil:		[self damageRecorder recordInvalidRect: damageRect]! !!MVCWiWPasteUpMorph methodsFor: 'geometry' stamp: 'RAA 11/25/1999 09:20'!position: aPoint	"Change the position of this morph and and all of its submorphs."	| delta |	delta _ aPoint - bounds topLeft.	(delta x = 0 and: [delta y = 0]) ifTrue: [^ self].  "Null change"	self changed.	self privateFullMoveBy: delta.	self changed.! !!MVCWiWPasteUpMorph methodsFor: 'geometry' stamp: 'RAA 11/24/1999 18:59'!resetViewBox	| c |	(c _ self canvas) == nil ifTrue: [^self resetViewBoxForReal].	c form == Display ifFalse: [^self resetViewBoxForReal].	c origin = (0@0) ifFalse: [^self resetViewBoxForReal].	c clipRect extent = (self viewBox "intersect: parentWorld viewBox") extent ifFalse: [^self resetViewBoxForReal].			! !!MVCWiWPasteUpMorph methodsFor: 'geometry' stamp: 'ar 5/25/2000 17:59'!resetViewBoxForReal	| newClip |	self viewBox ifNil: [^self].	newClip _ self viewBox "intersect: parentWorld viewBox".	self canvas: (		(Display getCanvas)			copyOffset:  0@0			clipRect: newClip	)! !!MacFileDirectory class methodsFor: 'platform specific' stamp: 'di 5/11/1999 08:53'!isCaseSensitive	"Mac OS ignores the case of file names"	^ false! !I am an abstract representation of objects that measure something linear. Examples are dates, times, and numbers.!!Magnitude methodsFor: 'comparing' stamp: 'jm 2/25/2003 17:03'!within: min and: max	"Answer the receiver if it is within the given interval [min..max]. Otherwise, answer the closest value within that interval."	self < min ifTrue: [^ min].	self > max ifTrue: [^ max].	^ self! !This class represents a transformation for points, that is a combination of scale, offset, and rotation. It is implemented as a 2x3 matrix containing the transformation from the local coordinate system in the global coordinate system. Thus, transforming points from local to global coordinates is fast and cheap whereas transformations from global to local coordinate systems are relatively expensive.Implementation Note: It is assumed that the transformation deals with Integer points. All transformations will return Integer coordinates (even though float points may be passed in here).!!MatrixTransform2x3 methodsFor: 'initialize' stamp: 'ar 11/2/1998 23:17'!setIdentiy	"Initialize the receiver to the identity transformation (e.g., not affecting points)"	self		a11: 1.0; a12: 0.0; a13: 0.0;		a21: 0.0; a22: 1.0; a23: 0.0.! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 2/4/1999 17:05'!at: index	<primitive: 'primitiveFloatArrayAt'>	^Float fromIEEE32Bit: (self basicAt: index)! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 2/4/1999 17:05'!at: index put: value	<primitive: 'primitiveFloatArrayAtPut'>	value isFloat 		ifTrue:[self basicAt: index put: value asIEEE32BitWord]		ifFalse:[self at: index put: value asFloat].	^value! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/18/1998 14:03'!inverseTransformation	"Return the inverse transformation of the receiver.	The inverse transformation is computed by first calculating	the inverse offset and then computing transformations	for the two identity vectors (1@0) and (0@1)"	| r1 r2 r3 m |	r3 _ self invertPoint: 0@0.	r1 _ (self invertPoint: 1@0) - r3.	r2 _ (self invertPoint: 0@1) - r3.	m _ self species new.	m		a11: r1 x; a12: r2 x; a13: r3 x;		a21: r1 y; a22: r2 y; a23: r3 y.	^m! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/2/1998 23:19'!offset	^self a13 @ self a23! !!MatrixTransform2x3 methodsFor: 'accessing' stamp: 'ar 11/2/1998 23:05'!offset: aPoint	self a13: aPoint x asFloat.	self a23: aPoint y asFloat.! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a11	^self at: 1! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a11: value	 self at: 1 put: value! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a12	^self at: 2! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a12: value	 self at: 2 put: value! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a13	^self at: 3! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a13: value	 self at: 3 put: value! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a21	 ^self at: 4! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a21: value	 self at: 4 put: value! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a22	 ^self at: 5! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a22: value	 self at: 5 put: value! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:56'!a23	 ^self at: 6! !!MatrixTransform2x3 methodsFor: 'element access' stamp: 'ar 11/2/1998 22:57'!a23: value	 self at: 6 put: value! !!MatrixTransform2x3 methodsFor: 'testing' stamp: 'ar 11/2/1998 23:05'!isIdentity	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."	<primitive: 'm23PrimitiveIsIdentity'>	^self isPureTranslation and:[self a13 = 0.0 and:[self a23 = 0.0]]! !!MatrixTransform2x3 methodsFor: 'testing' stamp: 'ar 11/2/1998 23:15'!isMatrixTransform2x3	"Return true if the receiver is 2x3 matrix transformation"	^true! !!MatrixTransform2x3 methodsFor: 'testing' stamp: 'ar 11/2/1998 23:06'!isPureTranslation	"Return true if the receiver specifies no rotation or scaling."	<primitive: 'm23PrimitiveIsPureTranslation'>	^self a11 = 1.0 and:[self a12 = 0.0 and:[self a22 = 0.0 and:[self a21 = 1.0]]]! !!MatrixTransform2x3 methodsFor: 'comparing' stamp: 'bf 8/20/1999 12:47'!= aMatrixTransform2x3 	| length |	<primitive: 'primitiveFloatArrayEqual'>	self class = aMatrixTransform2x3 class ifFalse: [^ false].	length _ self size.	length = aMatrixTransform2x3 size ifFalse: [^ false].	1 to: self size do: [:i | (self at: i)			= (aMatrixTransform2x3 at: i) ifFalse: [^ false]].	^ true! !!MatrixTransform2x3 methodsFor: 'comparing' stamp: 'ar 11/2/1998 19:31'!hash	| result |	<primitive:'primitiveFloatArrayHash'>	result _ 0.	1 to: self size do:[:i| result _ result + (self basicAt: i) ].	^result bitAnd: 16r1FFFFFFF! !!MatrixTransform2x3 methodsFor: 'composing' stamp: 'ar 11/2/1998 19:50'!composedWithLocal: aTransformation	"Return the composition of the receiver and the local transformation passed in"	aTransformation isMatrixTransform2x3 ifFalse:[^super composedWith: aTransformation].	^self composedWithLocal: aTransformation asMatrixTransform2x3 into: self class new! !!MatrixTransform2x3 methodsFor: 'composing' stamp: 'ar 11/2/1998 23:08'!composedWithLocal: aTransformation into: result	"Return the composition of the receiver and the local transformation passed in.	Store the composed matrix into result."	| a11 a12 a13 a21 a22 a23 b11 b12 b13 b21 b22 b23 matrix |	<primitive: 'm23PrimitiveComposeMatrix'>	matrix _ aTransformation asMatrixTransform2x3.	a11 _ self a11.		b11 _ matrix a11.	a12 _ self a12.		b12 _ matrix a12.	a13 _ self a13.		b13 _ matrix a13.	a21 _ self a21.		b21 _ matrix a21.	a22 _ self a22.		b22 _ matrix a22.	a23 _ self a23.		b23 _ matrix a23.	result a11: (a11 * b11) + (a12 * b21).	result a12: (a11 * b12) + (a12 * b22).	result a13: a13 + (a11 * b13) + (a12 * b23).	result a21: (a21 * b11) + (a22 * b21).	result a22: (a21 * b12) + (a22 * b22).	result a23: a23 + (a21 * b13) + (a22 * b23).	^result! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 11/9/1998 13:46'!globalPointToLocal: aPoint	"Transform aPoint from global coordinates into local coordinates"	<primitive: 'm23PrimitiveInvertPoint'>	^(self invertPoint: aPoint) rounded! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 11/16/1998 23:46'!invertPoint: aPoint	"Transform aPoint from global coordinates into local coordinates"	| x y det a11 a12 a21 a22 detX detY |	x _ aPoint x asFloat - (self a13).	y _ aPoint y asFloat - (self a23).	a11 _ self a11.	a12 _ self a12.	a21 _ self a21.	a22 _ self a22.	det _ (a11 * a22) - (a12 * a21).	det = 0.0 ifTrue:[^0@0]. "So we have at least a valid result"	det _ 1.0 / det.	detX _ (x * a22) - (a12 * y).	detY _ (a11 * y) - (x * a21).	^(detX * det) @ (detY * det)! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 11/3/1998 03:04'!localPointToGlobal: aPoint	"Transform aPoint from local coordinates into global coordinates"	<primitive: 'm23PrimitiveTransformPoint'>	^(self transformPoint: aPoint) rounded! !!MatrixTransform2x3 methodsFor: 'transforming points' stamp: 'ar 11/2/1998 23:09'!transformPoint: aPoint	"Transform aPoint from local coordinates into global coordinates"	| x y |	x _ (aPoint x * self a11) + (aPoint y * self a12) + self a13.	y _ (aPoint x * self a21) + (aPoint y * self a22) + self a23.	^x @ y! !!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'ar 11/9/1998 14:41'!globalBounds: srcRect toLocal: dstRect	"Transform aRectangle from global coordinates into local coordinates"	<primitive:'m23PrimitiveInvertRectInto'>	^super globalBoundsToLocal: srcRect! !!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'ar 11/9/1998 14:40'!globalBoundsToLocal: aRectangle	"Transform aRectangle from global coordinates into local coordinates"	^self globalBounds: aRectangle toLocal: Rectangle new! !!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'ar 11/9/1998 14:41'!localBounds: srcRect toGlobal: dstRect	"Transform aRectangle from local coordinates into global coordinates"	<primitive:'m23PrimitiveTransformRectInto'>	^super localBoundsToGlobal: srcRect! !!MatrixTransform2x3 methodsFor: 'transforming rects' stamp: 'ar 11/9/1998 14:40'!localBoundsToGlobal: aRectangle	"Transform aRectangle from local coordinates into global coordinates"	^self localBounds: aRectangle toGlobal: Rectangle new! !!MatrixTransform2x3 methodsFor: 'converting' stamp: 'ar 11/2/1998 15:34'!asMatrixTransform2x3	^self! !!MatrixTransform2x3 methodsFor: 'printing' stamp: 'ar 11/2/1998 23:11'!printOn: aStream	aStream 		nextPutAll: self class name;		nextPut: $(;		cr; print: self a11; tab; print: self a12; tab; print: self a13;		cr; print: self a21; tab; print: self a22; tab; print: self a23;		cr; nextPut:$).! !!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/2/1998 23:17'!setAngle: angle	"Set the raw rotation angle in the receiver"	| rad s c |	rad := angle degreesToRadians.	s := rad sin.	c := rad cos.	self a11: c.	self a12: s negated.	self a21: s.	self a22: c.! !!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/2/1998 23:17'!setOffset: aPoint	"Set the raw offset in the receiver"	| pt |	pt _ aPoint asPoint.	self a13: pt x asFloat.	self a23: pt y asFloat.! !!MatrixTransform2x3 methodsFor: 'private' stamp: 'ar 11/2/1998 23:16'!setScale: aPoint	"Set the raw scale in the receiver"	| pt |	pt _ aPoint asPoint.	self a11: pt x asFloat.	self a22: pt y asFloat.! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 22:50'!identity	^self new setScale: 1.0! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 7/9/1998 20:09'!new	^self new: 6! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/12/1998 01:25'!transformFromLocal: localBounds toGlobal: globalBounds	^((self withOffset: (globalBounds center)) composedWithLocal:		(self withScale: (globalBounds extent / localBounds extent) asFloatPoint))			composedWithLocal: (self withOffset: localBounds center negated)"	^(self identity)		setScale: (globalBounds extent / localBounds extent) asFloatPoint;		setOffset: localBounds center negated asFloatPoint;		composedWithGlobal:(self withOffset: globalBounds center asFloatPoint)"! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 02:49'!withAngle: angle	^self new setAngle: angle! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/3/1998 02:52'!withOffset: aPoint	^self identity setOffset: aPoint! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 23:17'!withRotation: angle	^self new setAngle: angle! !!MatrixTransform2x3 class methodsFor: 'instance creation' stamp: 'ar 11/2/1998 02:49'!withScale: aPoint	^self new setScale: aPoint! !A simulation of meme exchange in a population of users carrying smart name tags.!!MemeExchange methodsFor: 'all' stamp: 'jm 2/6/2003 12:06'!done: totals	"We're done when any meme count equals the number of tags, which means that every tag has that meme."	| tagCount |	tagCount _ tags size.	1 to: totals size do: [:i | (totals at: i) = tagCount ifTrue: [^ true]].	^ false! !!MemeExchange methodsFor: 'all' stamp: 'jm 2/4/2003 20:20'!history	^ history! !!MemeExchange methodsFor: 'all' stamp: 'jm 2/6/2003 12:08'!initMemes: memeCount tagsPerMeme: tagsPerMeme	"Initialize a population of (memeCount * tagsPerMeme) tags with tagsPerMeme instances of each meme value."	| i |	nMemes _ memeCount.	tags _ Array new: memeCount * tagsPerMeme.	i _ 0.	1 to: memeCount do: [:m |		1 to: tagsPerMeme do: [:f | tags at: (i _ i + 1) put: m]].	history _ OrderedCollection new.	random _ Random new.! !!MemeExchange methodsFor: 'all' stamp: 'jm 2/6/2003 12:05'!memeCounts	"Answer an array of meme counts across the entire population of tags."	| counts m |	counts _ Array new: nMemes withAll: 0.	1 to: tags size do: [:i |		m _ tags at: i.		counts at: m put: (counts at: m) + 1].	^ counts! !!MemeExchange methodsFor: 'all' stamp: 'jm 2/6/2003 12:04'!memeExchange: i with: j	"Tags i and j exchange memes. Each tag independently decides if it wants to replace it's own meme with the other tag's meme. This is done by picking a random integer between 0 and the meme value (it's 'desirability') and choosing the meme corresponding to the higher number. Thus, the exchange is weighted in favor of the higher numbered meme, and the weighting is heavier for larger differences in meme values."	| memeI memeJ |	memeI _ tags at: i.	memeJ _ tags at: j.	(random next * memeI) < ( random next * memeJ)		ifTrue: [tags at: i put: memeJ].	(random next * memeJ) < ( random next * memeI)		ifTrue: [tags at: j put: memeI].	! !!MemeExchange methodsFor: 'all' stamp: 'jm 2/6/2003 12:04'!run	"Run the simulation until only one meme survives."	| indices half totals |	indices _ (1 to: tags size) asArray.	half _ indices size // 2.	history addLast: self memeCounts.	[true] whileTrue: [		indices _ indices shuffled.		1 to: half do: [:i |			self memeExchange: (indices at: i) with: (indices at: i + half)].		totals _ self memeCounts.		history addLast: totals.		(self done: totals) ifTrue: [history _ history asArray. ^ self]].! !!MenuItemMorph methodsFor: 'initialization' stamp: 'sw 12/8/1999 17:26'!initialize	super initialize.	bounds _ 0@0 extent: 10@10.	color _ Color black.	contents _ ''.	hasFocus _ false.	isEnabled _ true.	subMenu _ nil.	isSelected _ false.	target _ nil.	selector _ nil.	arguments _ nil.	font _ Preferences standardMenuFont.! !!MenuItemMorph methodsFor: 'accessing' stamp: 'jm 10/4/2002 08:34'!adaptToWorld: aWorld	super adaptToWorld: aWorld.	target isMorph ifTrue: [		target isWorldMorph ifTrue: [self target: aWorld].		target isHandMorph ifTrue: [self target: aWorld primaryHand]].! !!MenuItemMorph methodsFor: 'drawing' stamp: 'sma 6/5/2000 14:50'!drawOn: aCanvas	| selectionColor |	isSelected & isEnabled		ifTrue:			[selectionColor _ Display depth <= 2				ifTrue: [Color gray]				ifFalse: [owner color darker].			aCanvas fillRectangle: self bounds color: selectionColor].	super drawOn: aCanvas.	subMenu ifNotNil:		[aCanvas			paintImage: SubMenuMarker			at: self right - 8 @ (self top + self bottom - SubMenuMarker height // 2)]! !!MenuItemMorph methodsFor: 'events' stamp: 'sw 6/24/1999 11:34'!invokeWithEvent: evt	"Perform the action associated with the given menu item."	| selArgCount |	self isEnabled ifFalse: [^ self].	(owner isKindOf: MenuMorph) ifTrue: [owner lastSelection: selector].	Cursor normal showWhile: [  "show cursor in case item opens a new MVC window"		(selArgCount _ selector numArgs) = 0			ifTrue:				[target perform: selector]			ifFalse:				[selArgCount = arguments size					ifTrue: [target perform: selector withArguments: arguments]					ifFalse: [target perform: selector withArguments: (arguments copyWith: evt)]]]! !!MenuItemMorph methodsFor: 'events' stamp: 'sw 3/2/1999 13:39'!mouseDown: evt	"Handle a mouse down event. Menu items get activated when the mouse is over them."	self isInMenu ifFalse: [^ super mouseDown: evt].	evt shiftPressed ifTrue: [^ super mouseDown: evt].  "enable label editing" 	(owner hasProperty: #paletteMenu)		ifFalse:			[self bringMenuChainToFront].	self selectFromHand: evt hand! !!MenuItemMorph methodsFor: 'events' stamp: 'bf 11/23/1999 09:37'!mouseUp: evt	"Handle a mouse up event. Menu items get activated when the mouse is over them."	| mouseInMe |	mouseInMe _ self containsPoint: evt cursorPoint.	self deselectItem.	self isInMenu		ifTrue:			[(mouseInMe and: [self selector = #toggleStayUp:])				ifFalse: [owner deleteIfPopUpFrom: self event: evt].			subMenu ifNil:				[mouseInMe ifTrue:					[evt hand world displayWorld.					owner invokeItem: self event: evt]]]		ifFalse:  			[self invokeWithEvent: evt]						! !!MenuItemMorph methodsFor: 'layout' stamp: 'ar 5/18/2000 18:34'!layoutInWidth: w height: h	| scanner |	scanner _ DisplayScanner quickPrintOn: Display box: Display boundingBox font: self fontToUse.	self extent: ((scanner stringWidth: contents) @ (scanner lineHeight) max: w@h).! !!MenuItemMorph methodsFor: 'layout' stamp: 'ar 5/18/2000 18:34'!minWidth	| scanner |	scanner _ DisplayScanner quickPrintOn: Display box: Display boundingBox font: self fontToUse.	^ (scanner stringWidth: contents) + (subMenu == nil ifTrue: [0] ifFalse: [10])! !!MenuItemMorph methodsFor: 'private' stamp: 'sw 6/20/1999 23:39'!bringMenuChainToFront	| menusToPopUp menu owningItem |	menusToPopUp _ OrderedCollection new.	menu _ self owner.	[menu isKindOf: MenuMorph] whileTrue: [		menusToPopUp addFirst: menu.		owningItem _ menu popUpOwner.		(owningItem isKindOf: MenuItemMorph)			ifTrue: [menu _ owningItem owner]			ifFalse: [menu _ nil]].	menusToPopUp do: [:m | (m owner isKindOf: AlignmentMorph)		ifFalse:			[m owner addMorphFront: m]].! !!MenuItemMorph methodsFor: 'private' stamp: 'di 8/8/1998 09:22'!selectFromHand: aHand	self isSelected: true.	aHand newMouseFocus: self.	subMenu ifNotNil: [		subMenu delete.		subMenu			popUpAdjacentTo: (Array with: self bounds topRight + (10@0)									with: self bounds topLeft)			forHand: aHand			from: self].! !!MenuLineMorph methodsFor: 'drawing' stamp: 'sw 7/14/1999 10:14'!drawOn: aCanvas	| pref |	aCanvas		fillRectangle: (bounds topLeft corner: bounds rightCenter)		color: ((pref _ Preferences menuColorFromWorld)					ifTrue:						[owner color darker]					ifFalse:						[Preferences menuLineUpperColor]).	aCanvas		fillRectangle: (bounds leftCenter corner: bounds bottomRight)		color: (pref					ifTrue:						[owner color lighter]					ifFalse:						[Preferences menuLineLowerColor])! !!MenuMorph methodsFor: 'accessing' stamp: 'sw 11/22/1999 10:25'!itemWithWording: wording	| aString aSubmenu subItem |	"If any of the receiver's items or submenu items have the given wording (case-blind comparison done), then return it, else return nil."	aString _ wording asString asLowercase.	self items do:		[:anItem |			(anItem contents asString asLowercase = aString) ifTrue: [^ anItem].			(aSubmenu _ anItem subMenu) ifNotNil:				[(subItem _ aSubmenu itemWithWording: wording) ifNotNil: [^ subItem]]].	^ nil! !!MenuMorph methodsFor: 'accessing' stamp: 'sw 4/19/1999 12:22'!lastItem	^ submorphs last! !!MenuMorph methodsFor: 'construction' stamp: 'jm 10/13/2002 17:38'!add: aString action: aSymbol	"Append a menu item with the given label. If the item is selected, it will send the given selector to the default target object."	"Details: Note that the menu item added captures the default target object at the time the item is added; the default target can later be changed before added additional items without affecting the targets of previously added entries. The model is that each entry is like a button that knows everything it needs to perform its action."	self add: aString		target: defaultTarget		selector: aSymbol		argumentList: Array empty.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 10/13/2002 17:38'!add: aString target: aTarget action: aSymbol	self add: aString		target: aTarget		selector: aSymbol		argumentList: Array empty.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 10/13/2002 17:38'!add: aString target: anObject selector: aSymbol	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object."	self add: aString		target: anObject		selector: aSymbol		argumentList: Array empty.! !!MenuMorph methodsFor: 'construction' stamp: 'md 12/15/1999 12:44'!addList: listOfPairs	"Add the given items to this menu, where each item is a pair (<string> <actionSelector>)..  ILf an element of the list is simply the symobl $-, add a line to the receiver."	listOfPairs do: [:pair |		#- = pair			ifTrue: [self addLine]			ifFalse: [self add: pair first action: pair last]]! !!MenuMorph methodsFor: 'construction' stamp: 'jm 10/13/2002 17:38'!addStayUpItem	"Append a menu item that can be used to toggle this menu's persistent."	self add: 'keep this menu up'		target: self		selector: #toggleStayUp:		argumentList: Array empty.	self addLine.! !!MenuMorph methodsFor: 'construction' stamp: 'sw 6/19/1999 23:09'!addTitle: aString	"Add a title line at the top of this menu."	self addTitle: aString updatingSelector: nil updateTarget: nil! !!MenuMorph methodsFor: 'construction' stamp: 'sw 12/8/1999 17:53'!addTitle: aString updatingSelector: aSelector updateTarget: aTarget	"Add a title line at the top of this menu  Make aString its initial contents.  If aSelector is not nil, then periodically obtain fresh values for its contents by sending aSelector to aTarget.."	| title |	title _ AlignmentMorph new.	self setTitleParametersFor: title.	title vResizing: #shrinkWrap.	title orientation: #vertical.	title centering: #center.	aSelector		ifNotNil:			[title addMorphBack: (UpdatingStringMorph new lock; useStringFormat; target: aTarget; getSelector: aSelector)]		ifNil:			[(aString asString findTokens: String cr) do:				[:line | title addMorphBack: (StringMorph contents: line font: Preferences standardMenuFont)]].		self addMorphFront: title.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 10/13/2002 17:38'!addUpdating: aWordingSelector action: aSymbol	self addUpdating: aWordingSelector		target: defaultTarget		selector: aSymbol		argumentList: Array empty.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 10/13/2002 17:38'!addUpdating: aWordingSelector enablement: anEnablementSelector action: aSymbol	self addUpdating: aWordingSelector		enablementSelector: anEnablementSelector		target: defaultTarget		selector: aSymbol		argumentList: Array empty.! !!MenuMorph methodsFor: 'construction' stamp: 'sw 6/21/1999 11:32'!addUpdating: wordingSelector enablementSelector: enablementSelector target: target selector: aSymbol argumentList: argList	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given arguments. If the selector takes one more argument than the number of arguments in the given list, then the triggering event is supplied as as the last argument.  In this variant, the wording of the menu item is obtained by sending the wordingSelector to the target, and the optional enablementSelector determines whether or not the item should be enabled."	| item |	item _ UpdatingMenuItemMorph new		target: target;		selector: aSymbol;		wordingProvider: target wordingSelector: wordingSelector;		enablementSelector: enablementSelector;		arguments: argList asArray.	self addMorphBack: item.! !!MenuMorph methodsFor: 'construction' stamp: 'jm 10/13/2002 17:38'!addUpdating: aWordingSelector target: aTarget action: aSymbol	self addUpdating: aWordingSelector		target: aTarget		selector: aSymbol		argumentList: Array empty.! !!MenuMorph methodsFor: 'construction' stamp: 'sw 6/11/1999 16:46'!addUpdating: wordingSelector target: target selector: aSymbol argumentList: argList	"Append a menu item with the given label. If the item is selected, it will send the given selector to the target object with the given arguments. If the selector takes one more argument than the number of arguments in the given list, then the triggering event is supplied as as the last argument.  In this variant, the wording of the menu item is obtained by sending the wordingSelector to the target"	| item |	item _ UpdatingMenuItemMorph new		target: target;		selector: aSymbol;		wordingProvider: target wordingSelector: wordingSelector;		arguments: argList asArray.	self addMorphBack: item.! !!MenuMorph methodsFor: 'construction' stamp: 'sw 11/5/1998 21:13'!balloonTextForLastItem: balloonText	submorphs last setBalloonText: balloonText! !!MenuMorph methodsFor: 'construction' stamp: 'di 8/20/1998 09:30'!labels: labelList lines: linesArray selections: selectionsArray	"This method allows the receiver to accept old-style SelectionMenu creation messages. It should be used only for backward compatibility during the MVC-to-Morphic transition. New code should be written using the other menu construction protocol such as addList:."	"Labels can be either a sting with embedded crs, or a collection of strings."	| labelArray |	(labelList isMemberOf: String)		ifTrue: [labelArray _ labelList findTokens: String cr]		ifFalse: [labelArray _ labelList].	1 to: labelArray size do: [:i |		self add: (labelArray at: i) action: (selectionsArray at: i).		(linesArray includes: i) ifTrue: [self addLine]].! !!MenuMorph methodsFor: 'construction' stamp: 'sw 7/1/1999 22:21'!title: aString	"Add a title line at the top of this menu."	self addTitle: aString! !!MenuMorph methodsFor: 'control' stamp: 'jm 10/15/2002 17:18'!deleteIfPopUp	"Remove this menu from the screen if stayUp is not true. If it is a submenu, also remove its owning menu."	stayUp ifFalse: [self delete].	(popUpOwner notNil and: [popUpOwner isKindOf: MenuItemMorph]) ifTrue: [		popUpOwner isSelected: false.		(popUpOwner owner isKindOf: MenuMorph)			ifTrue: [popUpOwner owner deleteIfPopUp]].! !!MenuMorph methodsFor: 'control' stamp: 'bf 11/23/1999 11:11'!deleteIfPopUpFrom: item event: evt	"Remove this menu from the screen if stayUp is not true, but only if the user did move the mouse since invoking me. This allows for click-move-click selection style."	stayUp ifFalse: 		[((self hasProperty: #stayUpOnce) or: 			[(evt cursorPoint dist: originalEvent cursorPoint) < 2]) ifTrue:				[self removeProperty: #stayUpOnce.				^evt hand newMouseFocus: item "Do tracking and delete on next click"]].	self deleteIfPopUp.! !!MenuMorph methodsFor: 'control' stamp: 'di 3/14/1999 13:04'!invokeItem: aMenuItem	"Perform the action associated with the given menu item."	^ self invokeItem: aMenuItem event: originalEvent! !!MenuMorph methodsFor: 'control' stamp: 'di 3/14/1999 13:03'!invokeItem: aMenuItem event: evt	"Perform the action associated with the given menu item."	| sel target args selArgCount |	aMenuItem isEnabled ifFalse: [^ self].	lastSelection _ aMenuItem.	"to do: report lastSelection"	sel _ aMenuItem selector.	target _ aMenuItem target.	args _ aMenuItem arguments.	selArgCount _ sel numArgs.	Cursor normal showWhile: [  "show cursor in case item opens a new MVC window"		selArgCount = 0			ifTrue: [target perform: sel]			ifFalse: [				selArgCount = args size					ifTrue: [target perform: sel withArguments: args]					ifFalse: [target perform: sel withArguments: (args copyWith: evt)]]].! !!MenuMorph methodsFor: 'control' stamp: 'bf 11/23/1999 11:17'!justDroppedInto: aMorph event: anEvent	"This menu was grabbed and moved. Save us from being deleted by the mouseUp event."	stayUp ifFalse: [self setProperty: #stayUpOnce toValue: true].	super justDroppedInto: aMorph event: anEvent! !!MenuMorph methodsFor: 'control' stamp: 'sma 6/5/2000 14:56'!popUpAdjacentTo: rightOrLeftPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| selectedItem delta tryToPlace selectedOffset |	hand world startSteppingSubmorphsOf: self.	popUpOwner _ sourceItem.	originalEvent _ hand lastEvent.	selectedItem _ self selectedItem.	self fullBounds.  "ensure layout is current"	selectedOffset _ selectedItem position - self position.	tryToPlace _		[:where :mustFit |		self position: where - selectedOffset.		delta _ self fullBoundsInWorld amountToTranslateWithin: hand worldBounds.		(delta x = 0 or: [mustFit]) ifTrue:			[delta = (0@0) ifFalse: [self position: self position + delta].			sourceItem owner owner addMorphFront: self.			^ self]].	tryToPlace 		value: rightOrLeftPoint first value: false;		value: rightOrLeftPoint last  - (self width @ 0) value: false;		value: rightOrLeftPoint first value: true	! !!MenuMorph methodsFor: 'control' stamp: 'sma 6/5/2000 13:55'!popUpAt: aPoint event: evt	"Present this menu at the given point in response to the given event."	self popUpAt: aPoint forHand: evt hand! !!MenuMorph methodsFor: 'control' stamp: 'mir 5/25/2000 17:39'!popUpAt: aPoint forHand: hand 	"Present this menu at the given point under control of the given hand."	| selectedItem i yOffset sub delta |	hand resetClickState.	popUpOwner _ hand.	originalEvent _ hand lastEvent.	selectedItem _ self items detect: [:each | each == lastSelection]				ifNone: [self items isEmpty						ifTrue: [^ self]						ifFalse: [self items first]].	"Note: items may not be laid out yet (I found them all to be at 0@0), 	so have to add up heights of items above the selected item."	i _ 0.	yOffset _ 0.	[(sub _ self submorphs at: (i _ i + 1)) == selectedItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2 @ (yOffset + 8)).	self bounds right > hand worldBounds right		ifTrue: [self position: self position - (self bounds width - 4 @ 0)].	delta _ self bounds amountToTranslateWithin: hand worldBounds.	delta = (0 @ 0) ifFalse: [self position: self position + delta].	hand world addMorphFront: self; startSteppingSubmorphsOf: self.	hand newMouseFocus: selectedItem.	self changed! !!MenuMorph methodsFor: 'control' stamp: 'sma 6/5/2000 14:43'!popUpAt: aPoint forHand: hand from: sourceItem	"Present this menu at the given point under control of the given hand."	| selectedItem delta |	popUpOwner _ sourceItem.	originalEvent _ hand lastEvent.	selectedItem _ self selectedItem.	self fullBounds.  "ensure layout is current"	self position: aPoint - (selectedItem position - self position).	sourceItem owner owner addMorphFront: self.	delta _ self fullBoundsInWorld amountToTranslateWithin: hand worldBounds.	delta = (0@0) ifFalse: [self position: self position + delta]! !!MenuMorph methodsFor: 'control' stamp: 'sma 6/5/2000 13:54'!popUpEvent: evt	"Present this menu in response to the given event."	self popUpForHand: evt hand! !!MenuMorph methodsFor: 'control' stamp: 'sma 6/5/2000 13:50'!popUpForHand: hand 	"Present this menu under control of the given hand."	self popUpAt: hand position forHand: hand! !!MenuMorph methodsFor: 'control' stamp: 'sw 5/26/2000 06:59'!popUpNearHand	| aHand |	aHand _ self currentHand.	self popUpAt: aHand position forHand: aHand! !!MenuMorph methodsFor: 'control' stamp: 'sw 5/9/2000 02:32'!willingToBeEmbeddedUponLanding	^ Preferences systemWindowEmbedOK! !!MenuMorph methodsFor: 'initialization' stamp: 'sw 11/29/1999 17:38'!initialize	super initialize.	self setDefaultParameters.	orientation _ #vertical.	hResizing _ #shrinkWrap.	vResizing _ #shrinkWrap.	defaultTarget _ nil.	lastSelection _ nil.	stayUp _ false.	originalEvent _ nil.	popUpOwner _ nil.	Preferences roundedMenuCorners ifTrue: [self useRoundedCorners]! !!MenuMorph methodsFor: 'initialization' stamp: 'sw 7/14/1999 10:21'!setDefaultParameters	| worldColor |	((Preferences menuColorFromWorld and: [Display depth > 4]) and: [(worldColor _ self currentWorld color) isKindOf: Color])		ifTrue: [self setColor: (worldColor luminance > 0.7							ifTrue: [worldColor mixed: 0.8 with: Color black]							ifFalse: [worldColor mixed: 0.4 with: Color white])					borderWidth: Preferences menuBorderWidth					borderColor: #raised]		ifFalse: [self setColor: Preferences menuColor					borderWidth: Preferences menuBorderWidth					borderColor: Preferences menuBorderColor].	inset _ 3! !!MenuMorph methodsFor: 'initialization' stamp: 'sw 11/3/1998 11:23'!setTitleParametersFor: aMenuTitle	aMenuTitle setColor: Preferences menuTitleColor borderWidth: Preferences menuTitleBorderWidth borderColor: Preferences menuTitleBorderColor! !!MenuMorph methodsFor: 'menu' stamp: 'jm 10/15/2002 17:18'!toggleStayUp: evt	"Toggle my 'stayUp' flag and adjust the menu item to reflect its new state."	self items do: [:item |		item selector = #toggleStayUp: ifTrue:			[stayUp _ stayUp not.				 stayUp				ifTrue: [item contents: 'dismiss this menu']				ifFalse: [item contents: 'keep this menu up']]].	stayUp ifFalse: [self delete].! !!MenuMorph methodsFor: 'private' stamp: 'sma 6/5/2000 14:40'!positionAt: aPoint	"Note: items may not be laid out yet (I found them all to be at 0@0),  	so we have to add up heights of items above the selected item."	| i yOffset selectedItem sub delta |	i _ 0.	yOffset _ 0.	selectedItem _ self selectedItem.	[(sub _ self submorphs at: (i _ i + 1)) == selectedItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2 @ (yOffset + 8)).	"If it doesn't fit, show it to the left, not to the right of the hand."	self right > popUpOwner worldBounds right		ifTrue: [self left: self left - self width + 4].	"Make sure that the menu fits in the world."	delta _ self bounds amountToTranslateWithin: popUpOwner worldBounds.	delta = (0 @ 0) ifFalse: [self position: self position + delta]! !!MenuMorph methodsFor: 'private' stamp: 'sma 6/5/2000 14:42'!positionAt: aPoint relativeTo: selectedItem	"Note: items may not be laid out yet (I found them all to be at 0@0),  	so we have to add up heights of items above the selected item."	| i yOffset sub delta |	i _ 0.	yOffset _ 0.	[(sub _ self submorphs at: (i _ i + 1)) == selectedItem]		whileFalse: [yOffset _ yOffset + sub height].	self position: aPoint - (2 @ (yOffset + 8)).	"If it doesn't fit, show it to the left, not to the right of the hand."	self right > popUpOwner worldBounds right		ifTrue: [self left: self left - self width + 4].	"Make sure that the menu fits in the world."	delta _ self bounds amountToTranslateWithin: popUpOwner worldBounds.	delta = (0 @ 0) ifFalse: [self position: self position + delta]! !!MenuMorph methodsFor: 'private' stamp: 'sma 6/5/2000 14:38'!selectedItem	| items |	items _ self items.	^ items detect: [:each | each == lastSelection] ifNone: [items first]! !I represent a selector and its argument values.	Generally, the system does not use instances of Message for efficiency reasons. However, when a message is not understood by its receiver, the interpreter will make up an instance of me in order to capture the information involved in an actual message transmission. This instance is sent it as an argument with the message doesNotUnderstand: to the receiver.!!Message methodsFor: 'printing' stamp: 'sma 6/1/2000 10:00'!printOn: aStream 	"Refer to the comment in Object|printOn:." 	super printOn: aStream.	aStream nextPutAll: ' with selector: ';	 print: selector;	 nextPutAll: ' and arguments: ';	 print: args! !!Message methodsFor: 'printing' stamp: 'sma 6/1/2000 10:01'!storeOn: aStream 	"Refer to the comment in Object|storeOn:."	aStream nextPut: $(;	 nextPutAll: self class name;	 nextPutAll: ' selector: ';	 store: selector;	 nextPutAll: ' arguments: ';	 store: args;	 nextPut: $)! !!Message methodsFor: 'sending' stamp: 'di 3/25/1999 21:54'!sentTo: receiver	"answer the result of sending this message to receiver"	lookupClass == nil		ifTrue: [^ receiver perform: selector withArguments: args]		ifFalse: [^ receiver perform: selector withArguments: args inSuperclass: lookupClass]! !This node represents accesses to temporary variables for do-its in the debugger.  Since they execute in another context, they must send a message to the original context to access the value of the temporary variable in that context.!!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:38'!asStorableNode: encoder	"This node is a message masquerading as a temporary variable.	It currently has the form {homeContext tempAt: offset}.	We need to generate code for {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack.	This, in turn will get turned into {homeContext tempAt: offset put: expr}	at runtime if nobody disturbs storeAt:inTempFrame: in Object (not clean)"	^ MessageAsTempNode new		receiver: nil  "suppress code generation for reciever already on stack"		selector: #storeAt:inTempFrame:		arguments: (arguments copyWith: receiver)		precedence: precedence		from: encoder! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 10/12/1999 17:29'!code	"Allow synthetic temp nodes to be sorted by code"	^ arguments first literalValue! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!emitStorePop: stack on: codeStream	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^ self emitForEffect: stack on: codeStream! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:35'!isTemp	"Masquerading for debugger access to temps."	^ true! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!nowHasDef	"For compatibility with temp scope protocol"! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!nowHasRef	"For compatibility with temp scope protocol"! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!scope	"For compatibility with temp scope protocol"	^ -1! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!scope: ignored	"For compatibility with temp scope protocol"! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:39'!sizeForStorePop: encoder	"This node has the form {expr storeAt: offset inTempFrame: homeContext},	where the expr, the block argument, is already on the stack."	^ self sizeForEffect: encoder! !!MessageAsTempNode methodsFor: 'access to remote temps' stamp: 'di 3/22/1999 09:40'!store: expr from: encoder 	"ctxt tempAt: n -> ctxt tempAt: n put: expr (see Assignment).	For assigning into temps of a context being debugged."	selector key ~= #tempAt: 		ifTrue: [^self error: 'cant transform this message'].	^ MessageAsTempNode new		receiver: receiver		selector: #tempAt:put:		arguments: (arguments copyWith: expr)		precedence: precedence		from: encoder! !I represent a receiver and its message.	Precedence codes:	1 unary	2 binary	3 keyword	4 other	If special>0, I compile special code in-line instead of sending messages with literal methods as remotely copied contexts.!!MessageNode methodsFor: 'initialize-release' stamp: 'di 1/28/2000 21:19'!receiver: rcvr selector: selNode arguments: args precedence: p 	"Decompile."	self receiver: rcvr		arguments: args		precedence: p.	self noteSpecialSelector: selNode key.	selector _ selNode.	"self pvtCheckForPvtSelector: encoder"	"We could test code being decompiled, but the compiler should've checked already. And where to send the complaint?"! !!MessageNode methodsFor: 'initialize-release' stamp: 'di 1/28/2000 21:19'!receiver: rcvr selector: selName arguments: args precedence: p from: encoder 	"Compile."	self receiver: rcvr		arguments: args		precedence: p.	self noteSpecialSelector: selName.	(self transform: encoder)		ifTrue: 			[selector isNil				ifTrue: [selector _ SelectorNode new 							key: (MacroSelectors at: special)							code: #macro]]		ifFalse: 			[selector _ encoder encodeSelector: selName.			rcvr == NodeSuper ifTrue: [encoder noteSuper]].	self pvtCheckForPvtSelector: encoder! !!MessageNode methodsFor: 'macro transformations' stamp: 'di 1/28/2000 21:19'!noteSpecialSelector: selectorSymbol	" special > 0 flags specially treated messages. "	special _ MacroSelectors indexOf: selectorSymbol.! !!MessageNode methodsFor: 'macro transformations' stamp: 'sma 3/3/2000 13:37'!toDoFromWhileWithInit: initStmt	"Return nil, or a to:do: expression equivalent to this whileTrue:"	| variable increment limit toDoBlock body test |	(selector key == #whileTrue:		and: [(initStmt isMemberOf: AssignmentNode) and:				[initStmt variable isTemp]])		ifFalse: [^ nil].	body _ arguments last statements.	variable _ initStmt variable.	increment _ body last toDoIncrement: variable.	(increment == nil or: [receiver statements size ~= 1])		ifTrue: [^ nil].	test _ receiver statements first.	"Note: test chould really be checked that <= or >= comparison	jibes with the sign of the (constant) increment"	((test isMemberOf: MessageNode)		and: [(limit _ test toDoLimit: variable) notNil])		ifFalse: [^ nil].	toDoBlock _ BlockNode statements: body allButLast returns: false.	toDoBlock arguments: (Array with: variable).	^ MessageNode new		receiver: initStmt value		selector: (SelectorNode new key: #to:by:do: code: #macro)		arguments: (Array with: limit with: increment with: toDoBlock)		precedence: precedence! !!MessageNode methodsFor: 'macro transformations' stamp: 'acg 1/28/2000 00:48'!transformIfFalseIfTrue: encoder	((self checkBlock: (arguments at: 1) as: 'False arg' from: encoder)		and: [self checkBlock: (arguments at: 2) as: 'True arg' from: encoder])		ifTrue: 			[selector _ #ifTrue:ifFalse:.			arguments swap: 1 with: 2.			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'di 4/24/2000 13:32'!transformIfNil: encoder	(self transformBoolean: encoder) ifFalse: [^ false].	(MacroSelectors at: special) = #ifNotNil:	ifTrue:		[(self checkBlock: arguments first as: 'ifNotNil arg' from: encoder) ifFalse: [^ false].		"Transform 'ifNotNil: [stuff]' to 'ifNil: [nil] ifNotNil: [stuff]'.		Slightly better code and more consistent with decompilation."		self noteSpecialSelector: #ifNil:ifNotNil:.		selector _ SelectorNode new key: (MacroSelectors at: special) code: #macro.		arguments _ {BlockNode withJust: NodeNil. arguments first}.		(self transform: encoder) ifFalse: [self error: 'compiler logic error'].		^ true]	ifFalse:		[^ self checkBlock: arguments first as: 'ifNil arg' from: encoder]! !!MessageNode methodsFor: 'macro transformations' stamp: 'acg 1/28/2000 21:49'!transformIfNilIfNotNil: encoder	((self checkBlock: (arguments at: 1) as: 'Nil arg' from: encoder)		and: [self checkBlock: (arguments at: 2) as: 'NotNil arg' from: encoder])		ifTrue: 			[selector _ SelectorNode new key: #ifTrue:ifFalse: code: #macro.			receiver _ MessageNode new				receiver: receiver				selector: #==				arguments: (Array with: NodeNil)				precedence: 2				from: encoder.			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'acg 1/28/2000 21:50'!transformIfNotNilIfNil: encoder	((self checkBlock: (arguments at: 1) as: 'NotNil arg' from: encoder)		and: [self checkBlock: (arguments at: 2) as: 'Nil arg' from: encoder])		ifTrue: 			[selector _ SelectorNode new key: #ifTrue:ifFalse: code: #macro.			receiver _ MessageNode new				receiver: receiver				selector: #==				arguments: (Array with: NodeNil)				precedence: 2				from: encoder.			arguments swap: 1 with: 2.			^true]		ifFalse: 			[^false]! !!MessageNode methodsFor: 'macro transformations' stamp: 'acg 1/27/2000 22:29'!transformIfTrueIfFalse: encoder	^(self checkBlock: (arguments at: 1) as: 'True arg' from: encoder)		and: [self checkBlock: (arguments at: 2) as: 'False arg' from: encoder]! !!MessageNode methodsFor: 'macro transformations' stamp: 'tao 1/30/1999 08:56'!transformToDo: encoder	" var _ rcvr. L1: [var <= arg1] Bfp(L2) [block body. var _ var + inc] Jmp(L1) L2: "	| limit increment block initStmt test incStmt limitInit blockVar |	"First check for valid arguments"	((arguments last isMemberOf: BlockNode)			and: [arguments last numberOfArguments = 1])		ifFalse: [^ false].	arguments last firstArgument isVariableReference		ifFalse: [^ false]. "As with debugger remote vars"	arguments size = 3		ifTrue: [increment _ arguments at: 2.				(increment isConstantNumber and:					[increment literalValue ~= 0]) ifFalse: [^ false]]		ifFalse: [increment _ encoder encodeLiteral: 1].	arguments size < 3 ifTrue:   "transform to full form"		[selector _ SelectorNode new key: #to:by:do: code: #macro].	"Now generate auxiliary structures"	block _ arguments last.	blockVar _ block firstArgument.	initStmt _ AssignmentNode new variable: blockVar value: receiver.	limit _ arguments at: 1.	limit isVariableReference | limit isConstantNumber		ifTrue: [limitInit _ nil]		ifFalse:  "Need to store limit in a var"			[limit _ encoder autoBind: blockVar key , 'LimiT'.			limit scope: -2.  "Already done parsing block"			limitInit _ AssignmentNode new					variable: limit					value: (arguments at: 1)].	test _ MessageNode new receiver: blockVar			selector: (increment key > 0 ifTrue: [#<=] ifFalse: [#>=])			arguments: (Array with: limit)			precedence: precedence from: encoder.	incStmt _ AssignmentNode new			variable: blockVar			value: (MessageNode new				receiver: blockVar selector: #+				arguments: (Array with: increment)				precedence: precedence from: encoder).	arguments _ (Array with: limit with: increment with: block)		, (Array with: initStmt with: test with: incStmt with: limitInit).	^ true! !!MessageNode methodsFor: 'code generation' stamp: 'acg 1/28/2000 21:59'!emitIfNil: stack on: strm value: forValue	| theNode theSize theSelector |	theNode _ arguments first.	theSize _ sizes at: 1.	theSelector _ #ifNotNil:.	receiver emitForValue: stack on: strm.	forValue ifTrue: [strm nextPut: Dup. stack push: 1].	strm nextPut: LdNil. stack push: 1.	equalNode emit: stack args: 1 on: strm.	self 		emitBranchOn: (selector key == theSelector)		dist: theSize 		pop: stack 		on: strm.	forValue 		ifTrue: 			[strm nextPut: Pop. stack pop: 1.			theNode emitForEvaluatedValue: stack on: strm]			ifFalse: [theNode emitForEvaluatedEffect: stack on: strm].! !!MessageNode methodsFor: 'code generation' stamp: 'acg 1/28/2000 22:00'!sizeIfNil: encoder value: forValue	| theNode theSize theSelector |	equalNode _ encoder encodeSelector: #==.	sizes _ Array new: 1.	theNode _ arguments first.	theSelector _ #ifNotNil:.	forValue		ifTrue:			[sizes at: 1 put: (theSize _ (1 "pop" + (theNode sizeForEvaluatedValue: encoder))).			 ^(receiver sizeForValue: encoder) +				2 "Dup. LdNil" +				(equalNode size: encoder args: 1 super: false) +				(self 					sizeBranchOn: (selector key == theSelector) 					dist: theSize) +				theSize]		ifFalse:			[sizes at: 1 put: (theSize _ (theNode sizeForEvaluatedEffect: encoder)).			 ^(receiver sizeForValue: encoder) +				1 "LdNil" +				(equalNode size: encoder args: 1 super: false) +				(self 					sizeBranchOn: (selector key == theSelector) 					dist: theSize) +				theSize]! !!MessageNode methodsFor: 'printing' stamp: 'acg 1/28/2000 00:45'!printIfNil: aStream indent: level	^self 		printKeywords: selector key		arguments: (Array with: arguments first)		on: aStream indent: level! !!MessageNode methodsFor: 'printing' stamp: 'di 1/28/2000 23:51'!printIfNilNotNil: aStream indent: level	receiver ifNotNil:		[receiver ifNilReceiver printOn: aStream indent: level precedence: precedence].	(arguments first isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifNotNil:				arguments: { arguments second }				on: aStream indent: level].	(arguments second isJust: NodeNil) ifTrue:		[^ self printKeywords: #ifNil:				arguments: { arguments first }				on: aStream indent: level].	^ self printKeywords: #ifNil:ifNotNil:			arguments: arguments			on: aStream indent: level! !!MessageNode methodsFor: 'printing' stamp: 'di 1/28/2000 23:47'!printOn: aStream indent: level	| printer |	special > 0 ifTrue: [printer _ MacroPrinters at: special].	(printer == #printCaseOn:indent:) ifTrue: 		[^self printCaseOn: aStream indent: level].	(printer == #printIfNilNotNil:indent:) ifTrue: 		[^self printIfNilNotNil: aStream indent: level].	receiver == nil 		ifFalse: [receiver printOn: aStream indent: level precedence: precedence].	(special > 0)		ifTrue: 			[self perform: printer with: aStream with: level]		ifFalse: 			[self 				printKeywords: selector key				arguments: arguments				on: aStream				indent: level]! !!MessageNode methodsFor: 'private' stamp: 'acg 1/28/2000 00:57'!ifNilReceiver	^receiver! !!MessageNode methodsFor: 'private' stamp: 'tk 8/2/1999 18:40'!pvtCheckForPvtSelector: encoder	"If the code being compiled is trying to send a private message (e.g. 'pvtCheckForPvtSelector:') to anyone other than self, then complain to encoder."	selector isPvtSelector ifTrue:		[receiver isSelfPseudoVariable ifFalse:			[encoder notify: 'Private messages may only be sent to self']].! !!MessageNode methodsFor: 'equation translation' stamp: 'tk 8/4/1999 17:33'!eval	"When everything in me is a constant, I can produce a value.  This is only used by the Scripting system (TilePadMorph tilesFrom:in:)"	| rec args |	(receiver isKindOf: VariableNode) ifFalse: [^ #illegal].	rec _ receiver key value.	args _ arguments collect: [:each | each eval].	^ rec perform: selector key withArguments: args! !!MessageNode class methodsFor: 'class initialization' stamp: 'acg 1/28/2000 21:58'!initialize		"MessageNode initialize"	MacroSelectors _ 		#(ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:			and: or:			whileFalse: whileTrue: whileFalse whileTrue			to:do: to:by:do:			caseOf: caseOf:otherwise:			ifNil: ifNotNil:  ifNil:ifNotNil: ifNotNil:ifNil:).	MacroTransformers _ 		#(transformIfTrue: transformIfFalse: transformIfTrueIfFalse: transformIfFalseIfTrue:			transformAnd: transformOr:			transformWhile: transformWhile: transformWhile: transformWhile:			transformToDo: transformToDo:			transformCase: transformCase:			transformIfNil: transformIfNil:  transformIfNilIfNotNil: transformIfNotNilIfNil:).	MacroEmitters _ 		#(emitIf:on:value: emitIf:on:value: emitIf:on:value: emitIf:on:value:			emitIf:on:value: emitIf:on:value:			emitWhile:on:value: emitWhile:on:value: emitWhile:on:value: emitWhile:on:value:			emitToDo:on:value: emitToDo:on:value:			emitCase:on:value: emitCase:on:value:			emitIfNil:on:value: emitIfNil:on:value: emitIf:on:value: emitIf:on:value:).	MacroSizers _ 		#(sizeIf:value: sizeIf:value: sizeIf:value: sizeIf:value:			sizeIf:value: sizeIf:value:			sizeWhile:value: sizeWhile:value: sizeWhile:value: sizeWhile:value:			sizeToDo:value: sizeToDo:value:			sizeCase:value: sizeCase:value:			sizeIfNil:value: sizeIfNil:value: sizeIf:value: sizeIf:value: ).	MacroPrinters _ 		#(printIfOn:indent: printIfOn:indent: printIfOn:indent: printIfOn:indent:			printIfOn:indent: printIfOn:indent:			printWhileOn:indent: printWhileOn:indent: printWhileOn:indent: printWhileOn:indent:			printToDoOn:indent: printToDoOn:indent:			printCaseOn:indent: printCaseOn:indent:			printIfNil:indent: printIfNil:indent: printIfNilNotNil:indent: printIfNilNotNil:indent:)! !I represent a query path of the retrieval result of making a query about methods in the system. The result is a set of methods, denoted by a message selector and the class in which the method was found. As a StringHolder, the string I represent is the source code of the currently selected method. I am typically viewed in a Message Set Browser consisting of a MessageListView and a BrowserCodeView.!!MessageSet methodsFor: 'message list' stamp: 'sma 5/28/2000 11:10'!messageListIndex: anInteger 	"Set the index of the selected item to be anInteger."	messageListIndex _ anInteger.	contents _ 		messageListIndex ~= 0			ifTrue: [self selectedMessage]			ifFalse: [''].	self changed: #messageListIndex.	"update my selection"	editSelection _ #editMessage.	self contentsChanged.	(messageListIndex ~= 0 and: [autoSelectString notNil])		ifTrue: [self changed: #autoSelect].! !!MessageSet methodsFor: 'message list' stamp: 'sbw 12/30/1999 17:19'!optionalButtonHeight	^ 15! !!MessageSet methodsFor: 'message list' stamp: 'sma 3/3/2000 11:17'!selectedMessageName	"Answer the name of the currently selected message."	"wod 6/16/1998: answer nil if none are selected."	messageListIndex = 0 ifTrue: [^ nil].	^ self setClassAndSelectorIn: [:class :selector | ^ selector]! !!MessageSet methodsFor: 'message functions' stamp: 'sw 2/24/1999 18:31'!methodCategoryChanged	self changed: #annotation! !!MessageSet methodsFor: 'message functions' stamp: 'sw 1/28/1999 12:34'!removeMessage	"Remove the selected message from the system. 1/15/96 sw"	| messageName confirmation |	messageListIndex = 0 ifTrue: [^ self].	self okToChange ifFalse: [^ self].	messageName _ self selectedMessageName.	confirmation _ self selectedClassOrMetaClass confirmRemovalOf: messageName.	confirmation == 3 ifTrue: [^ self].	self selectedClassOrMetaClass removeSelector: messageName.	self initializeMessageList: (messageList copyWithout: self selection).		"self messageListIndex: 0."	self changed: #messageList.	self changed: #messageListIndex.	self contentsChanged.	confirmation == 2 ifTrue:		[Smalltalk browseAllCallsOn: messageName]! !!MessageSet methodsFor: 'message functions' stamp: 'sw 1/28/1999 12:34'!removeMessageFromBrowser	"Remove the selected message from the browser."	messageListIndex = 0 ifTrue: [^ self].	self initializeMessageList: (messageList copyWithout: self selection).	"self messageListIndex: 0."	self changed: #messageList.	self changed: #messageListIndex.	self contentsChanged.! !!MessageSet methodsFor: 'message functions' stamp: 'sw 9/27/1999 15:30'!toggleDiff	self okToChange ifTrue:		[self showDiffs: self showDiffs not.		self changed: #contents]! !!MessageSet methodsFor: 'contents' stamp: 'sma 5/28/2000 11:09'!contents	^ contents == nil		ifTrue: [currentCompiledMethod _ nil. '']		ifFalse: [messageListIndex = 0 			ifTrue: [currentCompiledMethod _ nil. contents]			ifFalse: [editSelection == #byteCodes				ifTrue: [(self selectedClassOrMetaClass							compiledMethodAt: self selectedMessageName) symbolic]				ifFalse: [self selectedMessage]]]! !!MessageSet methodsFor: 'contents' stamp: 'sw 3/1/2000 10:57'!selectedMessage	"Answer the source method for the currently selected message."	| source |	self setClassAndSelectorIn: [:class :selector | 		class ifNil: [^ 'Class vanished'].		source _ class sourceMethodAt: selector ifAbsent:			[currentCompiledMethod _ nil.			^ 'Missing'].		currentCompiledMethod _ class compiledMethodAt: selector ifAbsent: [nil].		Preferences browseWithPrettyPrint ifTrue:			[source _ class compilerClass new				format: source in: class notifying: nil decorated: Preferences colorWhenPrettyPrinting].		self showDiffs ifTrue:			[source _ self diffFromPriorSourceFor: source].		^ source asText makeSelectorBoldIn: class]! !!MessageSet methodsFor: 'contents' stamp: 'sw 10/19/1999 17:30'!updateCodePaneIfNeeded	"If the code for the currently selected method has changed underneath me, then update the contents of my code pane unless it holds unaccepted edits.	Overridden here in order not to set contents to nil"	self didCodeChangeElsewhere		ifTrue:			[self hasUnacceptedEdits				ifFalse:					[self contentsChanged]				ifTrue:					[self changed: #codeChangedElsewhere]]! !!MessageSet methodsFor: 'private' stamp: 'ls 12/5/1999 13:46'!contents: aString notifying: aController 	"Compile the code in aString. Notify aController of any syntax errors. 	Answer false if the compilation fails. Otherwise, if the compilation 	created a new method, deselect the current selection. Then answertrue."	| category selector class oldSelector |	messageListIndex = 0 ifTrue: [^ false].	self okayToAccept ifFalse: [^ false].	self setClassAndSelectorIn: [:c :os | class_c.  oldSelector_os].	category _ class organization categoryOfElement: oldSelector.	selector _ class compile: aString				classified: category				notifying: aController.	selector == nil ifTrue: [^false].	selector == oldSelector ifFalse: [self messageListIndex: 0].	contents _ aString copy.	self changed: #annotation.	^ true! !!MessageSet class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 09:58'!open: aMessageSet name: aString 	"Create a standard system view for the messageSet, aMessageSet, whose label is aString."	| topView aListView aBrowserCodeView aTextView underPane y buttonsView winWidth |	Smalltalk isMorphic ifTrue: [^ self openAsMorph: aMessageSet name: aString].	winWidth _ 200.	topView _ (StandardSystemView new) model: aMessageSet.	topView label: aString.	topView minimumSize: winWidth @ 120.	topView borderWidth: 1.	aListView _ PluggableListView on: aMessageSet		list: #messageList		selected: #messageListIndex		changeSelected: #messageListIndex:		menu: #messageListMenu:shifted:		keystroke: #messageListKey:from:.	aListView  menuTitleSelector: #messageListSelectorTitle.	aListView window: (0 @ 0 extent: winWidth @ 100).	topView addSubView: aListView.	Preferences useAnnotationPanes		ifTrue: [			aTextView _ PluggableTextView on: aMessageSet 			text: #annotation accept: nil			readSelection: nil menu: nil.			aTextView window: (0 @ 0 extent: winWidth @ 24).			topView addSubView: aTextView below: aListView.			underPane _ aTextView.			y _ 300 - 24.			aTextView askBeforeDiscardingEdits: false]		ifFalse: [			underPane _ aListView.			y _ 300].	Preferences optionalButtons ifTrue: [		buttonsView _ aMessageSet buildOptionalButtonsView.		topView addSubView: buttonsView below: underPane.		underPane _ buttonsView.		y _ y - aMessageSet optionalButtonHeight].	aBrowserCodeView _ PluggableTextView on: aMessageSet 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	aBrowserCodeView window: (0 @ 0 extent: winWidth @ y).	topView addSubView: aBrowserCodeView below: underPane.	topView setUpdatablePanesFrom: #(messageList).	topView controller open! !!MessageSet class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 10:41'!openAsMorph: aMessageSet name: labelString 	"Create a SystemWindow aMessageSet, with the label labelString, in a Morphic project"	^ self openAsMorph: aMessageSet name: labelString inWorld: self currentWorld! !!MessageSet class methodsFor: 'instance creation' stamp: 'sw 12/13/1999 10:26'!openAsMorph: aMessageSet name: labelString inWorld: aWorld	"Create a SystemWindow aMessageSet, with the label labelString."	| window aListMorph aTextMorph baseline |	window _ (SystemWindow labelled: labelString) model: aMessageSet.	aListMorph _ PluggableListMorph on: aMessageSet list: #messageList			selected: #messageListIndex changeSelected: #messageListIndex:			menu: #messageListMenu:shifted:			keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph frame: (0@0 extent: 1@0.2).	Preferences useAnnotationPanes		ifFalse:			[baseline  _ 0.2]		ifTrue:			[aTextMorph _ PluggableTextMorph on: aMessageSet					text: #annotation accept: nil					readSelection: nil menu: nil.			aTextMorph askBeforeDiscardingEdits: false.			window addMorph: aTextMorph				frame: (0@0.2 corner: 1@0.25).			baseline _ 0.25].	Preferences optionalButtons		ifTrue:			[window addMorph: aMessageSet optionalButtonRow frame: ((0@baseline corner: 1 @ (baseline + 0.08))).			baseline _ baseline + 0.08].	window addMorph: (PluggableTextMorph on: aMessageSet 			text: #contents accept: #contents:notifying:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:)		frame: (0@baseline corner: 1@1).		window setUpdatablePanesFrom: #(messageList).	window openInWorld: aWorld! !!MessageSet class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 09:59'!openMessageList: messageList name: labelString autoSelect: autoSelectString	"Open a system view for a MessageSet on messageList. 	 1/24/96 sw: the there-are-no msg now supplied by my sender"	| messageSet |	messageSet _ self messageList: messageList.	messageSet autoSelectString: autoSelectString.	Smalltalk isMorphic ifTrue: [^ self openAsMorph: messageSet name: labelString].	ScheduledControllers scheduleActive: (self open: messageSet name: labelString)! !!MessageSet class methodsFor: 'instance creation' stamp: 'sw 3/1/2000 10:59'!parse: messageString toClassAndSelector: csBlock	"Decode strings of the form <className> [class] <selectorName>."	| tuple cl |	tuple _ messageString findTokens: ' .'.	cl _ Smalltalk atOrBelow: tuple first asSymbol ifAbsent: [^ csBlock value: nil value: nil].	(tuple size = 2 or: [tuple size > 2 and: [(tuple at: 2) ~= 'class']])		ifTrue: [^ csBlock value: cl value: (tuple at: 2) asSymbol]		ifFalse: [^ csBlock value: cl class value: (tuple at: 3) asSymbol]! !I transmit and receive "messages", where a message is simply a String or ByteArray that is treated as an atomic unit of communication. When sending, I queue messages for transmission and stream them out in order. When receiving, I gather the incoming data into discrete messages. This allows clients code to treat message transmission as an atomic action; the sender can "send and forget" and the receiver will never see an incomplete message. Messages are transmitted as a four-byte size field followed by the bytes of the message. Notes:1. Zero-length messages are allowed.2. Since messages are buffered in memory in their entirety, this facility is not appropriate for transmitting large pieces of data (i.e., many megabytes) such as large sound or movie files, unless both ends have enough heap space to buffer the data.3. The sender should call sendData and the receiver should call nextMessage frequently; these are the methods that actually feed data through the socket connection.!!MessageSocket methodsFor: 'initialization' stamp: 'jm 8/20/2001 22:36'!initialize	"Initialize this message socket."	socket _ nil.	inSizeBuf _ ByteArray new: 4.	inSizeIndex _ 1.	inBuf _ nil.	inIndex _ 1.	outgoingMessages _ OrderedCollection new.	outBuf _ nil.	outIndex _ 1.	lastActivityTime _ Time totalSeconds.! !!MessageSocket methodsFor: 'initialization' stamp: 'jm 8/20/2001 22:36'!on: aSocket	"Initialize this message socket on the given socket."	self initialize.	socket _ aSocket.! !!MessageSocket methodsFor: 'sending' stamp: 'jm 4/23/2003 08:53'!sendData	"Send some more data, if possible. Answer true if there is more data to be sent. This method should be called frequently by the client. It does nothing if there are no messages to send, or if the socket is not connected or ready to accept data. If outBuf is not a bytes object (i.e., a ByteArray or String) then assume it is a positionable stream and let sendStreamData send it."	| n szBuf | 	(socket notNil and: [socket isConnected]) ifFalse: [^ false].	socket waitForSendDoneUntil: (Socket deadlineSecs: 1).	outBuf ifNil: [  "not currently sending"		outgoingMessages size = 0 ifTrue: [^ false].  "no more message to send"		socket sendDone ifFalse: [^ true].  "still sending last data"		outBuf _ outgoingMessages removeFirst.		outBuf class isBytes ifFalse: [^ self sendStreamData].		outIndex _ 1.		szBuf _ ((WriteStream on: ByteArray new) uint32: outBuf size) contents.		n _ socket sendDataNoWait: szBuf startIndex: 1.		n > 0 ifTrue: [lastActivityTime _ Time totalSeconds].		n < 4 ifTrue: [  "unlikely case: socket did not accept entire 4-byte size"			"prepend leftover bytes to outBuf"			outBuf _ (szBuf copyFrom: n + 1 to: 4), outBuf].		outBuf size = 0 ifTrue: [outBuf _ nil]].	outBuf ifNotNil: [  "currently sending outBuf"		outBuf class isBytes ifFalse: [^ self sendStreamData].		n _ socket sendDataNoWait: outBuf startIndex: outIndex.		n > 0 ifTrue: [			lastActivityTime _ Time totalSeconds.			outIndex _ outIndex + n.			outIndex > outBuf size ifTrue: [				"finished sending the current message"				outBuf _ nil]]].	^ true! !!MessageSocket methodsFor: 'sending' stamp: 'jm 7/28/2001 20:06'!sendMessage: aByteArray	"Add this message to the list of messages to be sent."	outgoingMessages addLast: aByteArray.! !!MessageSocket methodsFor: 'sending' stamp: 'jm 4/23/2003 10:18'!sendStreamData	"Private!! Used by sendData only when outBuf is a positionable stream. Send some data from outBuf, if possible. Set outBuf to nil when the entire stream has been sent. Always answer true. "	| tempBuf n |	tempBuf _ outBuf next: 10000.  "read up to 10000 bytes from the stream"	outBuf skip: tempBuf size negated.	n _ socket sendDataNoWait: tempBuf startIndex: 1.	n > 0 ifTrue: [		lastActivityTime _ Time totalSeconds.		outBuf skip: n.		outBuf atEnd ifTrue: [outBuf _ nil]]. "finished sending outbuf"	^ true! !!MessageSocket methodsFor: 'receiving' stamp: 'jm 6/27/2002 12:21'!nextMessage	"Processing any data available on my socket and answer the next complete message, if any. Answer nil if the current messsage is not yet complete or if the socket is not connected."	"Details: If msgBuf is nil, then we are in the process of reading the four-byte size field. Otherwise, we are in the process of reading the current message into msgBuf."	| n sz msg |	(socket notNil and: [socket isConnected]) ifFalse: [^ nil].	inBuf ifNil: [		n _ socket readInto: inSizeBuf startingAt: inSizeIndex.		n > 0 ifTrue: [lastActivityTime _ Time totalSeconds].		inSizeIndex _ inSizeIndex + n.		inSizeIndex > 4 ifTrue: [  "received message size; allocate the message buffer"			sz _ (ReadStream on: inSizeBuf) uint32.			sz > 1000000 ifTrue: [  "msg size over a megabyte; check available space"				sz > (Smalltalk garbageCollect - 1000000) ifTrue: [					self error: 'message too big; bad size field?']].			inBuf _ ByteArray new: sz.			inIndex _ 1]].	inBuf ifNotNil: [		n _ socket readInto: inBuf startingAt: inIndex.		n > 0 ifTrue: [lastActivityTime _ Time totalSeconds].		inIndex _ inIndex + n.		inIndex > inBuf size ifTrue: [  "received complete message; reset and answer it"			msg _ inBuf.			inBuf _ nil.			inSizeIndex _ 1.  "ready to read size field of the next message"			^ msg]].	^ nil! !!MessageSocket methodsFor: 'receiving' stamp: 'jm 8/1/2001 07:25'!receiveProgress	"Answer a Float between 0.0 and 1.0 indicating the amount of progress towards receiving the current message."	inBuf ifNil: [^ 0.0].  "haven't even received the message size yet"	^ inIndex asFloat / inBuf size! !!MessageSocket methodsFor: 'receiving' stamp: 'jm 7/30/2001 22:08'!waitForData	"Wait a little while for data to arrive. Return when data arrives or when the deadline time is reached, whichever comes first. Calling this allows other threads to run while this thread is waiting for data."	^ socket waitForDataUntil: (Socket deadlineSecs: 1)! !!MessageSocket methodsFor: 'connection' stamp: 'jm 9/6/2001 17:50'!connectTo: serverAddress port: serverPortNumber	"Attempt to open a connection to the give port of the given host. Does not wait until the connection is established. Destroys previous socket, if any."	Socket initializeNetwork.	socket ifNotNil: [socket destroy].	socket _ Socket newTCP.	socket connectTo: serverAddress port: serverPortNumber.! !!MessageSocket methodsFor: 'connection' stamp: 'jm 9/6/2001 17:51'!connectTo: serverAddress port: serverPortNumber waitSecs: waitSecs	"Attempt to open a connection to the given port of the given host and wait for up to waitSecs for the connection to be established. Answer true if the connection is established. Destroys previous socket, if any."	self connectTo: serverAddress port: serverPortNumber.	socket waitForConnectionUntil: (Socket deadlineSecs: waitSecs).	socket isConnected ifFalse: [  "connection attempt failed or timed out"		socket destroy.		socket _ nil].	^ socket notNil! !!MessageSocket methodsFor: 'connection' stamp: 'jm 8/20/2001 22:38'!destroy	"Destroy my socket, breaking the connection. Do nothing if it the socket is nil."	socket ifNotNil: [		socket destroy.		socket _ nil].! !!MessageSocket methodsFor: 'connection' stamp: 'jm 7/29/2001 09:32'!isConnected	"Answer true if my socket is connected."	^ socket notNil and: [socket isConnected]! !!MessageSocket methodsFor: 'connection' stamp: 'jm 8/20/2001 21:55'!secondsSinceLastActivity	"Answer the time, in seconds, since data was last sent or received on this socket."	^ Time totalSeconds - lastActivityTime! !!MessageSocket methodsFor: 'connection' stamp: 'jm 7/28/2001 20:05'!socket	"Answer my socket."	^ socket! !!MessageSocket methodsFor: 'requests' stamp: 'jm 8/20/2001 22:07'!request: aByteArrayOrString	"Send the given message to the server and answer its reply message. Answer nil if the connection is broken before the transaction is complete. Wait indefinitely for the reply as long as the connection is unbroken."	| reply sending |	self sendMessage: aByteArrayOrString.	[self isConnected] whileTrue: [		sending _ self sendData.		reply _ self nextMessage.		reply ifNotNil: [^ reply].		sending ifFalse: [socket waitForDataUntil: (Socket deadlineSecs: 1)]].	"connection was broken"	self destroy.  "close my end"	^ nil! !!MessageSocket methodsFor: 'requests' stamp: 'jm 8/20/2001 22:07'!request: aByteArrayOrString timeoutSecs: timeoutSecs	"Send the given message to the server and answer its reply message. Answer nil if the connection is broken or timeoutSecs pass with no activity."	| sending reply |	self sendMessage: aByteArrayOrString.	[self isConnected and:	 [self secondsSinceLastActivity < timeoutSecs]] whileTrue: [		sending _ self sendData.		reply _ self nextMessage.		reply ifNotNil: [^ reply].		sending ifFalse: [socket waitForDataUntil: (Socket deadlineSecs: 1)]].	^ nil  "timeout or broken connection"! !!MessageSocket methodsFor: 'requests' stamp: 'jm 4/23/2003 18:44'!request: aByteArrayOrString withStream: aPositionableStream	"Send the given message to the server followed by the bytes from the given stream and answer its reply message. Answer nil if the connection is broken before the transaction is complete. Wait indefinitely for the reply as long as the connection is unbroken."	| reply sending |	self sendMessage: aByteArrayOrString.	self sendMessage: aPositionableStream.	[self isConnected] whileTrue: [		sending _ self sendData.		reply _ self nextMessage.		reply ifNotNil: [^ reply].		sending ifFalse: [socket waitForDataUntil: (Socket deadlineSecs: 1)]].	"connection was broken"	self destroy.  "close my end"	^ nil! !My instances observe and report the amount of time spent in methods. Observing a method implies observing all messages it sends.Q: How do you interpret MessageTally>>tallySendsA: The methods #tallySends and #spyOn: measure two very different quantities, but broken down in the same who-called-who format.  #spyOn: is approximate, but more indicative of real time spent, whereas #tallySends is exact and a precise record of how many times each method got executed.!!MessageTally methodsFor: 'initialize-release' stamp: 'stp 05/07/1999 15:31'!spyEvery: millisecs on: aBlock 	"Create a spy and spy on the given block at the specified rate."	| myDelay value startTime time0 |	(aBlock isMemberOf: BlockContext)		ifFalse: [self error: 'spy needs a block here'].	self class: aBlock receiver class method: aBlock method.		"set up the probe"	ObservedProcess _ Processor activeProcess.	myDelay := Delay forMilliseconds: millisecs.	time0 := Time millisecondClockValue.	Timer :=		[[true] whileTrue: 			[startTime := Time millisecondClockValue.			myDelay wait.			self tally: ObservedProcess suspendedContext				"tally can be > 1 if ran a long primitive"				by: (Time millisecondClockValue - startTime) // millisecs].		nil] newProcess.	Timer priority: Processor userInterruptPriority.		"activate the probe and evaluate the block"	Timer resume.	value := aBlock value.		"cancel the probe and return the value"	Timer terminate.	time := Time millisecondClockValue - time0.	^value! !!MessageTally methodsFor: 'reporting' stamp: 'stp 05/07/1999 14:38'!report: strm cutoff: threshold 	tally = 0		ifTrue: [strm nextPutAll: ' - no tallies obtained']		ifFalse: 			[strm nextPutAll: ' - '; print: tally; nextPutAll: ' tallies, ', time printString, ' msec.'; cr; cr.			self fullPrintOn: strm tallyExact: false orThreshold: threshold]! !!MessageTally methodsFor: 'reporting' stamp: 'stp 05/08/1999 12:06'!tally	"Answer the receiver's number of tally."	^tally! !!MessageTally methodsFor: 'reporting' stamp: 'stp 05/08/1999 11:47'!time	"Answer the receiver's run time."	^time! !!MessageTally methodsFor: 'printing' stamp: 'dew 3/15/2000 21:49'!fullPrintOn: aStream tallyExact: isExact orThreshold: perCent	| threshold |  	isExact ifFalse: [threshold _ (perCent asFloat / 100 * tally) rounded].	aStream nextPutAll: '**Tree**'; cr.	self treePrintOn: aStream		tabs: OrderedCollection new		thisTab: ''		total: tally		totalTime: time		tallyExact: isExact		orThreshold: threshold.	aStream nextPut: Character newPage; cr.	aStream nextPutAll: '**Leaves**'; cr.	self leavesPrintOn: aStream		tallyExact: isExact		orThreshold: threshold! !!MessageTally methodsFor: 'printing' stamp: 'dew 3/22/2000 02:28'!leavesPrintOn: aStream tallyExact: isExact orThreshold: threshold	| dict |	dict _ IdentityDictionary new: 100.	self leavesInto: dict fromSender: nil.	isExact ifTrue: 		[dict asSortedCollection			do: [:node |				node printOn: aStream total: tally totalTime: nil tallyExact: isExact.				node printSenderCountsOn: aStream]]		ifFalse:		[(dict asOrderedCollection				select: [:node | node tally > threshold])			asSortedCollection			do: [:node |				node printOn: aStream total: tally totalTime: time tallyExact: isExact]]! !!MessageTally methodsFor: 'printing' stamp: 'ls 10/10/1999 11:56'!printOn: aStream	| aSelector className aClass |	aSelector _ class selectorAtMethod: method setClass: [:c | aClass _ c].	className _ aClass name contractTo: 30.	aStream nextPutAll: className; nextPutAll: ' >> ';			nextPutAll: (aSelector contractTo: 60-className size)! !!MessageTally methodsFor: 'printing' stamp: 'dew 3/15/2000 21:56'!printOn: aStream total: total totalTime: totalTime tallyExact: isExact	| aSelector className myTally aClass percentage |	isExact		ifTrue:			[myTally _ tally.			receivers == nil				ifFalse: [receivers do: [:r | myTally _ myTally - r tally]].			aStream print: myTally; space]		ifFalse:			[percentage _ tally asFloat / total * 100.0 roundTo: 0.1.			aStream				print: percentage;				nextPutAll: '% {';				print: (percentage * totalTime / 100) rounded;				nextPutAll: 'ms} '].	receivers == nil		ifTrue: [aStream nextPutAll: 'primitives'; cr]		ifFalse: 			[aSelector _ class selectorAtMethod: method setClass: [:c | aClass _c].			className _ aClass name contractTo: 30.			aStream nextPutAll: class name;				nextPutAll: (aClass = class ifTrue: ['>>']								ifFalse: ['(' , aClass name , ')>>']);				nextPutAll: (aSelector contractTo: 60-className size); cr]! !!MessageTally methodsFor: 'printing' stamp: 'dew 3/22/2000 02:28'!printSenderCountsOn: aStream	| mergedSenders mergedNode |	mergedSenders _ IdentityDictionary new.	senders do:		[:node |		mergedNode _ mergedSenders at: node method ifAbsent: [nil].		mergedNode == nil			ifTrue: [mergedSenders at: node method put: node]			ifFalse: [mergedNode bump: node tally]].	mergedSenders asSortedCollection do:		[:node | 		10 to: node tally printString size by: -1 do: [:i | aStream space].		node printOn: aStream total: tally totalTime: nil tallyExact: true]! !!MessageTally methodsFor: 'printing' stamp: 'dew 3/15/2000 21:51'!treePrintOn: aStream tabs: tabs thisTab: myTab	total: total totalTime: totalTime tallyExact: isExact orThreshold: threshold	| sons sonTab |	tabs do: [:tab | aStream nextPutAll: tab].	tabs size > 0 ifTrue: [self printOn: aStream total: total totalTime: totalTime tallyExact: isExact].	sons _ isExact		ifTrue: [receivers]		ifFalse: [self sonsOver: threshold].	sons isEmpty ifFalse:		[tabs addLast: myTab.		sons _ sons asSortedCollection.		(1 to: sons size) do: 			[:i |			sonTab _ i < sons size ifTrue: ['  |'] ifFalse: ['  '].			(sons at: i) treePrintOn: aStream				tabs: (tabs size < 18					ifTrue: [tabs]					ifFalse: [(tabs select: [:x | x = '[']) copyWith: '['])				thisTab: sonTab total: total totalTime: totalTime				tallyExact: isExact orThreshold: threshold].		tabs removeLast]! !My instances add instance-specific behavior to various class-describing objects in the system. This typically includes messages for initializing class variables and instance creation messages particular to a class. There is only one instance of a particular Metaclass, namely the class which is being described. A Metaclass shares the class variables of its instance.	[Subtle] In general, the superclass hierarchy for metaclasses parallels that for classes. Thus,	Integer superclass == Number, and	Integer class superclass == Number class.However there is a singularity at Object. Here the class hierarchy terminates, but the metaclass hierarchy must wrap around to Class, since ALL metaclasses are subclasses of Class. Thus,	Object superclass == nil, and	Object class superclass == Class.[Subtle detail] A class is know by name to an environment.  Typically this is the SystemDictionary named Smalltalk.  If we ever make lightweight classes that are not in Smalltalk, they must be in some environment.  Specifically, the code that sets 'wasPresent' in name:inEnvironment:subclassOf:instanceVariableNames:variable:words:pointers:classVariableNames:poolDictionaries:category:comment:changed: must continue to work.!!Metaclass methodsFor: 'initialize-release' stamp: 'ar 7/13/1999 04:52'!adoptInstance: oldInstance from: oldMetaClass 	"Recreate any existing instances of the argument, oldClass, as instances of 	the receiver, which is a newly changed class. Permute variables as 	necessary."	thisClass class == self ifTrue:[^self error:'Metaclasses have only one instance'].	oldMetaClass isMeta ifFalse:[^self error:'Argument must be Metaclass'].	oldInstance class == oldMetaClass ifFalse:[^self error:'Not the class of argument'].	^thisClass _ self 		newInstanceFrom: oldInstance 		variable: self isVariable 		size: self instSize 		map: (self instVarMappingFrom: oldMetaClass)! !!Metaclass methodsFor: 'initialize-release' stamp: 'ar 7/15/1999 18:56'!instanceVariableNames: instVarString 	"Declare additional named variables for my instance."	^(ClassBuilder new)		class: self		instanceVariableNames: instVarString! !!Metaclass methodsFor: 'initialize-release' stamp: 'jm 10/14/2002 18:34'!updateInstancesFrom: oldClass 	"Recreate any existing instances of the argument, oldClass, as instances of the receiver, which is a newly changed class. Permute variables as necessary."	| oldInstances |	oldInstances _ oldClass allInstances asArray.	self updateInstances: oldInstances from: oldClass isMeta: true.! !!Metaclass methodsFor: 'accessing' stamp: 'ar 7/11/1999 08:14'!allInstances	thisClass class == self ifTrue:[^Array with: thisClass].	^super allInstances! !!Metaclass methodsFor: 'accessing' stamp: 'ar 7/11/1999 05:19'!environment	^thisClass environment! !!Metaclass methodsFor: 'instance creation' stamp: 'ar 7/11/1999 10:07'!new	"The receiver can only have one instance. Create it or complain that	one already exists."	thisClass class ~~ self		ifTrue: [^thisClass _ super new]		ifFalse: [self error: 'A Metaclass should only have one instance!!']! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 7/11/1999 15:43'!addSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 7/11/1999 15:43'!removeSubclass: aClass	"Do nothing."! !!Metaclass methodsFor: 'class hierarchy' stamp: 'ar 7/14/1999 11:19'!subclasses	"Answer the receiver's subclasses."	thisClass == nil ifTrue:[^#()].	^thisClass subclasses 		select:[:aSubclass| aSubclass isMeta not] 		thenCollect:[:aSubclass| aSubclass class]	"Metaclass allInstancesDo:		[:m | Compiler evaluate: 'subclasses_nil' for: m logged: false]"! !!Metaclass methodsFor: 'class hierarchy' stamp: 'jm 5/16/2003 09:48'!subclassesDo: aBlock	"Evaluate aBlock for each of the receiver's immediate subclasses. Skip metaclasses."	thisClass subclassesDo: [:cl |		cl isMeta ifFalse: [aBlock value: cl class]].! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'di 2/17/2000 22:33'!fileOutInitializerOn: aStream	(self methodDict includesKey: #initialize) ifTrue: 		[aStream cr.		aStream nextChunkPut: thisClass name , ' initialize'].! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'ar 12/22/1999 17:31'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex	^self fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex initializing: true! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'di 2/17/2000 22:33'!fileOutOn: aFileStream moveSource: moveSource toFile: fileIndex initializing: aBool	super fileOutOn: aFileStream		moveSource: moveSource		toFile: fileIndex.	(aBool and:[moveSource not and: [self methodDict includesKey: #initialize]]) ifTrue: 		[aFileStream cr.		aFileStream cr.		aFileStream nextChunkPut: thisClass name , ' initialize'.		aFileStream cr]! !!Metaclass methodsFor: 'fileIn/Out' stamp: 'di 2/17/2000 22:33'!nonTrivial 	"Answer whether the receiver has any methods or instance variables."	^ self instVarNames size > 0 or: [self methodDict size > 0]! !!Metaclass methodsFor: 'testing' stamp: 'ar 9/10/1999 17:41'!canZapMethodDictionary	"Return true if it is safe to zap the method dictionary on #obsolete"	thisClass == nil		ifTrue:[^true]		ifFalse:[^thisClass canZapMethodDictionary]! !!Metaclass methodsFor: 'testing' stamp: 'ar 7/11/1999 07:27'!isObsolete	"Return true if the receiver is obsolete"	^thisClass == nil "Either no thisClass"		or:[thisClass class ~~ self "or I am not the class of thisClass"			or:[thisClass isObsolete]] "or my instance is obsolete"! !!Metaclass methodsFor: 'enumerating' stamp: 'ar 7/15/1999 16:43'!allInstancesDo: aBlock	"There should be only one"	thisClass class == self ifTrue:[^aBlock value: thisClass].	^super allInstancesDo: aBlock! !!Metaclass class methodsFor: 'anti-corruption' stamp: 'di 11/24/1999 13:30'!isScarySelector: newbieSelector	"Return true if newbieSelector is already a part of Metaclass protocol."	(Metaclass includesSelector: newbieSelector) ifTrue: [^ true].	(ClassDescription includesSelector: newbieSelector) ifTrue: [^ true].	(Behavior includesSelector: newbieSelector) ifTrue: [^ true].	^ false! !I represent a block for invoking a user-defined script. I'm like any other command block but I also have a reference to the HatBlockMorph for the script I'll be invoking. I also have an action parameter, which may be #call, #start, #stop, or #test. The last action makes me a reporter that says if the given script has a running process or not.!!MethodCallBlockMorph methodsFor: 'initialization' stamp: 'jm 9/24/2003 19:19'!initialize	super initialize.	self isReporter: true.	action _ #call.! !!MethodCallBlockMorph methodsFor: 'accessing' stamp: 'jm 9/24/2003 19:19'!action	^ action! !!MethodCallBlockMorph methodsFor: 'accessing' stamp: 'jm 7/21/2003 02:12'!script	^ script! !!MethodCallBlockMorph methodsFor: 'accessing' stamp: 'jm 7/21/2003 02:13'!script: aHatBlockMorph	"Set the HatBlockMorph for the script that I call."	script _ aHatBlockMorph.	self commandSpec: script scriptName.! !!MethodCallBlockMorph methodsFor: 'stepping' stamp: 'DaveF 7/24/2003 13:30'!step	"Check if that name of the called script name has changed and update myself if it has."	super step.	self updateSpec.! !!MethodCallBlockMorph methodsFor: 'menu' stamp: 'jm 12/1/2003 16:19'!rightButtonMenu	| menu choice n |	menu _ CustomMenu new.	n _ script scriptName.	menu add: n action: #call.	menu add: 'start ', n action: #start.	menu add: 'stop ', n action: #stop.	menu add: n, ' is running' action: #test.	menu addLine.	menu add: 'copy' action: #duplicate.	menu add: 'delete' action: #delete.	(choice _ menu startUp) ifNil: [^ self].	(#(call start stop test) includes: choice) ifTrue: [		action _ choice.		^ self updateSpec].	self perform: choice.! !!MethodCallBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:18'!fieldsVersion	^ 1! !!MethodCallBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:21'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		script		action	) from: anObjStream.! !!MethodCallBlockMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:22'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		script		action	) on: anObjStream.! !!MethodCallBlockMorph methodsFor: 'private' stamp: 'DaveF 7/24/2003 12:05'!updateSpec	"Modifies the block to show labels, args, etc. in this format, by calling ommandSpec:.  Also inserts action into the spec."	| spec |	spec _ script commandSpec.	action = #start ifTrue:	[spec _ 'start ', spec].	action = #stop ifTrue:	[spec _ 'stop ', spec].	action = #test ifTrue:	[spec _ spec, ' is running'].	self commandSpec: spec.! !MethodChangeRecords are used to record method changes.  Here is a simple summary of the relationship between the changeType symbol and the recording of prior state			|	prior == nil			|	prior not nil		---------	|----------------------------	|--------------------	add		|	add					|	change	---------	|----------------------------	|--------------------	remove	|	addedThenRemoved	|	removeStructure:changeType			symbol -- as summarized abovecurrentMethod	method				This is the current version of the method.				It can be used to assert this change upon entry to a layer. infoFromRemoval -- an array of size 2.				The first element is the source index of the last version of the method.				The second element is the category in which it was defined, so it				can be put back there if re-accepted from a version browser.Note that the above states each have an associated revoke action:	add --> remove	change --> change back	remove --> add back	addedThenRemoved --> no changeHowever all of these are accomplished trivially by restoring the original method dictionary.!!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 12:02'!changeType	^ changeType! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 3/28/2000 23:34'!currentMethod	^ currentMethod! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 12:02'!methodInfoFromRemoval	"Return an array with the source index of the last version of the method,	and the category in which it was defined (so it can be put back there if	re-accepted from a version browser)."	(changeType == #remove or: [changeType == #addedThenRemoved])		ifTrue: [^ infoFromRemoval]		ifFalse: [^ nil]! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/4/2000 11:05'!noteChangeType: newChangeType	(changeType == #addedThenRemoved and: [newChangeType == #change])		ifTrue: [changeType _ #add]		ifFalse: [changeType _ newChangeType]! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 11:05'!noteMethodInfoFromRemoval: info	"Store an array with the source index of the last version of the method,	and the category in which it was defined (so it can be put back there if	re-accepted from a version browser)."	infoFromRemoval _ info! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 3/28/2000 23:32'!noteNewMethod: newMethod	currentMethod _ newMethod! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 12:02'!printOn: strm	super printOn: strm.	strm nextPutAll: ' ('; print: changeType; nextPutAll: ')'! !!MethodChangeRecord methodsFor: 'as yet unclassified' stamp: 'di 4/1/2000 10:47'!priorMethod: ignored	"We do not save original versions of changed methods because we only	revoke changes at the level of entire classes, and that is done by	restoration of the entire methodDictionary."! !My instances hold all the dynamic state associated with the execution of a CompiledMethod. In addition to their inherited state, this includes the receiver, a method, and temporary space in the variable part of the context.	MethodContexts, though normal in their variable size, are actually only used in two sizes, small and large, which are determined by the temporary space required by the method being executed.MethodContexts must only be created using the method newForMethod:.  Note that it is impossible to determine the real object size of a MethodContext except by asking for the frameSize of its method.  Any fields above the stack pointer (stackp) are truly invisible -- even (and especially!!) to the garbage collector.  Any store into stackp other than by the primitive method stackp: is potentially fatal.!!MethodContext methodsFor: 'initialize-release' stamp: 'di 1/11/1999 10:24'!restart	"Reinitialize the receiver so that it is in the state it was at its creation."	pc _ method initialPC.	self stackp: method numTemps! !!MethodContext methodsFor: 'private' stamp: 'di 1/14/1999 22:30'!instVarAt: index put: value	index = 3 ifTrue: [self stackp: value. ^ value].	^ super instVarAt: index put: value! !!MethodContext methodsFor: 'private' stamp: 'di 1/11/1999 10:23'!setSender: s receiver: r method: m arguments: args 	"Create the receiver's initial state."	sender _ s.	receiver _ r.	method _ m.	pc _ method initialPC.	self stackp: method numTemps.	1 to: args size do: [:i | self at: i put: (args at: i)]! !!MethodContext methodsFor: 'private-exceptions' stamp: 'tfei 6/7/1999 20:46'!cannotReturn: result	Debugger		openContext: thisContext		label: 'computation has been terminated'		contents: thisContext printString! !!MethodContext methodsFor: 'private-exceptions' stamp: 'tfei 3/23/1999 13:00'!receiver: r	receiver := r! !!MethodContext class methodsFor: 'instance creation' stamp: 'di 10/23/1999 17:06'!sender: s receiver: r method: m arguments: args 	"Answer an instance of me with attributes set to the arguments."	^(self newForMethod: m) setSender: s receiver: r method: m arguments: args! !I am just like a normal Dictionary, except that I am implemented differently.  Each Class has an instances of MethodDictionary to hold the correspondence between selectors (names of methods) and methods themselves.In a normal Dictionary, the instance variable 'array' holds an array of Associations.  Since there are thousands of methods in the system, these Associations waste space.  Each MethodDictionary is a variable object, with the list of keys (selector Symbols) in the variable part of the instance.  The variable 'array' holds the values, which are CompiledMethods.!!MethodDictionary methodsFor: 'accessing' stamp: 'ar 2/13/1999 21:17'!keyAtIdentityValue: value ifAbsent: exceptionBlock	"Answer the key whose value equals the argument, value. If there is	none, answer the result of evaluating exceptionBlock."	| theKey |	1 to: self basicSize do:		[:index |		value == (array at: index)			ifTrue:				[(theKey _ self basicAt: index) == nil					ifFalse: [^ theKey]]].	^ exceptionBlock value! !!MethodDictionary methodsFor: 'accessing' stamp: 'ar 2/13/1999 21:00'!keyAtValue: value ifAbsent: exceptionBlock	"Answer the key whose value equals the argument, value. If there is	none, answer the result of evaluating exceptionBlock."	| theKey |	1 to: self basicSize do:		[:index |		value = (array at: index)			ifTrue:				[(theKey _ self basicAt: index) == nil					ifFalse: [^ theKey]]].	^ exceptionBlock value! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ar 7/11/1999 08:05'!keysAndValuesDo: aBlock 	"Enumerate the receiver with all the keys and values passed to the block"	| key |	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (key _ self basicAt: i) == nil ifFalse:			[aBlock value: key value: (array at: i)]		]! !!MethodDictionary methodsFor: 'enumeration' stamp: 'ar 7/11/1999 07:29'!valuesDo: aBlock 	| value |	tally = 0 ifTrue: [^ self].	1 to: self basicSize do:		[:i | (value _ array at: i) == nil			ifFalse: [aBlock value: value]]! !I am the root of the parse tree.!!MethodNode methodsFor: 'initialize-release' stamp: 'tk 8/3/1999 12:47'!block	^ block! !!MethodNode methodsFor: 'code generation' stamp: 'di 5/25/2000 06:48'!generate: trailer 	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	| blkSize nLits stack strm nArgs method |	self generate: trailer ifQuick: 		[:m |  method _ m.		method cacheTempNames: self tempNames.		^ method].	nArgs _ arguments size.	blkSize _ block sizeForEvaluatedValue: encoder.	literals _ encoder allLiterals.	(nLits _ literals size) > 255		ifTrue: [^self error: 'Too many literals referenced'].	method _ CompiledMethod	"Dummy to allocate right size"				newBytes: blkSize				trailerBytes: trailer 				nArgs: nArgs				nTemps: encoder maxTemp				nStack: 0				nLits: nLits				primitive: primitive.	strm _ ReadWriteStream with: method.	strm position: method initialPC - 1.	stack _ ParseStack new init.	block emitForEvaluatedValue: stack on: strm.	stack position ~= 1 ifTrue: [^self error: 'Compiler stackdiscrepancy'].	strm position ~= (method size - trailer size) 		ifTrue: [^self error: 'Compiler code size discrepancy'].	method needsFrameSize: stack size.	1 to: nLits do: [:lit | method literalAt: lit put: (literals at: lit)].	method cacheTempNames: self tempNames.	^ method! !!MethodNode methodsFor: 'code generation' stamp: 'di 5/25/2000 06:45'!generate: trailer ifQuick: methodBlock	| v |	(primitive = 0 and: [arguments size = 0 and: [block isQuick]])		ifFalse: [^ self].	v _ block code.	v < 0		ifTrue: [^ self].	v = LdSelf		ifTrue: [^ methodBlock value: (CompiledMethod toReturnSelfTrailerBytes: trailer)].	(v between: LdTrue and: LdMinus1 + 3)		ifTrue: [^ methodBlock value: (CompiledMethod toReturnConstant: v - LdSelf trailerBytes: trailer)].	v < ((CodeBases at: LdInstType) + (CodeLimits at: LdInstType))		ifTrue: [^ methodBlock value: (CompiledMethod toReturnField: v trailerBytes: trailer)].	v // 256 = 1		ifTrue: [^ methodBlock value: (CompiledMethod toReturnField: v \\ 256 trailerBytes: trailer)]! !!MethodNode methodsFor: 'printing' stamp: 'sw 11/17/1999 13:57'!printOn: aStream 	| args |	precedence = 1		ifTrue: 			[aStream nextPutAll: self selector]		ifFalse: 			[args _ ReadStream on: arguments.			self selector keywords do: 				[:s | 				aStream nextPutAll: s; space.				aStream withAttributes: (Preferences syntaxAttributesFor: #methodArgument)					do: [aStream nextPutAll: args next key].				aStream space]].	comment == nil ifFalse: 			[aStream crtab: 1.			self printCommentOn: aStream indent: 1].	temporaries size > 0 ifTrue: 			[aStream crtab: 1.			aStream nextPutAll: '| '.			aStream withAttributes: (Preferences syntaxAttributesFor: #temporaryVariable)				do:					[temporaries do: 						[:temp | 						aStream nextPutAll: temp key.						aStream space]].			aStream nextPut: $|].	primitive > 0 ifTrue:			[(primitive between: 255 and: 519) ifFalse:  " Dont decompile <prim> for, eg, ^ self "				[aStream crtab: 1.				self printPrimitiveOn: aStream]].	aStream crtab: 1.	^ block printStatementsOn: aStream indent: 0! !!MethodNode methodsFor: 'printing' stamp: 'ar 11/28/1999 19:38'!printPrimitiveOn: aStream	"Print the primitive on aStream"	| primIndex primDecl |	primIndex _ primitive.	primIndex = 0 ifTrue:[^self].	primIndex = 120 "External call spec"		ifTrue:[^aStream print: encoder literals first].	aStream nextPutAll: '<primitive: '.	primIndex = 117 ifTrue:[		primDecl _ encoder literals at: 1.		aStream 			nextPut: $';			nextPutAll: (primDecl at: 2);			nextPut:$'.		(primDecl at: 1) notNil ifTrue:[			aStream 				nextPutAll:' module:';				nextPut:$';				nextPutAll: (primDecl at: 1);				nextPut:$'.		].	] ifFalse:[aStream print: primIndex].	aStream nextPut: $>.! !I can be used to time things like phone calls.Click to start/stop.Shift-click when stopped to reset to zero.!!MinuteMinderMorph methodsFor: 'as yet unclassified' stamp: 'jm 1/6/2003 21:59'!handlesMouseDown: evt	^ true! !!MinuteMinderMorph methodsFor: 'as yet unclassified' stamp: 'jm 1/6/2003 22:19'!initialize	super initialize.	self font: (StrikeFont familyName: 'ComicBold' size: 24) emphasis: 0.	isRunning _ false.	initialSecs _ startSecs _ 0.	self updateDisplay.! !!MinuteMinderMorph methodsFor: 'as yet unclassified' stamp: 'jm 1/6/2003 22:12'!mouseDown: evt	"Toggle the running state. If not currently running, a shift-click will reset to zero."	isRunning ifTrue: [  "stop running"		initialSecs _ initialSecs + (Time totalSeconds - startSecs).		isRunning _ false.		^ self updateDisplay].	evt shiftPressed ifTrue: [  "reset to zero"		(self confirm: 'Reset to zero?') ifTrue: [initialSecs _ 0].		^ self updateDisplay].	"start running"	startSecs _ Time totalSeconds.	isRunning _ true.! !!MinuteMinderMorph methodsFor: 'as yet unclassified' stamp: 'jm 1/6/2003 22:11'!step	isRunning ifTrue: [self updateDisplay].! !!MinuteMinderMorph methodsFor: 'as yet unclassified' stamp: 'jm 1/6/2003 22:13'!updateDisplay	| totalSecs minutes secs delimiter |	isRunning		ifTrue: [totalSecs _ initialSecs + (Time totalSeconds - startSecs)]		ifFalse: [totalSecs _ initialSecs].	minutes _ totalSecs // 60.	secs _ totalSecs \\ 60.	secs < 10 ifTrue: [delimiter _ ':0'] ifFalse: [delimiter _ ':'].	self contents: minutes printString, delimiter, secs printString.! !!MinuteMinderMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:01'!includeInNewMorphMenu	^ true! !!MixedSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:05'!duration	"Answer the duration of this sound in seconds."	| dur |	dur _ 0.	sounds do: [:snd | dur _ dur max: snd duration].	^ dur! !!MixedSound methodsFor: 'accessing' stamp: 'jm 7/20/2003 22:21'!isEmpty	^ sounds size = 0! !!MixedSound methodsFor: 'accessing' stamp: 'jm 12/16/2001 20:23'!isStereo	^ true! !!MixedSound methodsFor: 'accessing' stamp: 'jm 8/23/2003 15:59'!setPan: leftRightPan volume: volume for: index	"Set the pan left-right pan and volume for the sound with the given index, where 0.0 is full left, 1.0 is full right, and 0.5 is centered. Volume ranges from 0 to 1.0."	| pan vol |	(index < 1 or: [index > leftVols size]) ifTrue: [^ self].	pan _ ((leftRightPan * ScaleFactor) asInteger max: 0) min: ScaleFactor.	vol _ ((volume * ScaleFactor) asInteger max: 0) min: ScaleFactor.	leftVols at: index put: ((ScaleFactor - pan) * vol) // ScaleFactor.	rightVols  at: index put: (pan * vol) // ScaleFactor.! !!MixedSound methodsFor: 'sound generation' stamp: 'jm 1/10/1999 08:45'!stopGracefully	"End this note with a graceful decay. If the note has envelopes, determine the decay time from its envelopes."	super stopGracefully.	sounds do: [:s | s stopGracefully].! !Provides a superclass for classes that function as models.  The only behavior provided is fast dependents maintentance, which bypasses the generic DependentsFields mechanism.  1/23/96 sw!!Model methodsFor: 'dependents' stamp: 'sma 2/29/2000 19:26'!canDiscardEdits	"Answer true if none of the views on this model has unaccepted edits that matter."	dependents ifNil: [^ true].	^ super canDiscardEdits! !!Model methodsFor: 'dependents' stamp: 'sma 2/29/2000 19:54'!myDependents	^ dependents! !!Model methodsFor: 'dependents' stamp: 'sma 2/29/2000 19:54'!myDependents: aCollectionOrNil	dependents _ aCollectionOrNil! !!Model methodsFor: 'dependents' stamp: 'jm 10/19/2002 09:05'!topView	"Find the first top view on me. Is there any danger of their being two with the same model?  Any danger from ungarbage collected old views?  Ask if schedulled?"	dependents ifNil: [^ nil].	Smalltalk isMorphic ifTrue: [		dependents do: [:v |			((v isKindOf: SystemWindow) and: [v isInWorld]) ifTrue: [^ v].			((v owner isKindOf: SystemWindow) and: [v owner isInWorld]) ifTrue: [^ v owner]].		^ nil].	dependents do: [:v | v superView ifNil: [v model == self ifTrue: [^ v]]].	^ nil! !!Month methodsFor: 'converting' stamp: 'LC 7/26/1998 12:49'!asDate	^ Date		newDay: 1		month: self name		year: self year! !!Month methodsFor: 'converting' stamp: 'LC 7/26/1998 12:53'!next	^ self class fromDate: (self addDays: self duration)! !!Month methodsFor: 'converting' stamp: 'LC 7/26/1998 02:43'!previous	^ self class fromDate: (self subtractDays: 1)! !!Month methodsFor: 'inquiries' stamp: 'LC 7/27/1998 04:38'!duration	^ self daysInMonth! !!Month methodsFor: 'inquiries' stamp: 'LC 7/26/1998 02:53'!firstDate	^ self asDate! !!Month methodsFor: 'inquiries' stamp: 'LC 7/26/1998 12:51'!index	^ self monthIndex! !!Month methodsFor: 'inquiries' stamp: 'LC 7/26/1998 12:52'!lastDate	^ self firstDate addDays: self duration - 1! !!Month methodsFor: 'inquiries' stamp: 'LC 7/26/1998 12:50'!name	^ self monthName! !!Month methodsFor: 'enumerationg' stamp: 'LC 7/27/1998 04:36'!eachWeekDo: aBlock	| week |	week _ self firstDate week.	[week firstDate <= self lastDate]		whileTrue:			[aBlock value: week.			week _ week next]! !!Month methodsFor: 'printing' stamp: 'LC 7/26/1998 02:24'!printOn: aStream	aStream nextPutAll: self monthName, ' ', self year printString! !!Month class methodsFor: 'instance creation' stamp: 'LC 7/26/1998 12:47'!fromDate: aDate	^ self		newDay: 1		month: aDate monthName		year: aDate year! !!Month class methodsFor: 'instance creation' stamp: 'LC 7/26/1998 12:48'!readFrom: aStream	| m y c |	m _ (ReadWriteStream with: '') reset.	[(c _ aStream next) isSeparator] whileFalse: [m nextPut: c].	[(c _ aStream next) isSeparator] whileTrue.	y _ (ReadWriteStream with: '') reset.		y nextPut: c.	[aStream atEnd] whileFalse: [y nextPut: aStream next].	^ self fromDate: (Date newDay: 1 month: m contents asSymbol year: y contents asNumber)	"	Month readFrom: (ReadWriteStream with: 'July 1998') reset	"! !A morph (from the Greek "shape" or "form") is an interactive graphical object.The 'bounds' of a morph is a rectangle that just encloses its visual representation on the screen. A morph's drawOn: method should not write pixels outside of the bounds rectangle. This rectangle is used both to keep track of screen areas that need to be repainted and as the first approximation for mouse-click hit detection.Simple morphs can be combined to create a compound morph. In such a structure, one morph forms the root of the hierarchy, each morph has a list of zero or morph submorphs, and each morph knows which morph has it as a submorph (i.e., its 'owner').All coordinates are in global screen coordinates. (Except in the case of morphs within a TransformMorph, but TransformMorph's are being phased out.)Morphs have a set of flags (such as 'hidden') and an optional list of properties.!!Morph methodsFor: 'initialization' stamp: 'jm 10/14/2002 08:40'!initialize	bounds _ 0@0 corner: 50@40.	owner _ nil.	submorphs _ Array empty.	fullBounds _ nil.	color _ Color blue.	flags _ 0.	properties _ nil.! !!Morph methodsFor: 'initialization' stamp: 'jm 7/5/1998 12:40'!openInMVC	MorphWorldView		openWorldWith: self		labelled: self defaultLabelForInspector.! !!Morph methodsFor: 'initialization' stamp: 'djp 10/24/1999 17:13'!openInWindowLabeled: aString inWorld: aWorld	| window extent |	window _ (SystemWindow labelled: aString) model: nil.	window 		" guess at initial extent"		bounds:  (RealEstateAgent initialFrameFor: window initialExtent: self fullBounds extent);		addMorph: self frame: (0@0 extent: 1@1);		updatePaneColors.	" calculate extent after adding in case any size related attributes were changed.  Use	fullBounds in order to trigger re-layout of layout morphs"	extent _ self fullBounds extent + 			(window borderWidth@window labelHeight) + window borderWidth.	window extent: extent.	aWorld addMorph: window.	window activate.	aWorld startSteppingSubmorphsOf: window.	^window! !!Morph methodsFor: 'initialization' stamp: 'sma 4/30/2000 10:43'!openInWorld	"Add this morph to the world.  If in MVC, then provide a Morphic window for it."	Smalltalk isMorphic		ifTrue: [self openInWorld: self currentWorld]		ifFalse: [self openInMVC]! !!Morph methodsFor: 'initialization' stamp: 'bf 1/5/2000 19:57'!openInWorld: aWorld	"Add this morph to the requested World."	(aWorld viewBox origin ~= (0@0) and: [self position = (0@0)]) ifTrue:		[self position: aWorld viewBox origin].	aWorld addMorph: self.	aWorld startSteppingSubmorphsOf: self! !!Morph methodsFor: 'classification' stamp: 'jm 10/14/2002 09:14'!isColorable	"Answer true if my color can be changed using the color: message. Subclasses whose color cannot be changes this way (e.g., those based on a Form) should override this to return false."	^ true! !!Morph methodsFor: 'classification' stamp: 'jm 12/9/2003 18:05'!isPaintable	"Answer true if my image can be repainted."	^ false! !!Morph methodsFor: 'accessing' stamp: 'jm 8/11/2003 21:09'!balloonHelpTextFor: aSelector	#(	(chooseEmphasisOrAlignment				'Emphasis & alignment')		(chooseFont								'Change font')		(chooseStyle								'Change style')		(dismiss									'Remove')		(doDebug:with:							'Debug')		(doDirection:with:						'Choose forward direction')		(doDup:with:							'Duplicate')		(doMenu:with:							'Menu')		(doGrab:with:							'Pick up')		(doRecolor:with:							'Change color')		(editDrawing							'Repaint')		(maybeDoDup:with:						'Duplicate')		(mouseDownInDimissHandle:with:			'Delete')		(mouseDownInCollapseHandle:with:		'Collapse morph')		(mouseDownOnHelpHandle:				'Help')		(prepareToTrackCenterOfRotation:with:	'Set center of rotation')		(startDrag:with:							'Move')		(startGrow:with:							'Change size') 		(trackCenterOfRotation:with:				'Set center of rotation')	)  do: [:pair |		aSelector = pair first ifTrue: [^ pair last]].	^ aSelector asString  "this is best we can do; gives some information at least"! !!Morph methodsFor: 'accessing' stamp: 'jm 10/13/2002 20:09'!balloonText	"Answer balloon help text or nil, if no help is available."	^ self valueOfProperty: #balloonText! !!Morph methodsFor: 'accessing' stamp: 'di 1/3/1999 12:25'!hasTranslucentColor	"Answer true if this any of this morph is translucent but not transparent."	^ color isColor and: [color isTranslucentColor]! !!Morph methodsFor: 'accessing' stamp: 'sw 11/30/1998 12:44'!highlight	"The receiver is being asked to appear in a highlighted state.  Mostly used for textual morphs"	self color: self highlightColor! !!Morph methodsFor: 'accessing' stamp: 'sw 3/6/1999 02:09'!highlightColor		| val |	^ (val _ self valueOfProperty: #highlightColor)		ifNotNil:			[val ifNil: [self error: 'nil highlightColor']]		ifNil:			[owner ifNil: [self color] ifNotNil: [owner highlightColor]]! !!Morph methodsFor: 'accessing' stamp: 'sw 7/2/1998 13:51'!highlightColor: aColor	self setProperty: #highlightColor toValue: aColor! !!Morph methodsFor: 'accessing' stamp: 'sw 3/6/1999 02:09'!regularColor		| val |	^ (val _ self valueOfProperty: #regularColor)		ifNotNil:			[val ifNil: [self error: 'nil regularColor']]		ifNil:			[owner ifNil: [self color] ifNotNil: [owner regularColor]]! !!Morph methodsFor: 'accessing' stamp: 'sw 7/2/1998 13:51'!regularColor: aColor	self setProperty: #regularColor toValue: aColor! !!Morph methodsFor: 'accessing' stamp: 'sw 11/30/1998 12:44'!unHighlight	self color: self regularColor! !!Morph methodsFor: 'accessing' stamp: 'jm 10/14/2002 09:04'!unlockContents	self submorphsDo: [:m | m isLocked: false].! !!Morph methodsFor: 'access properties' stamp: 'jm 10/13/2002 21:06'!hasProperty: propName	"Return true if my properties list includes a property with the given name."	properties ifNil: [^ false].	^ (properties propertyForName: propName asSymbol) notNil! !!Morph methodsFor: 'access properties' stamp: 'jm 10/13/2002 21:06'!removeProperty: propName	"Remove the property with the given name from my properties list."	properties ifNil: [^ self].	properties _ properties copyWithoutName: propName asSymbol.! !!Morph methodsFor: 'access properties' stamp: 'jm 10/13/2002 21:07'!setProperty: propName toValue: anObject	| entry newEntry |	anObject ifNil: [^ self removeProperty: propName].	properties ifNil: [		properties _ MorphProperty new name: propName value: anObject.		^ self].	entry _ properties propertyForName: propName asSymbol.	entry		ifNil: [  "create and add a new entry at start of properties list"			newEntry _ MorphProperty new name: propName value: anObject.			newEntry nextLink: properties.			properties _ newEntry]		ifNotNil: [  "update the existing entry"			entry value: anObject].! !!Morph methodsFor: 'access properties' stamp: 'jm 10/13/2002 20:49'!valueOfProperty: propName	"Return the value of the property with the given name in my properties list, or nil if I have no property with that name."	^ self valueOfProperty: propName ifAbsent: [nil]! !!Morph methodsFor: 'access properties' stamp: 'jm 10/13/2002 21:07'!valueOfProperty: propName ifAbsent: aBlock	"Return the value of the property with the given name in my properties list, or the value of the given block if I have no property with that name."	| prop |	properties ifNil: [^ aBlock value].	prop _ properties propertyForName: propName asSymbol.	prop		ifNil: [^ aBlock value]		ifNotNil: [^ prop value].! !!Morph methodsFor: 'copying' stamp: 'jm 10/13/2002 21:23'!copyRecordingIn: dict	"Recursively copy this entire composite morph, recording the correspondence between old and new morphs in the given dictionary. This dictionary will be used to update intra-composite references in the copy. See updateReferencesUsing:.	Note: This default implementation copies ONLY morphs in the submorph hierarchy. If a subclass stores morphs in instance variables that it wants to copy, then it should override this method to do so. The same goes for subclasses that contain other data that should be copied when the morph is duplicated."	| new |	new _ self copy.	dict at: self put: new.	submorphs size > 0 ifTrue: [		new privateSubmorphs:			(submorphs collect: [:m |				(m copyRecordingIn: dict) privateOwner: new])].	properties ifNotNil: [new privateProperties: properties copyAll].	^ new! !!Morph methodsFor: 'copying' stamp: 'jm 10/13/2002 21:27'!copyWithoutSubmorphs	^ self clone		privateOwner: nil;		privateSubmorphs: Array empty;		privateBounds: (bounds origin corner: bounds corner)  "deep-copy bounds"! !!Morph methodsFor: 'copying' stamp: 'jm 10/7/2002 06:43'!deepCopy	^ self fullCopy! !!Morph methodsFor: 'copying' stamp: 'jm 10/13/2002 21:25'!fullCopy	"Produce a copy of me with my entire tree of submorphs. Morphs mentioned more than once are all directed to a single new copy. Simpleinst vars are not copied, so you must override to copy Arrays, Forms, editable text, etc."	| dict new |	dict _ IdentityDictionary new: 1000.	new _ self copyRecordingIn: dict.	new allMorphsDo: [:m | m updateReferencesUsing: dict].	^ new! !!Morph methodsFor: 'copying' stamp: 'jm 10/13/2002 21:01'!updateReferencesUsing: aDictionary	"Update intra-morph references within a composite morph that hasbeen copied. For example, if a button refers to morph X in the orginalcomposite then the copy of that button in the new composite should refer tothe copy of X in new composite, not the original X. This defaultimplementation updates the contents of any morph-bearing slot. It may beoverridden to avoid this behavior if so desired."	| old prop |	Morph instSize + 1 to: self class instSize do: [:i |		old _ self instVarAt: i.		old isMorph ifTrue:			[self instVarAt: i put: (aDictionary at: old ifAbsent: [old])]].	"map morph values in my properties list"	prop _ properties.	[prop == nil] whileFalse: [		old _ prop value.		old isMorph ifTrue: [			prop value: (aDictionary at: old ifAbsent: [old])].		prop _ prop nextLink].! !!Morph methodsFor: 'structure' stamp: 'LC 12/22/1998 12:41'!activeHand	^ (self world ifNil: [^ nil]) activeHand! !!Morph methodsFor: 'structure' stamp: 'sw 12/29/1999 12:27'!hasInOwnerChain: aMorph	"If aMorph is somewhere in the receiver's owner chain, respond true"	self eachStepInOwnerChainDo:		[:anOwner | anOwner == aMorph ifTrue: [^ true]].	^ false! !!Morph methodsFor: 'structure' stamp: 'di 6/7/1999 15:39'!primaryHand	^ self activeHand ifNil: [self world firstHand]! !!Morph methodsFor: 'structure' stamp: 'di 8/4/1999 15:41'!rootAt: location	"Just return myself, unless I am a WorldWindow.	If so, then return the appropriate root in that world"	^ self! !!Morph methodsFor: 'structure' stamp: 'di 6/7/1999 20:04'!world	^ owner == nil ifTrue: [nil] ifFalse: [owner world]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'jm 8/3/2003 14:07'!morphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point, possibly including the receiver itself. Must do this recursively because of transforms.  "	(self fullBounds containsPoint: aPoint) ifFalse: [^ mList].  "quick elimination"	submorphs size > 0 ifTrue: [		submorphs do: [:m | m morphsAt: aPoint addTo: mList]].	(self containsPoint: aPoint) ifTrue: [mList addLast: self].	^ mList! !!Morph methodsFor: 'submorphs-accessing' stamp: 'ar 11/8/1999 00:08'!rootMorphsAt: aPoint	"Return the list of root morphs containing the given point, excluding the receiver.	ar 11/8/1999: Moved into morph for an incredibly ugly hack in 3D worlds"	^ self submorphs select:		[:m | (m fullContainsPoint: aPoint) and: [m isLocked not]]! !!Morph methodsFor: 'submorphs-accessing' stamp: 'sw 12/22/1998 17:00'!submorphOfClass: aClass	^ self submorphs detect: [:p | p isKindOf: aClass] ifNone: [nil]! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'tk 12/15/1998 14:23'!abandon	"Like delete, but we really intend not to use this morph again.  Clean up a few things."	self delete! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'RAA 4/2/1999 16:56'!addAllMorphs: aCollection after: anotherMorph	| index |	index _ submorphs indexOf: anotherMorph ifAbsent: [submorphs size].	aCollection do: [:m |		m owner ifNotNil: [m owner privateRemoveMorph: m].		m layoutChanged.		m privateOwner: self].	submorphs _ (submorphs copyFrom: 1 to: index), aCollection,			(submorphs copyFrom: index+1 to: submorphs size).	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jm 5/29/1998 15:39'!addMorphFront: aMorph	| newSubmorphs |	aMorph owner ifNotNil: [aMorph owner privateRemoveMorph: aMorph].	aMorph layoutChanged.	aMorph privateOwner: self.	newSubmorphs _ submorphs species new: submorphs size + 1.	newSubmorphs at: 1 put: aMorph.	newSubmorphs		replaceFrom: 2		to: newSubmorphs size		with: submorphs		startingAt: 1.	submorphs _ newSubmorphs.	aMorph changed.	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'ar 11/15/1998 23:42'!addMorphFront: aMorph fromWorldPosition: wp	self addMorphFront: aMorph.	aMorph position: (self transformFromWorld globalPointToLocal: wp)! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jm 10/15/2002 17:20'!comeToFront	| myOwner |	myOwner _ self owner.	(myOwner == nil or: [myOwner hasSubmorphs not]) ifTrue: [^ self].	myOwner firstSubmorph == self ifFalse:		[myOwner addMorphFront: self].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jm 10/3/2002 19:23'!delete	"Remove the receiver as a submorph of its owner and make its new owner be nil."	owner ifNotNil: [		owner privateRemoveMorph: self.		owner _ nil].! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jm 10/11/2002 07:23'!goBehind	owner addMorphBack: self.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'jm 10/13/2002 17:37'!removeAllMorphs	self changed.	submorphs do: [:m | m privateOwner: nil].	submorphs _ Array empty.	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'RAA 10/6/1999 12:23'!removeAllMorphsIn: aCollection"greatly speeds up the removal of *lots* of submorphs"	| set |	self changed.	aCollection do: [:m | m privateOwner: nil].	set _ IdentitySet new: aCollection size * 4 // 3.	aCollection do: [:each | set add: each].	submorphs _ submorphs reject: [ :each | set includes: each].	self layoutChanged.! !!Morph methodsFor: 'submorphs-add/remove' stamp: 'sw 10/25/1999 23:34'!replaceSubmorph: oldMorph by: newMorph	| index itsPosition w |	oldMorph stopStepping.	itsPosition _ oldMorph referencePositionInWorld.	index _ submorphs indexOf: oldMorph.	oldMorph privateDelete.	self privateAddMorph: newMorph atIndex: index.	newMorph referencePositionInWorld: itsPosition.	(w _ newMorph world) ifNotNil:		[w startSteppingSubmorphsOf: newMorph]! !!Morph methodsFor: 'drawing' stamp: 'di 6/24/1998 14:10'!areasRemainingToFill: aRectangle	"May be overridden by any subclasses with opaque regions"	^ Array with: aRectangle! !!Morph methodsFor: 'drawing' stamp: 'jm 10/13/2002 18:24'!basicFullDrawOn: aCanvas	"Draw the full Morphic structure on the given Canvas.  This duplicates the implementation of fullDrawOn: (which could invoke this if it cared) but this method is never overridden, so that it can be invoked by subclass implementations of #fullDrawOn: without getting snagged by the complexities of intervening implementations of #fullDrawOn:"	self isHidden ifTrue: [^ self].	(self hasProperty: #errorOnDraw) ifTrue: [^ self drawErrorOn: aCanvas].	aCanvas drawMorph: self.	self drawSubmorphsOn: aCanvas! !!Morph methodsFor: 'drawing' stamp: 'ar 4/2/1999 13:13'!drawErrorOn: aCanvas	"The morph (or one of its submorphs) had an error in its drawing method."	aCanvas		frameAndFillRectangle: bounds		fillColor: Color red		borderWidth: 1		borderColor: Color yellow.	aCanvas line: bounds topLeft to: bounds bottomRight width: 1 color: Color yellow.	aCanvas line: bounds topRight to: bounds bottomLeft width: 1 color: Color yellow.! !!Morph methodsFor: 'drawing' stamp: 'jm 11/24/2002 10:35'!drawOn: aCanvas	aCanvas fillRectangle: self bounds color: color.! !!Morph methodsFor: 'drawing' stamp: 'ar 5/29/1999 05:23'!drawSubmorphsOn: aCanvas	"Display submorphs back to front"	submorphs reverseDo:[:m | aCanvas fullDrawMorph: m].! !!Morph methodsFor: 'drawing' stamp: 'sw 10/10/1999 10:23'!flash	| c w |	c _ self color.	self color: Color black.	(w _ self world) ifNotNil: [w displayWorldSafely].	self color: c! !!Morph methodsFor: 'drawing' stamp: 'jm 10/13/2002 18:18'!fullBounds	fullBounds ifNil: [		fullBounds _ self bounds.		submorphs size > 0 ifTrue: [			submorphs do: [:m |				m isHidden ifFalse: [					fullBounds _ fullBounds quickMerge: m fullBounds]]]].	^ fullBounds! !!Morph methodsFor: 'drawing' stamp: 'jm 10/13/2002 19:07'!fullDrawOn: aCanvas	"Draw my full Morphic structure on the given Canvas"	self isHidden ifTrue: [^ self].	(self hasProperty: #errorOnDraw) ifTrue:[^ self drawErrorOn: aCanvas].	aCanvas drawMorph: self.	self drawSubmorphsOn:aCanvas.! !!Morph methodsFor: 'drawing' stamp: 'jm 7/4/2003 10:34'!imageForm	^ self imageForm: Display depth forRectangle: self fullBounds! !!Morph methodsFor: 'drawing' stamp: 'jm 11/29/2002 10:12'!imageForm: depth forRectangle: rect	| canvas |	canvas _ FormCanvas extent: rect extent depth: depth.	canvas translateBy: rect topLeft negated during: [:c | self fullDrawOn: c].	^ canvas form offset: 0@0! !!Morph methodsFor: 'drawing' stamp: 'sw 10/10/1999 23:25'!refreshWorld	| aWorld |	(aWorld _ self world) ifNotNil: [aWorld displayWorldSafely]! !!Morph methodsFor: 'drawing' stamp: 'jm 11/24/2002 10:49'!shadowForm	"Return a form representing the 'shadow' of the receiver - e.g., all pixels that are occupied by the receiver are one, all others are zero."	| canvas |	canvas _ (FormCanvas extent: bounds extent depth: 1)				asShadowDrawingCanvas: Color black. "Color black represents one for 1bpp"	canvas translateBy: bounds topLeft negated		during: [:tempCanvas| self fullDrawOn: tempCanvas].	^ canvas form offset: bounds topLeft! !!Morph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:44'!boundsInWorld	owner ifNil: [^ bounds].	^ (owner transformFrom: self world) localBoundsToGlobal: bounds.! !!Morph methodsFor: 'geometry' stamp: 'sw 6/11/1999 18:48'!center: aPoint	self position: (aPoint - (self extent // 2))! !!Morph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:44'!fullBoundsInWorld	owner ifNil: [^ self fullBounds].	^ (owner transformFrom: self world) localBoundsToGlobal: self fullBounds.! !!Morph methodsFor: 'geometry' stamp: 'sw 6/4/2000 21:59'!minimumExtent	| ext |	"This returns the minimum extent that the morph may be shrunk to.  Not honored in too many places yet, but respected by the resizeToFit feature, at least.  copied up from SystemWindow 6/00"	(ext _ self valueOfProperty: #minimumExtent)		ifNotNil:			[^ ext].	^ 100 @ 80! !!Morph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:42'!pointFromWorld: aPoint	owner ifNil: [^ aPoint].	^ (owner transformFrom: self world) globalPointToLocal: aPoint.! !!Morph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:43'!pointInWorld: aPoint	owner ifNil: [^ aPoint].	^ (owner transformFrom: self world) localPointToGlobal: aPoint.! !!Morph methodsFor: 'geometry' stamp: 'di 9/30/1998 12:11'!positionInWorld	^ self pointInWorld: self position.! !!Morph methodsFor: 'geometry' stamp: 'sw 10/9/1998 08:56'!positionSubmorphs	self submorphsDo:		[:aMorph | aMorph snapToEdgeIfAppropriate]! !!Morph methodsFor: 'geometry' stamp: 'jm 10/15/2002 17:20'!setConstrainedPositionFrom: aPoint	"Change the position of this morph and and all of its submorphs to aPoint, but don't let me go outside my owner's bounds."	| trialRect delta boundingMorph |	trialRect _ aPoint extent: self bounds extent.	boundingMorph _ self owner.	delta _ boundingMorph			ifNil:    [0@0]			ifNotNil: [trialRect amountToTranslateWithin: boundingMorph bounds].	self position: aPoint + delta.	self layoutChanged  "So that, eg, surrounding text will readjust"! !!Morph methodsFor: 'geometry' stamp: 'sw 4/27/2000 13:53'!worldBoundsForHalo	"To restore older behavior, change this to return  self fullBoundsInWorld"	^ self boundsInWorld! !!Morph methodsFor: 'geometry-rotate scale and flex' stamp: 'jm 10/13/2002 19:15'!addTransparentSpacerOfSize: aPoint	self addMorphBack:		((Morph new extent: aPoint) color: Color transparent)! !!Morph methodsFor: 'geometry-rotate scale and flex' stamp: 'sw 10/25/1999 16:49'!referencePositionInWorld	^ self pointInWorld: self referencePosition! !!Morph methodsFor: 'geometry-rotate scale and flex' stamp: 'sw 10/25/1999 23:33'!referencePositionInWorld: aPoint	| localPosition |	localPosition _ owner		ifNil: [aPoint]		ifNotNil: [(owner transformFrom: self world) globalPointToLocal: aPoint].	self referencePosition: localPosition! !!Morph methodsFor: 'geometry-testing' stamp: 'di 5/3/2000 19:05'!fullContainsPoint: aPoint	(self fullBounds containsPoint: aPoint) ifFalse: [^ false].  "quick elimination"	(self containsPoint: aPoint) ifTrue: [^ true].  "quick acceptance"	submorphs do: [:m | (m fullContainsPoint: aPoint) ifTrue: [^ true]].	^ false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'jm 3/16/2003 11:03'!aboutToBeGrabbedBy: aHand	"The receiver is being grabbed by a hand. Perform necessary adjustments (if any) and return the morph that should be added to the hand. This default implementation just returns the reciver."	^ self! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/28/2000 10:51'!allowSubmorphExtraction	"Return true if this morph allows its submorphs to be extracted just by grabbing them. This default implementation returns false."	^self dragNDropEnabled		or: [self dragEnabled]! !!Morph methodsFor: 'dropping/grabbing'!asDraggableMorph	^self! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:50'!dragEnabled	"Get this morph's ability to add and remove morphs via drag-n-drop."	^(self valueOfProperty: #dragEnabled) == true! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:48'!dragNDropEnabled	"Get this morph's ability to add and remove morphs via drag-n-drop."	^(self valueOfProperty: #dragNDropEnabled) == true! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:51'!dropEnabled	"Get this morph's ability to add and remove morphs via drag-n-drop."	^(self valueOfProperty: #dropEnabled) == true! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:50'!enableDrag: aBoolean	self setProperty: #dragEnabled toValue: aBoolean! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:54'!enableDragNDrop: aBoolean	self enableDrag: aBoolean.	self enableDrop: aBoolean.	self setProperty: #dragNDropEnabled toValue: aBoolean! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:51'!enableDrop: aBoolean	self setProperty: #dropEnabled toValue: aBoolean! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 10/11/1999 13:20'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	| aWindow partsBinCase |	(partsBinCase _ aMorph isPartsBin) ifFalse:		[self isPartsDonor: false].	(aWindow _ aMorph ownerThatIsA: SystemWindow) ifNotNil:		[aWindow isActive ifFalse:			[aWindow activate]].	(self isInWorld and: [partsBinCase not]) ifTrue:		[self world startSteppingSubmorphsOf: self]  	"Note an unhappy inefficiency here:  the startStepping... call will often have already been called in the sequence leading up to entry to this method, but unfortunately the isPartsDonor: call often will not have already happened, with the result that the startStepping... call will not have resulted in the startage of the steppage."! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 1/11/1999 20:07'!repelsMorph: aMorph event: ev	^ false! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 6/30/1998 17:02'!rootForGrabOf: aMorph	^ (self isSticky and: [self isPartsDonor not])		ifTrue:			[nil]		ifFalse:			[(owner = nil or: [owner isWorldOrHandMorph])				ifTrue:					[self]				ifFalse:					[owner allowSubmorphExtraction						ifTrue: [self]						ifFalse: [owner rootForGrabOf: aMorph]]]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'jm 8/3/2003 10:06'!slideBackToFormerSituation: evt	| slideForm formerOwner formerPosition aWorld startPoint endPoint trans |	(formerOwner _ evt hand formerOwner) ifNil: [^ self].	formerPosition _ evt hand formerPosition.	aWorld _ self world.	trans _ formerOwner transformFromWorld.	slideForm _ self imageForm offset: 0@0.	startPoint _ evt hand fullBounds origin.	endPoint _ trans localPointToGlobal: formerPosition.	owner privateRemoveMorph: self.	aWorld displayWorld.	slideForm slideFrom: startPoint to: endPoint nSteps: 12 delay: 15.	formerOwner addMorph: self.	self position: formerPosition.	self justDroppedInto: formerOwner event: evt.! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:46'!toggleDragNDrop	"Toggle this morph's ability to add and remove morphs via drag-n-drop."		self enableDragNDrop: self dragNDropEnabled not.! !!Morph methodsFor: 'dropping/grabbing' stamp: 'jm 10/11/2002 16:55'!vanishAfterSlidingTo: aPosition event: evt	| aForm aWorld startPoint endPoint |	aForm _ self imageForm offset: 0@0.	aWorld _ self world.	startPoint _ evt hand fullBounds origin.	self delete.	aWorld displayWorld.	endPoint _ aPosition.	aForm slideFrom: startPoint  to: endPoint nSteps: 12 delay: 15.! !!Morph methodsFor: 'dropping/grabbing' stamp: 'panda 4/28/2000 10:51'!wantsDroppedMorph: aMorph event: evt	"Return true if the receiver wishes to accept the given morph, which is being dropped by a hand in response to the given event. The default implementation returns false.NOTE: the event is assumed to be in global (world) coordinates."	^self dragNDropEnabled		or: [self dropEnabled]! !!Morph methodsFor: 'dropping/grabbing' stamp: 'sw 5/9/2000 02:56'!willingToBeEmbeddedUponLanding	"Answer whether the receiver, when dropped over a container that is open to drag-and-drop, is eager to be embedded in the it.  SystemWindows and MenuMorphs are examples of morphs that are reluctant in this regard."		^ true! !!Morph methodsFor: 'event handling' stamp: 'jm 10/13/2002 11:21'!click: evt	"Handle a single-click event. This message is only sent to clients that request it by sending #waitForClicksOrDrag:event: to the initiating hand in their mouseDown: method. This default implementation does nothing."! !!Morph methodsFor: 'event handling' stamp: 'sw 3/8/1999 00:17'!cursorPoint	^ self currentHand lastEvent cursorPoint! !!Morph methodsFor: 'event handling' stamp: 'jm 10/13/2002 11:22'!doubleClick: evt	"Handle a double-click event. This message is only sent to clients that request it by sending #waitForClicksOrDrag:event: to the initiating hand in their mouseDown: method. This default implementation does nothing."! !!Morph methodsFor: 'event handling' stamp: 'jm 10/13/2002 11:24'!handlesMouseDown: evt	"Return true if this morph wants to receive mouseDown events (i.e., mouseDown:, mouseMove:, mouseUp:). The default response is false; subclasses that implement mouse messages should override this to return true." 	^ false! !!Morph methodsFor: 'event handling' stamp: 'jm 10/13/2002 11:32'!handlesMouseOver: evt	"Return true if I want to receive mouseEnter: and mouseLeave: when the button is up and the hand is empty. The default response is false; subclasses that implement mouse mouseEnter messages should override this to return true." 	^ false! !!Morph methodsFor: 'event handling' stamp: 'jm 10/13/2002 11:31'!handlesMouseOverDragging: evt	"Return true if I want to receive mouseEnterDragging: and mouseLeaveDragging: when the hand drags something over me (button up or button down), or when the mouse button is down but there is no mouseDown recipient. The default response is false; subclasses that implement mouse mouseEnterDragging messages should override this to return true."	"NOTE:  If the hand state matters in these cases, it may be tested by constructs such as		event anyButtonPressed		event hand hasSubmorphs"	^ false! !!Morph methodsFor: 'event handling' stamp: 'jm 10/13/2002 11:25'!keyStroke: anEvent	"Handle a keystroke event. This default implementation does nothing."! !!Morph methodsFor: 'event handling' stamp: 'jm 11/1/2002 10:45'!keyboardFocusChange: aBoolean	"The message is sent to a morph when its keyboard focus change. The argument is true if the receiver is gaining (versus losing) the keyboard focus. Morphs that accept keystrokes should change their appearance in some way when they are the current keyboard focus. This default implementation does nothing."! !!Morph methodsFor: 'event handling' stamp: 'jm 10/13/2002 11:25'!mouseDown: evt	"Handle a mouse down event. This default implementation does nothing."! !!Morph methodsFor: 'event handling' stamp: 'jm 10/13/2002 11:26'!mouseEnter: evt	"Handle a mouseEnter event. The mouse just entered my bounds with no button pressed. This default implementation does nothing."! !!Morph methodsFor: 'event handling' stamp: 'jm 10/13/2002 11:26'!mouseEnterDragging: evt	"Handle a mouseEnterDragging event. The mouse just entered my bounds with a button pressed or laden with submorphs. This default implementation does nothing."! !!Morph methodsFor: 'event handling' stamp: 'jm 10/13/2002 11:27'!mouseLeave: evt	"Handle a mouseLeave event. The mouse just left my bounds with no button pressed. This default implementation does nothing."! !!Morph methodsFor: 'event handling' stamp: 'jm 10/13/2002 11:27'!mouseLeaveDragging: evt	"Handle a mouseLeaveLaden event. The mouse just left my bounds with a button pressed or laden with submorphs. This default implementation does nothing."! !!Morph methodsFor: 'event handling' stamp: 'jm 10/13/2002 11:28'!mouseMove: evt	"Handle a mouse move event as part of the sequence mouseDown, mouseMove(s), mouseUp. This default implementation does nothing."! !!Morph methodsFor: 'event handling' stamp: 'jm 10/13/2002 11:29'!mouseUp: evt	"Handle a mouse up event. This default implementation does nothing."! !!Morph methodsFor: 'event handling' stamp: 'jm 8/24/2003 10:44'!startDrag: evt	"Handle a double-click event. This message is only sent to clients that request it by sending #waitForClicksOrDrag:event: to the initiating hand in their mouseDown: method. This default implementation grabs me."	| frontM rootForGrab |	frontM _ (self unlockedMorphsAt: evt cursorPoint) first.	rootForGrab _ frontM rootForGrabOf: frontM.	rootForGrab ifNil: [^ self].	rootForGrab position: rootForGrab position + (evt hand position - evt cursorPoint).	evt hand grabMorph: rootForGrab.! !!Morph methodsFor: 'naming' stamp: 'jm 10/13/2002 20:07'!externalName	^ self valueOfProperty: #externalName ifAbsent: [self innocuousName]! !!Morph methodsFor: 'naming' stamp: 'jm 10/7/2002 07:22'!innocuousName	"Choose an innocuous name for the receiver -- one that does not end in the word Morph"	| myName |	myName _ self class name asString copy.	(myName size > 5 and: [myName endsWith: 'Morph'])		ifTrue: [^ myName copyFrom: 1 to: myName size - 5]		ifFalse: [^ myName].! !!Morph methodsFor: 'naming' stamp: 'jm 10/13/2002 20:54'!setNameTo: aName	self setProperty: #externalName toValue: aName asString.! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 3/22/2000 14:27'!arrangeToStartStepping	"Arrange to start getting sent the 'step' message, but don't do that initial #step call that startStepping does"	self arrangeToStartSteppingIn: self world! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 3/22/2000 14:26'!arrangeToStartSteppingIn: aWorld	"Start getting sent the 'step' message in aWorld.  Like startSteppingIn:, but without the initial one to get started'"	aWorld ifNotNil:		[aWorld startStepping: self.		self changed]! !!Morph methodsFor: 'stepping and presenter' stamp: 'jm 10/7/2002 07:39'!step	"Do some periodic activity. Use startStepping/stopStepping to start and stop getting sent this message. The time between steps is specified by this morph's answer to the stepTime message. This default implementation does nothing."! !!Morph methodsFor: 'stepping and presenter' stamp: 'sw 10/20/1999 15:20'!stepAt: millisecondClockValue	"Do some periodic activity. Use startStepping/stopStepping to start and stop getting sent this message. The time between steps is specified by this morph's answer to the stepTime message.	The millisecondClockValue parameter gives the value of the millisecond clock at the moment of dispatch.	Default is to dispatch to the parameterless step method for the morph, but this protocol makes it possible for some morphs to do differing things depending on the clock value"		self step! !!Morph methodsFor: 'stepping and presenter' stamp: 'jm 10/7/2002 07:40'!stepTime	"Answer the desired time between steps in milliseconds. This default implementation requests that the 'step' method be called once every second."	^1000! !!Morph methodsFor: 'stepping and presenter' stamp: 'jm 10/7/2002 07:40'!wantsSteps	"Return true if the receiver overrides the default Morph step method."	"Details: Find the first class in superclass chain that implements #step and return true if it isn't class Morph."	| c |	self isPartsDonor ifTrue: [^ false].	c _ self class.	[c includesSelector: #step] whileFalse: [c _ c superclass].	^ c ~= Morph! !!Morph methodsFor: 'menus' stamp: 'jm 3/20/2003 21:39'!addAddHandMenuItemsForHalo: aMenu hand: aHandMorph	"Add halo menu items to be handled by the invoking hand. The halo menu is invoked by clicking on the menu-handle of the receiver's halo."	aMenu addLine.	self owner isWorldMorph ifTrue:		[aMenu add: #collapse target: self action: #collapse].	aMenu add: 'copy to paste buffer' action: #copyToPasteBuffer.	aMenu add: 'change color...' target: self action: #changeColor.	aMenu addLine.	aHandMorph potentialEmbeddingTargets size > 1 ifTrue:		[aMenu add: 'embed...' action: #placeArgumentIn].	aMenu defaultTarget: self.	(owner == nil) ifFalse: [		aMenu add: 'send to back' action: #goBehind.		aMenu add: 'bring to front' action: #comeToFront].	aMenu addLine.	aMenu defaultTarget: aHandMorph.! !!Morph methodsFor: 'menus' stamp: 'jm 3/20/2003 21:35'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand."	Preferences noviceMode ifFalse:		[self addDebuggingItemsTo: aCustomMenu hand: aHandMorph].! !!Morph methodsFor: 'menus' stamp: 'sw 6/19/1999 23:15'!addTitleForHaloMenu: aMenu	aMenu addTitle: self externalName! !!Morph methodsFor: 'menus' stamp: 'sw 2/7/2000 10:57'!adhereToEdge: edgeSymbol	(owner == nil or: [owner isHandMorph]) ifTrue: [^ self].	self perform: (edgeSymbol, ':') asSymbol withArguments: (Array with: (owner perform: edgeSymbol))! !!Morph methodsFor: 'menus' stamp: 'sw 2/3/2000 00:14'!adjustedCenter	"Provides a hook for objects to provide a reference point other than the receiver's center,for the purpose of centering a submorph under special circumstances, such as BalloonMorph"	^ self center! !!Morph methodsFor: 'menus' stamp: 'sw 2/3/2000 00:12'!adjustedCenter: c	"Set the receiver's position based on the #adjustedCenter protocol for adhereToEdge.  By default this simply sets the receiver's center.   Though there are (at its inception anyway) no other implementors of this method, it is required in use with the #adhereToEdge when the centering of a submorph is to be with reference to a rectangle  other than the receiver's center."	self center: c! !!Morph methodsFor: 'menus' stamp: 'di 9/3/1999 10:17'!changeColor	ColorPickerMorph new		sourceHand: self activeHand;		target: self;		selector: #color:;		originalColor: self color;		addToWorld: self world			near: self fullBounds! !!Morph methodsFor: 'menus' stamp: 'sw 2/21/2000 15:21'!collapse	CollapsedMorph new beReplacementFor: self! !!Morph methodsFor: 'menus' stamp: 'sw 2/16/1999 14:32'!inspectInMorphic	self currentHand attachMorph: ((Inspector openAsMorphOn: self) extent: 300@200)! !!Morph methodsFor: 'menus' stamp: 'sw 6/17/1998 14:25'!setToAdhereToEdge: anEdge	anEdge ifNil: [^ self].	anEdge == #none ifTrue: [^ self removeProperty: #edgeToAdhereTo].	self setProperty: #edgeToAdhereTo toValue: anEdge.	self layoutChanged! !!Morph methodsFor: 'menus' stamp: 'sw 8/30/1998 09:42'!snapToEdgeIfAppropriate	| edgeSymbol oldBounds aWorld |	(edgeSymbol _ self valueOfProperty: #edgeToAdhereTo) ifNotNil:		[oldBounds _ bounds.		self adhereToEdge: edgeSymbol.		bounds ~= oldBounds ifTrue: [(aWorld _ self world) ifNotNil: [aWorld viewBox ifNotNil:			[aWorld displayWorld]]]]! !!Morph methodsFor: 'menus' stamp: 'sw 9/27/1999 09:37'!stickinessString	^ self isSticky		ifTrue: ['stop being sticky']		ifFalse: ['start being sticky']! !!Morph methodsFor: 'halos and balloon help' stamp: 'jm 9/30/2003 00:13'!addHalo: evt	| halo |	halo _ HaloMorph new bounds: self worldBoundsForHalo.	self world addMorphFront: halo.	halo target: self.	halo startStepping.! !!Morph methodsFor: 'halos and balloon help' stamp: 'jm 10/11/2002 15:54'!addHandlesTo: aHaloMorph box: box	aHaloMorph haloBox: box.	Preferences haloSpecifications do: [:aSpec |		aHaloMorph perform: aSpec addHandleSelector with: aSpec].! !!Morph methodsFor: 'halos and balloon help' stamp: 'sma 12/23/1999 14:11'!balloonColor	^ Display depth <= 2		ifTrue: [Color white]		ifFalse: [Color r: 1.0 g: 1.0 b: 0.6]! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 2/7/2000 11:27'!balloonHelpAligner	"Answer the morph to which the receiver's balloon help should point"	^ (self valueOfProperty: #balloonTarget) ifNil: [self]! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 4/3/2000 15:20'!classForHalo	"Answer the name of the desired kind of HaloMorph to launch on behalf of the receiver"	^ #HaloMorph! !!Morph methodsFor: 'halos and balloon help' stamp: 'jm 9/30/2003 00:18'!comeToFrontAndAddHalo	self comeToFront.	self addHalo: nil.! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 1/11/2000 18:24'!defersHaloOnClickTo: aSubMorph	"If a cmd-click on aSubMorph would make it a preferred recipient of the halo, answer true"	"May want to add a way (via a property) for morphs to assert true here -- this would let certain kinds of morphs that are unusually reluctant to take the halo on initial click"	^ false	! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 1/28/1999 12:06'!halo	self currentWorld haloMorphs do:		[:h | h target == self ifTrue: [^ h]].	^ nil! !!Morph methodsFor: 'halos and balloon help' stamp: 'jm 10/8/2002 08:53'!mouseDownOnHelpHandle: anEvent	"The mouse went down in the show-balloon handle"		| str |	str _ self balloonText.	str ifNil: [str _ self noHelpString].	self showBalloon: str! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 12/30/1999 19:51'!seeksOutHalo	"Answer whether the receiver is an eager recipient of the halo"	^ true! !!Morph methodsFor: 'halos and balloon help' stamp: 'jm 10/13/2002 20:13'!setBalloonText: stringOrText	"Set receiver's balloon help text. Pass nil to remove the help."	| wrapped |	stringOrText		ifNil: [self removeProperty: #balloonText]		ifNotNil: [			wrapped _ stringOrText				withNoLineLongerThan: Preferences maxBalloonHelpLineLength.			self setProperty: #balloonText toValue: wrapped].! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 2/7/2000 11:28'!showBalloon: msgString	"Pop up a balloon containing the given string,	first removing any existing BalloonMorphs in the world."	| w balloon worldBounds |	(w _ self world) ifNil: [^ self].	w submorphsDo: [:m | (m isKindOf: BalloonMorph) ifTrue: [m delete]].	balloon _ BalloonMorph string: msgString for: self balloonHelpAligner.	balloon lock.	w addMorphFront: balloon.	"So that if the translation below makes it overlap the receiver, it won't	interfere with the rootMorphsAt: logic and hence cause flashing.  Without	this, flashing happens, believe me!!"	((worldBounds _ w bounds) containsRect: balloon bounds) ifFalse:		[balloon bounds: (balloon bounds translatedToBeWithin: worldBounds)].	self setProperty: #balloon toValue: balloon! !!Morph methodsFor: 'halos and balloon help' stamp: 'sma 12/23/1999 13:24'!wantsBalloon	"Answer true if receiver wants to show a balloon help text is a few moments." 	^ self balloonText notNil! !!Morph methodsFor: 'halos and balloon help' stamp: 'jm 10/15/2002 17:21'!wantsHalo	^ self owner ~~ nil and: [self owner wantsHaloFor: self]! !!Morph methodsFor: 'halos and balloon help' stamp: 'sw 1/25/2000 17:43'!wantsHaloFromClick	^ true! !!Morph methodsFor: 'change reporting' stamp: 'jm 10/13/2002 20:51'!invalidRect: damageRect	owner ifNotNil: [owner invalidRect: damageRect].! !!Morph methodsFor: 'change reporting' stamp: 'di 11/16/97 15:15'!layoutChanged	"Note that something has changed about the size, shape, or location of the receiver or one of its submorphs, so that fullBounds must be recomputed."	fullBounds _ nil.	owner ifNotNil: [owner layoutChanged].	submorphs size > 0 ifTrue:		["Let submorphs know about a change above"		submorphs do: [:m | m ownerChanged]].! !!Morph methodsFor: 'change reporting' stamp: 'jm 7/24/2003 18:06'!mayNeedLayout	"Answer true if something has occured that might require my layout to change That is, if layoutChanged has been sent to me or any of my submorphs."	^ fullBounds isNil! !!Morph methodsFor: 'change reporting' stamp: 'sw 7/8/1998 13:21'!ownerChanged	"The receiver's owner, some kind of a pasteup, has changed its layout."	self snapToEdgeIfAppropriate! !!Morph methodsFor: 'e-toy support' stamp: 'jm 10/13/2002 11:22'!adaptToWorld: aWorld	"The receiver finds itself operating in a possibly-different new world.  If any of the receiver's parts are world-dependent (such as a target of a SimpleButtonMorph, etc.), then have them adapt accordingly"	submorphs do: [:m | m adaptToWorld: aWorld].! !!Morph methodsFor: 'e-toy support' stamp: 'sw 5/23/2000 03:42'!containingWindow	^ self ownerThatIsA: SystemWindow! !!Morph methodsFor: 'e-toy support' stamp: 'jm 10/15/2002 17:15'!definePath	| points lastPoint aForm offset currentPoint dwell ownerPosition |	points _ OrderedCollection new: 70.	lastPoint _ nil.	aForm _ self imageForm.	offset _ aForm extent // 2.	ownerPosition _ owner position.	Cursor move show.	Sensor waitButton.	[Sensor anyButtonPressed and: [points size < 100]] whileTrue:		[currentPoint _ Sensor cursorPoint.		dwell _ 0.		currentPoint = lastPoint			ifTrue:				[dwell _ dwell + 1.				((dwell \\ 1000) = 0) ifTrue:					[self beep]]			ifFalse:				[self position: (currentPoint - offset).				self world displayWorld.				(Delay forMilliseconds: 20) wait.				points add: currentPoint.				lastPoint _ currentPoint]].	points size > 1		ifFalse:			[self inform: 'no path obtained']		ifTrue:			[points size = 100 ifTrue: [self playSoundNamed: 'croak'].			Transcript cr; show: 'path defined with', points size printString, ' points'.			self setProperty: #pathPoints toValue: 				(points collect: [:p | p - ownerPosition])].	Cursor normal show.! !!Morph methodsFor: 'e-toy support' stamp: 'sw 1/5/1999 10:05'!deletePath	self removeProperty: #pathPoints! !!Morph methodsFor: 'e-toy support' stamp: 'jm 10/9/2002 05:10'!embedInWindow	| w window |	w _ self world.	window _ (SystemWindow labelled: self defaultLabelForInspector) model: nil.	window bounds: ((self position - ((0@window labelHeight) + window borderWidth))						corner: self bottomRight + window borderWidth).	window addMorph: self frame: (0@0 extent: 1@1).	window updatePaneColors.	w addMorph: window.	window activate.! !!Morph methodsFor: 'e-toy support' stamp: 'sw 10/26/1999 23:32'!embeddedInMorphicWindowLabeled: labelString	| window |	window _ (SystemWindow labelled: labelString) model: nil.	window setStripeColorsFrom: nil defaultBackgroundColor.	window addMorph: self frame: (0@0 extent: 1@1).	^ window! !!Morph methodsFor: 'e-toy support' stamp: 'jm 10/15/2002 17:16'!followPath	| pathPoints offset |	(pathPoints _ self valueOfProperty: #pathPoints) ifNil: [^ self beep].	offset _ owner position - (self extent // 2).	pathPoints do: [:p |		self position: p + offset.		self world displayWorld.		(Delay forMilliseconds: 20) wait].! !!Morph methodsFor: 'e-toy support' stamp: 'jm 10/14/2002 09:05'!unlockOneSubpart	| unlockables aMenu reply |	unlockables _ self submorphs select: [:m | m isLocked].	unlockables size <= 1 ifTrue: [^ self unlockContents].	aMenu _ SelectionMenu labelList:		(unlockables collect: [:m | m externalName]) selections: unlockables.	reply _ aMenu startUpWithCaption: 'Who should be be unlocked?'.	reply ifNil: [^ self].	reply isLocked: false.! !!Morph methodsFor: 'e-toy support' stamp: 'tk 9/3/1999 11:46'!wrappedInWindow: aSystemWindow	| aWindow |	aWindow _ aSystemWindow model: Model new.	aWindow addMorph: self frame: (0@0 extent: 1@1).	aWindow extent: self extent.	^ aWindow! !!Morph methodsFor: 'e-toy support' stamp: 'tk 9/3/1999 11:46'!wrappedInWindowWithTitle: aTitle	| aWindow |	aWindow _ (SystemWindow labelled: aTitle) model: Model new.	aWindow addMorph: self frame: (0@0 extent: 1@1).	aWindow extent: self extent + (2 @ 18).	^ aWindow! !!Morph methodsFor: 'parts bin' stamp: 'di 8/11/1998 12:48'!inPartsBin	| o |	self isPartsDonor ifTrue: [^ true].	o _ self owner.	[o == nil] whileFalse:		[o isPartsBin ifTrue: [^ true].		o _ o owner].	^ false! !!Morph methodsFor: 'printing' stamp: 'jm 10/4/2002 07:22'!printOn: aStream	| m |	super printOn: aStream.	m _ self findA: StringMorph.	aStream nextPutAll: '('.	m ifNotNil: [aStream print: m contents; space]. 	aStream print: self identityHash; nextPutAll: ')'.! !!Morph methodsFor: 'printing' stamp: 'jm 5/28/1998 18:00'!printStructureOn: aStream indent: tabCount	tabCount timesRepeat: [aStream tab].	self printOn: aStream.	aStream cr.	self submorphsDo: [:m | m printStructureOn: aStream indent: tabCount + 1].! !!Morph methodsFor: 'printing' stamp: 'jm 5/28/1998 17:58'!structureString	"Return a string that showing this morph and all its submorphs in an indented list that reflects its structure."	| s |	s _ WriteStream on: (String new: 1000).	self printStructureOn: s indent: 0.	^ s contents! !!Morph methodsFor: 'caching' stamp: 'jm 10/13/2002 20:51'!releaseCachedState	"Release any state that can be recomputed on demand, such as the pixel values for a color gradient or the editor state for a TextMorph. This method may be called to save space when a morph becomes inaccessible. Implementations of this method should do 'super releaseCachedState'."! !!Morph methodsFor: 'debug and other' stamp: 'sw 10/21/1998 09:29'!addDebuggingItemsTo: aMenu hand: aHandMorph	aMenu add: 'debug...' subMenu:  (self debuggingMenuFor: aHandMorph)! !!Morph methodsFor: 'debug and other' stamp: 'jm 10/27/2003 15:12'!blink	Display reverse: self bounds.	Delay waitMSecs: 50.	Display reverse: self bounds.! !!Morph methodsFor: 'debug and other' stamp: 'jm 12/9/2003 09:13'!debuggingMenuFor: aHandMorph	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	(self hasProperty: #errorOnDraw) ifTrue: [		aMenu add: 'start drawing again' action: #resumeAfterDrawError.		aMenu addLine].	(self hasProperty: #errorOnStep) ifTrue: [		aMenu add: 'start stepping again' action: #resumeAfterStepError.		aMenu addLine].	aMenu add: 'inspect morph' action: #inspectInMorphic.	Smalltalk isMorphic ifFalse:		[aMenu add: 'inspect morph (in MVC)' action: #inspect]. 	aMenu addLine.	aMenu add: 'browse morph class' target: self selector: #browseHierarchy.	aMenu add: 'make own subclass' target: aHandMorph action: #subclassMorph.	aMenu addLine.	aMenu add: 'control-menu...' target: aHandMorph selector: #invokeMetaMenuFor: argument: self.	^ aMenu! !!Morph methodsFor: 'debug and other' stamp: 'ar 4/2/1999 15:11'!resumeAfterDrawError	self changed.	self removeProperty:#errorOnDraw.	self changed.! !!Morph methodsFor: 'debug and other' stamp: 'ar 4/2/1999 15:22'!resumeAfterStepError	"Resume stepping after an error has occured."	self startStepping. "Will #step"	self removeProperty:#errorOnStep. "Will remove prop only if #step was okay"! !!Morph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 15:37'!fieldsVersion	^ 1! !!Morph methodsFor: 'object i/o' stamp: 'jm 9/28/2003 18:23'!initFieldsFrom: anObjStream version: classVersion	"Set my instance variables from the given object stream."	self initFieldsNamed: #(		bounds		owner		submorphs		color		flags	) from: anObjStream.	anObjStream nextField.  "placeholder for properties"	fullBounds _ nil.! !!Morph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 15:32'!storeFieldsOn: anObjStream	self storeFieldsNamed: #(		bounds		owner		submorphs		color		flags	) on: anObjStream.	anObjStream putField: nil.  "placeholder for properties"! !!Morph methodsFor: 'private' stamp: 'jm 5/29/1998 21:28'!privateColor: aColor	color _ aColor.! !!Morph methodsFor: 'private' stamp: 'jm 10/9/2002 05:37'!privateMoveBy: delta	"Private!! Use 'position:' instead."	fullBounds == bounds		ifTrue: ["optimization: avoids recomputing fullBounds"			fullBounds _ bounds _ bounds translateBy: delta]		ifFalse: [			bounds _ bounds translateBy: delta.			fullBounds _ nil].! !!Morph methodsFor: 'private' stamp: 'jm 10/13/2002 21:22'!privateProperties: aMorphPropertyOrNil	"Private!! Used when copying."	properties _ aMorphPropertyOrNil.! !!Morph methodsFor: 'flags' stamp: 'jm 10/13/2002 17:50'!getFlag: maskInteger	"Return the boolean flag for the given mask. The maskInteger is assumed to be an integer with only a single bit set, the bit corresponding to the flag to be read."	^ (flags bitAnd: maskInteger) ~= 0! !!Morph methodsFor: 'flags' stamp: 'jm 10/13/2002 18:25'!isHidden	^ self getFlag: HiddenFlag! !!Morph methodsFor: 'flags' stamp: 'jm 10/31/2002 10:18'!isHidden: aBoolean	self setFlag: HiddenFlag to: aBoolean.	self changed.! !!Morph methodsFor: 'flags' stamp: 'jm 10/13/2002 18:29'!isLocked	^ self getFlag: LockedFlag! !!Morph methodsFor: 'flags' stamp: 'jm 10/13/2002 18:27'!isLocked: aBoolean	self setFlag: LockedFlag to: aBoolean.! !!Morph methodsFor: 'flags' stamp: 'jm 10/13/2002 18:29'!isPartsDonor	^ self getFlag: PartsDonorFlag! !!Morph methodsFor: 'flags' stamp: 'jm 10/14/2002 08:54'!isPartsDonor: aBoolean	self setFlag: PartsDonorFlag to: aBoolean.! !!Morph methodsFor: 'flags' stamp: 'jm 10/13/2002 18:29'!isSticky	^ self getFlag: StickyFlag! !!Morph methodsFor: 'flags' stamp: 'jm 10/14/2002 08:54'!isSticky: aBoolean	self setFlag: StickyFlag to: aBoolean.! !!Morph methodsFor: 'flags' stamp: 'jm 10/13/2002 18:27'!lock	self isLocked: true.! !!Morph methodsFor: 'flags' stamp: 'jm 10/13/2002 17:49'!setFlag: maskInteger to: aBoolean	"Set the given flag bit to the given boolean value (false = 0, true = 1). The maskInteger is assumed to be an integer with only as single bit set, the bit corresponding to the flag to be modified."	"Details: Morphs have a number of boolean properties that are most efficiently stored as a bit-vector packed into a single 31-bit Squeak SmallInteger."	aBoolean		ifTrue: [flags _ flags bitOr: maskInteger]		ifFalse: [flags _ flags bitAnd: maskInteger bitInvert].! !!Morph methodsFor: 'flags' stamp: 'jm 10/13/2002 18:07'!toggleStickiness	self isSticky: self isSticky not.! !!Morph class methodsFor: 'class initialization' stamp: 'jm 10/13/2002 17:58'!initialize	"Morph initialize"	"flag masks: integers with a single bit set used as masks for the flags field"	HiddenFlag _ 1.	StickyFlag _ 2.	LockedFlag _ 4.	PartsDonorFlag _ 8.! !!Morph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 19:52'!includeInNewMorphMenu	"Answer true for all classes that can be instantiated from the new morph menu."	^ false! !!Morph class methodsFor: 'instance creation' stamp: 'jm 5/29/1998 21:28'!newBounds: bounds color: color	^ (self new privateBounds: bounds) privateColor: color! !!Morph class methodsFor: 'instance creation' stamp: 'jm 6/28/2003 09:37'!open	"Answer an instance of me and add it to the world."	^ self new openInWorld! !I represent one (name, value) pair in a singly-linked list of properties.Note: A linked list representation was chosen to hold optional Morph properties because we expect there to be no more than ten properties associated with any given morph (more typically, just one or two). In this case, a linked list has lower space overhead and is just as fast as an IdentityDictionary. (The cross-over point is around 8 entries; the linked list is faster, on the average, than a dictionary for fewer entries.)!!MorphProperty methodsFor: 'accessing' stamp: 'jm 10/13/2002 20:26'!name	^ name! !!MorphProperty methodsFor: 'accessing' stamp: 'jm 10/14/2002 08:02'!name: aStringOrSymbol value: anObject	"Initialize this property. The name is always converted to a Symbol for faster comparisons."	name _ aStringOrSymbol asSymbol.	value _ anObject.! !!MorphProperty methodsFor: 'accessing' stamp: 'jm 10/13/2002 20:26'!value	^ value! !!MorphProperty methodsFor: 'accessing' stamp: 'jm 10/14/2002 08:03'!value: anObject	value _ anObject.! !!MorphProperty methodsFor: 'list operations' stamp: 'jm 8/18/2003 21:57'!copyAll	"Return a copy of this entire property list."	nextLink		ifNil: [^ self clone]		ifNotNil: [^ self clone nextLink: nextLink copyAll; yourself].! !!MorphProperty methodsFor: 'list operations' stamp: 'jm 10/14/2002 08:19'!copyWithoutName: aStringOrSymbol	"Return a copy of this property list without entries of the given name. Return nil if that leaves the list empty."	| dup |	name = aStringOrSymbol		ifTrue: [  "omit myself from the copy"			nextLink ifNil: [^ nil].			^ nextLink copyWithoutName: aStringOrSymbol]		ifFalse: [  "make a shallow copy of myself"			dup _ self clone.			nextLink ifNil: [^ dup].			dup nextLink: (nextLink copyWithoutName: aStringOrSymbol).			^ dup].! !!MorphProperty methodsFor: 'list operations' stamp: 'jm 10/14/2002 08:09'!do: aBlock	"Evaluate the given block on each of my elements."	| this |	this _ self.	[this isNil] whileFalse: [		aBlock value: this.		this _ this nextLink].! !!MorphProperty methodsFor: 'list operations' stamp: 'jm 10/13/2002 20:28'!propertyForName: aStringOrSymbol	"Answer the first MorphProperty with the given name in this linked list of properties, or nil if there isn't one."	| this |	this _ self.	[this == nil] whileFalse: [		this name = aStringOrSymbol ifTrue: [^ this].		this _ this nextLink].	^ nil! !!MorphProperty methodsFor: 'list operations' stamp: 'jm 10/14/2002 08:24'!size	"Answer the number of properties in this list."	| n |	n _ 0.	self do: [:prop | n _ n + 1].	^ n! !!MorphProperty methodsFor: 'printing' stamp: 'jm 10/14/2002 08:04'!printOn: aStream	name printOn: aStream.	aStream nextPutAll: '=>'.	value printOn: aStream.! !I am a controller for SceneViews. I support gestures for scrolling, click-selection, and area selection of scene glyphs. (See the class comment in GestureController for more details about gestures.) I also support construction operations such as inserting new glyphs and merging glyphs to make them share a common point.The mapping of gestures to actions is as follows (see GestureController comment for more about gestures):  Click:	click on glyph				select glyph	shift-click on glyph			toggle selection of that glyph	click on background			clear selection  Double click:	double-click on glyph			inspect glyph	double-click on background		select all  Hold/Drag/Sweep:	hold (no movement)			yellow-button menu	drag (up/left movement)		scrolling hand	sweep (down/right movement)	select glyphs in region	shift-sweep					toggle selection of glyphs in region!!MorphWorldController methodsFor: 'control sequence' stamp: 'di 11/26/1999 10:00'!controlInitialize	"This window is becoming active."	true ifTrue: [model becomeTheActiveWorldWith: nil].	model canvas ifNil: [  "i.e., only on first entry"		"In case of, eg, inspect during balloon help..."		model submorphsDo: [:m |  "delete any existing balloons"			(m isKindOf: BalloonMorph) ifTrue: [m delete]].		model handsDo: [:h | h initForEvents].		view displayView].  "initializes the WorldMorph's canvas"! !I am a view used to display a Scene. I may be scrolled by adjusting my offset. My default controller is SceneController.SceneViews encapsulate the notion of a changing foreground and a fixed background during interactive updates. During an interaction (such as dragging), some of the glyphs will not change location or appearance. These are part of the "background". All glyphs that may change (the "foreground" glyphs) are painted against this unchanging backdrop during the interaction.Instance Variables:	offset				the current offset of this view (used for scrolling)	enclosingRect 		a rectangle large enough to contain all the objects in the scene, plus a small border (this is a cache that must be recomputed when glyphs are moved, added, or removed from the scene)	backgroundForm		a <Form> containing the fixed background	visibleForeground		the glyphs that are changing but not selected during an interaction	selectedForeground	the selected glyphs that are changing during an interaction!!MorphWorldView methodsFor: 'as yet unclassified' stamp: 'dew 11/8/1999 02:00'!computeInsetDisplayBox	"This overrides the same method in View.  (It avoids using displayTransform: because it can return inaccurate results, causing a MorphWorldView's inset display box to creep inward when resized.)"	^superView insetDisplayBox insetBy: borderWidth! !!MorphWorldView methodsFor: 'as yet unclassified' stamp: 'jm 7/17/2003 22:58'!deEmphasizeView 	"This window is becoming inactive."	Cursor normal show.	model handsDo: [:h | h newKeyboardFocus: nil].	model canvas: nil.  "free model's canvas to save space"	model allMorphsDo: [:m | m releaseCachedState].	self topView cacheBitsAsTwoTone ifTrue: [		"draw deEmphasized as a two-tone (monochrome) form"		model displayWorldAsTwoTone].! !!MorphWorldView methodsFor: 'as yet unclassified' stamp: 'dew 11/8/1999 02:01'!displayView	"This method is called by the system when the top view is framed or moved."	| topView |	model viewBox: self insetDisplayBox.	self updateSubWindowExtent.	topView _ self topView.	(topView == ScheduledControllers scheduledControllers first view		or: [topView cacheBitsAsTwoTone not])		ifTrue: [model displayWorldSafely]		ifFalse: [model displayWorldAsTwoTone].  "just restoring the screen"! !!MorphWorldView methodsFor: 'as yet unclassified' stamp: 'RAA 11/25/1999 09:19'!updateSubWindowExtent	"If this MorphWorldView represents a single Morphic SystemWindow, then update that window to match the size of the WorldView."	| numMorphs subWindow scrollBarWidth |	numMorphs _ model submorphs size.	"(Allow for the existence of an extra NewHandleMorph (for resizing).)"	(numMorphs = 0 or: [numMorphs > 2]) ifTrue: [^ self].	subWindow _ model submorphs					detect: [:ea | ea respondsTo: #label]					ifNone: [^ self].	superView label = subWindow label ifFalse: [^ self].	(Preferences valueOfFlag: #inboardScrollbars)		ifTrue: [scrollBarWidth _ 0]		ifFalse: [scrollBarWidth _ 14].	subWindow position: model position + (scrollBarWidth@-16).	"adjust for WiW changes"	subWindow extent: model extent - (scrollBarWidth@-16).	subWindow isActive ifFalse: [subWindow activate].! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'RAA 11/25/1999 23:43'!convertToMVCWiWPasteUpMorph"MorphWorldView convertToMVCWiWPasteUpMorph"	| current w newModel topView |	Smalltalk isMorphic ifTrue: [^self inform: 'do this in MVC'].	current _ self allInstances select: [ :each | each model class == PasteUpMorph].	current do: [ :oldWorldView |		w _ MVCWiWPasteUpMorph newWorldForProject: nil.		w 			color: oldWorldView model color;			addAllMorphs: oldWorldView model submorphs.		newModel _ CautiousModel new initialExtent: 300@300.		topView _ self fullColorWhenInactive			ifTrue: [ColorSystemView new]			ifFalse: [StandardSystemView new].		topView			model: newModel;			label: oldWorldView topView label;			borderWidth: 1;			addSubView: (self new initialize model: w);			backgroundColor: w color.		topView controller openNoTerminate.		topView reframeTo: (oldWorldView topView expandedFrame expandBy:				(0@0 extent: (0@topView labelHeight))).		oldWorldView topView controller closeAndUnscheduleNoTerminate.	].	ScheduledControllers restore.	Processor terminateActive.! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'sw 9/21/1998 17:54'!openOn: aWorldMorph label: aString cautionOnClose: aBoolean	"Open a view with the given label on the given WorldMorph."	| aModel |	aModel _ aBoolean		ifTrue:		[CautiousModel new]		ifFalse:		[WorldViewModel new].	^ self openOn: aWorldMorph label: aString model: (aModel initialExtent: aWorldMorph initialExtent)! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'di 11/26/1999 11:46'!openWorld	| w |	(w _ MVCWiWPasteUpMorph newWorldForProject: nil).	w bounds: (0@0 extent: 400@300).	self openOn: w		label: 'A Morphic World'		extent: w fullBounds extent + 2.! !!MorphWorldView class methodsFor: 'instance creation' stamp: 'sma 6/12/2000 14:18'!openWorldWith: aMorph labelled: labelString	| w |	(w _ MVCWiWPasteUpMorph newWorldForProject: nil) addMorph: aMorph.	w extent: aMorph fullBounds extent.	w startSteppingSubmorphsOf: aMorph.	self openOn: w		label: labelString		extent: w fullBounds extent + 2.! !I describe Morphic input events such as keystrokes and mouse movements.	type -- a Symbol identifying the type of event (#mouse, #keyboard, etc.)	cursorPoint -- the coordinates of the mouse cursor	buttons -- bit-packed integer indicating the state of the mouse buttons and modifier keys	keyValue -- ASCII value of the key pressed	sourceHand -- the HandMorph that generated this eventMorphicEvents are created when a HandMorph receives the message processEvents.!!MorphicEvent methodsFor: 'mouse' stamp: 'bf 9/22/1999 12:58'!blueButtonPressed	"Answer true if the blue mouse button is being pressed. This is the third mouse button or cmd+click on the Mac."	^ buttons anyMask: 1! !!MorphicEvent methodsFor: 'mouse' stamp: 'bf 9/22/1999 12:41'!redButtonPressed	"Answer true if the red mouse button is being pressed. This is the first mouse button."	^ buttons anyMask: 4! !!MorphicEvent methodsFor: 'mouse' stamp: 'ar 11/15/1998 23:42'!transformedBy: aMorphicTransform	"Return a copy of the receiver transformed by the given transformation."	aMorphicTransform isIdentity ifTrue: [^ self].  "no transformation needed"	^ self copy setCursorPoint: (aMorphicTransform globalPointToLocal: cursorPoint)! !!MorphicEvent methodsFor: 'mouse' stamp: 'jm 11/22/2002 11:43'!translatedBy: delta	"Answer a new event whose cursorPoint is is offset by the given delta."	^ self shallowCopy setCursorPoint: cursorPoint + delta! !!MorphicEvent methodsFor: 'mouse' stamp: 'bf 9/22/1999 12:42'!yellowButtonPressed	"Answer true if the yellow mouse button is being pressed. This is the second mouse button or option+click on the Mac."	^ buttons anyMask: 2! !!MorphicEvent methodsFor: 'keyboard' stamp: 'di 9/28/1999 08:29'!anyModifierKeyPressed	"ignore, however, the shift keys 'cause that's not REALLY a command key "	^ self buttons anyMask: 16r70	"cmd | opt | ctrl"! !!MorphicEvent methodsFor: 'keyboard' stamp: 'jm 5/29/1998 14:20'!shiftPressed	"Answer true if the shift key on the keyboard was being held down when this event occurred."	^ buttons anyMask: 8! !!MorphicEvent methodsFor: 'private' stamp: 'tk 3/10/1999 11:24'!setButtons: mask	buttons _ mask! !!MorphicEvent methodsFor: 'private' stamp: 'ar 6/2/1999 14:35'!setCursorPoint: aPoint	cursorPoint _ aPoint.! !!MorphicEvent class methodsFor: 'instance creation' stamp: 'di 2/6/1999 12:42'!readFrom: aStream	"Read a MorphicEvent from the given stream."	| type x y buttons keyValue typeString c |	typeString _ String streamContents:		[:s |   [(c _ aStream next) isLetter] whileTrue: [s nextPut: c]].	typeString = 'mouseMove'		ifTrue: [type _ #mouseMove  "fast treatment of common case"]		ifFalse: [type _ typeString asSymbol].	x _ Integer readFrom: aStream.	aStream skip: 1.	y _ Integer readFrom: aStream.	aStream skip: 1.	buttons _ Integer readFrom: aStream.	aStream skip: 1.	keyValue _ Integer readFrom: aStream.	^ self basicNew setType: type		cursorPoint: x@y		buttons: buttons		keyValue: keyValue! !This class implements simple translation, scaling and rotation for points, as well as inverse transformations.  These transformations are used in TransformMorphs (clipping scrollers) and TransformationMorphs (general flex-morph wrappers) to map, eg, global mouse coords into local coords, and to invert, eg, local damage rectangles into global damage rectangles.!!MorphicTransform methodsFor: 'accessing' stamp: 'ar 11/9/1998 14:33'!inverseTransformation	"Return the inverse transformation of the receiver"	^MorphicTransform		offset: (self transform: 0@0) - (self transform: offset)		angle: angle negated		scale: scale reciprocal! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/28/1999 09:10'!invert: aPoint	"Transform the given point from local to global coordinates."	| p3 p2 |	self isPureTranslation ifTrue: [^ aPoint - offset].	p3 _  aPoint * scale.	p2 _ ((p3 x * angle cos) + (p3 y * angle sin))		@ ((p3 y * angle cos) - (p3 x * angle sin)).	^ (p2 - offset)! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/3/1998 00:18'!invertBoundsRect: aRectangle	"Return a rectangle whose coordinates have been transformed	from local back to global coordinates.  NOTE: if the transformation	is not just a translation, then it will compute the bounding box	in global coordinates."	| outerRect |	self isPureTranslation	ifTrue:		[^ (self invert: aRectangle topLeft)			corner: (self invert: aRectangle bottomRight)]	ifFalse:		[outerRect _ Rectangle encompassing:			(aRectangle innerCorners collect: [:p | self invert: p]).		"Following asymmetry due to likely subsequent truncation"		^ outerRect topLeft - (1@1) corner: outerRect bottomRight + (2@2)]! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/2/1998 08:54'!invertRect: aRectangle	self error: 'method name changed to emphasize enclosing bounds'.	^ self invertBoundsRect: aRectangle! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/28/1999 09:05'!transform: aPoint	"Transform the given point from global to local coordinates."	| p2 p3 |	self isPureTranslation ifTrue: [^ aPoint + offset].	p2 _ aPoint + offset.	p3 _ (((p2 x * angle cos) - (p2 y * angle sin))		@ ((p2 y * angle cos) + (p2 x * angle sin)))			/ scale.	^ p3! !!MorphicTransform methodsFor: 'transformations' stamp: 'di 10/3/1998 00:18'!transformBoundsRect: aRectangle	"Return a rectangle whose coordinates have been transformed	from global to local coordinates.  NOTE: if the transformation	is not just a translation, then it will compute the bounding box	in global coordinates."	| outerRect |	self isPureTranslation	ifTrue:		[^ (self transform: aRectangle topLeft)			corner: (self transform: aRectangle bottomRight)]	ifFalse:		[outerRect _ Rectangle encompassing:			(aRectangle innerCorners collect: [:p | self transform: p]).		"Following asymmetry due to likely subsequent truncation"		^ outerRect topLeft - (1@1) corner: outerRect bottomRight + (2@2)]! !!MorphicTransform methodsFor: 'initialize' stamp: 'ar 11/2/1998 20:58'!setIdentiy	scale _ 1.0.	offset _ 0@0.	angle _ 0.0.! !!MorphicTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 20:57'!isIdentity	"Return true if the receiver is the identity transform; that is, if applying to a point returns the point itself."	^ self isPureTranslation and: [offset = (0@0)]! !!MorphicTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 19:51'!isMorphicTransform	^true! !!MorphicTransform methodsFor: 'testing' stamp: 'ar 11/2/1998 20:57'!isPureTranslation	"Return true if the receiver specifies no rotation or scaling."	^ angle = 0.0 and: [scale = 1.0]! !!MorphicTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:13'!globalPointToLocal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^self transform: aPoint! !!MorphicTransform methodsFor: 'transforming points' stamp: 'ar 11/2/1998 16:32'!localPointToGlobal: aPoint	"Transform aPoint from global coordinates into local coordinates"	^self invert: aPoint! !!MorphicTransform methodsFor: 'converting' stamp: 'ar 11/2/1998 20:14'!asMatrixTransform2x3	^((MatrixTransform2x3 withRotation: angle radiansToDegrees negated) composedWithLocal:		(MatrixTransform2x3 withScale: scale))			offset: offset negated! !!MorphicTransform methodsFor: 'converting' stamp: 'di 10/26/1999 17:03'!asMorphicTransform	^ self! !!MorphicTransform methodsFor: 'printing' stamp: 'ar 5/19/1999 18:21'!printOn: aStream	super printOn: aStream.	aStream nextPut:$(;		nextPutAll:'angle = '; print: angle;		nextPutAll:'; scale = '; print: scale;		nextPutAll:'; offset = '; print: offset;		nextPut:$).! !!MorphicTransform methodsFor: 'encoding' stamp: 'ls 10/9/1999 19:06'!encodeForRemoteCanvas	"encode this transform into a string for use by a RemoteCanvas"	^String streamContents: [ :str |		str nextPutAll: 'Morphic,';			print: offset x truncated;			nextPut: $,;			print: offset y truncated;			nextPut: $,;			print: scale;			nextPut: $,;			print: angle	]! !!MorphicTransform class methodsFor: 'instance creation' stamp: 'jm 6/20/2003 10:12'!fromRemoteCanvasEncoding: encoded	| rs type offsetXEnc offsetYEnc scaleEnc angleEnc offsetX offsetY scale angle |	"separate the numbers"	rs _ ReadStream on: encoded.	type _ rs upTo: $,.	offsetXEnc _ rs upTo: $,.	offsetYEnc _ rs upTo: $,.	scaleEnc _ rs upTo: $,.	angleEnc _ rs upToEnd.	"decode the numbers"	offsetX _ Integer readFrom: (ReadStream on: offsetXEnc).	offsetY _ Integer readFrom: (ReadStream on: offsetYEnc).	scale _ Number readFrom: (ReadStream on: scaleEnc).	angle _ Number readFrom: (ReadStream on: angleEnc).	"create an instance"	^ self offset: offsetX@offsetY angle: angle scale: scale! !A draggable handle used by Polygon morph and Halos.!!MouseHandleMorph methodsFor: 'accessing' stamp: 'jm 10/11/2002 12:00'!argument	^ argument! !!MouseHandleMorph methodsFor: 'accessing' stamp: 'jm 10/11/2002 15:36'!mouseDownSelector	^ mouseDownSelector! !!MouseHandleMorph methodsFor: 'accessing' stamp: 'jm 10/11/2002 12:01'!mouseDownSelector: sel	mouseDownSelector _ sel asSymbol.! !!MouseHandleMorph methodsFor: 'accessing' stamp: 'jm 10/11/2002 12:48'!mouseMoveSelector: sel	mouseMoveSelector _ sel asSymbol.! !!MouseHandleMorph methodsFor: 'accessing' stamp: 'jm 10/11/2002 12:01'!mouseUpSelector: sel	mouseUpSelector _ sel asSymbol.! !!MouseHandleMorph methodsFor: 'accessing' stamp: 'jm 10/11/2002 14:46'!mouseUpTarget	^ mouseUpTarget! !!MouseHandleMorph methodsFor: 'accessing' stamp: 'jm 10/11/2002 15:02'!mouseUpTarget: anObject	"Set the secondary target to notify instead of the normal target on mouse up."	mouseUpTarget _ anObject.! !!MouseHandleMorph methodsFor: 'accessing' stamp: 'jm 10/11/2002 11:58'!target	^ target! !!MouseHandleMorph methodsFor: 'accessing' stamp: 'jm 10/11/2002 11:58'!target: anObject	target _ anObject.! !!MouseHandleMorph methodsFor: 'accessing' stamp: 'jm 10/11/2002 12:00'!target: anObject argument: argOrNil	target _ anObject.	argument _ argOrNil.! !!MouseHandleMorph methodsFor: 'event handling' stamp: 'jm 10/11/2002 12:46'!handlesMouseDown: evt	^ true! !!MouseHandleMorph methodsFor: 'event handling' stamp: 'jm 10/11/2002 14:48'!mouseDown: evt	self send: mouseDownSelector to: target withEvent: evt.! !!MouseHandleMorph methodsFor: 'event handling' stamp: 'jm 10/11/2002 14:48'!mouseMove: evt	self send: mouseMoveSelector to: target withEvent: evt.! !!MouseHandleMorph methodsFor: 'event handling' stamp: 'jm 10/11/2002 15:01'!mouseUp: evt	"If mouseUpTarget is not nil, notify it rather than the normal target."	| client |	client _ mouseUpTarget ifNil: [target] ifNotNil: [mouseUpTarget].	self send: mouseUpSelector to: client withEvent: evt.! !!MouseHandleMorph methodsFor: 'event handling' stamp: 'jm 10/11/2002 14:47'!send: selector to: client withEvent: event	"Send the given selector to the given object with the given event. The selector can take up to three arguments."	| argCount |	client isNil | selector isNil ifTrue: [^ self].	argCount _ selector numArgs.	argCount = 0 ifTrue:		[^ client perform: selector].	argCount = 1 ifTrue:		[^ client perform: selector with: event].	argCount = 2 ifTrue:		[^ client perform: selector with: event with: self].	argCount = 3 ifTrue:		[^ client perform: selector with: event with: self with: argument].	self error: 'selector must take 0-3 arguments'.! !I am a Controller that modifies the scheduling of user activities so that the three mouse buttons can be used to make selections or display menus. The menu items are unary messages to the value of sending my instance the message menuMessageReceiver.!!MouseMenuController methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 15:54'!release	super release.	redButtonMenu release! !!MouseMenuController methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 15:54'!reset	"Eliminate references to all mouse button menus."	redButtonMenu _ nil.	redButtonMessages _ nil! !!MouseMenuController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:28'!controlActivity	"Refer to the comment in Controller|controlActivity."	| cursorPoint |	cursorPoint _ sensor cursorPoint.	super controlActivity.	(cursorPoint = sensor cursorPoint and: [self viewHasCursor])		ifTrue: 			[sensor redButtonPressed ifTrue: [^ self redButtonActivity].			sensor yellowButtonPressed ifTrue: [^ self yellowButtonActivity].			sensor blueButtonPressed ifTrue: [^ self blueButtonActivity]]! !!MouseMenuController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 11:24'!isControlActive 	"In contrast to class Controller, only blue button but not yellow button	events will end the receiver's control loop."	^ self viewHasCursor and: [sensor blueButtonPressed not]! !!MouseMenuController methodsFor: 'menu setup'!redButtonMenu: aSystemMenu redButtonMessages: anArray 	"Initialize the pop-up menu that should appear when the user presses the 	red mouse button to be aSystemMenu. The corresponding messages that 	should be sent are listed in the array, anArray."	redButtonMenu release.	redButtonMenu _ aSystemMenu.	redButtonMessages _ anArray! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sma 3/11/2000 15:01'!blueButtonActivity	"This normally opens the window menu. It is a no-op here	as only the StandardSystemController deals with that kind	of menus."! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sma 3/11/2000 14:56'!redButtonActivity	"Determine which item in the red button pop-up menu is selected. If one 	is selected, then send the corresponding message to the object designated 	as the menu message receiver."	| index |	redButtonMenu ~~ nil		ifTrue: 			[index _ redButtonMenu startUp.			index ~= 0 				ifTrue: [self perform: (redButtonMessages at: index)]]		ifFalse: [super controlActivity]! !!MouseMenuController methodsFor: 'menu messages' stamp: 'sma 3/11/2000 14:59'!yellowButtonActivity	"This normally opens a popup menu. Determine the selected	item and, if one is selected, then send the corresponding message	to either the model or the receiver."	^ self pluggableYellowButtonActivity: sensor leftShiftDown! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 12:36'!getPluggableYellowButtonMenu: shiftKeyState	^ view getMenu: shiftKeyState! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 12:38'!pluggableYellowButtonActivity: shiftKeyState	"Invoke the model's popup menu."	| menu selector |	(menu _ self getPluggableYellowButtonMenu: shiftKeyState)		ifNil: [sensor waitNoButton]		ifNotNil:			[(selector _ menu startUp) ifNil: [^ self].			self terminateAndInitializeAround: [model perform: selector orSendTo: self]]! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 12:37'!shiftedYellowButtonActivity	"Invoke the model's special popup menu."	^ self pluggableYellowButtonActivity: true! !!MouseMenuController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 12:37'!unshiftedYellowButtonActivity	"Invoke the model's normal popup menu."	^ self pluggableYellowButtonActivity: false! !I am a simple display screen for a movie player. My step method advances the movie according to the current frame rate. If necessary, frames as skipped to maintain the desired frame rate. However, since even skipping frames takes time, it may not be possible to achieve fast frame rates with large frame sizes on slow machines.!!MovieDisplayMorph methodsFor: 'initialization' stamp: 'jm 11/20/2001 15:00'!initialize	super initialize.	super extent: 250@0.	frameBuffer _ nil.	mpegFile _ nil.	running _ false.		desiredFrameRate _ 10.0.	allowFrameDropping _ true.	repeat _ false.	soundTrack _ nil.	volume _ 0.5.! !!MovieDisplayMorph methodsFor: 'accessing' stamp: 'jm 11/16/2001 16:40'!extent: aPoint	"Overridden to maintain movie aspect ratio."	| scale |	frameBuffer ifNil: [^ super extent: aPoint].	scale _ (aPoint x / frameBuffer width) max: (aPoint y / frameBuffer height).	scale _ scale max: (16 / frameBuffer width).	super extent: (frameBuffer extent * scale) rounded.! !!MovieDisplayMorph methodsFor: 'accessing' stamp: 'jm 3/10/2003 13:30'!frameCount	^ mpegFile videoFrames: 0! !!MovieDisplayMorph methodsFor: 'accessing' stamp: 'jm 11/16/2001 16:29'!moviePosition	"Answer a number between 0.0 and 1.0 indicating the current position within the movie."	mpegFile ifNil: [^ 0.0].	mpegFile fileHandle ifNil: [^ 0.0].	mpegFile hasVideo		ifTrue: [^ ((mpegFile videoGetFrame: 0) asFloat / (mpegFile videoFrames: 0)) min: 1.0].	soundTrack ifNotNil: [^ soundTrack soundPosition].	^ 0.0! !!MovieDisplayMorph methodsFor: 'accessing' stamp: 'jm 12/16/2001 12:34'!moviePosition: fraction	"Jump to the position the given fraction through the movie. The argument is a number between 0.0 and 1.0."	| frameCount frameIndex |	self mpegFileIsOpen ifFalse: [^ self].	self stopPlaying.	mpegFile hasVideo ifTrue: [		frameCount _ mpegFile videoFrames: 0.		frameIndex _ (frameCount * fraction) truncated - 1.		frameIndex _ (frameIndex max: 0) min: (frameCount - 3).		mpegFile videoSetFrame: frameIndex stream: 0.		^ self nextFrame].	mpegFile hasAudio ifTrue: [		soundTrack soundPosition: fraction].! !!MovieDisplayMorph methodsFor: 'accessing' stamp: 'jm 6/3/2001 14:34'!repeat	"Answer the repeat flag."	repeat ifNil: [repeat _ false].	^ repeat! !!MovieDisplayMorph methodsFor: 'accessing' stamp: 'jm 6/3/2001 14:33'!repeat: aBoolean	"Set the repeat flag. If true, the movie will loop back to the beginning when it gets to the end."	repeat _ aBoolean.! !!MovieDisplayMorph methodsFor: 'accessing' stamp: 'jm 6/3/2001 14:35'!volume	"Answer the sound playback volume."	^ volume! !!MovieDisplayMorph methodsFor: 'accessing' stamp: 'jm 6/13/2001 16:12'!volume: aNumber	"Set the sound playback volume to the given level, between 0.0 and 1.0."	volume _ aNumber asFloat.	volume < 0.0 ifTrue: [volume _ 0.0].	volume > 1.0 ifTrue: [volume _ 1.0].	soundTrack ifNotNil: [soundTrack volume: volume].! !!MovieDisplayMorph methodsFor: 'file open/close' stamp: 'jm 2/21/2001 21:51'!closeFile	"Close my MPEG file, if any."	mpegFile ifNotNil: [		mpegFile closeFile.		mpegFile _ nil.		frameBuffer _ nil].	self changed.! !!MovieDisplayMorph methodsFor: 'file open/close' stamp: 'jm 3/22/2001 12:42'!mpegFileIsOpen	"Answer true if I have an open, valid MPEG file handle. If the handle is not valid, try to re-open the file."	mpegFile ifNil: [^ false].	mpegFile fileHandle ifNil: [		"try to reopen the file, which may have been saved in a snapshot"		mpegFile openFile: mpegFile fileName.		mpegFile fileHandle ifNil: [mpegFile _ nil]].	^ mpegFile notNil! !!MovieDisplayMorph methodsFor: 'file open/close' stamp: 'jm 11/17/2001 09:48'!openFileNamed: mpegFileName	"Try to open the MPEG file with the given name. Answer true if successful."	| e |	self closeFile.	(FileDirectory default fileExists: mpegFileName)		ifFalse: [self inform: 'File not found: ', mpegFileName. ^ false].	(MPEGFile isFileValidMPEG: mpegFileName)		ifTrue: [mpegFile _ MPEGFile openFile: mpegFileName]		ifFalse: [			(JPEGMovieFile isJPEGMovieFile: mpegFileName)				ifTrue: [mpegFile _ JPEGMovieFile new openFileNamed: mpegFileName]				ifFalse: [self inform: 'Not an MPEG or JPEG movie file: ', mpegFileName. ^ false]].	mpegFile fileHandle ifNil: [^ false].	"initialize soundTrack"	mpegFile hasAudio		ifTrue: [soundTrack _ mpegFile audioPlayerForChannel: 1]		ifFalse: [soundTrack _ nil].	mpegFile hasVideo		ifTrue: [  "set screen size and display first frame"			desiredFrameRate _ mpegFile videoFrameRate: 0.			soundTrack ifNotNil: [  "compute frame rate from length of audio track"				desiredFrameRate _ (mpegFile videoFrames: 0) / soundTrack duration].			e _ (mpegFile videoFrameWidth: 0)@(mpegFile videoFrameHeight: 0).			frameBuffer _ Form extent: e depth: (Display depth max: 16).			super extent: e.			self nextFrame]		ifFalse: [  "hide screen for audio-only files"			super extent: 250@0].! !!MovieDisplayMorph methodsFor: 'file open/close' stamp: 'jm 10/31/2002 08:49'!openMPEGFile	"Invoked by the 'Open' button. Prompt for a file name and try to open that file as an MPEG file."	| result fileName |	result _ StandardFileMenu oldFile.	result ifNil: [^ self].	fileName _ result directory pathName, FileDirectory slash, result name.	self stopPlaying.	self openFileNamed: fileName.! !!MovieDisplayMorph methodsFor: 'drawing' stamp: 'jm 3/20/2001 15:57'!areasRemainingToFill: aRectangle	"Drawing optimization. Since I completely fill my bounds with opaque pixels, this method tells Morphic that it isn't necessary to draw any morphs covered by me."		^ aRectangle areasOutside: self bounds! !!MovieDisplayMorph methodsFor: 'drawing' stamp: 'jm 11/11/2001 15:49'!drawOn: aCanvas	"Draw the current frame image, if there is one. Otherwise, fill screen with gray."	frameBuffer		ifNil: [aCanvas fillRectangle: self bounds color: (Color gray: 0.75)]		ifNotNil: [			self extent = frameBuffer extent				ifTrue: [aCanvas drawImage: frameBuffer at: bounds origin]				ifFalse: [self drawScaledOn: aCanvas]].! !!MovieDisplayMorph methodsFor: 'drawing' stamp: 'jm 5/29/2003 18:01'!drawScaledOn: aCanvas	"Draw the current frame image scaled to my bounds."	| outForm destPoint warpBlt |	((aCanvas isKindOf: FormCanvas) and: [aCanvas form = Display])		ifTrue: [  "optimization: when canvas is the Display, Warpblt directly to it"			outForm _ Display.			destPoint _ bounds origin + aCanvas origin]		ifFalse: [			outForm _ Form extent: self extent depth: aCanvas form depth.			destPoint _ 0@0].	warpBlt _ (WarpBlt toForm: outForm)		sourceForm: frameBuffer;		colorMap: (frameBuffer colormapIfNeededForDepth: outForm depth);		cellSize: 1;  "installs a new colormap if cellSize > 1"		combinationRule: Form over.	outForm == Display ifTrue: [warpBlt clipRect: aCanvas clipRect].	warpBlt		copyQuad: frameBuffer boundingBox innerCorners		toRect: (destPoint extent: self extent).	outForm == Display ifFalse: [		aCanvas drawImage: outForm at: bounds origin].! !!MovieDisplayMorph methodsFor: 'commands' stamp: 'jm 11/16/2001 15:39'!nextFrame	"Fetch the next frame into the frame buffer."	mpegFile ifNil: [^ self].	mpegFile videoReadFrameInto: frameBuffer stream: 0.	self changed.! !!MovieDisplayMorph methodsFor: 'commands' stamp: 'jm 4/6/2001 08:31'!previousFrame	"Go to the previous frame."	| n |	mpegFile ifNil: [^ self].	running ifTrue: [^ self].	n _ (mpegFile videoGetFrame: 0) - 2.	n _ (n min: ((mpegFile videoFrames: 0) - 3)) max: 0.	mpegFile videoSetFrame: n stream: 0.	self nextFrame.! !!MovieDisplayMorph methodsFor: 'commands' stamp: 'jm 11/13/2001 07:36'!rewindMovie	"Rewind to the beginning of the movie."	"Details: Seeking by percent or frame number both seem to have problems, so just re-open the file."	| savedExtent savedRate |	self mpegFileIsOpen ifFalse: [^ self].	self stopPlaying.	"re-open the movie, retaining current extent and frame rate"	savedExtent _ self extent.	savedRate _ desiredFrameRate.	self openFileNamed: mpegFile fileName.  "recomputes rate and extent"	self extent: savedExtent.	desiredFrameRate _ savedRate.! !!MovieDisplayMorph methodsFor: 'commands' stamp: 'jm 3/21/2001 16:25'!setFrameRate	"Ask the user to specify the desired frame rate."	| rateString |	rateString _ FillInTheBlank		request: 'Desired frames per second?'		initialAnswer: desiredFrameRate printString.	rateString size = 0 ifTrue: [^ self].	desiredFrameRate _ rateString asNumber asFloat.	desiredFrameRate <= 0.1 ifTrue: [desiredFrameRate _ 0.1].! !!MovieDisplayMorph methodsFor: 'commands' stamp: 'jm 11/21/2001 17:56'!startPlaying	"Start playing the movie at the current position."	| frameIndex |	self stopPlaying.	self mpegFileIsOpen ifFalse: [^ self].	mpegFile hasAudio		ifTrue: [			mpegFile hasVideo ifTrue: [				"set movie frame position from soundTrack position"				soundTrack reset.  "ensure file is open before positioning"				soundTrack soundPosition: (mpegFile videoGetFrame: 0) asFloat / (mpegFile videoFrames: 0).				"now set frame index from the soundtrack position for best sync"				frameIndex _ ((soundTrack millisecondsSinceStart * desiredFrameRate) // 1000).				frameIndex _ (frameIndex max: 0) min: ((mpegFile videoFrames: 0) - 3).				mpegFile videoSetFrame: frameIndex stream: 0].			SoundPlayer stopReverb.			soundTrack volume: volume.			soundTrack repeat: repeat.			soundTrack resumePlaying.			startFrame _ startMSecs _ 0]		ifFalse: [			soundTrack _ nil.			startFrame _ mpegFile videoGetFrame: 0.			startMSecs _ Time millisecondClockValue].	running _ true.! !!MovieDisplayMorph methodsFor: 'commands' stamp: 'jm 6/3/2001 14:30'!stopPlaying	"Stop playing the movie."	running _ false.	soundTrack ifNotNil: [soundTrack pause].! !!MovieDisplayMorph methodsFor: 'stepping' stamp: 'jm 6/3/2001 18:38'!step	"If I'm running and the mpegFile is open and has video, advance to the next frame. Stop if we we hit the end of the video."	running ifFalse: [^ self].	mpegFile ifNil: [^ self].	(mpegFile hasVideo and:	 [(mpegFile videoGetFrame: 0) >= (mpegFile videoFrames: 0)])		ifTrue: [  "end of video"			self stopPlaying.			repeat ifTrue: [				self rewindMovie.				self startPlaying]]		ifFalse: [self advanceFrame].! !!MovieDisplayMorph methodsFor: 'stepping' stamp: 'jm 4/6/2001 08:47'!stepTime	"Run my step method as often as possible. Step does very little work if it is not time to advance to the next frame."	^ 0! !!MovieDisplayMorph methodsFor: 'other' stamp: 'jm 12/14/2001 15:11'!advanceFrame	"Advance to the next frame if it is time to do so, skipping frames if necessary."	| msecs currentFrame desiredFrame framesToAdvance |	mpegFile hasVideo ifFalse: [^ self].	soundTrack		ifNil: [msecs _ Time millisecondClockValue - startMSecs]		ifNotNil: [msecs _ soundTrack millisecondsSinceStart - SoundPlayer bufferMSecs].	desiredFrame _ startFrame + ((msecs * desiredFrameRate) // 1000) + 1.	desiredFrame _ desiredFrame min: (mpegFile videoFrames: 0).	currentFrame _ mpegFile videoGetFrame: 0.	framesToAdvance _ desiredFrame - currentFrame.	framesToAdvance <= 0 ifTrue: [^ self].	(allowFrameDropping and: [framesToAdvance > 1]) ifTrue: [		mpegFile videoDropFrames: framesToAdvance - 1 stream: 0].	self nextFrame.! !!MovieDisplayMorph methodsFor: 'other' stamp: 'jm 10/27/2002 10:56'!jpegMovieSize: quality	"Convert all my frames to a JPEG and measure the total size."	| jpegSize jpegDecodeTime mSecs outForm buf |	mpegFile hasVideo ifFalse: [^ self error: 'movie has no video'].	jpegSize _ 0.	jpegDecodeTime _ 0.	self rewindMovie.	[(mpegFile videoGetFrame: 0) < (mpegFile videoFrames: 0)] whileTrue: [		buf _ FastJPEG compress: frameBuffer quality: quality.		jpegSize _ jpegSize + buf size.		mSecs _ [			outForm _ FastJPEG uncompress: buf doDithering: false.		] timeToRun.		jpegDecodeTime _ jpegDecodeTime + mSecs.		outForm display.		frameBuffer displayAt: (outForm width + 10)@0.		self nextFrame].	^ Array with: jpegSize with: jpegDecodeTime with: (mpegFile videoFrames: 0)! !!MovieDisplayMorph methodsFor: 'other' stamp: 'jm 11/21/2001 16:58'!measureMaxFrameRate	"For testing. Play through the movie as fast as possible, updating the world each time, and report the frame rate."	| oldFrameRate oldFrameDropping t |	self rewindMovie.	oldFrameRate _ desiredFrameRate.	oldFrameDropping _ allowFrameDropping.	desiredFrameRate _ 1000.0.	allowFrameDropping _ false.	self startPlaying.	t _ [[running] whileTrue: [self world doOneCycleNow]] timeToRun.	desiredFrameRate _ oldFrameRate.	allowFrameDropping _ oldFrameDropping.	^ (mpegFile videoFrames: 0) / (t / 1000.0)! !!MovieDisplayMorph methodsFor: 'menu' stamp: 'jm 6/4/2003 22:01'!addSoundtrack	"Add a soundtrack to this JPEG movie."	| result soundFileName menu compression movieFileName |	(mpegFile isKindOf: JPEGMovieFile) ifFalse: [^ self].  "do nothing if not a JPEG movie"	result _ StandardFileMenu oldFile.	result ifNil: [^ self].	soundFileName _ result directory pathName, FileDirectory slash, result name.	menu _ CustomMenu new title: 'Compression type:'.	menu addList: #(		('none (353 kbps)' none)		('mulaw (176 kbps)' mulaw)		('adpcm5 (110 kbps)' adpcm5)		('adpcm4 (88 kbps)' adpcm4)		('adpcm3 (66 kbps)' adpcm3)		('gsm (36 kbps)' gsm)).	compression _ menu startUp.	compression ifNil: [^ self].	movieFileName _ mpegFile fileName.	mpegFile closeFile.	JPEGMovieFile		addSoundtrack: soundFileName		toJPEGMovieNamed: movieFileName		compressionType: compression.	self openFileNamed: movieFileName.! !!MovieDisplayMorph methodsFor: 'menu' stamp: 'jm 12/17/2001 08:15'!createJPEGfromFolderOfFrames	"Create a new JPEG movie file from an folder of individual frames. Prompt the user for the folder and file names and the quality setting, then do the conversion."	| result folderName jpegFileName q frameRate |	result _ StandardFileMenu oldFile.	result ifNil: [^ self].	folderName _ result directory pathName.	jpegFileName _ FillInTheBlank request: 'New movie name?'.	jpegFileName size = 0 ifTrue: [^ self].	(jpegFileName asLowercase endsWith: '.jmv') ifFalse: [		jpegFileName _ jpegFileName, '.jmv'].	result _ FillInTheBlank request: 'Quality level (1 to 100)?'.	q _ result ifNil: [50] ifNotNil: [(result asNumber rounded max: 1) min: 100].	result _ FillInTheBlank request: 'Frame rate?'.	frameRate _ result ifNil: [10] ifNotNil: [(result asNumber rounded max: 1) min: 100].	JPEGMovieFile		convertFromFolderOfFramesNamed: folderName		toJPEGMovieNamed: jpegFileName		frameRate: frameRate		quality: q.! !!MovieDisplayMorph methodsFor: 'menu' stamp: 'jm 12/17/2001 08:15'!createJPEGfromMPEG	"Create a new JPEG movie file from an MPEG movie. Prompt the user for the file names and the quality setting, then do the conversion."	| result mpegFileName jpegFileName q |	result _ StandardFileMenu oldFile.	result ifNil: [^ self].	mpegFileName _ result directory pathName, FileDirectory slash, result name.	jpegFileName _ FillInTheBlank request: 'New movie name?'.	jpegFileName size = 0 ifTrue: [^ self].	(jpegFileName asLowercase endsWith: '.jmv') ifFalse: [		jpegFileName _ jpegFileName, '.jmv'].	result _ FillInTheBlank request: 'Quality level (1 to 100)?'.	q _ result ifNil: [50] ifNotNil: [(result asNumber rounded max: 1) min: 100].	JPEGMovieFile convertMPEGFileNamed: mpegFileName toJPEGMovieNamed: jpegFileName quality: q.! !!MovieDisplayMorph methodsFor: 'menu' stamp: 'jm 10/31/2002 10:32'!invokeMenu	"Invoke a menu of additonal functions."	| aMenu |	aMenu _ CustomMenu new.	repeat		ifTrue: [aMenu add: 'turn off repeat (now on)' action: #toggleRepeat]		ifFalse: [aMenu add: 'turn on repeat (now off)' action: #toggleRepeat].	aMenu addList:	#(		-		('set frame rate'							setFrameRate)		-		('create JPEG movie from MPEG'				createJPEGfromMPEG)		('create JPEG movie from folder of frames'	createJPEGfromFolderOfFrames)		-	).	(mpegFile isKindOf: JPEGMovieFile) ifTrue: [		mpegFile hasAudio			ifTrue: [aMenu add: 'remove all soundtracks' action: #removeAllSoundtracks]			ifFalse: [aMenu add: 'add soundtrack' action: #addSoundtrack]].	aMenu invokeOn: self defaultSelection: nil.! !!MovieDisplayMorph methodsFor: 'menu' stamp: 'jm 12/13/2001 20:48'!removeAllSoundtracks	"Remove all soundtracks from this JPEG movie."	(mpegFile isKindOf: JPEGMovieFile) ifFalse: [^ self].  "do nothing if not a JPEG movie"	mpegFile closeFile.	JPEGMovieFile removeSoundtrackFromJPEGMovieNamed: mpegFile fileName.	self openFileNamed: mpegFile fileName.! !!MovieDisplayMorph methodsFor: 'menu' stamp: 'jm 12/13/2001 08:55'!toggleRepeat	"Toggle the repeat flag."	repeat _ repeat not.! !I provide the user-interface for playing MPEG movies, including play/stop/rewind buttons and volume and position sliders. To create an instance of me, evaluate:  MoviePlayerMorph new openInWorldThen use the "open" button to open an MPEG or JPEG movie file or an MP3 audio file. This class just supplies the front panel; the real work is done by MovieDisplayMorph and StreamingMP3Sound.!!MoviePlayerMorph methodsFor: 'initialization' stamp: 'jm 1/8/2003 08:34'!initialize	super initialize.	self color: (Color gray: 0.9).  "old color"	self hResizing: #shrinkWrap; vResizing: #shrinkWrap.	borderWidth _ 2.	self orientation: #vertical.	self cornerStyle: #rounded.	self inset: 4.	moviePlayer _ MovieDisplayMorph new.	self addMorphFront: moviePlayer.	self addButtonRow.	self addVolumeSlider.	self addPositionSlider.	self extent: 10@10.  "make minimum size"! !!MoviePlayerMorph methodsFor: 'drawing' stamp: 'jm 11/13/2001 09:12'!drawOn: aCanvas	"Optimization: Do not draw myself if the movie player is one of my submorphs and the only damage is contained within it. This avoids overdrawing while playing a movie."	((moviePlayer owner == self) and:	 [moviePlayer bounds containsRect: aCanvas clipRect])		ifFalse: [super drawOn: aCanvas].! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'jm 4/6/2001 07:49'!step	"Update the position slider from the current movie position."	positionSlider adjustToValue: moviePlayer moviePosition.! !!MoviePlayerMorph methodsFor: 'stepping' stamp: 'jm 5/30/2001 23:33'!stepTime	"Update the position slider a few times a second."	^ 500! !!MoviePlayerMorph methodsFor: 'private' stamp: 'jm 12/13/2001 08:59'!addButtonRow	| r |	r _ AlignmentMorph newRow vResizing: #shrinkWrap; color: Color transparent.	r addMorphBack: (self buttonName: 'Open' action: #openMPEGFile).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Menu' action: #invokeMenu).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Rewind' action: #rewindMovie).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Play' action: #startPlaying).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Stop' action: #stopPlaying).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: '<' action: #previousFrame).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: '>' action: #nextFrame).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	self addMorphBack: r.! !!MoviePlayerMorph methodsFor: 'private' stamp: 'jm 10/26/2002 22:17'!addPositionSlider	| r |	positionSlider _ SimpleSliderMorph new		color: (Color r: 0.71 g: 0.871 b: 1.0);		extent: 200@2;		target: moviePlayer;		actionSelector: #moviePosition:;		adjustToValue: 0.	r _ AlignmentMorph newRow		color: Color transparent;		inset: 0;		centering: #center;		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'start ').	r addMorphBack: positionSlider.	r addMorphBack: (StringMorph contents: ' end').	self addMorphBack: r.! !!MoviePlayerMorph methodsFor: 'private' stamp: 'jm 10/26/2002 22:17'!addVolumeSlider	| levelSlider r |	levelSlider _ SimpleSliderMorph new		color: (Color r: 0.71 g: 0.871 b: 1.0);		extent: 200@2;		target: moviePlayer;		actionSelector: #volume:;		adjustToValue: 0.5.	r _ AlignmentMorph newRow		color: Color transparent;		inset: 0;		centering: #center;		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: '  soft ').	r addMorphBack: levelSlider.	r addMorphBack: (StringMorph contents: ' loud').	self addMorphBack: r.! !!MoviePlayerMorph methodsFor: 'private' stamp: 'jm 10/26/2002 17:22'!buttonName: aString action: aSymbol	^ SimpleButtonMorph new		target: moviePlayer;		label: aString;		actionSelector: aSymbol;		color: (Color gray: 0.8);		borderWidth: 0;		borderColor: #raised.! !!MoviePlayerMorph methodsFor: 'private' stamp: 'jm 3/10/2003 13:28'!moviePlayer	^ moviePlayer! !!MoviePlayerMorph class methodsFor: 'as yet unclassified' stamp: 'jm 5/31/2003 20:04'!includeInNewMorphMenu	^ true! !I implement an abstract server for message-based, request/reply interactions.In a "message-based" client/server interaction, the unit of communication is messages, not strings or data streams. A message in this context is simply a ByteArray or String of arbitrary size. The server follows a request/reply interaction model in which the server is passive until it receives a request message. For each request, it computes a reply message which is returned to the client. Every request must generate a reply of some sort, even if it is merely a zero-length message. Requests from a given client are handled sequentially. The request/reply model is similar to procedure call/return, which is familiar and easy to reason about.The message-based server abstraction hides most of the details of transmitting and receiving data over a socket, allowing the programmer to focus on designing the requests/reply interactions needed for a specific application. Although this server can handle messages up to 2^32 bytes, there is a practical limit on the size of messages and replies, since messages are buffered in memory. Thus this server design is not appropriate for serving larger files or for streaming audio or movie data.The server performs the following tasks:  assembles incoming data into complete messages  dispatching each message for processing  transmits the reply message back to the clientTo create a new kind of server, one typically makes a subclass of this class and implements:  o the instance method "processMessage:" to process incoming messages  o the class method "portNumber" to return port number on which the server will listenWhile servers can interpret messages any way they like, one useful convention is to use the first byte to identify the type of the request or reply message.To start and stop a server use:  o forkServerProcess to run the server in the background or runServer to run it in the UI thread  o stopServer to stop the server, kill it's thread (if any), and clean up all sockets!!MsgServer methodsFor: 'initialization' stamp: 'jm 9/5/2001 07:48'!initialize	"Initialize my state."	serverSocket _ nil.	serverProcess _ nil.	connections _ OrderedCollection new.! !!MsgServer methodsFor: 'accessing' stamp: 'jm 9/5/2001 12:07'!portNumber	"Answer the number of the port on which this server listens."	^ self class portNumber! !!MsgServer methodsFor: 'start/stop' stamp: 'jm 7/22/2002 14:27'!forkServerProcess	"Fork a process to run the server. This is useful if you want to run the client and the server in the same Squeak image, or if you need to run multiple servers. For debugging, you can run the server synchronously in the UI thread using 'runServer'. In this case, any errors will halt the server in a debugger."	self stopServer.	self serverStartup.	self openServerSocket.	serverProcess _ [self serverLoop] newProcess.	serverProcess		priority: Processor userInterruptPriority;		resume.	Transcript show: 'Server started.'; cr.! !!MsgServer methodsFor: 'start/stop' stamp: 'jm 9/26/2001 15:16'!runServer	"Run the server loop synchronously in the Squeak UI thread. This is useful to debugging, since if the server gets an error you can debug it and proceed. To stop the server, hit the interrupt key, then send it 'stopServer'. You can also run the server in the background using forkServerProcess, allowing clients to be run in the same Squeak image."	self stopServer.	self serverStartup.	self openServerSocket.	self serverLoop.! !!MsgServer methodsFor: 'start/stop' stamp: 'jm 9/26/2001 13:21'!serverShutdown	"Sent when the server is shutting down. Subclasses can override this message to do their own shutdown actions."! !!MsgServer methodsFor: 'start/stop' stamp: 'jm 9/26/2001 13:20'!serverStartup	"Sent when the server is starting up. Subclasses can override this message to do their own initialization at startup time."! !!MsgServer methodsFor: 'start/stop' stamp: 'jm 9/26/2001 14:19'!stopServer	"Stop this server and destroy all sockets. If the server was started using 'forkServerProcess', terminate the server process."	serverProcess ifNotNil: [serverProcess terminate].	serverProcess _ nil.	serverSocket ifNotNil: [serverSocket destroy].	serverSocket _ nil.	connections do: [:sock | sock destroy].	connections _ OrderedCollection new.	self serverShutdown.	Transcript show: 'Server stopped.'; cr.! !!MsgServer methodsFor: 'request handling' stamp: 'jm 1/7/2003 10:45'!processMessage: aByteArray	"Process the given message and return a String or ByteArray to be sent back to the client as the response. Typically, the first byte of the argument determines the operation to be performed. This method should be overridden by subclasses to provide their own server behavior. This default implementation simply answer the null (zero length) message."	"Note: If this method return nil or self, the null message is returned to the client."	^ ''! !!MsgServer methodsFor: 'request handling' stamp: 'jm 1/18/2003 11:00'!processMessage: aByteArray requestSocket: aSocket	"Process the given message and return a String or ByteArray to be sent back to the client as the response. Overriding this method allows a subclass to access the requesting socket, but message servers that don't need that socket should implement processMessage: instead. See additional comments in processMessage:."	"Details: The request socket will be destroyed when this method returns."	^ self processMessage: aByteArray! !!MsgServer methodsFor: 'private' stamp: 'jm 9/26/2001 15:10'!forkRequestLoopOnSocket: aSocket	"Fork a process to handle requests on the given socket."	[self requestLoopWithErrorRecoveryOnSocket: aSocket] fork.! !!MsgServer methodsFor: 'private' stamp: 'jm 6/27/2002 13:04'!openServerSocket	"Open a socket on my port and get ready to accept requests. If I am already running, clear the state of any current client connections and close their sockets."	Socket initializeNetwork.	serverSocket _ Socket new.	serverSocket		listenOn: self portNumber		backlogSize: self class backlogSize.! !!MsgServer methodsFor: 'private' stamp: 'jm 1/18/2003 10:58'!requestLoopOnSocket: aSocket	"This is the request handling loop."	"Details: This loop terminates and destroys the message socket if the connection is broken, either by the client or by a network failure."	| requestSock busy msg reply |	requestSock _ MessageSocket new on: aSocket.	[requestSock isConnected] whileTrue: [		busy _ requestSock sendData.		msg _ requestSock nextMessage.		msg ifNotNil: [			busy _ true.			reply _ self processMessage: msg requestSocket: requestSock.			((reply == nil) or: [reply == self]) ifTrue: [reply _ ByteArray new].			requestSock sendMessage: reply].		busy ifFalse: [(Delay forMilliseconds: 10) wait]].  "sleep a while if idle"	requestSock socket destroy.	connections remove: aSocket ifAbsent: [].! !!MsgServer methodsFor: 'private' stamp: 'jm 9/26/2001 15:10'!requestLoopWithErrorRecoveryOnSocket: aSocket	"Process requests on the given socket. If there are any errors, destroy the socket and return."	[self requestLoopOnSocket: aSocket]		ifError: [:err :rcvr |			aSocket destroy.			connections remove: aSocket ifAbsent: []].! !!MsgServer methodsFor: 'private' stamp: 'jm 9/26/2001 15:22'!serverLoop	"This is the main server loop. It's job is to accept incoming connections on the server socket and to respond to the sequence of requests on each connection accepted."	"Details: If running the background, fork a new thread to handle requests on each connection. Otherwise, handle requests on only one connection at a time, all in the same thread, to allow server errors to be debugged. This loop terminates and destroys the server socket if the primary socket becomes invalid (e.g. after a snapshot)."	| thisConnection |	serverSocket ifNil: [^ self].	[serverSocket isUnconnectedOrInvalid] whileFalse: [		(serverSocket waitForConnectionUntil: (Socket deadlineSecs: 5)) ifTrue: [			thisConnection _ serverSocket accept.			connections addLast: thisConnection.			serverProcess				ifNil: [self requestLoopOnSocket: thisConnection]				ifNotNil: [self forkRequestLoopOnSocket: thisConnection].			thisConnection _ nil]].	serverSocket destroy.	serverSocket _ nil.	connections do: [:sock | sock destroy].	connections _ OrderedCollection new.! !!MsgServer class methodsFor: 'constants' stamp: 'jm 7/30/2001 20:38'!backlogSize	"Answer the connection backlog size for this server."	^ 4! !!MsgServer class methodsFor: 'constants' stamp: 'jm 7/30/2001 20:38'!portNumber	"Answer the port number that this server will listen on. The subclass should override this method to change the port number."	^ 54321! !I am an example server using the MsgServer framework. I implement the four basic arithmetic functions. The first byte of the request message determines the operation:	1 -- add	2 -- subtract	3 -- multiply	4 -- divideThe 8 bytes following the operation byte are two 32-bit signed integer operands. Obviously, it doesn't take a server to do arithmetic, but it illustrates one way dispatch different server operations, how to pass arguments and results, and how to deal with errors.To try this server, copy the remainder of this comment into a workspace and follow the step-by-step directions.First start the server:  server _ MsgServerTest new.  server forkServerProcess.Next, create a client socket and connect it to the server:  sock _ MessageSocket new.  sock	connectTo: NetNameResolver localHostAddress	port: MsgServerTest portNumber	waitSecs: 10.  sock isConnected ifFalse: [self error: 'could not connect'].You can now build a request message, send it to the server, and decode the reply. Select and print the following four lines:  "operations: 1 - add, 2 - subtract, 3 - multiply, 4 - integer divide"  request _ MsgServerTest msgOp: 1 int1: 7 int2: 3.  result _ sock request: request.  (ReadStream on: result) int32.When you are done, you can close the client socket stop the server:  sock destroy.  server stopServer.That's all there is to it!!!!MsgServerTest methodsFor: 'request handling' stamp: 'jm 7/29/2001 10:52'!processMessage: aByteArray	"This server implements a very simple four-function calculator."	| op s arg1 arg2 result |	aByteArray size = 9 ifFalse: [^ 'bad message size'].	"read operation and arguments"	s _ ReadStream on: aByteArray.	op _ s next.	arg1 _ s int32.	arg2 _ s int32.	(op >= 1 and: [op <= 4]) ifFalse: [^ 'bad op'].	"compute result"	op = 1 ifTrue: [result _ arg1 + arg2].	op = 2 ifTrue: [result _ arg1 - arg2].	op = 3 ifTrue: [result _ arg1 * arg2].	op = 4 ifTrue: [		arg2 = 0			ifTrue: [^ 'divide by zero error']			ifFalse: [result _ arg1 // arg2]].	(result isKindOf: SmallInteger) ifFalse: [^ 'result is not a SmallInteger'].	"create and answer result message"	s _ WriteStream on: (ByteArray new: 4).	s int32: result.	^ s contents! !!MsgServerTest class methodsFor: 'port number' stamp: 'jm 7/30/2001 20:31'!portNumber	^ 54322! !!MsgServerTest class methodsFor: 'utilities' stamp: 'jm 1/7/2003 11:50'!msgOp: op int1: int1 int2: int2	"Answer a request message (a ByteArray) for a command to perform the given operation on the two arguments."	| s |	s _ WriteStream on: (ByteArray new: 9).	s nextPut: op.	s int32: int1.	s int32: int2.	^ s contents! !I represent a mu-law (u-law) codec. I compress sound data by a factor of 2:1 by encoding the most significant 12 bits of each 16-bit sample as a signed, exponentially encoded byte. The idea is to use more resolution for smaller lower sample values. This encoding was developed for the North American phone system and a variant of it, a-law, is a European phone standard. It is a popular sound encoding on Unix platforms (.au files).!!MuLawCodec methodsFor: 'subclass responsibility' stamp: 'jm 2/2/1999 09:15'!bytesPerEncodedFrame	"Answer the number of bytes required to hold one frame of compressed sound data. Answer zero if this codec produces encoded frames of variable size."	^ 1! !!MuLawCodec methodsFor: 'subclass responsibility' stamp: 'jm 2/2/1999 14:10'!decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex	"Decode the given number of monophonic frames starting at the given index in the given ByteArray of compressed sound data and storing the decoded samples into the given SoundBuffer starting at the given destination index. Answer a pair containing the number of bytes of compressed data consumed and the number of decompressed samples produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	| dst |	dst _ dstIndex.	srcIndex to: srcIndex + frameCount - 1 do: [:src |		dstSoundBuffer at: dst put: (DecodingTable at: (srcByteArray at: src) + 1).		dst _ dst + 1].	^ Array with: frameCount with: frameCount! !!MuLawCodec methodsFor: 'subclass responsibility' stamp: 'di 2/8/1999 22:25'!encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	"Encode the given number of frames starting at the given index in the given monophonic SoundBuffer and storing the encoded sound data into the given ByteArray starting at the given destination index. Encode only as many complete frames as will fit into the destination. Answer a pair containing the number of samples consumed and the number of bytes of compressed data produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	srcIndex to: srcIndex + frameCount - 1 do: [:i |		dstByteArray at: i put: (self uLawEncodeSample: (srcSoundBuffer at: i))].	^ Array with: frameCount with: frameCount! !!MuLawCodec methodsFor: 'subclass responsibility' stamp: 'jm 2/2/1999 09:11'!samplesPerFrame	"Answer the number of sound samples per compression frame."	^ 1! !!MuLawCodec methodsFor: 'external access' stamp: 'di 2/8/1999 22:28'!uLawDecodeSample: byte	"Decode a 16-bit signed sample from 8 bits using uLaw decoding"	^ DecodingTable at: byte + 1! !!MuLawCodec methodsFor: 'external access' stamp: 'di 2/8/1999 22:30'!uLawEncodeSample: sample	"Encode a 16-bit signed sample into 8 bits using uLaw encoding"	| s |	s _ sample // 8.  "drop 3 least significant bits"	s < 0 ifTrue: [^ (self uLawEncode12Bits: 0-s) + 16r80]		ifFalse: [^ (self uLawEncode12Bits: s)].! !!MuLawCodec methodsFor: 'private' stamp: 'di 2/9/1999 13:25'!uLawEncode12Bits: s	"Encode a 12-bit unsigned sample (0-4095) into 7 bits using uLaw encoding.	This gets called by a method that scales 16-bit signed integers down to a		12-bit magnitude, and then ORs in 16r80 if they were negative.	Detail: May get called with s >= 4096, and this works fine."	s < 496 ifTrue: [		s < 112 ifTrue: [			s < 48 ifTrue: [				s < 16					ifTrue: [^ 16r70 bitOr: (15 - s)]					ifFalse: [^ 16r60 bitOr: (15 - ((s - 16) bitShift: -1))]].			^ 16r50 bitOr: (15 - ((s - 48) bitShift: -2))].		s < 240			ifTrue: [^ 16r40 bitOr: (15 - ((s - 112) bitShift: -3))]			ifFalse: [^ 16r30 bitOr: (15 - ((s - 240) bitShift: -4))]].	s < 2032 ifTrue: [		s < 1008			ifTrue: [^ 16r20 bitOr: (15 - ((s - 496) bitShift: -5))]			ifFalse: [^ 16r10 bitOr: (15 - ((s - 1008) bitShift: -6))]].	s < 4080		ifTrue: [^ 15 - ((s - 2032) bitShift: -7)]		ifFalse: [^ 0].! !!MuLawCodec class methodsFor: 'class initialization' stamp: 'di 2/9/1999 14:57'!initialize	"Build the 256 entry table to be used to decode 8-bit uLaw-encoded samples."	"MuLawCodec initialize"	| encoded codec lastEncodedPos lastEncodedNeg |	DecodingTable _ Array new: 256.	codec _ self new.	lastEncodedPos _ nil.	lastEncodedNeg _ nil.	4095 to: 0 by: -1 do: [:s |		encoded _ codec uLawEncode12Bits: s.		lastEncodedPos = encoded			ifFalse: [				DecodingTable at: (encoded + 1) put: (s bitShift: 3).				lastEncodedPos _ encoded].		encoded _ encoded bitOr: 16r80.		lastEncodedNeg = encoded			ifFalse: [				DecodingTable at: (encoded + 1) put: (s bitShift: 3) negated.				lastEncodedNeg _ encoded]].! !!MyPaintCanvas methodsFor: 'initialization' stamp: 'ee 7/15/2003 12:47'!createBrush	brush _ Pen newOnForm: canvasForm.	brush roundNib: brushSize.	brush color: brushColor.! !!MyPaintCanvas methodsFor: 'initialization' stamp: 'ee 8/8/2003 11:30'!initialize	super initialize.	brushColor _ Color red.	altColor _ Color blue.	brushSize _ 3.	textSize _ 12.	textFont _ #NewYork.	fillMode _ #fill.	shapeMode _ #rectFill.	self enableDrop: true.	self setTransparency: 1.	zoomForm _ nil.	scale _ 1.! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 7/15/2003 09:40'!action: aSymbol	action _ aSymbol! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 7/17/2003 09:48'!altColor	^ altColor! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 7/15/2003 09:41'!brush	^ brush! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 7/15/2003 09:41'!brushColor	^ brushColor! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 7/30/2003 10:31'!brushColor: aColor	| newColor |	newColor _ aColor.	(aColor isKindOf: Symbol) 		ifTrue: [newColor _ (Color fromString: (newColor asString))].	Sensor yellowButtonPressed 		ifTrue: [altColor _ newColor.				self owner palette altColorDisplay color: newColor]		ifFalse: [brushColor _ newColor.				brush color: newColor.				self owner palette colorDisplay color: newColor.]! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 7/15/2003 09:41'!brushSize	^ brushSize! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 7/15/2003 09:42'!brushSize: aNumber	self owner palette sizeButtons ifNotNil: [		self owner palette sizeButtons			do: [:el | el arguments first = aNumber ifFalse: [el off]]].	brushSize _ aNumber.	brush roundNib: aNumber.	! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 7/11/2003 15:15'!canvasForm	^ canvasForm! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'jm 7/15/2003 14:12'!canvasForm: aForm	canvasForm _ aForm.	self changed.! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 9/27/2003 15:35'!fill		| fillPt |		Cursor blank show.	Cursor crossHair showWhile:		[fillPt _ Sensor waitButton - self position].	fillMode = #gradient 		ifTrue: [canvasForm shapeGradientFill: altColor altColor: brushColor interiorPoint: fillPt.				Sensor waitNoButton.				self changed]		ifFalse: [fillMode = #gradientV			ifTrue: [canvasForm shapeGradientVFill: altColor altColor: brushColor interiorPoint: fillPt.				Sensor waitNoButton.				self changed]			ifFalse: [fillMode = #gradientR				ifTrue: [canvasForm shapeGradientRFill: altColor altColor: brushColor interiorPoint: fillPt.					Sensor waitNoButton.					self changed]				ifFalse: [fillMode = #eraseFill					ifTrue: [canvasForm shapeFill: (Color transparent) interiorPoint: fillPt.						Sensor waitNoButton.						self changed]					ifFalse: [canvasForm shapeFill: brushColor interiorPoint: fillPt.						Sensor waitNoButton.						self changed]]]].! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 7/17/2003 10:24'!fillMode	^ fillMode! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 9/27/2003 15:34'!fillMode:  aSymbol	self owner palette fillButtons ifNotNil: [		self owner palette fillButtons			do: [:el | el arguments first = aSymbol ifFalse: [el off]]].	fillMode _ aSymbol.	! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 7/10/2003 10:20'!lastMouse	^ lastMouse! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'jm 12/8/2003 07:13'!setTextFont	| fontNames menu choice |	fontNames _ StrikeFont allInstances collect: [:f | f familyName].	fontNames _ fontNames asSet asArray sort.	menu _ CustomMenu new.	fontNames do: [:fname | menu add: fname action: fname].	choice _ menu startUp.	choice ifNotNil: [self textFont: choice].! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'jm 12/8/2003 07:14'!setTextSize	| sizes menu choice |	sizes _ OrderedCollection new.	StrikeFont allInstances do: [:f | f familyName = textFont ifTrue: [sizes add: f height]].	sizes _ sizes asSet asArray sort.	menu _ CustomMenu new.	sizes do: [:sz | menu add: sz printString action: sz].	choice _ menu startUp.	choice ifNotNil: [self textSize: choice].! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 7/15/2003 10:52'!setTransparency: aNumber	transparency _ aNumber.	self changed.! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 9/20/2003 11:41'!shapeForm	^ shapeForm! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 9/27/2003 12:15'!shapeForm: aMorphOrNil	| tempText |	tempText _ self findA: MyPaintTextMorph.	tempText ifNotNil: [		tempText passKeyboardFocusTo: nil.		self acceptDroppingMorph: tempText event: nil].	shapeForm ifNotNil: [shapeForm delete].  "delete old shape, if there was one"	shapeForm _ aMorphOrNil.	shapeForm ifNotNil: [			self addMorphBack: shapeForm].! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 7/30/2003 11:18'!shapeForm: aMorphOrNil position: aPoint	shapeForm ifNotNil: [shapeForm delete].  "delete old shape, if there was one"	shapeForm _ aMorphOrNil.	shapeForm ifNotNil: [			self addMorph: shapeForm]! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 7/16/2003 14:59'!shapeMode	shapeMode ifNotNil: [	^ shapeMode].! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 9/27/2003 11:52'!shapeMode: aSymbol	self owner palette rectButtons ifNotNil: [		self owner palette rectButtons			do: [:el | el arguments first = aSymbol ifFalse: [el off]]].	shapeMode _ aSymbol.! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 8/19/2003 11:40'!stampForm: anObject	stampForm _ anObject! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 7/28/2003 15:52'!switchColor	| temp temp2 |	temp _ brushColor.	temp2 _ altColor.	altColor _ temp.	self owner palette altColorDisplay color: altColor.	self brushColor: temp2.! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'jm 12/8/2003 07:06'!textFont: aSymbol		| currentText |	textFont _ aSymbol.	(currentText _ self findA: MyPaintTextMorph) ifNotNil: [		currentText beAllFont: (StrikeFont familyName: aSymbol size: textSize).		currentText layoutChanged].! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'jm 12/8/2003 07:06'!textSize: aNumber		| currentText |	textSize _ aNumber.	(currentText _ self findA: MyPaintTextMorph)  ifNotNil: [		currentText beAllFont: (StrikeFont familyName: textFont size: textSize).		currentText layoutChanged].! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 9/20/2003 11:52'!undo	"revert to a previous state.  "	| temp |	undoBuffer ifNil: [^ self beep].		temp _ canvasForm.	canvasForm _ undoBuffer.	undoBuffer _ temp.		"can get back to what you had by undoing again"	brush setDestForm: canvasForm.	shapeForm ifNotNil: [		(shapeForm shape = #text)			ifTrue: [shapeForm text delete]. 		self shapeForm: nil].	self changed.! !!MyPaintCanvas methodsFor: 'accessing' stamp: 'ee 8/4/2003 14:39'!updateUndoBuffer	undoBuffer _ canvasForm deepCopy! !!MyPaintCanvas methodsFor: 'geometry' stamp: 'ee 7/7/2003 14:37'!containsPoint: aPoint	^ self bounds containsPoint: aPoint! !!MyPaintCanvas methodsFor: 'geometry' stamp: 'ee 7/28/2003 14:39'!fullBounds	^ bounds! !!MyPaintCanvas methodsFor: 'geometry' stamp: 'ee 8/11/2003 11:23'!scale	^ scale! !!MyPaintCanvas methodsFor: 'geometry' stamp: 'ee 8/13/2003 12:34'!scaleBy: aNum	| r |	self owner palette zoomButtons ifNotNil: [		self owner palette zoomButtons			do: [:el | el arguments first = aNum ifFalse: [el off]]].	undoBuffer _ canvasForm deepCopy.	scale _ aNum.	zoomForm _ (Form extent: (canvasForm extent * aNum asFloat) depth: canvasForm depth).	r _ canvasForm boundingBox.	(WarpBlt toForm: zoomForm)		sourceForm: canvasForm;		colorMap: (canvasForm colormapIfNeededForDepth: zoomForm depth);		cellSize: 1;		combinationRule: Form over;		copyQuad: r innerCorners toRect: zoomForm boundingBox.	(aNum = 1)		ifTrue: [			zoomMorph ifNotNil: [zoomMorph delete]]		ifFalse: [			zoomMorph ifNotNil: [zoomMorph delete].			zoomMorph _ ScrollFrameMorph new.			zoomMorph 				extent: self extent;				position: self bounds origin;				color: (Color transparent).			zoomMorph contents 				color: (Color transparent);				addMorph: (MyPaintZoomMorph new form: zoomForm; canvas: self).			self addMorph: zoomMorph].	self changed.! !!MyPaintCanvas methodsFor: 'geometry' stamp: 'ee 8/13/2003 12:27'!updateRect: aRectangle	| zoomedBounds|	(scale = 1) 		ifTrue: [			self invalidRect: (aRectangle translateBy: bounds origin)]		ifFalse: [			zoomedBounds _ aRectangle scaleBy: scale.			(WarpBlt toForm: zoomForm)				sourceForm: canvasForm;				colorMap: (canvasForm colormapIfNeededForDepth: zoomForm depth);				cellSize: 1;				combinationRule: Form over;				copyQuad: aRectangle innerCorners 				toRect: zoomedBounds.			self invalidRect: (				zoomedBounds translateBy: (zoomMorph contents topLeft))].			! !!MyPaintCanvas methodsFor: 'drawing' stamp: 'ee 8/13/2003 10:26'!drawOn: aCanvas	aCanvas fillRectangle: self bounds color: (Color white alpha: transparency).	(scale = 1)		ifTrue: [aCanvas paintImage: canvasForm at: bounds origin].! !!MyPaintCanvas methodsFor: 'drawing' stamp: 'ee 7/16/2003 15:13'!drawSubmorphsOn: aCanvas"Clip submorphs to my bounds during shape filling."	aCanvas	clipBy: self bounds	during: [:clippedCanvas | super drawSubmorphsOn: clippedCanvas].! !!MyPaintCanvas methodsFor: 'event handling' stamp: 'ee 9/27/2003 12:08'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto a morph that has agreed to accept the dropped morph by responding 'true' to the wantsDroppedMorph:Event: message. This default implementation just adds the given morph to the receiver."	| c |	(action = #text or:  [action = #select])		ifFalse: [			undoBuffer _ canvasForm deepCopy].	(action = #stamp)		ifTrue: [			Sensor yellowButtonPressed ifTrue: [				aMorph delete.				stampForm _ nil.				self shapeForm: nil.				self changed.				self activeHand showTemporaryCursor: (Cursor crossHair).				^ self].			aMorph delete.			self changed]		ifFalse: [			aMorph delete.			self shapeForm: nil].	aMorph delete.	c _ (FormCanvas on: canvasForm) copyOffset: self topLeft negated.	aMorph drawOn: c.	self changed.! !!MyPaintCanvas methodsFor: 'event handling' stamp: 'ee 7/7/2003 15:13'!handlesMouseDown: evt	^ self inPartsBin not! !!MyPaintCanvas methodsFor: 'event handling' stamp: 'ee 7/7/2003 15:14'!handlesMouseOver: evt	^ true! !!MyPaintCanvas methodsFor: 'event handling' stamp: 'ee 7/30/2003 15:16'!handlesMouseOverDragging: evt	^ true.! !!MyPaintCanvas methodsFor: 'event handling' stamp: 'ee 9/20/2003 13:59'!mouseDown: evt	| tempText |	tempText _ self findA: MyPaintTextMorph.	tempText ifNotNil: [		tempText passKeyboardFocusTo: nil.		self acceptDroppingMorph: tempText event: evt].	(scale = 1)		ifTrue: [lastMouse _ evt cursorPoint]		ifFalse: [lastMouse _ ((evt cursorPoint - zoomMorph contents topLeft) / scale)].	shapeForm ifNotNil: [(shapeForm bounds containsPoint: evt cursorPoint)		ifFalse: [self shapeForm: nil]].	(action = #pickColor) ifFalse: [stampForm ifNil: [undoBuffer _ canvasForm deepCopy]].	action = #paint ifTrue: [lastMouse _ lastMouse - bounds origin. self paintMouseDown: evt].	action = #fill ifTrue: [self fill].	action = #pickColor ifTrue: [self pickColor: evt].	action = #erase ifTrue: [lastMouse _ lastMouse - bounds origin. self eraseMouseDown: evt].	shapeForm ifNil:[	action = #line ifTrue: [		self shapeForm: (MyPaintShapeMorph new setShape: #line for: self)			position: evt cursorPoint].	action = #rect ifTrue: [		self shapeForm: (MyPaintShapeMorph new setShape: #rect for: self)].	action = #oval ifTrue: [		self shapeForm: (MyPaintShapeMorph new setShape: #oval for: self)].	action = #select ifTrue: [		self shapeForm: (MyPaintShapeMorph new setShape: #select for: self)].	action = #text ifTrue: [		self shapeForm: (MyPaintShapeMorph new setShape: #text for: self)].	action = #stamp ifTrue: [		self shapeForm: (MyPaintShapeMorph new setShape: #stamp for: self)]].	self changed.	! !!MyPaintCanvas methodsFor: 'event handling' stamp: 'ee 11/22/2003 14:52'!mouseEnter: evt	| paintForm zoomedPaintForm offset |	paintForm _ (MyPaintFrame paintSkin at: ('brush', brushSize printString) asSymbol).	offset _ 15@15.	scale = 1 ifFalse: [		zoomedPaintForm _ (Form extent: (paintForm extent * scale) depth: canvasForm depth).		(WarpBlt toForm: zoomedPaintForm)			sourceForm: paintForm;			colorMap: (paintForm colormapIfNeededForDepth: zoomedPaintForm depth);			cellSize: 1;			combinationRule: Form paint;			copyQuad: paintForm boundingBox innerCorners toRect: zoomedPaintForm boundingBox.		paintForm _ zoomedPaintForm.		offset _ offset * scale].	scale = 1 ifTrue: [		action = #paint ifTrue: [evt hand showTemporaryCursor: paintForm hotSpotOffset: offset]].	action = #erase ifTrue: [evt hand showTemporaryCursor: paintForm hotSpotOffset: offset].	action = #pickColor ifTrue: [evt hand showTemporaryCursor: Cursor eyeDropper].	(#(fill select text stamp line rect oval) includes: action) ifTrue: [		evt hand showTemporaryCursor: Cursor crossHair].	shapeForm ifNotNil:[ (action = #text and: [shapeForm bounds containsPoint: evt cursorPoint]) ifTrue: [evt hand showTemporaryCursor: Cursor normal]]. 	action = #stamp ifTrue: [ 		stampForm ifNotNil:[			self activeHand attachMorph: stampForm.			self changed]].! !!MyPaintCanvas methodsFor: 'event handling' stamp: 'ee 7/31/2003 10:08'!mouseLeave: evt	self activeHand submorphs isEmpty ifFalse:[	self activeHand dismissMorph].	evt hand showTemporaryCursor: nil.! !!MyPaintCanvas methodsFor: 'event handling' stamp: 'jm 10/1/2003 08:58'!mouseLeaveDragging: evt	action = #stamp ifTrue: [		(self bounds containsPoint: evt cursorPoint) ifFalse:[			self activeHand submorphs size > 0 ifTrue: [				self shapeForm: nil.				stampForm _ self activeHand firstSubmorph deepCopy.				self activeHand firstSubmorph delete].			evt hand showTemporaryCursor: nil]].! !!MyPaintCanvas methodsFor: 'event handling' stamp: 'ee 7/25/2003 17:41'!mouseMove: evt	(action = #paint or: [action = #erase])		ifTrue: [self paintMouseMove: evt].	action = #line ifTrue: [self shapeMouseMove: evt].	action = #rect ifTrue: [self shapeMouseMove: evt].	action = #oval ifTrue: [self shapeMouseMove: evt].	action = #select ifTrue: [self shapeMouseMove: evt].	action = #text ifTrue: [self shapeMouseMove: evt].	action = #stamp ifTrue: [self shapeMouseMove: evt].! !!MyPaintCanvas methodsFor: 'event handling' stamp: 'ee 11/30/2003 18:28'!mouseUp: evt	"If I was drawing a shape, then paint the final shape onto my canvas and delete the shape morph. Otherwise, do nothing."	| c t |	currentMouse ifNotNil:[		(evt cursorPoint = lastMouse)			ifTrue: [				self shapeForm: nil.				self changed.				^ self]].	shapeForm ifNil: [^ self].	(action = #select)		ifTrue: [^ self].	(action = #stamp)		ifTrue: [			stampForm ifNil: [shapeForm makeCopy].			(stampForm bounds area = 0) ifTrue: [				stampForm _ nil.				self shapeForm: nil.				self changed].			^ self].	action = #text		ifTrue: [ 		(lastMouse > currentMouse) 			ifTrue: [shapeForm 					startPoint: evt cursorPoint; 					currentPoint: (lastMouse max: evt cursorPoint + (50@50))]			ifFalse: [shapeForm					startPoint: lastMouse;					currentPoint: (evt cursorPoint max: lastMouse + (50@50))].		t _ (MyPaintTextMorph new 			width: (shapeForm r width); 			setCanvas: self; 			position: (shapeForm r origin);			contents: 'Enter Text Here' wrappedTo: (shapeForm r width)).		t beAllFont: (StrikeFont familyName: textFont size: textSize).		self addMorph: t.		shapeForm text: t.		(t editor) ifNotNil: [t editor selectFrom: (t paragraph text size +1) to: (t paragraph text size)].		evt hand newKeyboardFocus: t.		self changed.		^ self].	c _ (FormCanvas on: canvasForm) copyOffset: self topLeft negated.	shapeForm drawOn: c.	self shapeForm: nil.  "end shape drawing"	self changed.! !!MyPaintCanvas methodsFor: 'event handling' stamp: 'ee 8/19/2003 15:34'!updateForm	| importedObject startingObject xOffset yOffset |	importedObject _ self owner importedObject.	startingObject _ self owner startingObject.	((startingObject bounds right) > (self bounds right))					ifTrue: [xOffset _ self bounds right - startingObject form boundingBox width - bounds origin x].	((startingObject bounds left) < (self bounds left))					ifTrue: [xOffset _ self bounds left - bounds origin x].	((startingObject bounds top) < (self bounds top))					ifTrue: [yOffset _ self bounds top - bounds origin y].	((startingObject bounds bottom) > (self bounds bottom))					ifTrue: [yOffset _ self bounds bottom - startingObject form boundingBox height - bounds origin y].	xOffset ifNil: [xOffset _ startingObject bounds left - bounds origin x].	yOffset ifNil: [yOffset _ startingObject bounds top - bounds origin y].	importedObject		ifNotNil:[			canvasForm 				copy: importedObject form boundingBox 				from: importedObject form 				to: importedObject position - bounds origin				rule: Form paint]		ifNil: [			(self bounds containsRect: startingObject bounds)			ifTrue: [				canvasForm 					copy: startingObject form boundingBox					from: startingObject form					to: startingObject position - bounds origin					rule: Form paint]			ifFalse: [				canvasForm 					copy: startingObject form boundingBox					from: startingObject form					to: (xOffset @ yOffset) 					rule: Form paint]]! !!MyPaintCanvas methodsFor: 'actions' stamp: 'ee 7/10/2003 17:03'!eraseMouseDown: evt	brush combinationRule: (Form erase1bitShape).	self paintMouseDown: evt! !!MyPaintCanvas methodsFor: 'actions' stamp: 'ee 9/20/2003 11:35'!paintMouseDown: evt	"Start drawing at the event point and report the invalid area."		action = #erase ifFalse: [brush combinationRule: Form paint].	(brushColor = (Color transparent)) 		ifTrue: [brush color: Color black. brush combinationRule: (Form erase1bitShape)].	brush drawFrom: lastMouse to: lastMouse.	self updateRect:		((lastMouse - brush sourceForm extent) corner:		 (lastMouse + brush sourceForm extent)).! !!MyPaintCanvas methodsFor: 'actions' stamp: 'ee 8/13/2003 12:18'!paintMouseMove: evt	"Draw from the last mouse position to the new position and report the invalid area."	| p r |	(scale = 1)		ifTrue: [p _ evt cursorPoint - bounds origin]		ifFalse: [p _ ((evt cursorPoint - zoomMorph contents topLeft) / scale)].	p = lastMouse ifTrue: [^ self].	brush drawFrom: lastMouse to: p.	r _ (p rect: lastMouse) expandBy: brush sourceForm extent.	self updateRect: r.	lastMouse _ p.! !!MyPaintCanvas methodsFor: 'actions' stamp: 'ee 7/8/2003 16:43'!pickColor: evt	self brushColor: (Display colorAt: (evt cursorPoint)).	! !!MyPaintCanvas methodsFor: 'actions' stamp: 'ee 11/30/2003 16:33'!shapeMouseMove: evt 	currentMouse _ evt cursorPoint.	shapeForm ifNotNil: [shapeForm currentPoint: evt cursorPoint]! !!MyPaintFrame methodsFor: 'intialization' stamp: 'ee 7/31/2003 16:08'!addCanvas	canvas _ MyPaintCanvas new.	self addMorphBack: canvas.	canvas position: self topLeft + (15@15).	! !!MyPaintFrame methodsFor: 'intialization' stamp: 'jm 9/28/2003 22:59'!addPalette	palette _ MyPaintPalette new.	self addMorphBack: palette.	palette createButtons.	palette createOptionPane.	palette createColorPicker.	palette addMorphBack: (AlignmentMorph newSpacer: (Color veryVeryLightGray)).		palette position: canvas topRight.	palette inset: 0.	palette changed.	palette target: self.! !!MyPaintFrame methodsFor: 'intialization' stamp: 'ee 9/27/2003 10:54'!initialize	super initialize.	self color: (Color transparent).		self		borderWidth: 10;		inset: 0;		borderColor: (Color black);		borderRaised;		doesBevels;		isSticky: true;		useRoundedCorners.	self addCanvas.	self addPalette.	action _ #nothing.	! !!MyPaintFrame methodsFor: 'actions' stamp: 'ee 7/11/2003 11:32'!cancel	self delete.! !!MyPaintFrame methodsFor: 'actions' stamp: 'ee 8/4/2003 14:19'!clear	canvas extent: self extent - (120@20).	canvas canvasForm: ((Form extent: canvas extent depth: 16) fillColor: Color transparent).	canvas createBrush.! !!MyPaintFrame methodsFor: 'actions' stamp: 'ee 10/25/2003 13:02'!doOp: aSymbol	aSymbol ~= #clear ifTrue: [		palette buttons ifNotNil: [			palette buttons do: [:el | el do: 				[:b | b arguments first = aSymbol ifFalse: [b off]]]]].	self world doOneCycle.	self setAction: aSymbol.! !!MyPaintFrame methodsFor: 'actions' stamp: 'ee 8/19/2003 11:45'!loadFile	| result fileName object|	canvas updateUndoBuffer.	result _ StandardFileMenu oldFileExtensions: #(jpg jpeg gif bmp png).	result ifNil: [^ self].	fileName _ result directory pathName, FileDirectory slash, result name.	object _ SketchMorph withForm: (Form fromFileNamed: fileName).	object center: (canvas center).	self withStartingObjectFromFile: object.		! !!MyPaintFrame methodsFor: 'actions' stamp: 'ee 10/25/2003 13:07'!setAction: aSymbol		action _ aSymbol.	canvas stampForm: nil.	canvas shapeForm ifNotNil: [canvas shapeForm: nil].	aSymbol = #clear		ifTrue: [self clear]		ifFalse: [			palette updateOptions.			canvas action: aSymbol].	self world doOneCycle.! !!MyPaintFrame methodsFor: 'actions' stamp: 'jm 12/9/2003 18:10'!withStartingObject: anObject	startingObject _ anObject.	self position: (0@0 + owner bounds origin).	self extent: (owner extent - (8@0)).	self clear.	self canvas updateForm.! !!MyPaintFrame methodsFor: 'actions' stamp: 'ee 8/4/2003 14:34'!withStartingObjectFromFile: anObject	importedObject _ anObject.	self position: (0@0 + owner bounds origin).	self extent: (owner extent - (20@0)).	self clear.	self canvas updateForm.		! !!MyPaintFrame methodsFor: 'accessing' stamp: 'ee 7/7/2003 16:37'!action	^ action.! !!MyPaintFrame methodsFor: 'accessing' stamp: 'ee 7/7/2003 16:40'!canvas	^ canvas.! !!MyPaintFrame methodsFor: 'accessing' stamp: 'ee 8/4/2003 14:35'!importedObject	^ importedObject! !!MyPaintFrame methodsFor: 'accessing' stamp: 'ee 7/8/2003 15:38'!palette	^ palette.! !!MyPaintFrame methodsFor: 'accessing' stamp: 'jm 10/10/2003 09:45'!save	| tempText c newBounds newForm |	tempText _ canvas findA: MyPaintTextMorph.	tempText ifNotNil: [		tempText passKeyboardFocusTo: nil.		c _ (FormCanvas on: canvas canvasForm) copyOffset: canvas topLeft negated.		tempText drawOn: c.		self changed].	canvas shapeForm ifNotNil: [canvas shapeForm delete].	startingObject ifNil: [^ self].	newBounds _ canvas canvasForm rectangleEnclosingPixelsNotOfColor: Color transparent.	(newBounds area = 0) ifTrue: [^ self cancel].  "cancel if canvas is empty"	newForm _ 	Form extent: newBounds extent depth: (canvas canvasForm) depth.	newForm copyBits: newBounds from: (canvas canvasForm) at: 0@0 		clippingBox: newForm boundingBox rule: Form over fillColor: nil.	newForm colorsUsed size < 256 ifTrue: [newForm _ newForm colorReduced8Bit].	startingObject editedForm: newForm.	startingObject position: newBounds origin + canvas bounds origin.	startingObject rotationCenter: newBounds extent // 2.	self delete.! !!MyPaintFrame methodsFor: 'accessing' stamp: 'ee 7/11/2003 15:10'!startingObject	^ startingObject	! !!MyPaintFrame class methodsFor: 'paintSkin' stamp: 'ee 7/18/2003 11:05'!paintSkin	^ PaintSkin! !!MyPaintFrame class methodsFor: 'paintSkin' stamp: 'ee 9/27/2003 15:26'!readPaintSkinFrom: aDirectory	"Read the Forms for my default skin from the given directory and store them in my DefaultSkin dictionary."	"self readPaintSkinFrom: (FileDirectory default directoryNamed: 'ScratchPaintSkin')"	| normal pressed |	PaintSkin _ Dictionary new.	"read brush size forms"	#(brush3 brush5 brush8 brush12 brush25 brush30 ) do: [:n |		normal _ n.		pressed _ (n, 'p') asSymbol.		PaintSkin at: normal put: (Utilities form: normal from: aDirectory).		PaintSkin at: pressed put: (Utilities form: pressed from: aDirectory)].	"read palette button forms"	#(blank fill paint erase pickColor line rect oval stamp text select zoom) do: [:n |		normal _ (n, 'UP') asSymbol.		pressed _ (n, 'DOWN') asSymbol.		PaintSkin at: normal put: (Utilities form: normal from: aDirectory).		PaintSkin at: pressed put: (Utilities form: pressed from: aDirectory)].	"read shape mode option forms"	#(rectFill  rectFrame) do: [:n |		normal _ n.		pressed _ (n, 'p') asSymbol.		PaintSkin at: normal put: (Utilities form: normal from: aDirectory).		PaintSkin at: pressed put: (Utilities form: pressed from: aDirectory)].	"read fill mode option forms"	#(gradient gradientR gradientV eraseFill) do: [:n |		normal _ n.		pressed _ (n, 'p') asSymbol.		PaintSkin at: normal put: (Utilities form: normal from: aDirectory).		PaintSkin at: pressed put: (Utilities form: pressed from: aDirectory)].	"read switch button"	#(switch) do: [:n |		normal _ n.		PaintSkin at: normal put: (Utilities form: normal from: aDirectory)].! !!MyPaintPalette methodsFor: 'initialization' stamp: 'ee 8/4/2003 14:21'!createOptionPane	optionPane _ AlignmentMorph new.	optionPane 		extent: 98@70;		orientation: #vertical;		vResizing: #rigid;		inset: 2;		centering: #center;		color: (Color gray);		borderWidth: 1;		borderColor: (Color black).	self addMorphBack: optionPane.	! !!MyPaintPalette methodsFor: 'initialization' stamp: 'ee 8/19/2003 14:15'!initialize	super initialize.	self		extent: 100@500; 		orientation: #vertical; 		color: Color veryVeryLightGray; 		inset: 0;		centering: #center;		hResizing: #rigid.		! !!MyPaintPalette methodsFor: 'accessing' stamp: 'ee 7/17/2003 11:43'!altColorDisplay	^ altColorDisplay! !!MyPaintPalette methodsFor: 'accessing' stamp: 'ee 7/7/2003 16:21'!buttons	^ buttons.! !!MyPaintPalette methodsFor: 'accessing' stamp: 'ee 7/8/2003 15:38'!colorDisplay	^ colorDisplay.! !!MyPaintPalette methodsFor: 'accessing' stamp: 'jm 12/17/2003 13:15'!createButtons	| topRow secondRow row  actions a f1 f2 cancelButton saveButton undoButton clearButton loadFileButton thirdRow |	actions _ OrderedCollection new.	actions addAll: #(fill paint pickColor erase line rect oval text stamp blank blank select). "zoom"	buttons _ #((button1 button2 button3) (button4 button5 button6) (button7 button8 button9) (button10 button11 button12)) 		collect: [:el | el collect: 			[:b | a _ actions removeFirst.				f1 _ MyPaintFrame paintSkin at: (a, 'UP') asSymbol.				f2 _ MyPaintFrame paintSkin at: (a, 'DOWN') asSymbol.				b _ ToggleButton onForm: f1 offForm: f2. 				b 	target: self owner; 					actWhen: #buttonDown; 					actionSelector: #doOp:; 					toggleMode: false;					arguments: (Array with: a)]].	topRow _ AlignmentMorph new. 	topRow 		hResizing: #rigid; 		vResizing: #shrinkWrap; 		borderWidth: 0; 		color: Color veryVeryLightGray; 		centering: #center;		orientation: #horizontal; 		inset: 1. 	secondRow _ AlignmentMorph new. 	secondRow 		hResizing: #rigid; 		vResizing: #shrinkWrap; 		borderWidth: 0; 		color: Color veryVeryLightGray; 		centering: #center;		orientation: #horizontal; 		inset: 1. 	thirdRow _ AlignmentMorph new. 	thirdRow 		hResizing: #rigid; 		vResizing: #shrinkWrap; 		borderWidth: 0; 		color: Color veryVeryLightGray; 		centering: #center;		orientation: #horizontal; 		inset: 1. 	saveButton _ SimpleButtonMorph new		label: 'Okay';		target: self owner;		actionSelector: #save;		color: Color white;		borderColor: Color black.	cancelButton _ SimpleButtonMorph new		label: 'Cancel';		target: self owner;		actionSelector: #cancel;		color: Color white;		borderColor: Color black.	undoButton _ SimpleButtonMorph new		label: 'Undo';		target: self owner canvas;		actionSelector: #undo;		color: Color white;		borderColor: Color black.	clearButton _ SimpleButtonMorph new		label: 'Clear';		target: self owner;		actionSelector: #doOp:;		arguments: (Array with: #clear);		color: Color white;		borderColor: Color black.	loadFileButton _ SimpleButtonMorph new		label: 'Load File';		target: self owner;		actionSelector: #loadFile;		color: Color white;		borderColor: Color black.	topRow addMorph: cancelButton; addMorph: saveButton.		secondRow addMorph: undoButton; addMorph: clearButton.	thirdRow addMorph: loadFileButton.	self addMorph: topRow; addMorphBack: secondRow; addMorphBack: thirdRow.	self addAllMorphs: 		(buttons collect: 			[:el | row _ AlignmentMorph new. 				 row 					hResizing: #rigid; 					vResizing: #rigid; 					borderWidth: 0; 					color: Color white; 					orientation: #horizontal; 					height: 30;					centering: #center;					inset: 0. 				row addMorph: el second. row addMorph: el first. row addMorph: el third.]).! !!MyPaintPalette methodsFor: 'accessing' stamp: 'ee 10/25/2003 13:44'!createColorPicker	| baseColors baseBlock row slider colorPicker |	bottomBin _ AlignmentMorph newColumn.	bottomBin		color: (Color gray);		inset: 0;		borderColor: (Color black);		borderWidth: 1;		vResizing: #shrinkWrap;		centering: #center.	middleBin _ AlignmentMorph newRow.	middleBin		color: (Color gray);		inset: 0;		height: 21;		borderColor: (Color black);		borderWidth: 1;		vResizing: #rigid;		centering: #center.	baseColors _ OrderedCollection new.	baseColors addAll: {		{(Color orange). (Color red). (Color yellow). (Color green). (Color blue)}.		{(Color lightRed). (Color magenta darker darker). (Color brown). (Color green). (Color lightBlue)}.		{(Color veryVeryDarkGray). (Color black). (Color gray). (Color veryVeryLightGray). (Color white)}}.	baseColors _ baseColors collect: [:c | c collect:		[:b |				baseBlock _ SimpleButtonMorph new.			baseBlock 				label: ' '; 				useSquareCorners;				borderWidth: 1; 				borderColor: (Color black);				extent: 20@20;				color: b;				actionSelector: #brushColor:;				actWhen: #buttonDown;				target: (owner canvas);				arguments: (Array with: b).			baseBlock]].	colorDisplay _ RectangleMorph new.	colorDisplay 		borderColor: (Color black); 		useRoundedCorners; 		color: (owner canvas brushColor);		extent: 40@20.	switchButton _ IconicButton new.	switchButton		labelGraphic: (MyPaintFrame paintSkin at: #switch);		color: Color black;		borderColor: Color black;		useRoundedCorners;		target: owner canvas;		actionSelector: #switchColor.	altColorDisplay _ RectangleMorph new.	altColorDisplay		borderColor: (Color black);		useRoundedCorners;		color: (owner canvas altColor);		extent: 40@20.	"moreColorsButton _ SimpleButtonMorph new.	moreColorsButton		label: 'More Colors >>';		color: Color black;		borderColor: Color black;		target: self;		actionSelector: #chooseColor."	"color picker is somewhat slow to create, so cache one and copy it"	(SavedColorPicker isNil or:	 [SavedColorPicker extent ~= (98@140)]) ifTrue: [		SavedColorPicker _ WebPageColorPicker new			selector: #brushColor:;			extent: 98@140].	colorPicker _ SavedColorPicker fullCopy target: self owner canvas.	slider _ SimpleSliderMorph new.	slider		extent: 98@10;		minVal: 0.5;		maxVal: 1;		setValue: 1;		target: self owner canvas;		actionSelector: #setTransparency:.	middleBin addMorphBack: colorDisplay; addMorphBack: switchButton; addMorphBack: altColorDisplay.	bottomBin addAllMorphs: 			(baseColors collect: 			[:el | row _ AlignmentMorph new. 				 row 					extent: 30@100;					borderWidth: 0; 					color: Color transparent; 					orientation: #horizontal; 					hResizing: #rigid;					centering: #center;					inset: 0. 				row addMorphBack: el second. 				row addMorphBack: el first. 				row addMorphBack: el third.				row addMorphBack: (el at: 4). 				row addMorphBack: (el at: 5)]).	bottomBin		addMorphBack: colorPicker;		addMorphBack: (StringMorph contents: 'Transparency');		addMorphBack: slider.     "addMorphBack: slider."  "transparency slider"	self addMorphBack: middleBin; addMorphBack: bottomBin.! !!MyPaintPalette methodsFor: 'accessing' stamp: 'ee 7/17/2003 11:33'!fillButtons	^ fillButtons! !!MyPaintPalette methodsFor: 'accessing' stamp: 'ee 7/17/2003 11:35'!rectButtons	^ rectButtons! !!MyPaintPalette methodsFor: 'accessing' stamp: 'ee 7/15/2003 09:31'!sizeButtons	^ sizeButtons! !!MyPaintPalette methodsFor: 'accessing' stamp: 'ee 7/7/2003 14:21'!target: anObject	target _ anObject.! !!MyPaintPalette methodsFor: 'accessing' stamp: 'ee 8/11/2003 11:02'!updateOptions	((target action = #paint or: [target action = #erase]) or: [target action = #line])		ifTrue: [self brushSizeSelector]		ifFalse: [((target action = #rect) or: [target action = #oval])			ifTrue: [self rectTypeSelector]			ifFalse: [(target action = #fill)				ifTrue: [self fillTypeSelector]				ifFalse: [(target action = #text)					ifTrue: [self textTypeSelector]					ifFalse: [(target action = #zoom)						ifTrue: [self zoomTypeSelector]						ifFalse: [optionPane submorphsDo: [:s | s delete]]]]]].! !!MyPaintPalette methodsFor: 'accessing' stamp: 'ee 8/11/2003 11:25'!zoomButtons	^ zoomButtons! !!MyPaintPalette methodsFor: 'accessing' stamp: 'jm 12/17/2003 13:15'!zoomTypeSelector		| row1 row2 |	optionPane submorphsDo: [:s | s delete].	zoomButtons _ #(1 2 4 6 8) collect: [:s |		ToggleButton new			label: s asString, '00%';			extent: 30@30;			target: target canvas;			toggleMode: false;			color: (Color veryVeryLightGray);			actionSelector: #scaleBy:;			arguments: (Array with: s)].	row1 _ AlignmentMorph newRow 		centering: #center;		color: Color gray;		addMorphBack: (zoomButtons at: 1);		addMorphBack: (zoomButtons at: 2);		addMorphBack: (zoomButtons at: 3);		inset: 0;		extent: 90@30;		hResizing: #rigid;		vResizing: #shrinkWrap.	row2 _ AlignmentMorph newRow 		centering: #center;		color: Color gray;		addMorphBack: (zoomButtons at: 4);		addMorphBack: (zoomButtons at: 5);		inset: 0;		extent: 90@30;		hResizing: #rigid;		vResizing: #shrinkWrap.	optionPane addMorphBack: row1; addMorphBack: row2.	zoomButtons			do: [:el | el arguments first = (target canvas scale) ifTrue: [el on]].! !!MyPaintPalette methodsFor: 'other' stamp: 'jm 12/17/2003 13:15'!brushSizeSelector	| row1 row2 |	optionPane submorphsDo: [:s | s delete].	sizeButtons _ #(3 5 8 12 25 30).	sizeButtons _ sizeButtons collect: [:s |		ToggleButton new			onForm: (MyPaintFrame paintSkin at: ('brush', s printString, 'p') asSymbol)			offForm: (MyPaintFrame paintSkin at: ('brush', s printString) asSymbol);			extent: 30@30;			target: self owner canvas;			toggleMode: false;			actionSelector: #brushSize:;			arguments: (Array with: s)].	row1 _ AlignmentMorph newRow 		centering: #center;		color: Color gray;		addMorphBack: (sizeButtons at: 1);		addMorphBack: (sizeButtons at: 2);		addMorphBack: (sizeButtons at: 3);		inset: 0;		extent: 90@30;		hResizing: #rigid;		vResizing: #shrinkWrap.	row2 _ AlignmentMorph newRow 		centering: #center;		color: Color gray;		borderWidth: 0;		addMorphBack: (sizeButtons at: 4);		addMorphBack: (sizeButtons at: 5);		addMorphBack: (sizeButtons at: 6);		inset: 0;			extent: 90@30;		hResizing: #rigid;		vResizing: #shrinkWrap.	optionPane addMorphBack: row1; addMorphBack: row2.	sizeButtons			do: [:el | el arguments first = (target canvas brushSize) ifTrue: [el on]].! !!MyPaintPalette methodsFor: 'other' stamp: 'ee 8/4/2003 14:20'!chooseColor	| tempColorPicker |	(self owner findA: WebPageColorPicker)	ifNil:[	tempColorPicker _ WebPageColorPicker new.	tempColorPicker		target: self owner canvas;		selector: #brushColor:;		extent: 98@150;		position: (self bottomRight - (0@200)).	self owner addMorph: tempColorPicker.	(bottomBin findA: SimpleButtonMorph)		label: '<< Less Colors'. ]	ifNotNil: [	(self owner findA: WebPageColorPicker) delete.	(bottomBin findA: SimpleButtonMorph)		label: 'More Colors >>'].! !!MyPaintPalette methodsFor: 'other' stamp: 'jm 12/17/2003 13:15'!fillTypeSelector	| row1 row2|	optionPane submorphsDo: [:s | s delete].		fillButtons _ #(rectFill eraseFill gradient gradientV gradientR).	fillButtons _ fillButtons collect: [:s |		ToggleButton new			onForm: (MyPaintFrame paintSkin at: (s, 'p') asSymbol)			offForm: (MyPaintFrame paintSkin at: s asSymbol);			extent: 30@30;			target: target canvas;			toggleMode: false;			actionSelector: #fillMode:;			arguments: (Array with: s)].	row1 _ AlignmentMorph newRow 		centering: #center;		color: (Color gray);		addMorphBack: (fillButtons at: 1);		addMorphBack: (fillButtons at: 2);		inset: 0;		extent: 90@30;		hResizing: #rigid;		vResizing: #shrinkWrap.	row2 _ AlignmentMorph newRow 		centering: #center;		color: (Color gray);		addMorphBack: (fillButtons at: 3);		addMorphBack: (fillButtons at: 4);		addMorphBack: (fillButtons at: 5);		inset: 0;		extent: 90@30;		hResizing: #rigid;		vResizing: #shrinkWrap.	optionPane addMorphBack: row1; addMorphBack: row2.	fillButtons			do: [:el | 					(el arguments first = #rectFill and: [target canvas fillMode = #fill])						ifTrue: [el on].					el arguments first = (target canvas fillMode) ifTrue: [el on]].! !!MyPaintPalette methodsFor: 'other' stamp: 'jm 12/17/2003 13:15'!rectTypeSelector	| row1 |	optionPane submorphsDo: [:s | s delete].	rectButtons _ #(rectFill rectFrame) collect: [:s |		ToggleButton new			onForm: (MyPaintFrame paintSkin at: (s, 'p') asSymbol)			offForm: (MyPaintFrame paintSkin at: s);			extent: 30@30;			target: target canvas;			toggleMode: false;			actionSelector: #shapeMode:;			arguments: (Array with: s)].	row1 _ AlignmentMorph newRow 		centering: #center;		color: Color gray;		addMorphBack: (rectButtons at: 1);		addMorphBack: (rectButtons at: 2);		inset: 0;		extent: 90@30;		hResizing: #rigid;		vResizing: #shrinkWrap.	optionPane addMorphBack: row1.	rectButtons			do: [:el | el arguments first = (target canvas shapeMode) ifTrue: [el on]].! !!MyPaintPalette methodsFor: 'other' stamp: 'ee 8/4/2003 16:32'!textTypeSelector	| textFontButton textSizeButton row1 |	optionPane submorphsDo: [:s | s delete].	textFontButton _  (SimpleButtonMorph new		label: 'Font';		color: Color white;		borderWidth: 1;		borderColor: Color black;		target: target canvas;		actWhen: #buttonDown;		actionSelector: #setTextFont).	textSizeButton _  (SimpleButtonMorph new		label: 'Size';		color: Color white;		borderWidth: 1;		borderColor: Color black;		target: target canvas;		actWhen: #buttonDown;		actionSelector: #setTextSize).	row1 _ AlignmentMorph newRow 		centering: #center;		color: Color gray;		addMorphBack: textFontButton;		addMorphBack: textSizeButton;		inset: 0;		extent: 90@30;		hResizing: #rigid;		vResizing: #shrinkWrap.	optionPane addMorphBack: row1.! !!MyPaintSelectionMorph methodsFor: 'event handling' stamp: 'ee 9/27/2003 13:35'!justDroppedInto: aMorph event: anEvent	"This message is sent to a dropped morph after it has been dropped on--and been accepted by--a drop-sensitive morph"	| aWindow partsBinCase |	(partsBinCase _ aMorph isPartsBin) ifFalse:		[self isPartsDonor: false].	(aWindow _ aMorph ownerThatIsA: SystemWindow) ifNotNil:		[aWindow isActive ifFalse:			[aWindow activate]].	(self isInWorld and: [partsBinCase not]) ifTrue:		[self delete.]  	"Note an unhappy inefficiency here:  the startStepping... call will often have already been called in the sequence leading up to entry to this method, but unfortunately the isPartsDonor: call often will not have already happened, with the result that the startStepping... call will not have resulted in the startage of the steppage."! !!MyPaintShapeMorph methodsFor: 'drawing' stamp: 'ee 11/30/2003 16:52'!drawOn: aCanvas	shape = #text ifFalse: [r _ self bounds].	shape = #line ifTrue: [		aCanvas line: startPoint to: currentPoint brushForm: brushForm].	shape = #rect ifTrue: [		(self owner shapeMode = #rectFrame)		ifTrue: [ 		aCanvas frameRectangle: r width: canvas brushSize color: color]		ifFalse: [		aCanvas fillRectangle: r color: color]].	shape = #oval ifTrue: [		(self owner shapeMode = #rectFrame)		ifTrue: [ 		aCanvas frameOval: r width: canvas brushSize color: color]		ifFalse: [		aCanvas fillOval: r color: color]].	(shape = #select or: [shape = #stamp]) ifTrue: [ 		selection ifNil:[		aCanvas frameRectangle: r width: 1 color: Color black.		self changed]].	shape = #text ifTrue: [		aCanvas frameRectangle: r width: 1 color: Color black.		aCanvas fillRectangle: (Rectangle center: (r corner) extent: (6@6)) color: Color black.		self changed].	! !!MyPaintShapeMorph methodsFor: 'accessing' stamp: 'ee 7/31/2003 10:55'!fullBounds	^ bounds! !!MyPaintShapeMorph methodsFor: 'accessing' stamp: 'ee 7/31/2003 15:08'!r	^ r! !!MyPaintShapeMorph methodsFor: 'accessing' stamp: 'ee 7/18/2003 16:07'!selection	^ selection! !!MyPaintShapeMorph methodsFor: 'accessing' stamp: 'ee 11/22/2003 14:41'!setShape: aSymbol for: aPaintCanvas	| offSet |	canvas _ aPaintCanvas.	offSet _ canvas brushSize //2.	textResizeMode _ false.	self color: aPaintCanvas brushColor.	shape _ aSymbol.	"brush used for line drawing:"	brushForm _ aPaintCanvas brush sourceForm asFormOfDepth: 16.	brushForm mapColor: Color white to: Color transparent.	brushForm mapColor: Color black to: aPaintCanvas brushColor.	(aSymbol = #line)		ifTrue: [startPoint _ aPaintCanvas lastMouse - (offSet@offSet)]		ifFalse: [startPoint _ aPaintCanvas lastMouse].	self currentPoint: startPoint.! !!MyPaintShapeMorph methodsFor: 'accessing' stamp: 'ee 9/20/2003 11:26'!shape	^ shape! !!MyPaintShapeMorph methodsFor: 'accessing' stamp: 'ee 8/13/2003 13:15'!text	^ text! !!MyPaintShapeMorph methodsFor: 'event handling' stamp: 'ee 11/30/2003 17:29'!currentPoint: aPoint	| c offSet newWidth newHeight newExtent |	(shape = #line) 		ifTrue: [		offSet _ canvas brushSize // 2.		currentPoint _ aPoint - (offSet@offSet).		r _ Rectangle encompassing: (Array with: startPoint with: currentPoint).		self bounds: (r origin extent: r extent + brushForm extent)]		ifFalse: [ (shape = #text)			ifTrue: [text						ifNil:						[currentPoint _ aPoint.						r _ Rectangle encompassing: (Array with: startPoint with: currentPoint).						self bounds: (r expandBy: 6@6)]					ifNotNil: 						[newWidth _ (aPoint x - self left - 6) max: 50.					 	 newHeight _ (aPoint y - self top - 6) max: 50.						 newExtent _ newWidth@newHeight.						 r _ Rectangle origin: startPoint extent: newExtent.						 self bounds: (r expandBy: 6@6)]]			ifFalse:				[currentPoint _ aPoint.				r _ Rectangle encompassing: (Array with: startPoint with: currentPoint).				self bounds: r]].	text ifNotNil: [		c _ text editor selectionInterval.		text bounds: r.		text editor selectInterval: c].		self changed.	! !!MyPaintShapeMorph methodsFor: 'event handling' stamp: 'ee 7/18/2003 14:26'!handlesMouseDown: evt	^ true.! !!MyPaintShapeMorph methodsFor: 'event handling' stamp: 'ee 7/18/2003 14:26'!handlesMouseOver: evt	^ true.! !!MyPaintShapeMorph methodsFor: 'event handling' stamp: 'ee 9/27/2003 12:51'!makeCopy	| formToCopy newBounds |	"Only called once when mouse goes up after selecting the rectangle; after every stamping action, mouseEnter is called on MyPaintCanvas to reattach the stampForm."	formToCopy _ Form 		extent: r extent		depth: 16.	formToCopy 		copy: (r translateBy: (canvas bounds origin negated))		from: (canvas canvasForm)		to: 0@0		rule: Form paint.	newBounds _ formToCopy rectangleEnclosingPixelsNotOfColor: Color transparent.	formToCopy _ formToCopy copy: newBounds.	selection _ ImageMorph new		form: formToCopy.	canvas stampForm: selection.	(newBounds area = 0) ifTrue: [^ self].	self activeHand attachMorph: selection.	Cursor crossHair show.	self changed.		! !!MyPaintShapeMorph methodsFor: 'event handling' stamp: 'ee 11/30/2003 18:40'!mouseDown: evt	| formToCopy bottomRight |	bottomRight _ (Rectangle center: (r corner) extent: (6@6)).	shape = #text ifFalse:[	(shape = #select)		ifTrue: [selection ifNil:[	formToCopy _ Form 		extent: r extent		depth: 16.	formToCopy 		copy: (r translateBy: (canvas bounds origin negated))		from: (canvas canvasForm)		to: 0@0		rule: Form paint.	(shape = #stamp) ifFalse: [	canvas canvasForm 		fill: (r translateBy: (canvas bounds origin negated))		fillColor: (Color transparent)].		selection _ MyPaintSelectionMorph new		form: formToCopy.	selection position: (r origin).	self activeHand grabMorph: selection.	canvas shapeForm: nil.	self changed]]].	(shape = #text and: [bottomRight containsPoint: (evt cursorPoint)])		ifTrue: [self currentPoint: evt cursorPoint].	(shape = #text and: [Sensor shiftPressed])		ifTrue: [evt hand showTemporaryCursor: (Cursor handOpen).				self activeHand grabMorph: self].	! !!MyPaintShapeMorph methodsFor: 'event handling' stamp: 'jm 9/29/2003 11:05'!mouseEnter: evt	(shape = #select or: [shape = #stamp])		ifTrue: [evt hand showTemporaryCursor: Cursor handOpen].	shape = #text 		ifTrue: [evt hand showTemporaryCursor: Cursor normal].! !!MyPaintShapeMorph methodsFor: 'event handling' stamp: 'ee 7/31/2003 11:03'!mouseLeave: evt	(shape = #select or: [shape = #text or: [shape = #stamp]])		ifTrue: [evt hand showTemporaryCursor: (Cursor crossHair)].! !!MyPaintShapeMorph methodsFor: 'event handling' stamp: 'ee 11/22/2003 16:53'!mouseMove: evt	| bottomRight |	bottomRight _ Rectangle center: r corner extent: 6@6.		(shape = #text and: [bottomRight containsPoint: evt cursorPoint])		ifTrue:			[textResizeMode _ true.			self currentPoint: evt cursorPoint].	textResizeMode ifTrue: [self currentPoint: evt cursorPoint].	self changed.! !!MyPaintShapeMorph methodsFor: 'event handling' stamp: 'ee 11/22/2003 14:40'!mouseUp: evt 	textResizeMode _ false! !!MyPaintShapeMorph methodsFor: 'event handling' stamp: 'ee 11/30/2003 18:18'!startPoint: aPoint	startPoint _ aPoint.! !!MyPaintShapeMorph methodsFor: 'as yet unclassified' stamp: 'ee 7/23/2003 14:00'!text: aTextMorph	text _ aTextMorph! !!MyPaintTextMorph methodsFor: 'editing' stamp: 'ee 7/23/2003 11:29'!color: aColor	super color: aColor.	self changed.	! !!MyPaintTextMorph methodsFor: 'drawing' stamp: 'ee 9/20/2003 13:14'!drawOn: aCanvas	self setDefaultContentsIfNil.	"self drawBoundsOn: aCanvas."  "show line rects for debugging"	self startingIndex > text size		ifTrue: [self drawNullTextOn: aCanvas]		ifFalse: [aCanvas paragraph: self paragraph bounds: bounds color: (canvas brushColor)].! !!MyPaintTextMorph methodsFor: 'initialization' stamp: 'ee 7/23/2003 12:18'!initialize	super initialize.! !!MyPaintTextMorph methodsFor: 'initialization' stamp: 'ee 7/21/2003 16:22'!setCanvas:  aCanvasForm	canvas _ aCanvasForm.	self color: canvas brushColor.! !!MyPaintTextMorph methodsFor: 'event handling' stamp: 'ee 7/23/2003 12:23'!handlesMouseOver: evt	^ true! !!MyPaintTextMorph methodsFor: 'event handling' stamp: 'ee 7/23/2003 12:24'!mouseEnter: evt	evt hand showTemporaryCursor: (Cursor normal).! !!MyPaintTextMorph methodsFor: 'as yet unclassified'!bounds	^ bounds! !!MyPaintTextMorph methodsFor: 'as yet unclassified' stamp: 'ee 7/23/2003 12:29'!mouseLeave: evt	evt hand showTemporaryCursor: (Cursor crossHair).! !!MyPaintTextMorph methodsFor: 'as yet unclassified' stamp: 'ee 7/24/2003 14:48'!releaseEditor 	"Release the editor for my paragraph.  This morph no longer 'hasFocus'."	editor ifNotNil:		[self selectionChanged.		self paragraph selectionStart: nil selectionStop: nil.		editor _ nil].! !!MyPaintTextMorph methodsFor: 'as yet unclassified' stamp: 'ee 7/24/2003 14:47'!releaseParagraph	"Paragraph instantiation is lazy -- it will be created only when needed"	self releaseEditor.	paragraph ifNotNil:		[paragraph _ nil].	container ifNotNil:		[container releaseCachedState]! !!MyPaintZoomMorph methodsFor: 'accessing' stamp: 'ee 8/13/2003 09:58'!canvas: aMyPaintCanvas	canvas _ aMyPaintCanvas! !!MyPaintZoomMorph methodsFor: 'accessing' stamp: 'ee 8/11/2003 16:23'!form: aForm	self extent: aForm extent.	form _ aForm! !!MyPaintZoomMorph methodsFor: 'event handling' stamp: 'ee 8/13/2003 09:57'!handlesMouseOver: evt	^ true! !!MyPaintZoomMorph methodsFor: 'event handling' stamp: 'ee 8/13/2003 10:06'!mouseEnter: evt	| paintForm offset zoomedPaintForm |	paintForm _ (MyPaintFrame paintSkin at: ('brush', canvas brushSize printString) asSymbol).	offset _ (15@15).	(canvas scale = 1)		ifFalse: [		zoomedPaintForm _ (Form extent: (paintForm extent * canvas scale) depth: canvas canvasForm depth).		(WarpBlt toForm: zoomedPaintForm)		sourceForm: paintForm;		colorMap: (paintForm colormapIfNeededForDepth: zoomedPaintForm depth);		cellSize: 1;		combinationRule: Form paint;		copyQuad: paintForm boundingBox innerCorners toRect: zoomedPaintForm boundingBox.		paintForm _ zoomedPaintForm.		offset _ offset * canvas scale].	evt hand showTemporaryCursor: paintForm hotSpotOffset: offset.! !!MyPaintZoomMorph methodsFor: 'event handling' stamp: 'ee 8/13/2003 10:02'!mouseLeave: evt	evt hand showTemporaryCursor: nil.! !!MyPaintZoomMorph methodsFor: 'drawing' stamp: 'ee 8/11/2003 16:11'!drawOn: aCanvas	form ifNotNil: [	aCanvas paintImage: form at: bounds origin].! !!NTagDumpAnalyzer methodsFor: 'as yet unclassified' stamp: 'jm 4/12/2003 10:36'!analyze: dmpFileName sourceFile: srcFileName tagCount: tagCnt	"NTagDumpAnalyzer new analyze: 'cisco33n300.final.dmp'		sourceFile: 'cisco33jhm.txt'		tagCount: 300"	file _ (FileStream oldFileNamed: dmpFileName) binary.	compiler _ NTagLogoCompiler new.	compiler compileFileNamed: srcFileName at: 16r3000.	tagCount _ tagCnt.	self readGlobals.! !!NTagDumpAnalyzer methodsFor: 'as yet unclassified' stamp: 'jm 4/11/2003 20:08'!getLogs	| tagMemSz logaddr logelsize logi mem addr w |	tagMemSz _ 128 * 1024.	logaddr _ (2 * (compiler defs at: '&log') last) + 1.	logelsize _ (compiler defs at: 'logelsize') last.	^ (1 to: tagCount) collect: [:t |		"get logi global:"		file position: ((t - 1) * tagMemSz) + tagMemSz - (256 - (2 * 7)).		logi _ file next. logi _ logi + (file next << 8).		file position: (t - 1) * tagMemSz.		mem _ file next: tagMemSz - 256 - 1.		addr _ logaddr.		(1 to: logi) collect: [:i |			(1 to: logelsize) collect: [:j |				w _ (mem at: addr) + ((mem at: addr + 1) << 8).				addr _ addr + 2.				w]]]! !!NTagDumpAnalyzer methodsFor: 'as yet unclassified' stamp: 'jm 4/11/2003 20:38'!getMates	| raw s total byT byU byS matrix |	raw _ self getStruct: 'mates'.	^ raw collect: [:data |		s _ ReadStream on: data.		total _ s next + (256 * s next).		byT _ (1 to: (compiler constantValue: 'tTheaters'))			collect: [:x | s next + (256 * s next)].		byU _ (1 to: (compiler constantValue: 'tUserTypes'))			collect: [:x | s next + (256 * s next)].		byS _ (1 to: (compiler constantValue: 'tSpecializations'))			collect: [:x | s next + (256 * s next)].		matrix _ s next: (((compiler constantValue: 'tTags') roundUpTo: 16) // 8).		Array with: total with: byT with: byU with: byS with: matrix]! !!NTagDumpAnalyzer methodsFor: 'as yet unclassified' stamp: 'jm 4/11/2003 20:31'!getStruct: structName	"self getStruct: 'mates'"	| tagMemSz addr bytes mem |	tagMemSz _ 128 * 1024.	addr _ (2 * (compiler defs at: '&', structName) last) + 1.	bytes _ 2 * (compiler defs at: structName, 'size') last.	^ (1 to: tagCount) collect: [:t |		file position: (t - 1) * tagMemSz.		mem _ file next: tagMemSz - 256 - 1.		mem copyFrom: addr to: addr + bytes - 1]! !!NTagDumpAnalyzer methodsFor: 'as yet unclassified' stamp: 'jm 4/11/2003 20:27'!globalValueSets	| names vals |	names _ compiler globalNames.	^ (1 to: names size) collect: [:i |		vals _ ((1 to: tagCount) collect: [:j | ((globals at: j) at: i) last]) asSet.		Array with: (names at: i) with: vals asArray sort]! !!NTagDumpAnalyzer methodsFor: 'as yet unclassified' stamp: 'jm 4/11/2003 19:59'!lastNonZeroByteIndex	| tagMemSz mem |	tagMemSz _ 128 * 1024.	^ (1 to: tagCount) collect: [:t |		file position: (t - 1) * (128 * 1024).		mem _ file next: tagMemSz - 256 - 1.		(mem size to: 1 by: -1) detect: [:i | (mem at: i) > 0]]! !!NTagDumpAnalyzer methodsFor: 'as yet unclassified' stamp: 'jm 4/11/2003 20:44'!mateTotals	| bitCountTable bb bits meetings |	bitCountTable _ (0 to: 255) collect: [:b |		bb _ b.		bits _ 0.		8 timesRepeat: [bb odd ifTrue: [bits _ bits + 1]. bb _ bb >> 1].		bits].	^ self getMates collect: [:struct |		meetings _ 0.		struct last do: [:b | meetings _ meetings + (bitCountTable at: b + 1)].		Array with: struct first			with: ((struct copyFrom: 2 to: 4) collect: [:byX | byX sum])			with: meetings]! !!NTagDumpAnalyzer methodsFor: 'as yet unclassified' stamp: 'jm 4/11/2003 20:28'!readGlobals	| tagMemSz mem s val |	tagMemSz _ 128 * 1024.	globals _ (1 to: tagCount) collect: [:t |		file position: ((t - 1) * tagMemSz) + tagMemSz - 256.		mem _ file next: 256.		s _ ReadStream on: mem.		compiler globalNames collect: [:n |			val _ s next.			val _ val + (256 * s next).			Array with: n with: val]]! !This is a bytecode compiler for a simple Logo VM to run on the ntag.!!NTagLogoCompiler methodsFor: 'entry points' stamp: 'jm 2/6/2003 11:14'!addressOfFunction: fName	"Answer the address of the user function with the given name or nil if it isn't defined."	| r |	r _ self lookup: fName ifAbsent: [^ nil].	(r at: 2) = #ufun ifFalse: [self halt].	^ r last! !!NTagLogoCompiler methodsFor: 'entry points' stamp: 'jm 3/29/2003 09:39'!compile: aString at: startingAddress	"Compile a full Logo program from the given String and answer the resulting bytecode array."	| tokenList |	tokenList _ self tokensFromString: aString.	self parseAllDefinitions: tokenList.	pass1 _ true.	self generateBytecodesAt: startingAddress.  "pass 1, discard the output"	pass1 _ false.	^ self generateBytecodesAt: startingAddress  "pass 2, return the generated bytecodes"! !!NTagLogoCompiler methodsFor: 'entry points' stamp: 'jm 1/27/2003 15:12'!compileCommand: aString	"Compile the given Logo command and answer the resulting bytecodes."	| result tokenStream |	result _ WriteStream on: (ByteArray new: 1000).	tokenStream _ ReadStream on: (self tokensFromString: aString).	[tokenStream atEnd] whileFalse: [		self bytecodesFor: tokenStream onto: result lookAhead: true].	result nextPut: 0.  "end with a stop bytecode"	^ result contents! !!NTagLogoCompiler methodsFor: 'entry points' stamp: 'jm 1/27/2003 15:09'!compileFileNamed: fileName at: startingAddress	"Compile the Logo code in the file with the given name and answer the resulting bytecode array."	| sourceCode |	sourceCode _ (FileStream oldFileNamed: fileName) contentsOfEntireFile.	^ self compile: sourceCode at: startingAddress! !!NTagLogoCompiler methodsFor: 'entry points' stamp: 'jm 1/27/2003 15:19'!defs	^ defs! !!NTagLogoCompiler methodsFor: 'entry points' stamp: 'jm 2/23/2003 22:44'!globalNames	"Answer an array of global variable names, sorted by increasing memory address."	| globalRecs seen |	globalRecs _ (defs select: [:r | ((r at: 2) = #global) and: [(r at: 4) = EvalGlobalGet]]) asArray.	seen _ Set new.	globalRecs _ globalRecs select: [:r |		(seen includes: r last)			ifTrue: [false]			ifFalse: [seen add: r last. true]].	globalRecs sort: [:r1 :r2 | r1 last < r2 last].  "sort by address"	^ globalRecs collect: [:r | r first]! !!NTagLogoCompiler methodsFor: 'tokenizing' stamp: 'jm 1/13/2003 09:35'!isDelimiter: aCharacter	"Answer true if the given character is a Logo delimiter."	aCharacter <= Character space ifTrue: [^ true].  "white space"	^ '()[]"' includes: aCharacter! !!NTagLogoCompiler methodsFor: 'tokenizing' stamp: 'jm 12/19/2002 09:04'!numberFor: s base: base	"Answer the positive number represented by the given string, or nil if the string contains characters other than 0 through the last digit for the given base. Base can be 2-36."	| result digit |	result _ 0.	s do: [:ch |		(digit _ ch asUppercase digitValue) < 0 ifTrue: [^ nil].		digit > (base - 1) ifTrue: [^ nil].		result _ (base * result) + digit].	^ result! !!NTagLogoCompiler methodsFor: 'tokenizing' stamp: 'jm 12/19/2002 09:02'!numberOrToken: s	"If the given string represents a number, answer that number. Otherwise, answer the string."	| n |	(s size > 2 and: [s beginsWith: '0x']) ifTrue: [  "example: 0xFF"		n _ self numberFor: (s copyFrom: 3 to: s size) base: 16.		n ifNotNil: [^ n]].	(s size > 1 and: [s first = $$]) ifTrue: [  "example: $FF"		n _ self numberFor: (s copyFrom: 2 to: s size) base: 16.		n ifNotNil: [^ n]].	s first isDigit ifTrue: [  "example: 17"		(n _ self numberFor: s base: 10) ifNotNil: [^ n]].	(s size > 1 and: [s first = $-]) ifTrue: [  "example: -17"		n _ self numberFor: (s copyFrom: 2 to: s size) base: 10.		n ifNotNil: [^ n negated]].	^ s! !!NTagLogoCompiler methodsFor: 'tokenizing' stamp: 'jm 12/17/2002 18:34'!readList: aStream	"Read and answer list from the given stream. Lists are represented as Arrays, and may contain nested lists."	| result token |	result _ OrderedCollection new.	[aStream atEnd not and:	 [(token _ self readToken: aStream) notNil]]		whileTrue: [			token = ']' ifTrue: [^ result asArray].			result addLast: token].	self error: 'missing ]'.! !!NTagLogoCompiler methodsFor: 'tokenizing' stamp: 'jm 1/13/2003 08:36'!readLogoString: aStream	"Read a string delimited by vertical bars from the given stream."	| result ch |	result _ WriteStream on: (String new: 100).	aStream next = $| ifFalse: [self error: 'not at string start'].	[aStream atEnd] whileFalse: [		ch _ aStream next.		ch = $| ifTrue: [^ result contents].		result nextPut: ch].	self error: 'no closing | for string'! !!NTagLogoCompiler methodsFor: 'tokenizing' stamp: 'jm 1/29/2003 07:47'!readRawToken: aStream	"Read and answer the next raw Logo token from the given stream. The result is a string containing the next delimiter, word, or number. Answer nil if the stream is at the end."	| result ch |	self skipSpace: aStream.	aStream atEnd ifTrue: [^ nil].	ch _ aStream peek.	(self isDelimiter: ch) ifTrue: [^ aStream next asString].	ch = $| ifTrue: [^ self readLogoString: aStream].	result _ WriteStream on: (String new: 20).	[true] whileTrue: [		aStream atEnd ifTrue: [^ result contents].		ch _ aStream peek.		(ch = $; or: [self isDelimiter: ch]) ifTrue: [^ result contents].		result nextPut: aStream next].! !!NTagLogoCompiler methodsFor: 'tokenizing' stamp: 'jm 12/18/2002 07:31'!readToken: aStream	"Read and answer the next Logo token from the given stream. Answer nil if at the end of stream."	| token |	token _ self readRawToken: aStream.	token ifNil: [^ nil].  "end of stream"	token = '[' ifTrue: [^ self readList: aStream].	^ self numberOrToken: token! !!NTagLogoCompiler methodsFor: 'tokenizing' stamp: 'jm 12/17/2002 09:31'!skipSpace: aStream	"Advance the given stream past all white space and comments."	| ch |	[aStream atEnd not and:	 [((ch _ aStream peek) <= Character space) or: [ch = $;]]] whileTrue: [		aStream next.		ch = $; ifTrue: [  "comment; skip to end of line"			[aStream atEnd not and: [aStream peek ~= Character cr]]				whileTrue: [aStream next]]].! !!NTagLogoCompiler methodsFor: 'tokenizing' stamp: 'jm 1/27/2003 14:55'!tokensFromString: aString	"Answer an Array of tokens from the given string."	| s result token |	s _ ReadStream on: aString.	result _ OrderedCollection new: 1000.	[(token _ self readToken: s) notNil] whileTrue: [result addLast: token].	^ result asArray! !!NTagLogoCompiler methodsFor: 'parsing' stamp: 'jm 2/7/2003 08:35'!parseAllDefinitions: tokenList	"Parse the given list of tokens, processing constant, global, string, structure, and function definitions and recording them in the defs dictionary. String and function defintions are also added outputList for processing during bytecode generation."	| tokenStream |	defs _ Dictionary new.	Primitives do: [:r | self define: r first record: r].	nextGlobalAddr _ 0.  "internal RAM (2 kbytes total, 128 bytes reserved for globals)"	nextStructAddr _ 0.  "external RAM (128 kbytes total)"	"handy constants a pre-defined globals:"	self defConst: 'true' value: 1.	self defConst: 'false' value: 0.	self parseGlobalFrom: (ReadStream on: #(('n' 'm'))).	outputList _ OrderedCollection new.  "sequence of functions and strings to output"	tokenStream _ ReadStream on: tokenList.	[tokenStream atEnd] whileFalse: [		self parseTopLevel: tokenStream next from: tokenStream].! !!NTagLogoCompiler methodsFor: 'parsing' stamp: 'jm 2/7/2003 07:07'!parseConstantsFrom: tokenStream	"Read a constants definition from the given stream."	| s cName val |	s _ ReadStream on: (tokenStream next).	[s atEnd] whileFalse: [		cName _ s next.		val _ self evaluateConstant: s next.		self defConst: cName value: val].! !!NTagLogoCompiler methodsFor: 'parsing' stamp: 'jm 4/6/2003 10:40'!parseDefstructArrayFrom: tokenStream	"Read an defstruct array definition from the given stream."	| structName count items fields structWords baseAddr fName fType fOffset prefix |	structName _ tokenStream next.	count _ tokenStream next.	count isNumber ifFalse: [count _ self constantValue: count].	items _ tokenStream next.	fields _ self structFieldsFrom: items.	structWords _ fields inject: 0 into: [:t :f | t _ t + (f at: 4)].	baseAddr _ nextStructAddr.	structName = '"'		ifTrue: [structName _ '']  "anonymous struct"		ifFalse: [			self defConst: ('&', structName) value: baseAddr.			self defConst: (structName, 'elsize') value: structWords.			self defConst: (structName, 'size') value: (count * structWords).			self defMacro: ('&', structName, 'el')				expansion: (Array with: #arg with: structWords with: '*' with: baseAddr with: '+')].	fOffset _ 0.  "in words"	fields do: [:f |		fName _ structName, f first.		fType _ f at: 2.		prefix _ Array with: #arg with: structWords with: '*' with: (baseAddr + fOffset) with: '+'.  "computes field address"		self defMacro: ('&', fName) expansion: prefix.		fType = 'word' ifTrue: [			self defMacro: fName expansion: prefix, #('read').			self defMacro: ('set', fName) expansion: prefix, #(arg 'write')].		fType = 'array' ifTrue: [			self defMacro: fName expansion: prefix, #(arg '+' 'read').			self defMacro: ('set', fName) expansion: prefix, #(arg '+' arg 'write').			self defConst: (fName, 'size') value: (f at: 4)].		fType = 'bits' ifTrue: [			self defMacro: fName expansion: prefix, #(arg 'btst').			self defMacro: ('set', fName) expansion: prefix, #(arg arg 'bstore').			self defConst: (fName, 'size') value: (f at: 4).			self defConst: (fName, 'bits') value: (f at: 3)].		fType = 'string' ifTrue: [			self defMacro: fName expansion:  prefix, #(arg 'readbyte').			self defMacro: ('set', fName) expansion: prefix, #(arg arg 'writebyte').			self defConst: (fName, 'size') value: (f at: 4).			self defConst: (fName, 'chars') value: (f at: 3)].		fOffset _ fOffset + (f at: 4)].	nextStructAddr _ nextStructAddr + (count * structWords).! !!NTagLogoCompiler methodsFor: 'parsing' stamp: 'jm 2/10/2003 12:09'!parseDefstructFrom: tokenStream	"Read an defstruct definition from the given stream."	"Details: Field records have the form <fieldName><type><elementCount><sizeInWords>."	| structName items fields structWords addr fName fType prefix |	structName _ tokenStream next.	items _ tokenStream next.	fields _ self structFieldsFrom: items.	structWords _ fields inject: 0 into: [:t :f | t _ t + (f at: 4)].	addr _ nextStructAddr.	structName = '"'		ifTrue: [structName _ '']  "anonymous struct"		ifFalse: [			self defConst: ('&', structName) value: addr.			self defConst: (structName, 'size') value: structWords].	fields do: [:f |		fName _ structName, f first.		fType _ f at: 2.		self defConst: ('&', fName) value: addr.		prefix _ Array with: addr.		fType = 'word' ifTrue: [			self defMacro: fName expansion: prefix, #('read').			self defMacro: ('set', fName) expansion: prefix, #(arg 'write')].		fType = 'array' ifTrue: [			self defMacro: fName expansion: prefix, #(arg '+' 'read').			self defMacro: ('set', fName) expansion: prefix, #(arg '+' arg 'write').			self defConst: (fName, 'size') value: (f at: 4)].		fType = 'bits' ifTrue: [			self defMacro: fName expansion: prefix, #(arg 'btst').			self defMacro: ('set', fName) expansion: prefix, #(arg arg 'bstore').			self defConst: (fName, 'size') value: (f at: 4).			self defConst: (fName, 'bits') value: (f at: 3)].		fType = 'string' ifTrue: [			self defMacro: fName expansion: prefix, #(arg 'readbyte').			self defMacro: ('set', fName) expansion: prefix, #(arg arg 'writebyte').			self defConst: (fName, 'size') value: (f at: 4).			self defConst: (fName, 'chars') value: (f at: 3)].		addr _ addr + (f at: 4)].	nextStructAddr _ nextStructAddr + structWords.! !!NTagLogoCompiler methodsFor: 'parsing' stamp: 'jm 2/7/2003 07:06'!parseEnumFrom: tokenStream	"Read an enum definition from the given stream."	| n items |	n _ tokenStream next.  "starting value"	items _ tokenStream next.	items do: [:s |		self defConst: s value: n.		n _ n + 1].! !!NTagLogoCompiler methodsFor: 'parsing' stamp: 'jm 2/7/2003 07:57'!parseFunctionFrom: tokenStream	"Read a function definition from the given stream."	| functionName args body t |	functionName _ tokenStream next.	args _ OrderedCollection new.	[tokenStream peek first = $:]		whileTrue: [args addLast: tokenStream next].	body _ OrderedCollection new: 100.	[(t _ tokenStream next) = 'end'] whileFalse: [body addLast: t].	self defFunction: functionName argNames: args asArray body: body asArray.	outputList addLast: (Array with: #function with: functionName).! !!NTagLogoCompiler methodsFor: 'parsing' stamp: 'jm 2/7/2003 07:53'!parseGlobalFrom: tokenStream	"Read a global definition from the given stream."	| globalList |	globalList _ tokenStream next.	globalList do: [:gName |		nextGlobalAddr >= 256 ifTrue: [self error: 'cannot have more than 128 global variables'].		self defGlobal: gName args: 0 op: EvalGlobalGet addr: nextGlobalAddr.		self defGlobal: ('set', gName) args: 1 op: EvalGlobalSet addr: nextGlobalAddr.		nextGlobalAddr _ nextGlobalAddr + 2].! !!NTagLogoCompiler methodsFor: 'parsing' stamp: 'jm 3/29/2003 09:17'!parseStringsFrom: tokenStream	"Read a strings definition from the given stream."	| name strings |	name _ tokenStream next.	strings _ tokenStream next.	outputList addLast: (Array with: #strings with: name with: strings).	self defConst: name value: 1000.  "actual string address filled in later"! !!NTagLogoCompiler methodsFor: 'parsing' stamp: 'jm 1/25/2003 17:55'!parseTopLevel: token from: tokenStream	"Parse a top-level construct from the given token stream based on its first token."	"these first two constructs are the most common:"	'to' = token ifTrue: [^ self parseFunctionFrom: tokenStream].	'strings' = token ifTrue: [^ self parseStringsFrom: tokenStream].	'constants' = token ifTrue: [^ self parseConstantsFrom: tokenStream].	'defstruct' = token ifTrue: [^ self parseDefstructFrom: tokenStream].	'defstructa' = token ifTrue: [^ self parseDefstructArrayFrom: tokenStream].	'enum' = token ifTrue: [^ self parseEnumFrom: tokenStream].	'global' = token ifTrue: [^ self parseGlobalFrom: tokenStream].! !!NTagLogoCompiler methodsFor: 'parsing' stamp: 'jm 1/28/2003 11:22'!structFieldsFrom: anArray	"Answer an array of structure field records for the given field declarations. Field records have the form <fieldName><type><elementCount><sizeInWords>."	| result declarations fieldName type elements words |	result _ OrderedCollection new.	declarations _ ReadStream on: anArray.	[declarations atEnd] whileFalse: [		fieldName _ declarations next.		type _ declarations next asLowercase.		type = 'word'			ifTrue: [elements _ words _ 1]			ifFalse: [				elements _ declarations next.				elements isNumber ifFalse: [elements _ self evaluateConstant: elements].				words _ nil.				type = 'array' ifTrue: [words _ elements].				type = 'bits' ifTrue: [words _ (elements + 15) // 16].				type = 'string' ifTrue: [words _ (elements + 1) // 2].				words ifNil: [self error: 'unknown type in struct or structa: ', type]].		result addLast: (Array with: fieldName with: type with: elements with: words)].	^ result asArray! !!NTagLogoCompiler methodsFor: 'compiling' stamp: 'jm 2/6/2003 11:16'!bytecodesFor: tokenStream onto: aStream lookAhead: doLookahead 	| t nextT |	tokenStream atEnd ifTrue: [^ self].	t _ tokenStream next.	self bytecodesForToken: t from: tokenStream onto: aStream.	doLookahead ifTrue: [		[(nextT _ tokenStream peek) notNil and: [self isInfix: nextT]] whileTrue: [			nextT _ tokenStream next.			tokenStream atEnd ifTrue: [self error: 'missing operand for ', nextT].			self bytecodesFor: tokenStream onto: aStream lookAhead: false.  "compute operand"			aStream nextPut: ((self lookup: nextT) at: 5)]].  "append binary primitive bytecode"! !!NTagLogoCompiler methodsFor: 'compiling' stamp: 'jm 2/6/2003 11:14'!bytecodesForEvaluatingList: tokenStream token: token onto: aStream	"Generate bytecodes for a construct such as 'while' or 'waituntil' whose first argument is a list that generates a boolean value."	| listArg |	listArg _ tokenStream next.	(listArg isKindOf: Array) ifFalse: [self error: 'first argument of ', token, ' must be a list'].	self bytecodesForList: listArg onto: aStream returnsValue: true.	((self lookup: token) at: 3) - 1 timesRepeat: [  "evaluate the other arguments, if any"		self bytecodesFor: tokenStream onto: aStream lookAhead: true].! !!NTagLogoCompiler methodsFor: 'compiling' stamp: 'jm 2/17/2003 16:48'!bytecodesForFunction: functionName	| bytecodes r args body offset tokenStream result |	bytecodes _ WriteStream on: (ByteArray new: 100).	r _ self lookup: functionName.	args _ r at: 4.	body _ r at: 5.	localsAndArgs _ Dictionary new.	1 to: args size do: [:i |		offset _ (args size - i) + 3.  "offset from the frame pointer, in words"		localsAndArgs at: (args at: i) asLowercase put: offset].	localCount _ 0.	thisFunction _ functionName.	tokenStream _ ReadStream on: body.	[tokenStream atEnd] whileFalse: [		self bytecodesFor: tokenStream onto: bytecodes lookAhead: true].	result _ WriteStream on: (ByteArray new: bytecodes size + 3).	result nextPut: 2 * args size.  "argument count"	result nextPut: 2 * (localsAndArgs size - args size).  "local variable count"	result nextPutAll: bytecodes contents.	result nextPut: StopPrim.	localsAndArgs _ Dictionary new.	localCount _ 0.	thisFunction _ nil.	^ result contents! !!NTagLogoCompiler methodsFor: 'compiling' stamp: 'jm 3/29/2003 09:26'!bytecodesForIntegerLiteral: v onto: aStream	"Append the bytecodes for the given integer literal onto the given stream."	(0 <= v) & (v <= 255)		ifTrue: [  "use EvalByte for non-negative integers < 255"			aStream nextPut: EvalByte.			aStream nextPut: v]		ifFalse: [  "use EvalNum for negative integers or positive integers > 255"			aStream nextPut: EvalNum.			self int16: v onto: aStream].! !!NTagLogoCompiler methodsFor: 'compiling' stamp: 'jm 2/17/2003 16:46'!bytecodesForLet: anArray onto: aStream	"Generate bytecodes for a let construct, a sequence of alternating variable names and expressions."	| s n |	s _ ReadStream on: anArray.	[s atEnd] whileFalse: [		n _ ':', s next asLowercase.		self addLocal: n.		self bytecodesFor: s onto: aStream lookAhead: true.		aStream nextPut: EvalLocalSet.		self int8: (2 * (localsAndArgs at: n)) onto: aStream].! !!NTagLogoCompiler methodsFor: 'compiling' stamp: 'jm 1/27/2003 17:33'!bytecodesForList: anArray onto: aStream returnsValue: returnsValueFlag	| pStart pEnd listTokens |	aStream nextPut: EvalList.	pStart _ aStream position.	self int16: 0 onto: aStream.  "list size, filled in below"	listTokens _ ReadStream on: anArray.	[listTokens atEnd] whileFalse: [		self bytecodesFor: listTokens onto: aStream lookAhead: true].	returnsValueFlag		ifTrue: [aStream nextPut: EvalEOLReturn]		ifFalse: [aStream nextPut: EvalEOL].	pEnd _ aStream position.	aStream position: pStart.	self int16: (pEnd - pStart) - 2 onto: aStream.  "don't count two bytes of list size"	aStream position: pEnd.! !!NTagLogoCompiler methodsFor: 'compiling' stamp: 'jm 2/7/2003 08:02'!bytecodesForMacro: anArray from: tokenStream onto: aStream	"Generate bytecodes the given macro, drawing arguments from the token stream. A macro is a sequence of numeric bytecodes, primitive names, and the special symbol 'arg', which shows where to insert the bytecodes for the next argument from the token stream."	| r |	anArray do: [:el |		el isNumber			ifTrue: [self bytecodesForIntegerLiteral: el onto: aStream]			ifFalse: [				#arg == el					ifTrue: [self bytecodesFor: tokenStream onto: aStream lookAhead: true]					ifFalse: [						r _ self lookup: el.(r at: 2) = #prim ifFalse: [self error: 'Bad element in macro'].						aStream nextPut: (r at: 5)]]].! !!NTagLogoCompiler methodsFor: 'compiling' stamp: 'jm 3/29/2003 10:07'!bytecodesForString: aString onto: aStream	"Inline a string literal using the bytecode used for list literals."	aStream nextPut: EvalList.	self int16: aString size + 1 onto: aStream.	aStream nextPutAll: (self stringBytes: aString).	aStream nextPut: 0.! !!NTagLogoCompiler methodsFor: 'compiling' stamp: 'jm 3/2/2003 16:03'!bytecodesForStrings: intAndStringList startingAt: startingBytecodeAddr	"Answer the bytecodes for a 'strings' construct. This contains a table of absolute addresses for the string and list elements of the contruct, possibly mixed with 16-bit word constants. This table is followed by the string/bytecode data itself. Strings in the output are zero-terminated. Bytecode lists are terminated with EvalEOL. Word alignment is not done."	| nextStringAddr items words addr out |	nextStringAddr _ startingBytecodeAddr + (2 * intAndStringList size).  "reserve space for the address/word table"	items _ intAndStringList collect: [:item | self stringsElement: item].	words _ items collect: [:el |		el isNumber			ifTrue: [el]			ifFalse: [				addr _ nextStringAddr.				nextStringAddr _ nextStringAddr + el size.				addr]].	out _ WriteStream on: (ByteArray new: 1000).	words do: [:w | self int16: w onto: out].	items do: [:el | el isNumber ifFalse: [out nextPutAll: el]].	^ out contents! !!NTagLogoCompiler methodsFor: 'compiling' stamp: 'jm 2/17/2003 16:52'!bytecodesForToken: t from: tokenStream onto: aStream	| n offset r what argCount |	t isInteger ifTrue: [^ self bytecodesForIntegerLiteral: t onto: aStream].	(t isKindOf: Array) ifTrue: [^ self bytecodesForList: t onto: aStream returnsValue: false].	(t = '"') ifTrue: [^ self bytecodesForString: tokenStream next onto: aStream].	t = '(' ifTrue: [		self bytecodesFor: tokenStream onto: aStream lookAhead: true.		tokenStream peek = ')'			ifTrue: [tokenStream next]			ifFalse: [self error: 'unbalanced parentheses'].		^ self].	t = 'let' ifTrue: [^ self bytecodesForLet: tokenStream next onto: aStream].	((t = 'waituntil') |	 (t = 'while')) ifTrue: [		self bytecodesForEvaluatingList: tokenStream token: t onto: aStream.		aStream nextPut: ((self lookup: t) at: 5).		^ self].	t = 'make' ifTrue: [		tokenStream next = '"' ifFalse: [self error: 'first argument to make must be quoted'].		n _ ':', tokenStream next asLowercase.  "variables stored with leading colon"		offset _ localsAndArgs at: n ifAbsent: [self error: 'undefined local or argument: ', n].		self bytecodesFor: tokenStream onto: aStream lookAhead: true.  "emit code for right-hand side"		aStream nextPut: EvalLocalSet.		self int8: (2 * offset) onto: aStream.		^ self].	(r _ self lookup: t ifAbsent: [nil]) ifNotNil: [		what _ r at: 2.		argCount _ r at: 3.		argCount = -1 ifTrue: [self error: 'improper use of infix operator: ', t].		argCount timesRepeat: [self bytecodesFor: tokenStream onto: aStream lookAhead: true].		what = #const ifTrue: [self bytecodesForIntegerLiteral: (r at: 4) onto: aStream].		what = #global ifTrue: [aStream nextPut: (r at: 4). aStream nextPut: (r at: 5)].		what = #macro ifTrue: [self bytecodesForMacro: (r at: 4) from: tokenStream onto: aStream].		what = #prim ifTrue: [aStream nextPut: (r at: 5)].		what = #ufun ifTrue: [			(t = thisFunction and: [tokenStream atEnd])				ifTrue: [aStream nextPut: EvalUfunTail]				ifFalse: [aStream nextPut: EvalUfun].			self int16: (r at: 6) onto: aStream].  "function address"		^ self].	n _ t asLowercase.	(localsAndArgs includesKey: n) ifTrue: [		aStream nextPut: EvalLocalGet.		self int8: (2 * (localsAndArgs at: n)) onto: aStream.		^ self].	self error: 'undefined: ', t.! !!NTagLogoCompiler methodsFor: 'compiling' stamp: 'jm 3/29/2003 09:44'!generateBytecodesAt: startingAddress	"Make a pass over the outputList generating bytecodes and computing the addresses of all functions and strings."	"Details: This is method is used for both passes, but the result of the first pass is discarded because the bytecodes produced in that pass are based on placeholder values for the function and string addresses. As a sanity check, the sizes of all functions and strings from the first pass are recorded in a dictionary in pass one and checked in pass two. If they are not the same, there is a problem."	| nextBytecodeAddr out what name bytecodes |	pass1 ifTrue: [pass1Sizes _ Dictionary new: outputList size].	nextBytecodeAddr _ startingAddress.  "Flash memory (60 kbytes total, holds bytecodes and strings"	out _ WriteStream on: (ByteArray new: 10000).	outputList do: [:r |		what _ r first.		name _ r at: 2.		what = #function ifTrue: [			(self lookup: name) at: 6 put: nextBytecodeAddr.  "record the address of this function"			bytecodes _ self bytecodesForFunction: name.			nextBytecodeAddr _ nextBytecodeAddr + bytecodes size.			out nextPutAll: bytecodes].		what = #strings ifTrue: [			(self lookup: name) at: 4 put: nextBytecodeAddr.  "update strings address"			bytecodes _ self bytecodesForStrings: (r at: 3) startingAt: nextBytecodeAddr.			nextBytecodeAddr _ nextBytecodeAddr + bytecodes size.			out nextPutAll: bytecodes].		"sanity check: sizes must be the same in pass2 or addresses will be wrong"		pass1			ifTrue: [pass1Sizes at: name put: bytecodes size]			ifFalse: [(pass1Sizes at: name) = bytecodes size ifFalse: [self halt: name]]].	^ out contents! !!NTagLogoCompiler methodsFor: 'private' stamp: 'jm 1/26/2003 22:40'!addLocal: localName	"Add a local variable with the given name."	(localsAndArgs includes: localName)		ifTrue: [self error: 'Already defined as a local or argument: ', localName].	localCount _ localCount + 1.	localsAndArgs at: localName put: localCount negated.! !!NTagLogoCompiler methodsFor: 'private' stamp: 'jm 2/6/2003 11:15'!constantValue: constantName	"Return the value of the given numeric constant."	| r |	r _ self lookup: constantName ifAbsent: [nil].	(r notNil and:	 [(r at: 2) = #const and:	 [(r at: 4) isNumber]]) ifTrue: [^ r at: 4].	self error: 'Undefined constant: ', constantName.! !!NTagLogoCompiler methodsFor: 'private' stamp: 'jm 2/7/2003 07:21'!defConst: aString value: val	"Add a constant definition to defs mapping the given name to the given value. Give an error if the name is already defined."	self		define: aString		record: (Array with: aString with: #const with: 0 with: val).! !!NTagLogoCompiler methodsFor: 'private' stamp: 'jm 2/7/2003 08:00'!defFunction: aString argNames: argNames body: bodyTokens	"Add a definition to defs for the given function. Give an error if the name is already defined."	self		define: aString		record: (Array			with: aString with: #ufun with: argNames size with: argNames with: bodyTokens			with: 0).  "function address filled in later"! !!NTagLogoCompiler methodsFor: 'private' stamp: 'jm 2/7/2003 07:52'!defGlobal: aString args: argCount op: op addr: addr	"Add a global definition to defs. Give an error if the name is already defined."	self		define: aString		record: (Array with: aString with: #global with: argCount with: op with: addr).! !!NTagLogoCompiler methodsFor: 'private' stamp: 'jm 2/7/2003 07:24'!defMacro: aString expansion: anArray	"Add a macro definition to defs. Give an error if the name is already defined."	self		define: aString		record: (Array with: aString with: #macro with: 0 with: anArray).! !!NTagLogoCompiler methodsFor: 'private' stamp: 'jm 2/7/2003 07:20'!define: aString record: anArray	"Add a definition to defs mapping the given name to the given record. Give an error if the name is already defined. If the name is not already all lowercase, make an additional entry for the all-lowercase version of the name."	| lowercase |	lowercase _ aString asLowercase.	(defs includesKey: lowercase) ifTrue: [self error: 'Cannot redefine: ', aString].	defs at: aString put: anArray.	(aString = lowercase) ifFalse: [defs at: lowercase put: anArray].! !!NTagLogoCompiler methodsFor: 'private' stamp: 'jm 1/23/2003 10:04'!evaluateConstant: tokenOrList	"Evaluate the given constant definition. The argument may be a number, a string (i.e., the name of another constant), or an Array (i.e., a Logo expression)."	| expr |	tokenOrList isNumber ifTrue: [^ tokenOrList].	(tokenOrList isKindOf: String) ifTrue: [^ self constantValue: tokenOrList].	"tokenOrList is an expression; evaluate it"	expr _ WriteStream on: String new.	tokenOrList do: [:el |		el isNumber ifTrue: [expr nextPutAll: el printString].		(el isKindOf: String) ifTrue: [			((el size = 1) and: ['+-*/()' includes: el first])				ifTrue: [expr nextPutAll: el]				ifFalse: [expr nextPutAll: (self constantValue: el) printString]].		expr space].	^ Compiler evaluate: expr contents! !!NTagLogoCompiler methodsFor: 'private' stamp: 'jm 3/29/2003 09:23'!int16: v onto: aStream	"Append a two-byte (16-bit) signed integer onto the given stream, low-order byte first."	(-32768 <= v) & (v <= 65535) ifFalse: [self error: 'integer value out of range'].	aStream nextPut: (v bitAnd: 255).	aStream nextPut: ((v bitShift: -8) bitAnd: 255).! !!NTagLogoCompiler methodsFor: 'private' stamp: 'jm 1/23/2003 11:47'!int8: v onto: aStream	"Append a one-byte signed integer onto the given stream."	(-128 <= v) & (v < 127) ifFalse: [self error: 'signed byte value out of range'].	v < 0		ifTrue: [aStream nextPut: 256 + v]		ifFalse: [aStream nextPut: v].! !!NTagLogoCompiler methodsFor: 'private' stamp: 'jm 2/6/2003 11:13'!isInfix: token	"Answer true if the given token is a primitive infix operator."	| r argCount |	r _ self lookup: token ifAbsent: [^ false].	argCount _ r at: 3.	^ ((r at: 2) = #prim) and: [argCount = -1]! !!NTagLogoCompiler methodsFor: 'private' stamp: 'jm 2/6/2003 11:14'!lookup: aString	"Look up and return the definition of the given string in the definitions dictionary."	^ self lookup: aString ifAbsent: [self error: 'Undefined: ', aString]! !!NTagLogoCompiler methodsFor: 'private' stamp: 'jm 2/7/2003 07:33'!lookup: aString ifAbsent: aBlock	"Look up and return the definition of the given string in the definitions dictionary. Lookup ignores case. If it is not defined, return the result of evaluating the given block."	"Details: All names in defs have an all-lowercase entry, if needed, in addition to the mixed-case version of the name as it first appears in the source file. A name is first looked up in its raw form. This will succeed if the programmer was consistent about the casing of the name. If that fails, the name is looked up in it's all-lowercase form. Note: this method is sometimes called with a non-string argument." 	^ defs at: aString ifAbsent: [		(aString isKindOf: String)			ifTrue: [defs at: aString asLowercase ifAbsent: aBlock]			ifFalse: [aBlock value]]! !!NTagLogoCompiler methodsFor: 'private' stamp: 'jm 4/7/2003 00:09'!stringBytes: aString	"Answer a ByteArray representing the given string. Map Mac to nTag characters."	| result ch |	result _ aString copy asByteArray.	1 to: result size do: [:i |		ch _ result at: i.		ch > 127 ifTrue: [			Transcript show: 'char > 127 in "', aString, '"'; cr.			(ch = 226) | (ch = 146)				ifTrue: [result at: i put: 39] "apostrophe character"				ifFalse: [result at: i put: 32]]].	^ result! !!NTagLogoCompiler methodsFor: 'private' stamp: 'jm 3/29/2003 10:08'!stringsElement: arg	"Compute an element for the 'strings' construct. The argument may be a number, a constant, a string, or a list (code). If the result is a number, it will be inserted directly into the string address array. If it is a ByteArray, its bytes will be appended to the end of the strings construct and their starting address will be inserted in the string address array."	| s bytecodes |	arg isNumber ifTrue: [^ arg].	(arg isKindOf: Array) ifTrue: [		s _ WriteStream on: ByteArray new.		self bytecodesForList: arg onto: s returnsValue: false.		bytecodes _ s contents.		"Note: bytecodes already ends with EOL bytecode; skip first three bytes"		^ bytecodes copyFrom: 4 to: bytecodes size].	(arg isKindOf: String) ifTrue: [		arg first = $: ifTrue: [^ self constantValue: (arg copyFrom: 2 to: arg size)].		^ (self stringBytes: arg) copyWith: 0].	self error: 'unexpected "strings" element'.! !!NTagLogoCompiler class methodsFor: 'class initialization' stamp: 'jm 2/23/2003 08:01'!definePrimitives: aString	"Define the Logo primitives from the given string."	| triplesArray n j primName isReporter argCount |	triplesArray _ aString findTokens: #(9 10 12 13 32) asByteArray asString.	(triplesArray size \\ 3) = 0 ifFalse: [self error: 'should be a multiple of 3'].	Primitives _ OrderedCollection new.	n _ FirstPrimitive.  "n is the primitive number"	(1 to: triplesArray size // 3) do: [:i |		j _ ((i - 1) * 3) + 1.		primName _ (triplesArray at: j) asString.		isReporter _ (triplesArray at: j + 1) = 'r'.		argCount _ (triplesArray at: j + 2) asNumber.		Primitives addLast: (Array with: primName with: #prim with: argCount with: isReporter with: n).		primName = 'stop' ifTrue: [StopPrim _ n].		n _ n + 1].	Primitives addLast: (Array with: 'db-str' with: #prim with: 1 with: false with: 252).	Primitives addLast: (Array with: 'db-num' with: #prim with: 1 with: false with: 253).	Primitives addLast: (Array with: 'db-sp' with: #prim with: 0 with: false with: 254).	Primitives addLast: (Array with: 'db-cr' with: #prim with: 0 with: false with: 255).! !!NTagLogoCompiler class methodsFor: 'class initialization' stamp: 'jm 1/27/2003 16:12'!initialize	"self initialize"	EvalDone _ 0.	EvalByte _ 1.	EvalNum _ 2.	EvalList _ 3.	EvalEOL _ 4.	EvalEOLReturn _ 5.	EvalLocalGet _ 6.	EvalLocalSet _ 7.	EvalGlobalGet _ 8.	EvalGlobalSet _ 9.	EvalUfun _ 10.	EvalUfunTail _ 11.	FirstPrimitive _ 12.	self definePrimitives: self primitiveDefinitionsString.! !!NTagLogoCompiler class methodsFor: 'class initialization' stamp: 'jm 4/7/2003 18:39'!primitiveDefinitionsString	"Answer the primitives definition string. This string was copied verbatim from the Logo code for the Ntag Logo compiler (logoConsole.logo)."	"self initialize"	^ '   stop c 0 output c 1 stop!! c 0  loop c 1  repeat c 2     run c 1  if c 2  ifelse c 3  waituntil c 1  while c 2   catch c 1  throw c 0   + r -1 - r -1  * r -1  / r -1  % r -1   lsh r 2  and r -1  or r -1  not r 1   = r -1  !!= r -1  > r -1  < r -1  random r 1   resett c 0  resett2 c 0  resett3 c 0  resett4 c 0     timer r 0  timer2 r 0  timer3 r 0  timer4 r 0     wait c 1  seconds r 0  setseconds c 1   timestamp r 0  settimestamptime c 2   lowbyte r 1  highbyte r 1  makeword r 2   eb r 1  db c 2  ew r 1  dw c 2  nth r 2  memcpy c 3  memset c 3   read r 1  write c 2  readbyte r 2  writebyte c 3   bset c 2  bclr c 2 btst r 2 bstore c 3    button1 r 0  button2 r 0  button3 r 0  tilt r 0   green c 0  greenoff c 0  bl c 0  bloff c 0   drawc c 3 printn c 3  show c 1  clearline c 1 cls c 0    normal c 0  inverse c 0 smallfont c 0  bigfont c 0   setrc c 2  row r 0  column r 0   drawstr c 1  strwidth r 1  nextline c 0     fast c 0  slow c 0   lcd-cmd c 1  rightside-up c 0  upside-down c 0   sendpacket c 2 packet? r 0  packet-count r 0  move-packet c 2  clear-packet c 0   silence r 0  packet-errors r 0  clear-packet-errors c 0   setrange c 1  hgetc r 0  hputc c 1   thestring r 0  clearstr c 0  addcstr c 1  addnum c 1   addstr c 1 storestr c 2  %reset c 0     limit r 2  setlimithandler c 1  limip r 0  limval r 0  limlim r 0   tag# r 0'! !!NTagLogoCompiler class methodsFor: 'java utils' stamp: 'jm 2/20/2003 14:06'!extractImplementedPrimitivesFromJava: aString	"Extract a list of primtives that appear to be implemented in the given string, assumed to be a Java source file."	| lines prims startI endI |	lines _ aString findTokens: String crlf.	lines _ lines select: [:s | (s findString: 'case prim_') > 0].	prims _ lines asArray collect: [:s |		startI _ (s findString: 'prim_') + 5.		endI _ (s findString: ':' startingAt: startI).		s copyFrom: startI to: endI - 1].	^ prims! !!NTagLogoCompiler class methodsFor: 'java utils' stamp: 'jm 2/2/2003 11:12'!javaPrimitiveDefs	"Answer a string containing primitive definitions formated as Java constant declarations."	"self javaPrimitiveDefs"	| substitutions result prefix primName |	substitutions _ self javaPrimitiveSubstitutionsDict.	result _ WriteStream on: (String new: 10000).	prefix _ '   static final int prim_'.	Primitives do: [:r |		primName _ substitutions at: r first ifAbsent: [r first].		(primName includes: $-) ifTrue: [  "replace dash with underscore"			primName _ primName collect: [:c | c = $- ifTrue: [$_] ifFalse: [c]]].		result nextPutAll: prefix.		result nextPutAll: primName.		result nextPutAll: ' = ', r last printString, ';'.		result cr].	^ result contents! !!NTagLogoCompiler class methodsFor: 'java utils' stamp: 'jm 4/6/2003 23:48'!javaPrimitiveSubstitutionsDict	"Answer a Dictionary that maps between Logo primitive names and their Java case statement equivalents."	| dict |	dict _ Dictionary new.	#(('stop!!' stopb)('packet?' packetp)('tag#' tagnum)('rfsend?' rfsendp)('%reset' xreset)	  (+ sum)(- diff)(* mul)(/ divide)(% remainder)	  (= eq)('!!=' ne)(< lt)(> gr)) do: [:pair |		dict at: pair first asString put: pair second asString].	^ dict! !!NTagLogoCompiler class methodsFor: 'java utils' stamp: 'jm 2/20/2003 14:04'!primitivesNotImplementedInJava: aString	"Answer a collection of primitives defined here but not implemented in the given Java source string."	| substitutions javaPrims allPrims jName |	substitutions _ self javaPrimitiveSubstitutionsDict.	javaPrims _ (self extractImplementedPrimitivesFromJava: aString) asSet.	allPrims _ Primitives collect: [:r |		jName _ r first asString.		jName _ substitutions at: jName ifAbsent: [jName].		(jName includes: $-) ifTrue: [			jName _ jName collect: [:s | s = $- ifTrue: [$_] ifFalse: [s]]].		jName].	^ allPrims asArray select: [:p | (javaPrims includes: p) not]! !!NTagPuppetMaster methodsFor: 'initialization' stamp: 'jm 4/3/2003 11:40'!initialize	"compiler on empty source allows evaluation even when no file has been loaded:"	compiler _ NTagLogoCompiler new.	compiler compile: '' at: 0.	scriptStream _ nil.! !!NTagPuppetMaster methodsFor: 'file creation' stamp: 'jm 4/7/2003 21:52'!generateFullMatrix: n	"NTagPuppetMaster new generateFullMatrix: 500"	| simName |	simName _ 'fullMatrix', n printString.	scriptStream _ FileStream newFileNamed: simName, '.sim'.	self addCreateTags: 1 tagReaders: 0.	self addDumpTagDataToFile: simName, '.begin.dmp'.	self addCreateTags: n tagReaders: 0.	1 to: n do: [:i |		self addMessage: 'Tag ', i printString, ' of ', n printString.		1 to: n do: [:j |			i = j ifFalse: [				self addRunTags: (Array with: i with: j) doIR: true doRF: false mSecs: 5000]]].	self addDumpTagDataToFile: simName, '.final.dmp'.	scriptStream close.	scriptStream _ nil.! !!NTagPuppetMaster methodsFor: 'file creation' stamp: 'jm 4/9/2003 21:44'!generateFullTest2: n seconds: totalSeconds sourceFile: srcFileName	"NTagPuppetMaster new generateFullTest2: 100 seconds: 5000 sourceFile: 'cisco27test.txt'"	"NTagPuppetMaster new loadCodeFromFile: 'cisco27test.txt' outFile: 'cisco27testB.sim'"	| simName rand mSecs msecsPerRound rounds indices tagPair |	n odd ifTrue: [self error: 'n must be even'].	simName _ 'test', n printString.	scriptStream _ (FileStream newFileNamed: simName, '.sim') binary.	self addCreateTags: n tagReaders: 0.	"simulate clock jitter by running each tag a random of seconds (0 to 60)"	rand _ Random seed: 314159265.	1 to: n do: [:i |		mSecs _ (rand next * 60000) roundTo: 10.		self addZoomTags: (Array with: i) runMSecs: 1 skipMSecs: 9 totalMSecs: mSecs].	msecsPerRound _ 13300.	rounds _ ((totalSeconds * 1000) / msecsPerRound) truncated.	indices _ (1 to: n) asArray.	0 to: rounds do: [:r |		(r \\ 20) = 0 ifTrue: [self addMessage: 'Round ', r printString, ' of ', rounds printString].		indices _ indices shuffledBy: rand.		1 to: n by: 2 do: [:i |			tagPair _ Array with: (indices at: i) with: (indices at: i + 1).			mSecs _ (rand next * msecsPerRound) roundTo: 100.			self addZoomTags: tagPair runMSecs: 5 skipMSecs: 95 totalMSecs: mSecs.			self addRunTags: tagPair doIR: true doRF: false mSecs: (msecsPerRound - mSecs)]].	self addDumpTagDataToFile: simName, '.final.dmp'.	scriptStream close.	scriptStream _ nil.! !!NTagPuppetMaster methodsFor: 'file creation' stamp: 'jm 4/8/2003 13:50'!generateFullTest: n seconds: totalSeconds sourceFile: srcFileName	"NTagPuppetMaster new generateFullTest: 100 seconds: 175000 sourceFile: 'cisco27jhmV2.txt'"	| simName rand mSecs sched elapsedSecs interactionProb rfReadProb msecsPerRound rounds indices nonCommunicatingTags tagPair p pairs |	n odd ifTrue: [self error: 'n must be even'].	simName _ 'fullconf', n printString.	scriptStream _ (FileStream newFileNamed: simName, '.sim') binary.	self loadCodeFromFile: srcFileName.	self addCreateTags: n tagReaders: 0.	"simulate clock jitter by running each tag a random of seconds (0 to 60)"	rand _ Random seed: 314159265.	1 to: n do: [:i |		mSecs _ (rand next * 60000) roundTo: 10.		self addZoomTags: (Array with: i) runMSecs: 1 skipMSecs: 9 totalMSecs: mSecs].	friends _ (1 to: n) collect: [:i | ByteArray new: n].	meetings _ Array new: n withAll: 0.	sched _ self interactionProbabilitySchedule.	elapsedSecs _ 0.	interactionProb _ 0.1.  "default"	rfReadProb _ 0.005.	msecsPerRound _ 13300.	rounds _ ((totalSeconds * 1000) / msecsPerRound) truncated.	pairsPerRound _ OrderedCollection new: 1000.	indices _ (1 to: n) asArray.	0 to: rounds do: [:r |		pairs _ 0.		(sched size > 0 and: [elapsedSecs >= sched first first]) ifTrue: [			interactionProb _ sched removeFirst last].		(r \\ 100) = 0 ifTrue: [self addMessage: 'Round ', r printString, ' of ', rounds printString].		(r \\ 2000) = 0 ifTrue: [			self addDumpTagDataToFile: simName, '.r', r printString, '.dmp.txt'.			"self addDumpLogsToFile: simName, '.r', r printString, '.log.txt'"].		indices _ indices shuffledBy: rand.		nonCommunicatingTags _ OrderedCollection new.		1 to: n by: 2 do: [:i |			tagPair _ Array with: (indices at: i) with: (indices at: i + 1).			p _ interactionProb.			((friends at: tagPair first) at: tagPair second) = 0 ifTrue: [p _ p / 10.0].			rand next < p				ifTrue: [					meetings at: tagPair first put: (meetings at: tagPair first) + 1.					meetings at: tagPair second put: (meetings at: tagPair second) + 1.					(friends at: tagPair first) at: tagPair second put: 1.					(friends at: tagPair second) at: tagPair first put: 1.					pairs _ pairs + 1.					mSecs _ (rand next * msecsPerRound) roundTo: 100.					self addZoomTags: tagPair runMSecs: 5 skipMSecs: 95 totalMSecs: mSecs.					self addRunTags: tagPair doIR: true doRF: false mSecs: (msecsPerRound - mSecs)]				ifFalse: [					rand next < rfReadProb						ifTrue: [							mSecs _ (rand next * msecsPerRound) roundTo: 100.							self addZoomTags: tagPair runMSecs: 5 skipMSecs: 95 totalMSecs: mSecs.							self addRunTags: tagPair doIR: false doRF: true mSecs: (msecsPerRound - mSecs)]						ifFalse: [nonCommunicatingTags addAll: tagPair]]].		nonCommunicatingTags size > 0 ifTrue: [			self addZoomTags: nonCommunicatingTags runMSecs: 5 skipMSecs: 95 totalMSecs: msecsPerRound].		pairsPerRound addLast: pairs.		elapsedSecs _ elapsedSecs + (msecsPerRound / 1000.0)].	self addDumpLogsToFile: simName, '.logs.txt'.	self addDumpTagDataToFile: simName, '.final.dmp'.	scriptStream close.	scriptStream _ nil.! !!NTagPuppetMaster methodsFor: 'file creation' stamp: 'jm 4/12/2003 00:11'!generateFullTest: n seconds: totalSeconds sourceFile: srcFileName stringsFile: stringsFile	"NTagPuppetMaster new generateFullTest: 10 seconds: 175000 sourceFile: 'cisco33jhm.txt' stringsFile: 'ciscostrings33.txt'"	| simName rand mSecs sched elapsedSecs interactionProb rfReadProb msecsPerRound rounds indices nonCommunicatingTags tagPair p pairs |	n odd ifTrue: [self error: 'n must be even'].	simName _ 'cisco33n', n printString.	scriptStream _ (FileStream newFileNamed: simName, '.sim') binary.	self loadCodeFromFile: stringsFile at: 16rB000.	self loadCodeFromFile: srcFileName.	self addCreateTags: n tagReaders: 0.	"simulate clock jitter by running each tag a random of seconds (0 to 60)"	rand _ Random seed: 314159265.	1 to: n do: [:i |		mSecs _ (rand next * 60000) roundTo: 10.		self addZoomTags: (Array with: i) runMSecs: 1 skipMSecs: 9 totalMSecs: mSecs].	friends _ (1 to: n) collect: [:i | ByteArray new: n].	meetings _ Array new: n withAll: 0.	sched _ self interactionProbabilitySchedule.	elapsedSecs _ 0.	interactionProb _ 0.1.  "default"	rfReadProb _ 0.005.	msecsPerRound _ 13300.	rounds _ ((totalSeconds * 1000) / msecsPerRound) truncated.	pairsPerRound _ OrderedCollection new: 1000.	indices _ (1 to: n) asArray.	0 to: rounds do: [:r |		pairs _ 0.		(sched size > 0 and: [elapsedSecs >= sched first first]) ifTrue: [			interactionProb _ sched removeFirst last].		(r \\ 100) = 0 ifTrue: [self addMessage: 'Round ', r printString, ' of ', rounds printString].		(r \\ 2000) = 0 ifTrue: [			self addDumpTagDataToFile: simName, '.r', r printString, '.dmp.txt'.			"self addDumpLogsToFile: simName, '.r', r printString, '.log.txt'"].		indices _ indices shuffledBy: rand.		nonCommunicatingTags _ OrderedCollection new.		1 to: n by: 2 do: [:i |			tagPair _ Array with: (indices at: i) with: (indices at: i + 1).			p _ interactionProb.			((friends at: tagPair first) at: tagPair second) = 0 ifTrue: [p _ p / 10.0].			rand next < p				ifTrue: [					meetings at: tagPair first put: (meetings at: tagPair first) + 1.					meetings at: tagPair second put: (meetings at: tagPair second) + 1.					(friends at: tagPair first) at: tagPair second put: 1.					(friends at: tagPair second) at: tagPair first put: 1.					pairs _ pairs + 1.					mSecs _ (rand next * msecsPerRound) roundTo: 100.					self addZoomTags: tagPair runMSecs: 5 skipMSecs: 95 totalMSecs: mSecs.					self addRunTags: tagPair doIR: true doRF: false mSecs: (msecsPerRound - mSecs)]				ifFalse: [					rand next < rfReadProb						ifTrue: [							mSecs _ (rand next * msecsPerRound) roundTo: 100.							self addZoomTags: tagPair runMSecs: 5 skipMSecs: 95 totalMSecs: mSecs.							self addRunTags: tagPair doIR: false doRF: true mSecs: (msecsPerRound - mSecs)]						ifFalse: [nonCommunicatingTags addAll: tagPair]]].		nonCommunicatingTags size > 0 ifTrue: [			self addZoomTags: nonCommunicatingTags runMSecs: 5 skipMSecs: 95 totalMSecs: msecsPerRound].		pairsPerRound addLast: pairs.		elapsedSecs _ elapsedSecs + (msecsPerRound / 1000.0)].	self addDumpLogsToFile: simName, '.logs.txt'.	self addDumpTagDataToFile: simName, '.final.dmp'.	scriptStream close.	scriptStream _ nil.! !!NTagPuppetMaster methodsFor: 'file creation' stamp: 'jm 4/8/2003 02:14'!generateMOSTest: n minutes: minutes sourceFile: srcFileName	"NTagPuppetMaster new generateMOSTest: 150 minutes: 120 sourceFile: 'mos3jhm.txt'"	| simName msecsPerRound meetingsPerHour meetingProb rounds rand indices nonCommunicatingTags tagPair t |	n odd ifTrue: [self error: 'n must be even'].	simName _ 'shuffled', n printString.	scriptStream _ (FileStream newFileNamed: simName, '.sim') binary.	self loadCodeFromFile: srcFileName.	self addCreateTags: n tagReaders: 0.	self museumOfScienceInit: n.	msecsPerRound _ 13300.	meetingsPerHour _ 30.	meetingProb _ meetingsPerHour asFloat / ((60 * 60 * 1000) / msecsPerRound). "per round"	rounds _ (minutes * 60 * 1000) // msecsPerRound.	rand _ Random seed: 314159265.	indices _ (1 to: n) asArray.	0 to: rounds do: [:r |		(r \\ 100) = 0 ifTrue: [self addMessage: 'Round ', r printString, ' of ', rounds printString].		indices _ indices shuffledBy: rand.		nonCommunicatingTags _ OrderedCollection new.		1 to: n by: 2 do: [:i |			tagPair _ Array with: (indices at: i) with: (indices at: i + 1).			rand next < meetingProb				ifTrue: [					t _ (rand next * msecsPerRound) asInteger roundTo: 100.					self addRunTags: tagPair doIR: true doRF: false mSecs: t.					self addZoomTags: tagPair runMSecs: 5 skipMSecs: 95 totalMSecs: (msecsPerRound - t)]				ifFalse: [nonCommunicatingTags addAll: tagPair]].		nonCommunicatingTags size > 0 ifTrue: [			self addZoomTags: nonCommunicatingTags runMSecs: 5 skipMSecs: 95 totalMSecs: msecsPerRound]].	self addDumpTagDataToFile: simName, '.final.dmp'.	scriptStream close.	scriptStream _ nil.! !!NTagPuppetMaster methodsFor: 'file creation' stamp: 'jm 4/10/2003 20:36'!generateMeme: n seconds: seconds sourceFile: srcFileName	"NTagPuppetMaster new generateMeme: 10 seconds: 13200 sourceFile: 'cisco30meme.txt'"	| simName rand mSecs msecsPerRound rounds indices tagPair mSecs2 nonCommunicatingTags |	n odd ifTrue: [self error: 'n must be even'].	simName _ 'meme', n printString.	scriptStream _ (FileStream newFileNamed: simName, '.sim') binary.	self loadCodeFromFile: srcFileName.	self addCreateTags: n tagReaders: 0.	"simulate clock jitter by running each tag a random of seconds (0 to 60)"	rand _ Random seed: 314159265.	1 to: n do: [:i |		mSecs _ (rand next * 60000) roundTo: 10.		self addZoomTags: (Array with: i) runMSecs: 1 skipMSecs: 9 totalMSecs: mSecs].	msecsPerRound _ 13300.	rounds _ (seconds * 1000) // msecsPerRound.	indices _ (1 to: n) asArray.	0 to: rounds do: [:r |		(r \\ 20) = 0 ifTrue: [self addMessage: 'Round ', r printString, ' of ', rounds printString].		indices _ indices shuffledBy: rand.		nonCommunicatingTags _ OrderedCollection new.		1 to: n by: 2 do: [:i |			tagPair _ Array with: (indices at: i) with: (indices at: i + 1).			(rand next < 0.2)				ifTrue: [					mSecs _ (rand next * 6000) roundTo: 100.					self addZoomTags: tagPair runMSecs: 5 skipMSecs: 95 totalMSecs: mSecs.					mSecs2 _ (rand next * (msecsPerRound - (mSecs + 200))) truncated.					self addRunTags: tagPair doIR: true doRF: false mSecs: mSecs2.					(rand next < 0.3) ifTrue: [self addSetButtons: 516 tag: tagPair first].					(rand next < 0.3) ifTrue: [self addSetButtons: 516 tag: tagPair last].					self addRunTags: tagPair doIR: true doRF: false mSecs: (msecsPerRound - (mSecs + mSecs2)).					self addSetButtons: 512 tag: tagPair first.					self addSetButtons: 512 tag: tagPair last]				ifFalse: [nonCommunicatingTags addAll: tagPair]].		nonCommunicatingTags size > 0 ifTrue: [			self addZoomTags: nonCommunicatingTags runMSecs: 5 skipMSecs: 95 totalMSecs: msecsPerRound]].	self addDumpLogsToFile: simName, '.logs.txt'.	self addDumpTagDataToFile: simName, '.final.dmp'.	scriptStream close.	scriptStream _ nil.! !!NTagPuppetMaster methodsFor: 'file creation' stamp: 'jm 4/3/2003 11:46'!loadCodeFromFile: inFileName outFile: outFileName	"Compile and load the given file. The file is compiled for a specific target address. The compiler state is retained to allow compiling commands the call functions defined in the file."	"NTagPuppetMaster new loadCodeFromFile: 'cisco12.txt' outFile: 'cisco12.sim'"	scriptStream _ FileStream newFileNamed: outFileName.	self loadCodeFromFile: inFileName.	scriptStream close.	scriptStream _ nil.! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 4/3/2003 11:42'!addCreateTags: tagCount tagReaders: readerCount	"Create the given number of ntags. All existing tags will be destroyed."	scriptStream nextPutAll:		('C' asByteArray, (self numToBytes: tagCount), (self numToBytes: readerCount)).! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 4/3/2003 17:13'!addDumpLogsToFile: fileName	"Add a command to dump all tag logs to the file with the given name. The log starting address and log entry size are extracted from the compiler, which means that scripts created using this command depend on the source file."	| logiAddr msg |	logiAddr _ 16r300 + (2 * ((compiler globalNames indexOf: 'logi') - 1)).	msg _ 'U', (ByteArray with: fileName size), fileName,		(self numToBytes: (compiler constantValue: '&log')),		(self numToBytes: logiAddr),		(self numToBytes: (compiler constantValue: 'logelsize')).	scriptStream nextPutAll: msg.! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 4/3/2003 17:11'!addDumpTagDataToFile: fileName	"Add a command to dump all tag memories to a file with the given name."	scriptStream nextPutAll: ('W', (ByteArray with: fileName size), fileName).! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 4/3/2003 17:11'!addMessage: aString	"Add a command to the script to print the given message string."	scriptStream nextPutAll: 'M', (ByteArray with: aString size), aString.! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 4/7/2003 22:06'!addRunTags: tagArray doIR: doIR doRF: doRF mSecs: mSecs	"Add a command to execute the given tags for the given number of milliseconds. If doIRFlag is true, the first two tags are placed in IR communication with each other. If tagReaderIndex is > 0, then the tags are considered to be in range of an RF tag reader."	| msg |	msg _ WriteStream on: (ByteArray new: 100).	msg nextPut: $R asciiValue.	msg nextPutAll: (self numToBytes: tagArray size).	tagArray do: [:tagIndex | msg nextPutAll: (self numToBytes: tagIndex)].	msg nextPut: (doIR ifTrue: [1] ifFalse: [0]).	msg nextPut: (doRF ifTrue: [1] ifFalse: [0]).	msg nextPutAll: (self numToBytes: mSecs).	scriptStream nextPutAll: msg contents.! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 4/7/2003 21:06'!addRunTags: tagArray doIR: doIRFlag reader: tagReaderIndex mSecs: mSecs	"Add a command to execute the given tags for the given number of milliseconds. If doIRFlag is true, the first two tags are placed in IR communication with each other. If tagReaderIndex is > 0, then the tags are considered to be in range of an RF tag reader."	| msg |doIRFlag ifTrue: [Transcript show: '*'].tagReaderIndex > 0 ifTrue: [Transcript show: '='].Transcript show: '[', mSecs printString, '] '.tagArray do: [:t | Transcript show: t printString; space].Transcript cr.	msg _ WriteStream on: (ByteArray new: 100).	msg nextPut: $R asciiValue.	msg nextPutAll: (self numToBytes: tagArray size).	tagArray do: [:tagIndex | msg nextPutAll: (self numToBytes: tagIndex)].	msg nextPut: (doIRFlag ifTrue: [1] ifFalse: [0]).	msg nextPut: tagReaderIndex.	msg nextPutAll: (self numToBytes: mSecs).	scriptStream nextPutAll: msg contents.! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 4/10/2003 19:16'!addSetButtons: buttonWord tag: tagNum	"Set the button state word for the given ntag. The ntag's three buttons are in the least significant three bits of the button word as follow: <...13-bits reserved...><button-3><button-2><button-1>."	scriptStream		nextPutAll: 'B' asByteArray;		nextPutAll: (self numToBytes: tagNum);		nextPutAll: (self numToBytes: buttonWord).! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 4/6/2003 12:49'!addWriteBytes: aByteArray at: address tag: tagNum	| msg |	msg _ '<' asByteArray,		(self numToBytes: tagNum),		(self numToBytes: address),		(self numToBytes: aByteArray size),		aByteArray asByteArray.	scriptStream nextPutAll: msg.! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 4/6/2003 10:28'!addWriteExtWords: anArray at: address tag: tagNum	| msg |	msg _ '[' asByteArray,		(self numToBytes: tagNum),		(self numToBytes: address),		(self numToBytes: anArray size),		(self wordsToBytes: anArray).	scriptStream nextPutAll: msg.! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 4/3/2003 17:08'!addZoomTags: tagArray runMSecs: runMSecs skipMSecs: skipMSecs totalMSecs: totalMSecs	"Add a command to execute the given tags in 'zoom' mode for the given number of milliseconds. Repeatedly run the VM for runMSecs then skip time ahead by skipMSecs until totalMSecs milliseconds has been simulated."	scriptStream nextPut: $Z asciiValue.	scriptStream nextPutAll: (self numToBytes: tagArray size).	tagArray do: [:tagIndex | scriptStream nextPutAll: (self numToBytes: tagIndex)].	scriptStream nextPutAll: (self numToBytes: runMSecs).	scriptStream nextPutAll: (self numToBytes: skipMSecs).	scriptStream nextPutAll: (self numToBytes: totalMSecs).! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 4/3/2003 18:39'!compileFile: inFileName	"Compile the given file. The file is compiled for a specific target address. The compiler state is retained to allow looking up symbols defined in the file."	compiler _ NTagLogoCompiler new.	compiler compileFileNamed: inFileName at: 16r3000.! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 4/8/2003 02:08'!interactionProbabilitySchedule	"Answer a collection of pairs where the first entry in each pair is the elapsed time in seconds and the second entry is the probability of two tags interacting in a given 13.3 second epoch."	"Note: Array below is pairs of <duration in minutes><interaction level mnemonic>."	"NTagPuppetMaster new interactionProbabilitySchedule"	| result elapsed p |	result _ OrderedCollection new.	elapsed _ 0.	#(	"Day 1:"		(30 low)		(60 hi)		(90 med)		(60 hi)		(120 low)	"Day 2:"		(420 vlow)		(60 hi)		(135 med)		(30 hi)		(90 med)		(75 med) "lunch"		(480 hi)		(150 low)	"Day 3:"		(420 vlow)		(60 hi)		(135 med)		(30 hi)		(45 med)		(60 med) "lunch"		(240 hi)		(60 med)		(45 hi)	) do: [:e |		'vlow' = e last ifTrue: [p _ 0.002].		'low' = e last ifTrue: [p _ 0.01].		'med' = e last ifTrue: [p _ 0.05].		'hi' = e last ifTrue: [p _ 0.4].		result addLast: (Array with: elapsed with: p).		elapsed _ elapsed + (e first * 60)].	^ result! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 4/3/2003 11:55'!loadCodeFromFile: inFileName	"Compile and load the given file. The file is compiled for a specific target address. The compiler state is retained to allow compiling commands the call functions defined in the file."	| tagNum targetAddr bytecodes startAddr |	tagNum _ 0.	targetAddr _ 16r3000.	compiler ifNil: [compiler _ NTagLogoCompiler new].	bytecodes _ compiler compileFileNamed: inFileName at: targetAddr.	scriptStream nextPutAll: '<' asByteArray,		(self numToBytes: tagNum), (self numToBytes: targetAddr), (self numToBytes: bytecodes size).	scriptStream nextPutAll: bytecodes.	startAddr _ compiler addressOfFunction: 'startup'.	startAddr ifNotNil: [		scriptStream nextPutAll: ('P' asByteArray, (self numToBytes: tagNum), (self numToBytes: startAddr + 2))].! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 4/12/2003 00:01'!loadCodeFromFile: inFileName at: targetAddr	"Compile and load the given file. The file is compiled for a specific target address. The compiler state is retained to allow compiling commands the call functions defined in the file."	| tagNum bytecodes startAddr |	tagNum _ 0.	compiler ifNil: [compiler _ NTagLogoCompiler new].	bytecodes _ compiler compileFileNamed: inFileName at: targetAddr.	scriptStream nextPutAll: '<' asByteArray,		(self numToBytes: tagNum), (self numToBytes: targetAddr), (self numToBytes: bytecodes size).	scriptStream nextPutAll: bytecodes.	startAddr _ compiler addressOfFunction: 'startup'.	startAddr ifNotNil: [		scriptStream nextPutAll: ('P' asByteArray, (self numToBytes: tagNum), (self numToBytes: startAddr + 2))].! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 4/6/2003 12:51'!museumOfScienceInit: tagCount	"Initialize the 'microseconds' register with random 16-bit values."	| rand n |	rand _ Random seed: 314159265.	1 to: tagCount do: [:tagNum |		n _ (65535 * rand next) rounded.		self addWriteBytes: (Array with: (n bitAnd: 255) with: ((n >> 8) bitAnd: 255))			at: 16r190 tag: tagNum].! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 2/2/2003 18:12'!numToBytes: anInteger	"Answer a two-byte ByteArray containing the given 16-bit integer, least significant byte first."	^ ByteArray with: (anInteger bitAnd: 255) with: ((anInteger >> 8) bitAnd: 255)! !!NTagPuppetMaster methodsFor: 'private' stamp: 'jm 4/6/2003 10:46'!wordsToBytes: aCollection	"Serialize the given collection of 16-bit integers into a ByteArray."	| result |	result _ WriteStream on: (ByteArray new: 2 * aCollection size).	aCollection do: [:n |		result nextPut: (n bitAnd: 255).		result nextPut: ((n bitShift: -8) bitAnd: 255)].	^ result contents! !I represent an image in the repository or timeline view of a Narrator.!!NarratorImageMorph methodsFor: 'initialization' stamp: 'jm 9/11/2003 12:34'!initialize	super initialize.	titleMorph _ StringMorph new.	fileName _ ''.	self addMorph: titleMorph.	self title: 'Untitled'.! !!NarratorImageMorph methodsFor: 'accessing' stamp: 'jm 9/11/2003 12:31'!fileName	^ fileName! !!NarratorImageMorph methodsFor: 'accessing' stamp: 'jm 9/11/2003 12:31'!fileName: aString	fileName _ aString.! !!NarratorImageMorph methodsFor: 'accessing' stamp: 'RG 11/26/2003 14:56'!lastLocation"returns the Morph that this was last located in" "should be of type StoryLineContentsMorph and NarratorRepositoryMorph only"^ lastLocation! !!NarratorImageMorph methodsFor: 'accessing' stamp: 'RG 11/26/2003 14:41'!lastLocation: aMorph	lastLocation _ aMorph.! !!NarratorImageMorph methodsFor: 'accessing' stamp: 'jm 9/9/2003 11:18'!originalImage	^ originalImage! !!NarratorImageMorph methodsFor: 'accessing' stamp: 'jm 9/9/2003 21:07'!originalImage: aForm	| thumbnail |	originalImage _ aForm.	thumbnail _ originalImage toThumbnail: 60@60 borderWidth: 1 borderColor: Color yellow.	self form: thumbnail.! !!NarratorImageMorph methodsFor: 'accessing' stamp: 'jm 9/9/2003 16:26'!title		^ titleMorph contents! !!NarratorImageMorph methodsFor: 'accessing' stamp: 'jm 9/9/2003 16:30'!title: aString		titleMorph contents: aString.	titleMorph center: self center.	titleMorph top: self bottom + 2.! !!NarratorImageMorph class methodsFor: 'instance creation' stamp: 'jm 12/9/2003 17:49'!fromFileNamed: fileName	| f title |	[f _ Form fromFileNamed: fileName] ifError: [f _ ImageMorph defaultForm.].	title _ FileDirectory baseNameFor: (FileDirectory localNameFor: fileName).	^ self new originalImage: f; fileName: fileName; title: title! !I am a tool for creating and playing simple slide shows with sound tracks and narration. I have three main subwindows:	o repository (a NarratorRepositoryMorph) -- shows the images and sounds that have been imported	o story line (a StoryLineMorph) -- a scrollable time-line into which images and sounds are dragged	o output (an ImageMorph) -- shows the current imageI also have buttons to load the repository with images or sounds from a user-selected folder and a set of buttons to control playback and to allow recording of new sounds.!!NarratorMorph methodsFor: 'initialization' stamp: 'jm 1/4/2004 10:09'!initialize	| b controls t |	super initialize.	"self class readIcons."	"create the background"	self extent: 800@600.	self borderWidth: 3.	self borderColor: #raised.	self color: Color lightGray.		"create the image and sound repository"	repositoryMorph _ NarratorRepositoryMorph new.	repositoryMorph position: 25@5; extent: 400@300.	self addMorph: repositoryMorph.	"create buttons to load images and sounds"	b _ IconicButton new.	b labelGraphic: ImportImagesButton.	b extent: ImportImagesButton extent.	b borderColor: Color black.	b borderWidth: 1; color: Color transparent. 	b position: 430@10.	b target: repositoryMorph.	b actionSelector: #loadImagesFromUserFolder.	self addMorph: b.		b _ b copy.	b labelGraphic: ImportSoundsButton.	b target: repositoryMorph.	b position: 430@(20 + b height).	b actionSelector: #loadSoundsFromUserFolder.	self addMorph: b.	b _ b copy.	b labelGraphic: NewSoundsButton.	b target: repositoryMorph.	b position: 430@130.	b actionSelector: #record.	self addMorph: b.		"adding trash bin"	t _ TrashBinMorph new.	t position: 430@180.	self addMorph: t.	"create the output morph"	outputMorph _ ImageMorph new.	outputMorph form: (Form extent: 300@225 depth: 16).	outputMorph form fillColor: Color veryLightGray.	outputMorph position: 490@5.	self addMorph: outputMorph.	"create the StoryLine"	storyLineMorph _ StoryLineMorph new.	storyLineMorph narrator: self.	storyLineMorph position: 25@330.	self addMorph: storyLineMorph.	"create controls"	controls _ self makePlayButtons.	controls position: 490@238.	self addMorph: controls.	b _ SimpleButtonMorph new 	label: 'save';	target: storyLineMorph;	actionSelector: #save; 	borderColor: #raised;	borderWidth: 3; 	useSquareCorners.	b position: 435@275.	self addMorph: b.! !!NarratorMorph methodsFor: 'other' stamp: 'LY 11/20/2003 12:56'!makePlayButtons	| r space b slider |	r _ AlignmentMorph newRow.	r color: Color white; borderWidth: 1; inset: 3.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #center.	space _ Morph new color: r color; extent: 5@5.	b _ SimpleButtonMorph new		target: storyLineMorph;		borderColor: #raised;		borderWidth: 3;		useSquareCorners.	r addMorphBack: (b fullCopy label: 'Rewind'; actionSelector: #rewind).	r addMorphBack: space copy.	r addMorphBack: (b fullCopy label: 'Play'; actionSelector: #startPlaying).	r addMorphBack: space copy.	r addMorphBack: (b fullCopy label: 'Stop'; actionSelector: #stopPlaying).	r addMorphBack: space copy.	"r addMorphBack: (b fullCopy label: 'Record'; actionSelector: #record; target: self)."	r addMorphBack: (space copy width: 5).	r addMorphBack: (StringMorph new contents: 'Volume').	r addMorphBack: space copy.		slider _ SimpleSliderMorph new		color: Color veryVeryLightGray;		extent: 60@2;		target: storyLineMorph;		value: storyLineMorph volume;		actionSelector: #setVolume:.	r addMorphBack: slider.	^ r! !!NarratorMorph methodsFor: 'other' stamp: 'jm 9/10/2003 16:13'!showImage: aForm	| f scale destExtent destRect |	f _ outputMorph form.	f fillColor: Color veryLightGray.	scale _ ((f width / aForm width) min: (f height / aForm height)) min: 1.0.	destExtent _ (aForm extent * scale) truncated.	destRect _ (f extent - destExtent) // 2 extent: destExtent.	(WarpBlt toForm: f)		sourceForm: aForm;		colorMap: (aForm colormapIfNeededForDepth: f depth);		cellSize: 2;		combinationRule: Form over;		copyQuad: aForm boundingBox innerCorners toRect: destRect.	outputMorph changed.! !!NarratorMorph methodsFor: 'accessing' stamp: 'RG 9/30/2003 14:20'!repository^ repositoryMorph! !!NarratorMorph methodsFor: 'accessing' stamp: 'RG 9/30/2003 14:21'!storyLine^ storyLineMorph! !!NarratorMorph methodsFor: 'loading' stamp: 'jm 1/4/2004 10:45'!loadProject	"load from a project folder"	| fileDir imageFiles imageHolder fullName soundFiles soundHolder |	"ask user for the folder"	fileDir _ StandardFileMenu getFolder.	"convert image files into ImageHolder instances and add them to the ImageRepository"		fileDir ifNotNil: [	"load up images to be little thumbnails"		imageFiles _  fileDir fileNames select: [:n |			#(jpg gif) includes: ((FileDirectory extensionFor: n) asLowercase).].		imageFiles do: [ :i | 			fullName _ fileDir pathName, FileDirectory slash, i.			imageHolder _ NarratorImageMorph fromFileNamed: fullName.			repositoryMorph contents addMorphBack: imageHolder].	"load up sounds to be little thumbnails"		soundFiles _ fileDir fileNames select: [:n |			#(wav aif) includes: ((FileDirectory extensionFor: n) asLowercase).].		soundFiles do: [:i | 			fullName _ fileDir pathName, FileDirectory slash, i.			soundHolder _ NarratorSoundMorph fromFileNamed: fullName.			repositoryMorph contents addMorphBack: soundHolder].].		self changed.! !!NarratorMorph class methodsFor: 'instance creation' stamp: 'jm 9/12/2003 16:29'!includeInNewMorphMenu	^ true! !!NarratorMorph class methodsFor: 'class initialization' stamp: 'jm 9/10/2003 16:15'!initialize	PixelsPerSecond _ 100.! !!NarratorMorph class methodsFor: 'class initialization' stamp: 'jm 9/10/2003 08:59'!pixelsPerSecond	^ PixelsPerSecond! !!NarratorMorph class methodsFor: 'class initialization' stamp: 'LY 11/20/2003 12:43'!readIcons	"Read the Forms for my icons from the default directory."	"self readIcons"	ImportImagesButton _ Form fromFileNamed: 'folder-icon.jpg'.	ImportSoundsButton _ Form fromFileNamed: 'folder-music-icon.jpg'.	NewSoundsButton _ Form fromFileNamed: 'new-sound.jpg'.! !I am a set of controls that supports sound recording for a Narrator.the recorded sound is in SequentialSound format and sampledSound is that sound converted to a SampledSound.!!NarratorRecordingMorph methodsFor: 'initialization' stamp: 'jm 9/9/2003 11:21'!initialize	| r |	super initialize.	borderWidth _ 2.	orientation _ #vertical.	recorder _ SoundRecorder new.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self makeRecordLevelSlider).	r addMorphBack: self makeRecordMeter.	r addMorphBack: self makeButtonColumn.	self addMorphBack: r.	self extent: 10@10.  "make minimum size"! !!NarratorRecordingMorph methodsFor: 'initialization' stamp: 'LY 9/23/2003 13:08'!makeButtonColumn	| r r2 |	r _ AlignmentMorph newColumn hResizing: #shrinkWrap.	r2 _ AlignmentMorph newRow vResizing:#shrinkWrap.	r2 addMorphBack: (self buttonName: 'Record' action: #record).	r2 addMorphBack: self makeStatusLight.	r addMorphBack: r2.	r addMorphBack: (Morph new extent: 1@2; color: color).	r addMorphBack: (self buttonName: 'Play' action: #playback).	r addMorphBack: (Morph new extent: 1@2; color: color).	r addMorphBack: (self buttonName: 'Stop' action: #stop).	r addMorphBack: (Morph new extent: 1@2; color: color).	r addMorphBack: (self buttonName: 'Edit'  action: #edit).	r addMorphBack: (Morph new extent: 1@9; color: color).		r addMorphBack: (self buttonName: 'accept' action: #accept).	r addMorphBack: (Morph new extent: 1@2; color: color).	r addMorphBack: (self buttonName: 'cancel' action: #cancel).	^ r! !!NarratorRecordingMorph methodsFor: 'initialization' stamp: 'jm 9/9/2003 11:21'!makeStatusLight	recordingStatusLight _ Morph new extent: 7@7.	recordingStatusLight color: Color transparent.	^ recordingStatusLight! !!NarratorRecordingMorph methodsFor: 'initialization' stamp: 'LY 11/20/2003 12:55'!repository: aNarratorRepositoryMorph 	repository _ aNarratorRepositoryMorph.	! !!NarratorRecordingMorph methodsFor: 'button commands' stamp: 'LY 12/19/2003 14:51'!accept	| name soundHolder |	"Still need to make the new sound into a sound file.	copy sound by creating array of total sound size, and copyingFrom: to: for the entire array, faster"	recorder recordedSound ifNil: [^ self delete].	recorder recordedSound pause.	name _ 'sound', (repository nextSoundNum asString).	soundHolder _ NarratorSoundMorph fromSound: sampledSound name: name.	"sampledSound storeWAVOnFileNamed: (name, '.wav')"	repository contents addMorphBack: soundHolder.		self delete.! !!NarratorRecordingMorph methodsFor: 'button commands' stamp: 'jm 9/9/2003 11:25'!cancel	recorder pause.	self delete.! !!NarratorRecordingMorph methodsFor: 'button commands' stamp: 'LY 9/23/2003 13:00'!edit	recorder pause.	recorder recordedSound ifNil: [^ self].	sampledSound ifNil: [ sampledSound _ self consolidateSound].	ScratchSoundEditor new sound: sampledSound;	openInWorld.! !!NarratorRecordingMorph methodsFor: 'button commands' stamp: 'jm 9/9/2003 11:25'!playback	recorder pause.	recorder playback.! !!NarratorRecordingMorph methodsFor: 'button commands' stamp: 'jm 9/9/2003 11:22'!record	recorder clearRecordedSound.	recorder resumeRecording.	recordingStatusLight color: Color red.! !!NarratorRecordingMorph methodsFor: 'button commands' stamp: 'LY 9/23/2003 12:49'!stop		recorder pause.	sampledSound _ self consolidateSound.! !!NarratorRecordingMorph methodsFor: 'stepping' stamp: 'LY 8/8/2003 12:15'!startStepping	"Make the level meter active when dropped into the world. Do nothing if already recording. Note that this will cause other recorders to stop recording..."	super startStepping.	recorder isPaused ifTrue: [		SoundRecorder allSubInstancesDo: [:r | r stopRecording].  "stop all other sound recorders"		recorder pause].  "meter is updated while paused"! !!NarratorRecordingMorph methodsFor: 'stepping' stamp: 'jm 9/9/2003 11:26'!step	| ex |	recorder isPaused		ifTrue: [recordingStatusLight color: Color transparent]		ifFalse: [recordingStatusLight color: Color red].	ex _  (recordMeter width)@(recorder meterLevel + 1).	recordMeter position: recordMeter position + recordMeter extent - ex.	recordMeter extent: ex.! !!NarratorRecordingMorph methodsFor: 'stepping' stamp: 'LY 8/8/2003 12:15'!stepTime	^ 50! !!NarratorRecordingMorph methodsFor: 'stepping' stamp: 'LY 8/8/2003 12:15'!stopStepping	"Turn off recording."	super stopStepping.	recorder stopRecording.! !!NarratorRecordingMorph methodsFor: 'other' stamp: 'LY 8/8/2003 15:01'!addRecordLevelSlider	| levelSlider r |	levelSlider _ SimpleSliderMorph new		color: color;		extent: 10@100;		target: recorder;		actionSelector: #recordLevel:;		adjustToValue: recorder recordLevel.	levelSlider color: Color lightGray.	levelSlider toggleDescending.	r _ AlignmentMorph newColumn		color: color;		inset: 0;		centering: #center;		hResizing: #rigid;		vResizing: #shrinkWrap;		width: 24.	r addMorphBack: (StringMorph contents: '10').	r addMorphBack: levelSlider.	r addMorphBack: (StringMorph contents: ' 0').	self addMorphBack: r.! !!NarratorRecordingMorph methodsFor: 'other' stamp: 'LY 8/8/2003 12:15'!buttonName: aString action: aSymbol	^ SimpleButtonMorph new		target: self;		label: aString;		actionSelector: aSymbol! !!NarratorRecordingMorph methodsFor: 'other' stamp: 'LY 8/12/2003 17:41'!consolidateSound	"makes the sound into one SampledSound instead of a sequential sound that contains an array of sounds"	| sounds samplesLength totSamples index |		recorder recordedSound ifNil: [^self].		"ALTERNATE WAY"	"totSamples _ #().	recorder recordedSound sounds 		do: [:ss |	 totSamples _ totSamples, ss samples.].	^SampledSound samples: totSamples samplingRate: recorder samplingRate."	sounds _ recorder recordedSound sounds. "sounds is an array of SampledSounds"	samplesLength _ sounds inject: 0 into: [:subLength :currSound | subLength + (currSound samples size)].		totSamples _ Array new: samplesLength.		index _ 1.	sounds do: [:ellie | 		totSamples replaceFrom: index to: (index + (ellie samples size) - 1) with: ellie samples.		index _ index + (ellie samples size).]. 	^ SampledSound samples: totSamples samplingRate: recorder samplingRate.! !!NarratorRecordingMorph methodsFor: 'other' stamp: 'LY 8/8/2003 15:00'!makeRecordLevelSlider	| levelSlider r |	levelSlider _ SimpleSliderMorph new		color: color;		extent: 10@100;		target: recorder;		actionSelector: #recordLevel:;		adjustToValue: recorder recordLevel.	levelSlider color: Color lightGray.	levelSlider toggleDescending.	r _ AlignmentMorph newColumn		color: color;		inset: 0;		centering: #center;		hResizing: #rigid;		vResizing: #shrinkWrap;		width: 24.	r addMorphBack: (StringMorph contents: '10').	r addMorphBack: levelSlider.	r addMorphBack: (StringMorph contents: ' 0').	^r.! !!NarratorRecordingMorph methodsFor: 'other' stamp: 'LY 8/8/2003 16:17'!makeRecordMeter	| outerBox r |	outerBox _ Morph new extent: 18@102; color: Color gray.	recordMeter _ Morph new extent: 16@1; color: Color yellow.	recordMeter left: (outerBox left) + 1.	recordMeter bottom: (outerBox bottom) - 1.	outerBox addMorph: recordMeter.	r _ AlignmentMorph newColumn		color: color;		inset: 0;		centering: #center;		hResizing: #rigid;		vResizing: #shrinkWrap;		width: 24.	r addMorphBack: (StringMorph contents: '10').	r addMorphBack: outerBox.	r addMorphBack: (StringMorph contents: ' 0').	^r.! !!NarratorRecordingMorph methodsFor: 'other' stamp: 'LY 8/8/2003 12:15'!updateReferencesUsing: aDictionary	"Copy my recorder."	super updateReferencesUsing: aDictionary.	recorder _ SoundRecorder new.! !I am used as a parts bin of the available images and sounds in a Narrator.!!NarratorRepositoryMorph methodsFor: 'initialization' stamp: 'LY 11/18/2003 13:53'!initialize	super initialize.	soundNum _ 0.	"make me into a parts bin that accepts images dragged from the desktop"	contents isPartsBin: true.	contents enableDragNDrop: true.	contents padding: 20.	contents autoLineLayout: true.! !!NarratorRepositoryMorph methodsFor: 'stepping' stamp: 'RG 11/26/2003 14:50'!step	"Check for dropped image or sound files."	| droppedFiles p m |	droppedFiles _ FileStream droppedFiles.	droppedFiles size = 0 ifTrue: [^ self].	p _ droppedFiles first. "store the the point in which the file was dropped"	(droppedFiles copyFrom: 2 to: droppedFiles size) do: [:file |		m _ [NarratorSoundMorph fromFileNamed: file name] ifError: [nil].		m ifNil: [			m _ [NarratorImageMorph fromFileNamed: file name] ifError: [nil]].		m ifNotNil: [			m position: p.			self contents acceptDroppingMorph: m event: MorphicEvent new]].! !!NarratorRepositoryMorph methodsFor: 'stepping' stamp: 'LB 6/27/2003 16:35'!stepTime	^ 300! !!NarratorRepositoryMorph methodsFor: 'other' stamp: 'jm 12/8/2003 15:02'!loadImagesFromUserFolder	"Load images from user-specified folder."	| fileDir imageFiles imageHolder fullName |	fileDir _ StandardFileMenu getFolder.  "ask user for the folder"	"convert image files into ImageHolder instances and add them to the ImageRepository"	fileDir ifNotNil: [		imageFiles _  fileDir fileNames select: [:n |			#(jpg gif) includes: ((FileDirectory extensionFor: n) asLowercase).].		imageFiles do: [ :i | 			fullName _ fileDir pathName, FileDirectory slash, i.			imageHolder _ NarratorImageMorph fromFileNamed: fullName.			"now we set the last location of the ImageMorph to the repository			so that this image knows its source, this will change if its dropped into			the storyLine"			imageHolder lastLocation: self.			self contents addMorphBack: imageHolder]].	self changed.! !!NarratorRepositoryMorph methodsFor: 'other' stamp: 'jm 12/8/2003 15:03'!loadSoundsFromUserFolder	"Load all sounds from a user-specified folder."	| fileDir m |	fileDir _ StandardFileMenu getFolder.  "ask user for the folder"	fileDir ifNil: [^ self].	"collect sounds"	fileDir fileNames do: [:n |		(#(aif aiff au wav) includes: (FileDirectory extensionFor: n) asLowercase) ifTrue: [			m _ NarratorSoundMorph fromFileNamed: (fileDir fullNameFor: n).			m lastLocation: self.			self contents addMorphBack: m]].	self changed.! !!NarratorRepositoryMorph methodsFor: 'other' stamp: 'jm 9/9/2003 18:38'!nextSoundNum	^ soundNum _ soundNum + 1.! !!NarratorRepositoryMorph methodsFor: 'other' stamp: 'LY 11/20/2003 13:58'!record	| recorder |	recorder _ NarratorRecordingMorph new openInWorld.	recorder repository: self.	recorder position: self bounds origin + (472@270).	owner addMorphFront: recorder.! !I represent an image in the repository or timeline view of a Narrator. I display a compressed version of the entire sound scaled to the same timescale as the timeline.!!NarratorSoundMorph methodsFor: 'initialization' stamp: 'jm 9/13/2003 19:22'!initialize	super initialize.	self form: SpeakerIconForm.	titleMorph _ StringMorph new.	fileName _ ''.	self addMorph: titleMorph.	self title: 'Untitled'.! !!NarratorSoundMorph methodsFor: 'accessing' stamp: 'jm 9/11/2003 12:35'!fileName	^ fileName! !!NarratorSoundMorph methodsFor: 'accessing' stamp: 'jm 9/11/2003 12:35'!fileName: aString	fileName _ aString.! !!NarratorSoundMorph methodsFor: 'accessing' stamp: 'RG 11/26/2003 14:42'!lastLocation"returns the Morph that this was last located in" "should be of type StoryLine and Repository only"^ lastLocation! !!NarratorSoundMorph methodsFor: 'accessing' stamp: 'RG 11/26/2003 14:43'!lastLocation: aMorph	lastLocation _ aMorph.! !!NarratorSoundMorph methodsFor: 'accessing' stamp: 'jm 9/13/2003 19:29'!scaleToPixelsPerSecond: pixPerSec	"Compute my image for the given time scale."	pixPerSecOrNil = pixPerSec ifTrue: [^ self].  "already computed"	self form: (sound formPixelsPerSecond: pixPerSec).	pixPerSecOrNil _ pixPerSec.	self title: self title.  "re-center my title"! !!NarratorSoundMorph methodsFor: 'accessing' stamp: 'jm 7/30/2003 10:37'!sound	^ sound! !!NarratorSoundMorph methodsFor: 'accessing' stamp: 'jm 9/13/2003 19:25'!sound: aSound	sound _ aSound.! !!NarratorSoundMorph methodsFor: 'accessing' stamp: 'jm 9/9/2003 16:40'!title		^ titleMorph contents! !!NarratorSoundMorph methodsFor: 'accessing' stamp: 'jm 9/9/2003 16:40'!title: aString		titleMorph contents: aString.	titleMorph center: self center.	titleMorph top: self bottom + 2.! !!NarratorSoundMorph methodsFor: 'accessing' stamp: 'LY 10/2/2003 12:59'!writeSoundFile: fullFileName	sound storeWAVOnFileNamed: fullFileName.	! !!NarratorSoundMorph methodsFor: 'menu ops' stamp: 'LY 11/18/2003 13:05'!editSound	sound ifNil: [^self].	ScratchSoundEditor new sound: sound; 	openInWorld.! !!NarratorSoundMorph methodsFor: 'menu ops' stamp: 'LY 11/18/2003 13:17'!rename	| answer |	"called when the user wants to input a scale value"	answer _ (FillInTheBlankMorph request: 'Please type desired name:' initialAnswer: (self title) centerAt: self bounds topLeft + (150@30) inWorld: World onCancelReturn:  '1x' acceptOnCR: true).	self title: answer.	self fileName: answer.	 ! !!NarratorSoundMorph methodsFor: 'menu ops' stamp: 'LY 11/18/2003 13:00'!rightButtonMenu	| menu |	menu _ CustomMenu new.	menu add: 'rename sound' action: #rename.	menu add: 'edit sound' action: #editSound.		menu invokeOn: self. ! !!NarratorSoundMorph methodsFor: 'event handling' stamp: 'LY 11/18/2003 13:58'!handlesMouseDown: evt	evt yellowButtonPressed		ifTrue: [^true].	^super handlesMouseDown: evt.! !!NarratorSoundMorph methodsFor: 'event handling' stamp: 'LY 11/18/2003 13:59'!mouseDown: evt	evt yellowButtonPressed		ifTrue:[ Sensor waitNoButton. self rightButtonMenu].	! !!NarratorSoundMorph class methodsFor: 'class initialization' stamp: 'jm 9/13/2003 19:23'!initialize	SpeakerIconForm _ ((ColorForm		extent: 48@48		depth: 4		fromArray: #(1145320243 858993459 858993459 858993459 858993459 858997828 1078211379 858993459 858993459 858993459 858993459 858997764 1144193024 0 0 0 0 13124 1144193024 0 0 0 0 13124 855638016 0 0 0 0 51 855638016 0 0 0 0 51 855638016 0 34 0 570425344 51 855638016 0 34 0 570425344 51 855638016 0 8738 0 2228224 51 855638016 0 8738 0 2228224 51 855638016 0 2232610 8704 8704 51 855638016 0 2232610 8704 8704 51 855638016 0 571543842 34 34 51 855638016 0 571543842 34 34 51 855638016 34 286331170 0 570425378 51 855638016 34 286331170 0 570425378 51 855638016 8721 286331170 2228224 570425378 51 855638016 8721 286331170 2228224 570425378 51 855638050 572657937 286331170 2228224 570425344 570425395 855638050 572657937 286331170 2228224 570425344 570425395 855638050 286331153 286331170 8704 2228224 570425395 855638050 286331153 286331170 8704 2228224 570425395 855638050 286331153 286331170 8704 2228224 570425395 855638050 286331153 286331170 8704 2228224 570425395 855638050 286331153 286331170 8704 2228224 570425395 855638050 286331153 286331170 8704 2228224 570425395 855638050 286331153 286331170 8704 2228224 570425395 855638050 286331153 286331170 8704 2228224 570425395 855638050 572657937 286331170 2228224 570425344 570425395 855638050 572657937 286331170 2228224 570425344 570425395 855638016 8721 286331170 2228224 570425378 51 855638016 8721 286331170 2228224 570425378 51 855638016 34 286331170 0 570425378 51 855638016 34 286331170 0 570425378 51 855638016 0 571543842 34 34 51 855638016 0 571543842 34 34 51 855638016 0 2232610 8704 8704 51 855638016 0 2232610 8704 8704 51 855638016 0 8738 0 2228224 51 855638016 0 8738 0 2228224 51 855638016 0 51 0 570425344 51 855638016 0 51 0 570425344 51 855638016 0 0 0 0 51 855638016 0 0 0 0 51 1144193024 0 0 0 0 13124 1144193024 0 0 0 0 13124 1078211379 858993459 858993459 858993459 858993459 858997764 1145320243 858993459 858993459 858993459 858993459 858997828)		offset: 0@0)		colorsFromArray: #(			(1.0 1.0 1.0)			(0.623 0.623 0.623)			(0.0 0.0 0.031)			(0.0 0.0 0.004)			( )			(0.0 0.0 0.0)			(0.0 0.0 0.0)			(0.0 0.0 0.0)			( )			( )			( )			( )			( )			( )			( )			( ) )).! !!NarratorSoundMorph class methodsFor: 'instance creation' stamp: 'jm 12/4/2003 19:37'!fromFileNamed: fileName	| snd title |	snd _ SampledSound fromFileNamed: fileName.	snd ifNil: [^ nil].	title _ FileDirectory baseNameFor: (FileDirectory localNameFor: fileName).	^ self new		sound: snd;		fileName: fileName;		title: title! !!NarratorSoundMorph class methodsFor: 'instance creation' stamp: 'LY 11/18/2003 13:16'!fromSound: aSampledSound name: aString	^ self new		sound: aSampledSound;		fileName: aString;		title: aString! !This class implements TCP/IP style network name lookup and translation facilities.Attempt to keep track of whether there is a network available.HaveNetwork	true if last attempt to contact the network was successful.LastContact		Time of that contact (totalSeconds).haveNetwork	returns true, false, or #expired.  True means there was contact in the last 30 minutes.  False means contact failed or was false last time we asked.  Get out of false state by making contact with a server in some way (FileList or updates).!!NetNameResolver class methodsFor: 'lookups' stamp: 'ls 9/5/1998 01:14'!addressForName: aString	^self addressForName: aString timeout: 60! !!NetNameResolver class methodsFor: 'lookups' stamp: 'JMM 5/3/2000 17:35'!addressForName: hostName timeout: secs	"Look up the given host name and return its address. Return nil if the address is not found in the given number of seconds."	"NetNameResolver addressForName: 'create.ucsb.edu' timeout: 30"	"NetNameResolver addressForName: '100000jobs.de' timeout: 30"	"NetNameResolver addressForName: '1.7.6.4' timeout: 30"	"NetNameResolver addressForName: '' timeout: 30 (This seems to return nil?)"	| deadline ready success result |	"check if this is a valid numeric host address (e.g. 1.2.3.4)"	result _ self addressFromString: hostName.	result isNil ifFalse: [^result].	"Look up a host name, including ones that start with a digit (e.g. 100000jobs.de or squeak.org)"	deadline _ Time millisecondClockValue + (secs * 1000).	ready _ self waitForResolverReadyUntil: deadline.	ready ifFalse: [^ nil].	self primStartLookupOfName: hostName.	success _ self waitForCompletionUntil: deadline.	success		ifTrue: [^ self primNameLookupResult]		ifFalse: [^ nil].! !!NetNameResolver class methodsFor: 'lookups' stamp: 'JMM 5/3/2000 11:25'!resolverError	^self primNameResolverError! !!NetNameResolver class methodsFor: 'lookups' stamp: 'JMM 5/3/2000 11:25'!resolverStatus	^self primNameResolverStatus! !!NetNameResolver class methodsFor: 'network initialization' stamp: 'tk 2/15/1999 14:35'!haveNetwork	"Our best estimate of whether a network is available.  Caller will want to ask user if we should try this time."	HaveNetwork ifFalse: [^ false].	Time totalSeconds - LastContact > 1800 "30 min" ifTrue: [^ #expired].	^ true	"are current"! !!NetNameResolver class methodsFor: 'network initialization' stamp: 'tk 2/15/1999 14:47'!haveNetwork: boolean	"Allow user to say we don't want to try to start a connection.  Not enforced.  Only for caller's information when he asks."	HaveNetwork _ boolean.	LastContact _ Time totalSeconds.! !!NetNameResolver class methodsFor: 'network initialization' stamp: 'JMM 5/3/2000 11:35'!initializeNetworkIfFail: errorBlock	"Initialize the network drivers and record the semaphore to be used by the resolver. Do nothing if the network is already initialized. Evaluate the given block if network initialization fails."	"NetNameResolver initializeNetworkIfFail: [self error: 'network initialization failed']"	| semaIndex result |	self resolverStatus = ResolverUninitialized		ifFalse: [			LastContact _ Time totalSeconds.  HaveNetwork _ true.			^ self].  "network is already initialized"	LastContact _ Time totalSeconds.  HaveNetwork _ false.	"in case abort"	ResolverSemaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: ResolverSemaphore.	Utilities informUser:'Initializing the network drivers; this maytake up to 30 seconds and can''t be interrupted'		during: [result _ self primInitializeNetwork: semaIndex].	Smalltalk isMorphic ifTrue: [World displayWorld].  "take the informer down"	"result is nil if network initialization failed, self if it succeeds"	result ifNil: [errorBlock value]		ifNotNil: [HaveNetwork _ true].! !!NetNameResolver class methodsFor: 'private' stamp: 'JMM 5/3/2000 13:57'!readDecimalByteFrom: aStream	"Read a positive, decimal integer from the given stream. Stop when a non-digit or end-of-stream is encountered. Return nil if stream is not positioned at a decimal digit or if the integer value read exceeds 255.JMM - 000503 fixed didn't work correctly"	| digitSeen value digit |	digitSeen _ false.	value _ 0.	[aStream atEnd] whileFalse: 		[digit _ aStream next digitValue.		(digit < 0 or: [digit > 9]) ifTrue: [			aStream skip: -1.			(digitSeen not or: [value > 255]) ifTrue: [^ nil].			^ value].		digitSeen _ true.		value _ (value * 10) + digit].	(digitSeen not or: [value > 255]) ifTrue: [^ nil].	^ value! !!NetNameResolver class methodsFor: 'private' stamp: 'JMM 5/3/2000 11:35'!waitForCompletionUntil: deadline	"Wait up to the given number of seconds for the resolver to be ready to accept a new request. Return true if the resolver is ready, false if the network is not initialized or the resolver does not become free within the given time period."	| status |	status _ self resolverStatus.	[(status = ResolverBusy) and:	 [Time millisecondClockValue < deadline]]		whileTrue: [			"wait for resolver to be available"			ResolverSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status _ self resolverStatus].	status = ResolverReady		ifTrue: [^ true]		ifFalse: [			status = ResolverBusy ifTrue: [self primAbortLookup].			^ false].! !!NetNameResolver class methodsFor: 'private' stamp: 'JMM 5/3/2000 11:36'!waitForResolverReadyUntil: deadline	"Wait up to the given number of seconds for the resolver to be ready to accept a new request. Return true if the resolver is not busy, false if the network is not initialized or the resolver does not become free within the given time period."	| status |	status _ self resolverStatus.	status = ResolverUninitialized ifTrue: [^ false].	[(status = ResolverBusy) and:	 [Time millisecondClockValue < deadline]]		whileTrue: [			"wait for resolver to be available"			ResolverSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).			status _ self resolverStatus].	^ status ~= ResolverBusy! !A handle used for resizing SystemWindows and their panes.!!NewHandleMorph methodsFor: 'all' stamp: 'sw 11/5/1998 10:24'!initialize	waitingForClickInside _ true.	super initialize.	Preferences noviceMode ifTrue: [self setBalloonText: 'stretch']! !!NewHandleMorph methodsFor: 'all' stamp: 'di 4/30/1999 14:06'!justDroppedInto: aMorph event: anEvent	"No dropping behavior because stepping will delete me.	Moreover it needs to be done that way to evaluate lastPointBlock"! !A Paragraph represents text that has been laid out, or composed, in some container.	text 		A Text with encoded per-character emphasis.	textStyle	A TextStyle with font set, line height and horizontal alignment.	firstCharacterIndex    The starting index in text for this paragraph, allowing				composition of a long text into a number of containers.	container	A Rectangle or TextContainer that determines where text can go.	lines		An Array of TextLines comprising the final layout of the text				after it has been composed within its container.	positionWhenComposed   As its name implies.  Allows display at new locations				without the need to recompose the text.Lines are ordered vertically.  However, for a given y, there may be several lines in left to right order.  Lines must never be empty, even if text is empty.!!NewParagraph methodsFor: 'access' stamp: 'sbw 10/13/1999 22:31'!numberOfLines	^lines size! !!NewParagraph methodsFor: 'composition' stamp: 'di 4/28/1999 10:26'!composeAll	self composeLinesFrom: firstCharacterIndex to: text size delta: 0		into: OrderedCollection new priorLines: Array new atY: container top! !!NewParagraph methodsFor: 'composition' stamp: 'ar 5/18/2000 18:34'!composeLinesFrom: start to: stop delta: delta into: lineColl priorLines: priorLines	atY: startingY	"While the section from start to stop has changed, composition may ripple all the way to the end of the text.  However in a rectangular container, if we ever find a line beginning with the same character as before (ie corresponding to delta in the old lines), then we can just copy the old lines from there to the end of the container, with adjusted indices and y-values"	| charIndex lineY lineHeight scanner line row firstLine lineHeightGuess saveCharIndex hitCR maybeSlide sliding bottom priorIndex priorLine |	charIndex _ start.	lines _ lineColl.	lineY _ startingY.	lineHeightGuess _ textStyle lineGrid.	maxRightX _ container left.	maybeSlide _ stop < text size and: [container isMemberOf: Rectangle].	sliding _ false.	priorIndex _ 1.	bottom _ container bottom.	scanner _ CompositionScanner new text: text textStyle: textStyle.	firstLine _ true.	[charIndex <= text size and: [(lineY + lineHeightGuess) <= bottom]]		whileTrue:		[sliding			ifTrue:			["Having detected the end of rippling recoposition, we are only sliding old lines"			priorIndex < priorLines size				ifTrue: ["Adjust and re-use previously composed line"						priorIndex _ priorIndex + 1.						priorLine _ (priorLines at: priorIndex)									slideIndexBy: delta andMoveTopTo: lineY.						lineColl addLast: priorLine.						lineY _ priorLine bottom.						charIndex _ priorLine last + 1]				ifFalse: ["There are no more priorLines to slide."						sliding _ maybeSlide _ false]]			ifFalse:			[lineHeight _ lineHeightGuess.			saveCharIndex _ charIndex.			hitCR _ false.			row _ container rectanglesAt: lineY height: lineHeight.			1 to: row size do:				[:i | (charIndex <= text size and: [hitCR not]) ifTrue:						[line _ scanner composeFrom: charIndex inRectangle: (row at: i)								firstLine: firstLine leftSide: i=1 rightSide: i=row size.					lines addLast: line.					(text at: line last) = Character cr ifTrue: [hitCR _ true].					lineHeight _ lineHeight max: line lineHeight.  "includes font changes"					charIndex _ line last + 1]].			row size >= 1 ifTrue:			[lineY _ lineY + lineHeight.			lineY > bottom				ifTrue: ["Oops -- the line is really too high to fit -- back out"						charIndex _ saveCharIndex.						row do: [:r | lines removeLast]]				ifFalse: ["It's OK -- the line still fits."						maxRightX _ maxRightX max: scanner rightX.						1 to: row size - 1 do:  "Adjust heights across row if necess"							[:i | (lines at: lines size - row size + i)									lineHeight: lines last lineHeight									baseline: lines last baseline].						charIndex > text size ifTrue:							["end of text"							hitCR ifTrue:								["If text ends with CR, add a null line at the end"								((lineY + lineHeightGuess) <= container bottom) ifTrue:									[row _ container rectanglesAt: lineY height: lineHeightGuess.									row size > 0 ifTrue:										[line _ (TextLine start: charIndex stop: charIndex-1											internalSpaces: 0 paddingWidth: 0)										rectangle: row first;										lineHeight: lineHeightGuess baseline: textStyle baseline.										lines addLast: line]]].							lines _ lines asArray.							^ maxRightX].						firstLine _ false]]				ifFalse:				[lineY _ lineY + lineHeight].			(maybeSlide and: [charIndex > stop]) ifTrue:				["Check whether we are now in sync with previously composed lines"				 [priorIndex < priorLines size					and: [(priorLines at: priorIndex) first < (charIndex - delta)]]						whileTrue: [priorIndex _ priorIndex + 1].				(priorLines at: priorIndex) first = (charIndex - delta)					ifTrue: ["Yes -- next line will have same start as prior line."							priorIndex _ priorIndex - 1.							maybeSlide _ false.							sliding _ true]					ifFalse: [priorIndex = priorLines size ifTrue:								["Weve reached the end of priorLines,								so no use to keep looking for lines to slide."								maybeSlide _ false]]]]].	firstLine ifTrue:		["No space in container or empty text"		line _ (TextLine start: start stop: start-1						internalSpaces: 0 paddingWidth: 0)				rectangle: (container topLeft extent: 0@lineHeightGuess);				lineHeight: lineHeightGuess baseline: textStyle baseline.		lines _ Array with: line].	"end of container"	lines _ lines asArray.	^ maxRightX! !!NewParagraph methodsFor: 'composition' stamp: 'di 4/28/1999 10:13'!recomposeFrom: start to: stop delta: delta	"Recompose this paragraph.  The altered portion is between start and stop.	Recomposition may continue to the end of the text, due to a ripple effect.	Delta is the amount by which the current text is longer than it was	when its current lines were composed."	| startLine newLines |	"Have to recompose line above in case a word-break was affected."	startLine _ (self lineIndexForCharacter: start) - 1 max: 1.	[startLine > 1 and: [(lines at: startLine-1) top = (lines at: startLine) top]]		whileTrue: [startLine _ startLine - 1].  "Find leftmost of line pieces"	newLines _ OrderedCollection new: lines size + 1.	1 to: startLine-1 do: [:i | newLines addLast: (lines at: i)].	self composeLinesFrom: (lines at: startLine) first to: stop delta: delta			into: newLines priorLines: lines			atY: (lines at: startLine) top! !!NewParagraph methodsFor: 'selection' stamp: 'ar 5/18/2000 18:33'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for the character in the text at aPoint."	| line |	line _ lines at: (self lineIndexForPoint: aPoint).	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: aPoint index: nil		in: line! !!NewParagraph methodsFor: 'selection' stamp: 'ar 5/18/2000 18:33'!characterBlockForIndex: index 	"Answer a CharacterBlock for the character in text at index."	| line |	line _ lines at: (self lineIndexForCharacter: index).	^ (CharacterBlockScanner new text: text textStyle: textStyle)		characterBlockAtPoint: nil index: ((index max: line first) min: text size+1)		in: line! !!NewParagraph methodsFor: 'selection' stamp: 'di 10/5/1998 12:59'!defaultCharacterBlock	^ (CharacterBlock new stringIndex: firstCharacterIndex text: text			topLeft: lines first topLeft extent: 0 @ 0)		textLine: lines first! !!NewParagraph methodsFor: 'selection' stamp: 'di 6/7/2000 16:52'!selectionRectsFrom: characterBlock1 to: characterBlock2 	"Return an array of rectangles representing the area between the two character blocks given as arguments."	| line1 line2 rects cb1 cb2 w |	characterBlock1 <= characterBlock2		ifTrue: [cb1 _ characterBlock1.  cb2 _ characterBlock2]		ifFalse: [cb2 _ characterBlock1.  cb1 _ characterBlock2].	cb1 = cb2 ifTrue:		[w _ self caretWidth.		^ Array with: (cb1 topLeft - (w@0) corner: cb1 bottomLeft + ((w+1)@0))].	line1 _ self lineIndexForCharacter: cb1 stringIndex.	line2 _ self lineIndexForCharacter: cb2 stringIndex.	line1 = line2 ifTrue:		[^ Array with: (cb1 topLeft corner: cb2 bottomRight)].	rects _ OrderedCollection new.	rects addLast: (cb1 topLeft corner: (lines at: line1) bottomRight).	(container isMemberOf: Rectangle)		ifTrue: [(line1+1) <= (line2-1) ifTrue:					[rects addLast: ((lines at: line1+1) topLeft								corner: (lines at: line2-1) bottomRight)]]		ifFalse: [(line1+1) to: (line2-1) do:					[:i | rects addLast: (lines at: i) rectangle]].	rects addLast: ((lines at: line2) topLeft corner: cb2 bottomLeft).	^ rects! !!NewParagraph methodsFor: 'editing' stamp: 'sw 12/7/1999 11:34'!clickAt: clickPoint for: model controller: editor	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action target |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex forStyle: textStyle) 		do: [:att | att mayActOnClick ifTrue:				[	"			range _ text rangeOf: att startingAt: startBlock stringIndex.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last).				box _ boxes detect: [:each | each containsPoint: clickPoint].					*This doesn't work in morphic*				Need to replace by a highlighting morph that waits for moueUp.				Utilities awaitMouseUpIn: (editor transform invertRect: box)						repeating: []						ifSucceed: [(att actOnClickFor: model) ifTrue: [action _ true]].	"				(target _ model) ifNil: [target _ editor morph].				(att actOnClickFor: target)					ifTrue: [Sensor waitNoButton.  "FIX THIS"							action _ true]]].	^ action! !!NewParagraph methodsFor: 'editing' stamp: 'di 4/28/1999 10:14'!replaceFrom: start to: stop with: aText displaying: displayBoolean 	"Edit the text, and then recompose the lines." 	text replaceFrom: start to: stop with: aText.	self recomposeFrom: start to: start + aText size - 1 delta: aText size - (stop-start+1)! !!NewParagraph methodsFor: 'display' stamp: 'sw 9/7/1999 13:05'!displaySelectionInLine: line on: aCanvas	| leftX rightX w caretColor |	selectionStart ifNil: [^ self].  "No selection"	selectionStart = selectionStop		ifTrue: ["Only show caret on line where clicked"				selectionStart textLine ~= line ifTrue: [^ self]]		ifFalse: ["Test entire selection before or after here"				(selectionStop stringIndex < line first					or: [selectionStart stringIndex > (line last+1)])					ifTrue: [^ self].  "No selection on this line"				(selectionStop stringIndex = line first					and: [selectionStop textLine ~= line])					ifTrue: [^ self].  "Selection ends on line above"				(selectionStart stringIndex = (line last+1)					and: [selectionStop textLine ~= line])					ifTrue: [^ self]].  "Selection begins on line below"	selectionStart stringIndex < line first		ifTrue: [leftX _ line left]		ifFalse: [leftX _ selectionStart left].	(selectionStop stringIndex > (line last+1)			or: [selectionStop stringIndex = (line last+1)					and: [selectionStop textLine ~= line]])		ifTrue: [rightX _ line right]		ifFalse: [rightX _ selectionStop left].	selectionStart = selectionStop		ifTrue:		[rightX _ rightX + 1.		w _ self caretWidth.		caretColor _ self insertionPointColor.		1 to: w do:			[:i |  "Draw caret triangles at top and bottom"			aCanvas fillRectangle: ((leftX-w+i-1)@(line top+i-1) extent: (w-i*2+3)@1)				color: caretColor.			aCanvas fillRectangle: ((leftX-w+i-1)@(line bottom-i) extent: (w-i*2+3)@1)				color: caretColor].		aCanvas fillRectangle: (leftX@line top corner: rightX@line bottom)				color: caretColor]	ifFalse:		[aCanvas fillRectangle: (leftX@line top corner: rightX@line bottom)				color: self selectionColor]! !!NewParagraph methodsFor: 'display' stamp: 'sw 9/7/1999 13:04'!insertionPointColor	^ Display depth <= 2		ifTrue: [Color black]		ifFalse: [Preferences insertionPointColor]! !!NewParagraph methodsFor: 'display' stamp: 'sw 9/7/1999 13:03'!selectionColor	Display depth = 1 ifTrue: [^ Color veryLightGray].	Display depth = 2 ifTrue: [^ Color gray].	^ Preferences textHighlightColor! !!NewParagraph methodsFor: 'private' stamp: 'RAA 8/30/1998 15:30'!indentationOfLineIndex: lineIndex ifBlank: aBlock	"Answer the number of leading tabs in the line at lineIndex.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value.	 If the line is word-wrap overflow, back up a line and recur."	| arrayIndex first last cr |	cr _ Character cr.	arrayIndex _ lineIndex.	[first _ (lines at: arrayIndex) first.	 first > 1 and: [(text string at: first - 1) ~~ cr]] whileTrue: "word wrap"		[arrayIndex _ arrayIndex - 1].	last _ (lines at: arrayIndex) last.		^(text string copyFrom: first to: last) indentationIfBlank: aBlock.! !!NewParagraph methodsFor: 'private' stamp: 'RAA 8/30/1998 15:04'!lineIndexOfCharacterIndex: characterIndex 	"Answer the line index for a given characterIndex."	"apparently the selector changed with NewParagraph"	^self lineIndexForCharacter: characterIndex ! !!NewSerialPortPrimsTest class methodsFor: 'as yet unclassified' stamp: 'jm 10/31/2003 11:53'!primTest: int1 times: int2	"self primTest: 2 times: 3"	<primitive: 'primitiveTest' module: 'TestPlugin'>	self primitiveFailed! !I represent a controller that never wants control. I am the controller for views that are non-interactive.!!NoteEvent methodsFor: 'accessing' stamp: 'jm 8/27/1998 16:38'!endTime	^ time + duration! !!NoteEvent methodsFor: 'accessing' stamp: 'jm 8/3/1998 17:06'!pitch	"Convert my MIDI key number to a pitch and return it."	^ AbstractSound pitchForMIDIKey: midiKey! !!NoteEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 15:58'!endNoteOnMidiPort: aMidiPort	"Output a noteOff event to the given MIDI port. (Actually, output a noteOff event with zero velocity. This does the same thing, but allows running status to be used when sending a mixture of note on and off commands.)"	aMidiPort		midiCmd: 16r90		channel: channel		byte: midiKey		byte: 0.! !!NoteEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 15:56'!startNoteOnMidiPort: aMidiPort	"Output a noteOn event to the given MIDI port."	aMidiPort		midiCmd: 16r90		channel: channel		byte: midiKey		byte: velocity.! !I am an abstract representation of a number. My subclasses Float, Fraction, and Integer, and their subclasses, provide concrete representations of a numeric quantity.All my subclasses participate in a simple type coercion mechanism that supports mixed-mode arithmetic and comparisons.  It works as follows:  If	self<typeA> op: arg<typeB>fails because of incompatible types, then it is retried in the following guise:	(arg adaptTypeA: self) op: arg adaptToTypeA.This gives the arg of typeB an opportunity to resolve the incompatibility, knowing exactly what two types are involved.  If self is more general, then arg will be converted, and viceVersa.  This mechanism is extensible to any new number classes that one might wish to add to Squeak.  The only requirement is that every subclass of Number must support a pair of conversion methods specific to each of the other subclasses of Number.!!Number methodsFor: 'mathematical functions' stamp: 'jsp 2/24/1999 15:20'!arcTan: denominator	"The receiver is the tangent of an angle. Answer the angle measured in 	radians."	^(self asFloat) arcTan: denominator.! !!Number methodsFor: 'mathematical functions' stamp: 'di 9/8/1998 17:10'!log	"Answer the base-10 log of the receiver."	^self asFloat log! !!Number methodsFor: 'mathematical functions' stamp: 'RJ 3/15/1999 19:35'!raisedTo: aNumber 	"Answer the receiver raised to aNumber."	aNumber isInteger ifTrue:		["Do the special case of integer power"		^ self raisedToInteger: aNumber].	self < 0 ifTrue:		[ self error: self printString, ' raised to a non-integer power' ].	aNumber = 0 ifTrue: [^ 1].		"Special case of exponent=0"	(self = 0) | (aNumber = 1) ifTrue:		[^ self].						"Special case of exponent=1"	^ (aNumber * self ln) exp		"Otherwise use logarithms"! !!Number methodsFor: 'mathematical functions' stamp: 'RJ 3/15/1999 19:32'!raisedToInteger: anInteger 	"Answer the receiver raised to the power anInteger where the argument 	must be a kind of Integer. This is a special case of raisedTo:."	anInteger isInteger ifFalse:		[^self error: 'raisedToInteger: only works for integral arguments'].	anInteger = 0 ifTrue: [^ 1].	(self = 0) | (anInteger = 1) ifTrue: [^ self].	anInteger > 1 ifTrue:		[^ (self * self raisedToInteger: anInteger // 2)					* (self raisedToInteger: anInteger \\ 2)].	^ (self raisedToInteger: anInteger negated) reciprocal! !!Number methodsFor: 'truncation and round off' stamp: 'di 10/4/1999 08:08'!roundTo: quantum 	"Answer the nearest number that is a multiple of quantum."	^(self / quantum) rounded * quantum! !!Number methodsFor: 'testing' stamp: 'sw 12/30/1998 13:21'!isDivisibleBy: aNumber	aNumber = 0 ifTrue: [^ false].	aNumber isInteger ifFalse: [^ false].	^ (self \\ aNumber) = 0! !!Number methodsFor: 'testing'!isZero	^self = 0! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:21'!adaptToFloat: rcvr andSend: selector 	"If I am involved in arithmetic with a Float, convert me to a Float."	^ rcvr perform: selector with: self asFloat! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:44'!adaptToFraction: rcvr andSend: selector	"If I am involved in arithmetic with a Fraction, convert us and evaluate exprBlock."	^ self subclassResponsibility! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:44'!adaptToInteger: rcvr andSend: selector	"If I am involved in arithmetic with a Integer, convert us and evaluate exprBlock."	^ self subclassResponsibility! !!Number methodsFor: 'converting' stamp: 'di 11/6/1998 13:44'!adaptToPoint: rcvr andSend: selector	"If I am involved in arithmetic with a Point, convert me to a Point."	^ rcvr perform: selector with: self@self! !!Number methodsFor: 'converting' stamp: 'sw 2/16/1999 18:15'!asNumber	^ self! !!Number methodsFor: 'converting' stamp: 'sw 10/7/1999 12:24'!asSmallPositiveDegrees	"Return the receiver normalized to lie within the range (0, 360)"	| result |	result _ self.	[result < 0] whileTrue: [result _ result + 360].	^ result \\ 360"#(-500 -300 -150 -5 0 5 150 300 500 1200) collect: [:n | n asSmallPositiveDegrees]"! !!Number methodsFor: 'intervals' stamp: 'tao 1/30/1999 08:58'!to: stop by: step do: aBlock 	"Normally compiled in-line, and therefore not overridable.	Evaluate aBlock for each element of the interval (self to: stop by: step)."	| nextValue |	nextValue _ self.	step = 0 ifTrue: [self error: 'step must be non-zero'].	step < 0		ifTrue: [[stop <= nextValue]				whileTrue: 					[aBlock value: nextValue.					nextValue _ nextValue + step]]		ifFalse: [[stop >= nextValue]				whileTrue: 					[aBlock value: nextValue.					nextValue _ nextValue + step]]! !!Number methodsFor: 'printing' stamp: 'sw 6/29/1999 21:10'!isOrAreStringWith: aNoun	| result |	result _ self = 1		ifTrue:			[' is one ']		ifFalse:			[self = 0				ifTrue:					[' are no ']				ifFalse:					[' are ', self printString, ' ']].	result _ result, aNoun.	self = 1 ifFalse: [result _ result, 's'].	^ result"#(0 1 2 98.6) do:	[:num | Transcript cr; show: 'There', (num isOrAreStringWith: 'way'), ' to skin a cat']"! !!Number methodsFor: 'printing' stamp: 'sw 7/1/1998 12:33'!stringForReadout	^ self rounded printString! !!Number class methodsFor: 'instance creation' stamp: 'bf 12/9/1998 19:21'!readFrom: stringOrStream 	"Answer a number as described on aStream.  The number may	include a leading radix specification, as in 16rFADE"	| value base aStream sign |	aStream _ (stringOrStream isMemberOf: String)		ifTrue: [ReadStream on: stringOrStream]		ifFalse: [stringOrStream].	(aStream nextMatchAll: 'NaN') ifTrue: [^ Float nan].	sign _ (aStream peekFor: $-) ifTrue: [-1] ifFalse: [1].	(aStream nextMatchAll: 'Infinity') ifTrue: [^ Float infinity * sign].	base _ 10.	value _ Integer readFrom: aStream base: base.	(aStream peekFor: $r)		ifTrue: 			["<base>r<integer>"			(base _ value) < 2 ifTrue: [^self error: 'Invalid radix'].			(aStream peekFor: $-) ifTrue: [sign _ sign negated].			value _ Integer readFrom: aStream base: base].	^ self readRemainderOf: value from: aStream base: base withSign: sign.! !Instances of me are used to temporarily record inter-object references when ObjStream is reading in an object structure. After all the objects have been read, a second pass is made to replace each object reference with a pointer directly to to the object in the object table.!!ObjRefRecord methodsFor: 'accessing' stamp: 'jm 9/23/2003 15:58'!objectID	^ objectID! !!ObjRefRecord methodsFor: 'accessing' stamp: 'jm 9/23/2003 15:59'!objectID: anInteger	objectID _  anInteger.! !!ObjRefRecord methodsFor: 'printing' stamp: 'jm 9/24/2003 10:02'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(', objectID printString, ')'.! !I can serialize a collection of inter-connected objects onto a binary stream or reconstruct the original object network from its serialized form. This allows object structures to be saved in files, transmitted over a network, etc.I support user class evolution via class version numbers, making it possible to detect and, if so desired, convert old object formats.The format consists of a table of serialized objects. The first object in this table is the "root" object that was serialized; the rest of the objects in the table are objects reachable from this root object. Inter-object references are stored as indices into this table. These indices are mapped to actual object references when the structure is deserialized.Object storage formats fall into one of these categories:  a. immediate values: the constants nil, true, false, integers, and floats  b. fixed-format objects whose serialization is handled by this class  c. objects that handle their own serialization and whose formats may change over timeObjects in the first category are encoded in-line; they do not appear in the object table and thus cannot be shared. Integers that small enough to be represented in 16 bits have their own format. Objects in the second catetory are assumed to have stable storage formats, so they do not have a class version number. In the unlikely event that the storage format of any of these classes changes, the file format version must be incremented.Objects in the last category support user-defined serialization. They are expected to implement the three instance methods storeFieldsOnXX:, initializeFromFieldsXX:, and objStreamVersion, where XX is the class version number. In general, any change to the serialization format of an object requires adding new versions of the methods storeFieldsOnXX: and initializeFromFieldsXX:, then incrementing the version number returned by objStreamVersion.The class of every object in this category must appear in the class ID table. To ensure that old object files can be read, once an object has been assigned an ID that ID can't be changed and even if the class is deleted, it's ID must not used for another class.Maximums:  Object types (i.e., classes): 255  User-defined class fields: 255  Number of objects: 2^24 - 1  Indexable object size: 2^32 - 1!!ObjStream methodsFor: 'entry points' stamp: 'jm 9/28/2003 12:03'!nextField	"Answer the next field and advance to the next field. This method should only be called from initFieldsFrom:version: during deserialization."	^ fields at: (fieldIndex _ fieldIndex + 1)! !!ObjStream methodsFor: 'entry points' stamp: 'jm 9/28/2003 12:07'!putField: anObject	"Put the given object. If the given object is nil, true, false, an integer, or a float, it is stored directly. Otherwise, it is stored as an object reference and the object will be stored exactly once no matter how many other objects refer to it."	| entry classID putSelector |	entry _ self classEntryFor: anObject.	classID _ entry at: 1.	putSelector _ entry at: 4. 	firstPass ifTrue: [fields addLast: anObject].	fieldIndex _ fieldIndex + 1.	classID <= FloatClassID ifTrue: [  "store the value directly inline"		firstPass ifFalse: [self perform: putSelector with: anObject with: classID].		^ self].		firstPass		ifTrue: [self recordObject: anObject id: classID]		ifFalse: [self writeObjRef: (fields at: fieldIndex)].! !!ObjStream methodsFor: 'entry points' stamp: 'jm 9/24/2003 16:40'!readObjFrom: aStream	"Read the root object from the given binary stream."	| objCount |	objects _ OrderedCollection new.	stream _ aStream.	self readFileHeader.	firstPass _ true.	objCount _ stream uint32.	objCount timesRepeat: [objects addLast: self readObjectRecord].	firstPass _ false.	objects do: [:rec | self fixReferencesForObjectRecord: rec].	objects do: [:rec | self initializeUserDefinedFields: rec].	^ objects first first! !!ObjStream methodsFor: 'entry points' stamp: 'jm 9/28/2003 12:09'!storeObj: anObject on: aStream	"Write the given object and all the objects that can be reached from it on the given binary stream."	| sortedObjEntries obj |	objects _ IdentityDictionary new.	objectIndex _ 1.	stream _ nil.	firstPass _ true.	toDo _ OrderedCollection new.	self recordObject: anObject id: (self classEntryFor: anObject) first.	[toDo size > 0] whileTrue: [self recordFieldsOf: toDo removeFirst].	"write object table"	stream _ aStream.	firstPass _ false.	sortedObjEntries _ objects asArray sort: [:e1 :e2 | e1 first < e2 first].	self writeFileHeader.	stream uint32: sortedObjEntries size.	sortedObjEntries do: [:objEntry |		obj _ objEntry at: 2.		self writeObject: obj objEntry: objEntry].! !!ObjStream methodsFor: 'entry points' stamp: 'jm 12/3/2003 07:18'!storeObj: anObject on: aStream showProgress: showProgress	"Write the given object and all the objects that can be reached from it on the given binary stream. If showProgress is true, display a progress bar."	| sortedObjEntries i obj |	objects _ IdentityDictionary new.	objectIndex _ 1.	"collect objects"	stream _ nil.	firstPass _ true.	toDo _ OrderedCollection new.	self recordObject: anObject id: (self classEntryFor: anObject) first.	[toDo size > 0] whileTrue: [self recordFieldsOf: toDo removeFirst].	"write object table"	stream _ aStream.	firstPass _ false.	sortedObjEntries _ objects asArray sort: [:e1 :e2 | e1 first < e2 first].	self writeFileHeader.	stream uint32: sortedObjEntries size.	showProgress		ifTrue: [			i _ 0.  "object counter for progress bar"			'Saving...'				displayProgressAt: Sensor cursorPoint				from: 0 to: sortedObjEntries size				during:  [:progressBar |					sortedObjEntries do: [:objEntry |						progressBar value: (i _ i + 1).						obj _ objEntry at: 2.						self writeObject: obj objEntry: objEntry]]]		ifFalse: [			sortedObjEntries do: [:objEntry |				obj _ objEntry at: 2.				self writeObject: obj objEntry: objEntry]].! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/23/2003 20:16'!putArray: anObject id: classID	self putCollection: anObject id: classID.! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/23/2003 16:49'!putBigInt: anObject id: classID	firstPass ifTrue: [^ self].	stream nextPut: classID.	stream uint16: anObject digitLength.	1 to: anObject digitLength do: [:i | stream nextPut: (anObject digitAt: i)].! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 10/10/2003 09:06'!putBitmap: anObject id: classID	firstPass ifTrue: [^ self].	stream nextPut: classID.	stream uint32: anObject size.	anObject do: [:el | stream uint32: el].! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/22/2003 18:42'!putBytes: anObject id: classID	firstPass ifTrue: [^ self].	stream nextPut: classID.	stream uint32: anObject size.	stream nextPutAll: anObject asByteArray.! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/23/2003 20:15'!putCollection: anObject id: classID	firstPass ifFalse: [		stream nextPut: classID.		stream uint32: anObject size].	anObject do: [:el | self putField: el].! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/23/2003 16:48'!putColor: anObject id: classID	| a |	firstPass ifTrue: [^ self].	stream nextPut: classID.	stream uint32: anObject privateRGB.	anObject class = TranslucentColor ifTrue: [		a _ (anObject privateAlpha asInteger min: 255) max: 0.		stream nextPut: a].! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/22/2003 18:31'!putConst: anObject id: classID	firstPass ifTrue: [^ self].	stream nextPut: classID.! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/22/2003 18:57'!putDict: anObject id: classID	firstPass ifFalse: [		stream nextPut: classID.		stream uint32: anObject size].	anObject associationsDo: [:assoc |		self putField: assoc key.		self putField: assoc value].! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/28/2003 11:48'!putFloat: anObject id: classID	firstPass ifTrue: [^ self].	stream nextPut: classID.	stream uint32: (anObject basicAt: 1).	stream uint32: (anObject basicAt: 2).! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/24/2003 12:16'!putForm: anObject id: classID	firstPass ifFalse: [stream nextPut: classID].	anObject hibernate.	self putField: anObject width.	self putField: anObject height.	self putField: anObject depth.	self putField: anObject privateOffset.	self putField: anObject bits.	(anObject class = ColorForm) ifTrue: [self putField: anObject colors].! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/22/2003 18:55'!putPoint: anObject id: classID	firstPass ifFalse: [		stream nextPut: classID].	self putField: anObject x.	self putField: anObject y.! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/22/2003 18:56'!putRect: anObject id: classID	firstPass ifFalse: [		stream nextPut: classID].	self putField: anObject left.	self putField: anObject top.	self putField: anObject right.	self putField: anObject bottom.! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 9/23/2003 13:55'!putSmallInt: anObject id: classID	firstPass ifTrue: [^ self].	((-32768 <= anObject) and: [anObject <= 32767])		ifTrue: [  "optimization for integers that fit into 16 bits"			stream nextPut: classID + 1.			stream int16: anObject]		ifFalse: [			stream nextPut: classID.			stream int32: anObject].! !!ObjStream methodsFor: 'fixed format-writing' stamp: 'jm 12/5/2003 18:42'!putSoundBuf: anObject id: classID	firstPass ifTrue: [^ self].	stream nextPut: classID.	stream uint32: anObject size.	anObject storeOn: stream bigEndian: true stereo: false.! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/28/2003 11:56'!getArray: anObject id: classID	| sz result |	firstPass ifTrue: [		sz _ stream uint32.		result _ Array new: sz.		1 to: sz do: [:i | result at: i put: self readField].		^ result].	"fix references"	self fixRefsInArray: anObject.! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/28/2003 11:39'!getBigInt: anObject id: classID	| digitCount result |	digitCount _ stream uint16.	result _ (self classForID: classID) new: digitCount.	1 to: digitCount do: [:i | result digitAt: i put: stream next].	^ result! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 10/10/2003 09:07'!getBitmap: anObject id: classID	| count result |	count _ stream uint32.	result _ Bitmap new: count.	1 to: count do: [:i | result at: i put: stream uint32].	^ result! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/23/2003 17:12'!getBytes: anObject id: classID	| byteCount result |	byteCount _ stream uint32.	result _ stream next: byteCount.	classID = 9 ifTrue: [^ result asString].	classID = 10 ifTrue: [^ result asString asSymbol].	^ result! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/28/2003 11:56'!getCollection: anObject id: classID	| sz result newContents |	firstPass ifTrue: [		sz _ stream uint32.		result _ (self classForID: classID) new: sz.		sz timesRepeat: [result add: self readField].		^ result].	"fix references"	newContents _ anObject asArray.	self fixRefsInArray: newContents.	anObject removeAll: anObject copy; addAll: newContents.! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/23/2003 17:30'!getColor: anObject id: classID	| rgb |	firstPass ifFalse: [^ anObject].	rgb _ stream uint32.	(self classForID: classID) = TranslucentColor		ifTrue: [^ TranslucentColor basicNew setRgb: rgb alpha: stream next]		ifFalse: [^ Color basicNew setRgb: rgb].! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/23/2003 16:35'!getConst: anObject id: classID	classID = 1 ifTrue: [^ nil].	classID = 2 ifTrue: [^ true].	classID = 3 ifTrue: [^ false].! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/28/2003 11:57'!getDict: anObject id: classID	| sz result key value newContents |	firstPass ifTrue: [		sz _ stream uint32.		result _ (self classForID: classID) new: sz.		sz timesRepeat: [			key _ self readField.			value _ self readField.			result at: key put: value].		^ result].	"fix references"	newContents _ OrderedCollection new: anObject size.	anObject copy associationsDo: [:assoc |		newContents add: ((self targetObjectFor: assoc key) -> (self targetObjectFor: assoc value)).		anObject removeKey: assoc key].	anObject size = 0 ifFalse: [self error: 'should be empty!!'].	anObject addAll: newContents.! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/24/2003 09:58'!getFloat: anObject id: classID	| result |	result _ Float new: 2.	result basicAt: 1 put: stream uint32.	result basicAt: 2 put: stream uint32.	^ result! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/24/2003 12:43'!getForm: anObject id: classID	| w h d offset bits result |	firstPass ifTrue: [		w _ self readField.		h _ self readField.		d _ self readField.		offset _ self readField.		bits _ self readField.		result _ (self classForID: classID) basicNew			setExtent: w@h depth: d bits: bits;			offset: offset.		(result class = ColorForm) ifTrue: [result privateColors: self readField].		^ result].	"fix references"	anObject bits: (self targetObjectFor: anObject bits).	anObject offset: (self targetObjectFor: anObject privateOffset).	(anObject class = ColorForm) ifTrue: [anObject privateColors: (self targetObjectFor: anObject privateColors)].! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/24/2003 14:13'!getPoint: anObject id: classID	| x y |	firstPass ifTrue: [		x _ self readField.		y _ self readField.		^ Point x: x y: y].	"fix references"	anObject		setX: (self targetObjectFor: anObject x)		setY: (self targetObjectFor: anObject y).! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/24/2003 14:13'!getRect: anObject id: classID	| x1 y1 x2 y2 |	firstPass ifTrue: [		x1 _ self readField.		y1 _ self readField.		x2 _ self readField.		y2 _ self readField.		^ (Point x: x1 y: y1) corner: (Point x: x2 y: y2)].	"fix references"	anObject origin		setX: (self targetObjectFor: anObject origin x)		setY: (self targetObjectFor: anObject origin y).	anObject corner		setX: (self targetObjectFor: anObject corner x)		setY: (self targetObjectFor: anObject corner y).! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 9/23/2003 16:52'!getSmallInt: anObject id: classID	classID = 4 ifTrue: [^ stream int32].	classID = 5 ifTrue: [^ stream int16].! !!ObjStream methodsFor: 'fixed format-reading' stamp: 'jm 12/5/2003 18:38'!getSoundBuf: anObject id: classID	| sampleCount result |	sampleCount _ stream uint32.	result _ SoundBuffer newMonoSampleCount: sampleCount.	stream next: (sampleCount // 2) into: result startingAt: 1.  "size is in 32-bit words"	Smalltalk isBigEndian ifFalse: [result reverseEndiannessStereo: false].	^ result! !!ObjStream methodsFor: 'private-writing' stamp: 'jm 9/23/2003 14:15'!classEntryFor: anObject	"Answer the entry containing the class id and read/write selectors for the given object's class. Raise an error if the class is not registered."	^ NameToClassEntry at: anObject class name		ifAbsent: [self error: 'Unknown class ',  anObject class name]! !!ObjStream methodsFor: 'private-writing' stamp: 'jm 9/23/2003 14:16'!putUserObj: anObject id: ignored	"Ask the given user-defined object to write it's fields."	anObject storeFieldsOn: self.! !!ObjStream methodsFor: 'private-writing' stamp: 'jm 9/23/2003 15:19'!recordFieldsOf: anObject	"Record the fields of the given object."	"Details: Sometimes a user-defined class creates an object dynamically in a call to putField:. To preserve object identity between passes one and two, the objects passed to all calls to putField: are recorded during the first pass (i.e., by this method) and those exact same objects are used in the second pass."	| entry classID putSelector |	entry _ self classEntryFor: anObject.	classID _ entry at: 1.	putSelector _ entry at: 4.	fields _ OrderedCollection new.	fieldIndex _ 0.	self perform: putSelector with: anObject with: classID.	(objects at: anObject) at: 4 put: fields asArray.! !!ObjStream methodsFor: 'private-writing' stamp: 'jm 9/28/2003 12:26'!recordObject: anObject id: classID	"Assign an ID for the given object, add it to the list of objects to be stored in the object table, and add it to the toDo list. Do nothing if this object has already been recorded."	(objects includesKey: anObject) ifTrue: [^ self].	objects at: anObject put: (Array with: objectIndex with: anObject with: classID with: nil).	toDo addLast: anObject.	objectIndex _ objectIndex + 1.! !!ObjStream methodsFor: 'private-writing' stamp: 'jm 9/23/2003 15:08'!writeFileHeader	"Write the file header on my stream."	stream nextPutAll: 'ObjS' asByteArray.	stream nextPut: 1.	stream nextPutAll: 'Stch' asByteArray.	stream nextPut: 1.! !!ObjStream methodsFor: 'private-writing' stamp: 'jm 9/23/2003 15:19'!writeObjRef: anObject	"Write a reference to the given object to my output stream. The object must have an entry in the object dictionary."	| objEntry objectIndex |	objEntry _ objects at: anObject ifAbsent: [self error: 'object not in dictionary'].  "should never happen"	objectIndex _ objEntry at: 1.	stream nextPut: ObjectReferenceID.	stream uint24: objectIndex.! !!ObjStream methodsFor: 'private-writing' stamp: 'jm 9/24/2003 15:37'!writeObject: anObject objEntry: objEntry	"Write the object described by the given entry."	| entry classID putSelector |	entry _ self classEntryFor: anObject.	classID _ entry at: 1.	putSelector _ entry at: 4.	fields _ objEntry at: 4.	fieldIndex _ 0.	putSelector = #putUserObj:id: ifTrue: [		stream nextPut: classID.		stream nextPut: anObject fieldsVersion.		stream nextPut: fields size].	self perform: putSelector with: anObject with: classID.! !!ObjStream methodsFor: 'private-reading' stamp: 'jm 9/23/2003 16:51'!classForID: classID	"Answer the class for the given class ID."	^ Smalltalk at: (IDToClassEntry at: classID) second! !!ObjStream methodsFor: 'private-reading' stamp: 'jm 9/28/2003 15:27'!fixReferencesForObjectRecord: objectRecord	"After reading all the objects in the objects table, this method is called on each object record to replace all its object references with pointers to the actual object in the object table. The fields for user-defined objects are still held in an array in the object table record. Fixed-format objects are processed by calling their read selector a second time and, since firstPass is now false, this read method fixes any object references."	| obj classEntry classID readSelector |	obj _ objectRecord first.	classEntry _ self classEntryFor: obj.	classID _ classEntry first.	classID >= FirstPointerClassID ifTrue: [		classID > ObjectReferenceID			ifTrue: [  "user defined class"				self fixRefsInArray: (objectRecord at: 4)]			ifFalse: [  "fixed format class"				readSelector _ classEntry at: 3.				self perform: readSelector with: obj with: classID]].! !!ObjStream methodsFor: 'private-reading' stamp: 'jm 10/21/2003 10:36'!fixRefsInArray: anArray	"Replace any ObjRefRecord objects in the given array with references to the actual objects."	| el |	1 to: anArray size do: [:i |		el _ anArray at: i.		el class = ObjRefRecord ifTrue: [			el objectID > objects size				ifTrue: [anArray at: i put: #badObjRef]				ifFalse: [anArray at: i put: (objects at: el objectID) first]]].! !!ObjStream methodsFor: 'private-reading' stamp: 'jm 9/28/2003 15:17'!initializeUserDefinedFields: objectRecord	"If the given object record designates a user-defined object, ask that object to initialiize itself from its fields list. Otherwise, do nothing."	| obj classID classVersion |	obj _ objectRecord at: 1.	classID _ objectRecord at: 2.	classID > ObjectReferenceID ifTrue: [  "user defined class"		classVersion _ objectRecord at: 4.		fields _ objectRecord at: 4.		fieldIndex _ 0.		obj initFieldsFrom: self version: classVersion].! !!ObjStream methodsFor: 'private-reading' stamp: 'jm 9/23/2003 18:30'!readField	"Read a single object field. The result may be an object or an object reference."	| classID readSelector |	classID _ stream next.	classID = ObjectReferenceID ifTrue: [		^ ObjRefRecord new objectID: stream uint24].	readSelector _ (IDToClassEntry at: classID) at: 3.	^ self perform: readSelector with: nil with: classID! !!ObjStream methodsFor: 'private-reading' stamp: 'jm 9/23/2003 15:11'!readFileHeader	"Read the file header on my stream."	(((stream next: 4) asString = 'ObjS') &	 (stream next = 1) &	 ((stream next: 4) asString = 'Stch') &	 (stream next = 1)) ifFalse: [		self error: 'bad header'].! !!ObjStream methodsFor: 'private-reading' stamp: 'jm 9/28/2003 12:15'!readObjectRecord	"Read the next object record. Answer an array of the form (<obj> <class ID> [<version> <fieldsArray>]). The version and fields array are supplied only for user-defined objects."	| classID obj classVersion fieldCount fieldList readSelector |	classID _ stream next.	classID > ObjectReferenceID		ifTrue: [  "user defined object"			obj _ (self classForID: classID) new.			classVersion _ stream next.			fieldCount _ stream next.			fieldList _ (1 to: fieldCount) collect: [:i | self readField].			^ Array with: obj with: classID with: classVersion with: fieldList]		ifFalse: [  "fixed format object"			readSelector _ (IDToClassEntry at: classID) at: 3.			obj _ self perform: readSelector with: nil with: classID.			^ Array with: obj with: classID].! !!ObjStream methodsFor: 'private-reading' stamp: 'jm 9/23/2003 18:33'!targetObjectFor: anObject	"If the argument is an ObjRefRecord, answer the object that it refers to. Otherwise, just answer the argument."	anObject class = ObjRefRecord		ifTrue: [^ (objects at: anObject objectID) first]		ifFalse: [^ anObject].! !!ObjStream class methodsFor: 'class initialization' stamp: 'jm 10/10/2003 08:58'!fixedFormatClasses	"Answer an array of records for fixed-format classes."	^ #(		"id	class					read selector		write selector"		(1	UndefinedObject			getConst:id:			putConst:id:)		(2	True					getConst:id:			putConst:id:)		(3	False					getConst:id:			putConst:id:)		(4	SmallInteger			getSmallInt:id:		putSmallInt:id:)		(5	SmallInteger16			getSmallInt:id:		putSmallInt:id:)  "optimization for ints that fit into 16 bits"		(6	LargePositiveInteger		getBigInt:id:			putBigInt:id:)		(7	LargeNegativeInteger	getBigInt:id:			putBigInt:id:)		(8	Float					getFloat:id:			putFloat:id:)		(9	String					getBytes:id:			putBytes:id:)		(10	Symbol					getBytes:id:			putBytes:id:)		(11	ByteArray				getBytes:id:			putBytes:id:)		(12	SoundBuffer			getSoundBuf:id:		putSoundBuf:id:)		(13	Bitmap					getBitmap:id:		putBitmap:id:)	"12-19 reserved for additional non-pointer objects"		(20	Array					getArray:id:			putArray:id:)		(21	OrderedCollection		getCollection:id:		putCollection:id:)		(22	Set						getCollection:id:		putCollection:id:)		(23	IdentitySet				getCollection:id:		putCollection:id:)		(24	Dictionary				getDict:id:			putDict:id:)		(25	IdentityDictionary		getDict:id:			putDict:id:)	"26-29 reserved for additional collections"		(30	Color					getColor:id:			putColor:id:)		(31	TranslucentColor		getColor:id:			putColor:id:)		(32	Point					getPoint:id:			putPoint:id:)		(33	Rectangle				getRect:id:			putRect:id:)		(34	Form					getForm:id:			putForm:id:)		(35	ColorForm				getForm:id:			putForm:id:)	"99 reserved for object references"	"100-255 reserved for user-defined classes"	)! !!ObjStream class methodsFor: 'class initialization' stamp: 'jm 9/28/2003 15:39'!initialize	"self initialize"	ObjectReferenceID _ 99.	IDToClassEntry _ Dictionary new.	NameToClassEntry _ Dictionary new.	self fixedFormatClasses do: [:entry |		(IDToClassEntry includesKey: entry first) ifTrue: [self error: 'duplicate fixed class ID'].		IDToClassEntry at: entry first put: entry.		NameToClassEntry at: entry second put: entry].	self userClasses do: [:pair |		entry _ pair, #(unused putUserObj:id:).		(IDToClassEntry includesKey: entry first) ifTrue: [self error: 'duplicate user class ID'].		IDToClassEntry at: entry first put: entry.		NameToClassEntry at: entry second put: entry].	FloatClassID _ (NameToClassEntry at: #Float) first.	FirstPointerClassID _ (NameToClassEntry at: #Array) first.! !!ObjStream class methodsFor: 'class initialization' stamp: 'jm 12/1/2003 10:54'!userClasses	"Answer an array of (<class id>, <class name>) records for all version numbered user classes."	^ #(		"id		class"		(100		Morph)		(101		BorderedMorph)		(102		RectangleMorph)		(103		EllipseMorph)		(104		AlignmentMorph)		(105		StringMorph)		(106		UpdatingStringMorph)		(107		SimpleSliderMorph)		(108		SimpleButtonMorph)		(109		SampledSound)		(120		SpriteMorph)		(121		SoundMorph)		(122		ImageBoxMorph)		(123		SensorBoardMorph)		(140		ChoiceArgMorph)		(141		ColorArgMorph)		(142		ExpressionArgMorph)		(143		ParameterReferenceMorph)		(144		PositionArgMorph)		(145		SpriteArgMorph)		(146		VariableArgMorph)		(147		BlockMorph)		(148		CommandBlockMorph)		(149		CBlockMorph)		(150		MethodCallBlockMorph)		(151		HatBlockMorph)		(152		ScratchButtonMorph)		(153		ScratchScriptsMorph)		(154		ScratchSliderMorph)		(155		WatcherMorph)		(156		ParameterMorph)		(157		SetterBlockMorph)	)! !!ObjStream class methodsFor: 'testing' stamp: 'jm 9/24/2003 12:19'!equalityTest: inObj	"For testing. Serialize and deserialize the given object and compare the result for equality with the original object."	| outObj |	outObj _ self serializeAndDeserialize: inObj.	outObj class == inObj class ifFalse: [self error: 'output class is not equal to input class'].	outObj = inObj ifFalse: [self error: 'output is not equal to input'].! !!ObjStream class methodsFor: 'testing' stamp: 'jm 10/10/2003 09:12'!fixedFormatClassTests	"Test conversions for fixed-format objects."	"self initialize; fixedFormatClassTests"	| shared |	self equalityTest: #().	self equalityTest: #(1 2 3).	self equalityTest: (Array with: nil with: true with: false).	self equalityTest: #(123 -123 123456 -123456 123456789000 -123456789000 3.14159).	self equalityTest: 'hello'.	self equalityTest: 'hello' asSymbol.	self equalityTest: #(1 2 3) asByteArray.	self equalityTest: (SoundBuffer fromArray: #(1 2 3 4)).	self equalityTest: (Bitmap withAll: #(0 1 2 2147483647 2147483648 4294967295)).	self equalityTest: #(1 2 3) asOrderedCollection.	self equalityTest: #(1 2 3) asSet.	self equalityTest: (IdentitySet new addAll: #(1 2 3); yourself).	self equalityTest: (Dictionary new at: 1 put: 'a'; at: 'b' put: 2; yourself).	self equalityTest: (IdentityDictionary new at: 1 put: 'a'; at: 'b' put: 2; yourself).	self equalityTest: (Color gray: 0.3).	self equalityTest: (Color red alpha: 0.5).	self equalityTest: 2 @ 3.14159.	self equalityTest: (0@0 extent: 2.5).	self formEqualityTest: (Form fromDisplay: (0@0 extent: 10)).	self formEqualityTest: ((Form fromDisplay: (0@0 extent: 10)) colorReduced).	shared _ #Shared.	self equalityTest: (Point x: shared y: shared).	self equalityTest: ((Point x: shared y: shared) corner: (Point x: shared y: shared)).	self equalityTest: (OrderedCollection with: shared with: shared).	self equalityTest: (Array with: shared with: (Set new add: shared; yourself)).	self equalityTest: (Dictionary new at: shared put: shared; at: 'b' put: shared; yourself).	self equalityTest: (IdentityDictionary new at: shared put: shared; at: 'b' put: shared; yourself).	self inform: 'Fixed-format tests passed.'.! !!ObjStream class methodsFor: 'testing' stamp: 'jm 9/28/2003 12:42'!formEqualityTest: inForm	"For testing. Serialize and deserialize the given form and compare the result for equality with the original."	| outForm |	outForm _ self serializeAndDeserialize: inForm.	outForm class == inForm class ifFalse: [self error: 'output class is not equal to input class'].	((outForm extent = inForm extent) &	 (outForm depth = inForm depth) &	 (outForm bits = inForm bits) &	 (outForm offset = inForm offset))		 ifFalse: [self error: 'output Form is not equal to input Form'].	(inForm isKindOf: ColorForm) ifTrue: [		inForm colors = outForm colors			ifFalse: [self error: 'output colors are not equal to input colors']].! !!ObjStream class methodsFor: 'testing' stamp: 'jm 12/3/2003 07:14'!serializeAndDeserialize: anObject	"For testing. Serialize and de-serialize the given object and answer the result."	| stream |	stream _ WriteStream on: ByteArray new.	ObjStream new storeObj: anObject on: stream showProgress: false.	^ ObjStream new readObjFrom: (ReadStream on: stream contents)! !!ObjStream class methodsFor: 'testing' stamp: 'jm 9/25/2003 22:36'!userClassTests	"Test conversions for fixed-format objects."	"self initialize; userClassTests"	| userClassList suspectClasses |	userClassList _ self userClasses collect: [:rec | Smalltalk at: rec second].	userClassList do: [:cl | self serializeAndDeserialize: cl new].	self inform: 'User class tests passed.'.	suspectClasses _ userClassList select: [:cl |		(cl includesSelector: #fieldsVersion) not and: [cl instVarNames size > 0]].	suspectClasses size > 0 ifTrue: [self error: 'not all classes implement #fieldsVersion'].! !Object is the root class for almost all of the other classes in the class hierarchy. The exceptions are ProtoObject (the superclass of Object) and its subclasses.Class Object provides default behavior common to all normal objects, such as access, copying, comparison, error handling, message sending, and reflection. Also utility messages that all objects should respond to are defined here.Object has no instance variables, nor should any be added. This is due to several classes of objects that inherit from Object that have special implementations (SmallInteger and UndefinedObject for example) or the VM knows about and depends on the structure and layout of certain standard classes.Class Variables:	DependentsFields		an IdentityDictionary		Provides a virtual 'dependents' field so that any object may have one		or more dependent views, synchronized by the changed:/update: protocol.		Note that class Model has a real slot for its dependents, and overrides		the associated protocol with more efficient implementations.Because Object is the root of the inheritance tree, methods are often defined in Object to give all objects special behaviors needed by certain subsystems or applications, or to respond to certain general test messages such as isMorph.!!Object methodsFor: 'accessing' stamp: 'di 3/29/1999 11:39'!at: index 	"Primitive. Assumes receiver is indexable. Answer the value of an 	indexable element in the receiver. Fail if the argument index is not an 	Integer or is out of bounds. Essential. See Object documentation 	whatIsAPrimitive."	<primitive: 60>	index isInteger ifTrue:		[self class isVariable			ifTrue: [self errorSubscriptBounds: index]			ifFalse: [self error: (self class name) , 's are not indexable']].	index isNumber		ifTrue: [^self at: index asInteger]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'di 3/29/1999 11:41'!at: index put: value 	"Primitive. Assumes receiver is indexable. Store the argument value in 	the indexable element of the receiver indicated by index. Fail if the 	index is not an Integer or is out of bounds. Or fail if the value is not of 	the right type for this kind of collection. Answer the value that was 	stored. Essential. See Object documentation whatIsAPrimitive."	<primitive: 61>	index isInteger ifTrue:		[self class isVariable			ifTrue: [(index >= 1 and: [index <= self size])					ifTrue: [self errorImproperStore]					ifFalse: [self errorSubscriptBounds: index]]			ifFalse: [self error: (self class name) , 's are not indexable']].	index isNumber		ifTrue: [^self at: index asInteger put: value]		ifFalse: [self errorNonIntegerIndex]! !!Object methodsFor: 'accessing' stamp: 'di 3/29/1999 13:10'!size	"Primitive. Answer the number of indexable variables in the receiver. 	This value is the same as the largest legal subscript. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 62>	self class isVariable ifFalse: [self errorNotIndexable].	^ 0! !!Object methodsFor: 'testing' stamp: 'jm 5/15/2003 22:54'!ifNil: nilBlock	"Just return self, since I am not nil."	^ self! !!Object methodsFor: 'testing' stamp: 'jm 5/15/2003 22:48'!ifNil: nilBlock ifNotNil: notNilBlock	"Evaluate notNilBlock, since I am not nil."	^ notNilBlock value! !!Object methodsFor: 'testing' stamp: 'jm 5/15/2003 22:55'!ifNotNil: notNilBlock	"Evaluate notNilBlock, since I am not nil."	^ notNilBlock value! !!Object methodsFor: 'testing' stamp: 'jm 5/15/2003 22:55'!ifNotNil: notNilBlock ifNil: nilBlock 	"Evaluate notNilBlock, since I am not nil."	^ notNilBlock value! !!Object methodsFor: 'testing' stamp: 'ar 7/9/1999 18:18'!isBehavior	"Return true if the receiver is a behavior.	Note: Do not override in any class except behavior."	^false! !!Object methodsFor: 'testing' stamp: 'di 11/9/1998 09:38'!isFloat	"Overridden to return true in Float, natch"	^ false! !!Object methodsFor: 'testing' stamp: 'len 1/13/98 21:18'!isFraction	"Answer true if the receiver is a Fraction."	^ false! !!Object methodsFor: 'testing' stamp: 'jm 5/15/2003 22:33'!isNil	"Coerces nil to true and everything else to false."	^false! !!Object methodsFor: 'testing' stamp: 'di 11/6/1998 08:04'!isPoint	"Overridden to return true in Point."	^ false! !!Object methodsFor: 'testing' stamp: 'jm 5/15/2003 22:56'!notNil	"Answer true, since I am not nil."	^ true! !!Object methodsFor: 'testing' stamp: 'jm 5/15/2003 22:33'!pointsTo: anObject	"This method returns true if self contains a pointer to anObject,		and returns false otherwise"	<primitive: 132>	1 to: self class instSize do:		[:i | (self instVarAt: i) == anObject ifTrue: [^ true]].	1 to: self basicSize do:		[:i | (self basicAt: i) == anObject ifTrue: [^ true]].	^ false! !!Object methodsFor: 'testing' stamp: 'sw 10/20/1999 14:52'!stepAt: millisecondClockValue in: aWindow	^ self stepIn: aWindow! !!Object methodsFor: 'testing' stamp: 'sw 10/19/1999 08:16'!stepIn: aWindow	^ self step! !!Object methodsFor: 'testing' stamp: 'sw 10/19/1999 08:21'!stepTime		^ 1000 "milliseconds -- default backstop for objects serving as models of system windows"! !!Object methodsFor: 'testing' stamp: 'sw 10/19/1999 08:22'!stepTimeIn: aSystemWindow		^ 1000 "milliseconds -- default backstop for objects serving as models of system windows"! !!Object methodsFor: 'testing' stamp: 'di 1/8/1999 15:04'!wantsSteps	"Overridden by morphic classes whose instances want to be stepped,	or by model classes who want their morphic views to be stepped."	^ false! !!Object methodsFor: 'testing' stamp: 'sw 10/19/1999 08:26'!wantsStepsIn: aSystemWindow		^ self wantsSteps! !!Object methodsFor: 'comparing' stamp: 'jm 5/15/2003 22:58'!== anObject 	"Primitive. Answer true if the receiver and the argument are the same object (have the same object pointer). Do not redefine the message == in any other class!! Essential. No Lookup. Do not override in any subclass."	<primitive: 110>	self primitiveFailed! !!Object methodsFor: 'comparing' stamp: 'jm 5/15/2003 22:34'!identityHash	"Answer a SmallInteger whose value is related to the receiver's identity.	This method must not be overridden, except by SmallInteger.	Primitive. Fails if the receiver is a SmallInteger. Essential.	See Object documentation whatIsAPrimitive.	Do not override."	<primitive: 75>	self primitiveFailed! !!Object methodsFor: 'comparing' stamp: 'jm 5/15/2003 22:57'!~~ anObject	"Answer true if the argument are not the same object (do not have the same object pointer)."	self == anObject		ifTrue: [^ false]		ifFalse: [^ true]! !!Object methodsFor: 'copying' stamp: 'tk 11/27/1998 09:00'!copyFrom: anotherObject	"Copy to myself all instance variables I have in common with anotherObject.  This is dangerous because it ignores an object's control over its own inst vars.  "	| mine his |	mine _ self class allInstVarNames.	his _ anotherObject class allInstVarNames.	1 to: (mine size min: his size) do: [:ind |		(mine at: ind) = (his at: ind) ifTrue: [			self instVarAt: ind put: (anotherObject instVarAt: ind)]].	self class isVariable & anotherObject class isVariable ifTrue: [		1 to: (self basicSize min: anotherObject basicSize) do: [:ind |			self basicAt: ind put: (anotherObject basicAt: ind)]].! !!Object methodsFor: 'copying' stamp: 'di 6/9/1999 14:44'!copySameFrom: otherObject	"Copy to myself all instance variables named the same in otherObject.	This ignores otherObject's control over its own inst vars."	| myInstVars otherInstVars match |	myInstVars _ self class allInstVarNames.	otherInstVars _ otherObject class allInstVarNames.	myInstVars doWithIndex: [:each :index |		(match _ otherInstVars indexOf: each) > 0 ifTrue:			[self instVarAt: index put: (otherObject instVarAt: match)]]! !!Object methodsFor: 'dependents access' stamp: 'sma 2/29/2000 20:24'!addDependent: anObject	"Make the given object one of the receiver's dependents."	| dependents |	dependents _ self dependents.	(dependents includes: anObject) ifFalse:		[self myDependents: (dependents copyWith: anObject)].	^ anObject! !!Object methodsFor: 'dependents access' stamp: 'sma 2/29/2000 19:53'!breakDependents	"Remove all of the receiver's dependents."	self myDependents: nil! !!Object methodsFor: 'dependents access' stamp: 'jm 5/23/2003 20:38'!canDiscardEdits	"Answer true if none of the views on this model has unaccepted edits that matter."	self dependents do: [:each |		each = self ifFalse: [each canDiscardEdits ifFalse: [^ false]]].	^ true! !!Object methodsFor: 'dependents access' stamp: 'sma 2/29/2000 19:58'!dependents	"Answer a collection of objects that are 'dependent' on the receiver;	 that is, all objects that should be notified if the receiver changes."	^ self myDependents ifNil: [#()]! !!Object methodsFor: 'dependents access' stamp: 'jm 5/23/2003 20:40'!hasUnacceptedEdits	"Answer true if any of the views on this object has unaccepted edits."	self dependents do: [:each |		each = self ifFalse: [each hasUnacceptedEdits ifTrue: [^ true]]].	^ false! !!Object methodsFor: 'dependents access' stamp: 'sma 2/29/2000 19:55'!myDependents	"Private. Answer a list of all the receiver's dependents."	^ DependentsFields at: self ifAbsent: []! !!Object methodsFor: 'dependents access' stamp: 'sma 2/29/2000 19:52'!myDependents: aCollectionOrNil	"Private. Set (or remove) the receiver's dependents list."	aCollectionOrNil		ifNil: [DependentsFields removeKey: self ifAbsent: []]		ifNotNil: [DependentsFields at: self put: aCollectionOrNil]! !!Object methodsFor: 'dependents access' stamp: 'jm 10/4/2002 17:27'!release	"Remove references to objects that may refer to the receiver. This message 	should be overridden by subclasses with any cycles, in which case the 	subclass should also include the expression super release."	self breakDependents.! !!Object methodsFor: 'dependents access' stamp: 'sma 2/29/2000 20:23'!removeDependent: anObject	"Remove the given object as one of the receiver's dependents."	| dependents |	dependents _ self dependents reject: [:each | each == anObject].	self myDependents: (dependents isEmpty ifFalse: [dependents]).	^ anObject! !!Object methodsFor: 'updating' stamp: 'sw 10/31/1999 00:15'!noteSelectionIndex: anInteger for: aSymbol	"backstop"! !!Object methodsFor: 'updating' stamp: 'sma 2/29/2000 20:05'!update: aParameter 	"Receive a change notice from an object of whom the receiver is a 	dependent. The default behavior is to do nothing; a subclass might want 	to change itself in some way."	^ self! !!Object methodsFor: 'updating' stamp: 'sw 10/19/1999 14:39'!updateListsAndCodeIn: aWindow	self canDiscardEdits ifFalse: [^ self].	aWindow updatablePanes do: [:aPane | aPane verifyContents]! !!Object methodsFor: 'updating' stamp: 'jm 8/20/1998 18:26'!windowIsClosing	"This message is used to inform a models that its window is closing. Most models do nothing, but some, such as the Debugger, must do some cleanup. Note that this mechanism must be used with care by models that support multiple views, since one view may be closed while others left open."! !!Object methodsFor: 'printing' stamp: 'sma 6/1/2000 09:28'!longPrintOn: aStream	"Append to the argument, aStream, the names and values of all 	of the receiver's instance variables."	self class allInstVarNames doWithIndex:		[:title :index |		aStream nextPutAll: title;		 nextPut: $:;		 space;		 tab;		 print: (self instVarAt: index);		 cr]! !!Object methodsFor: 'printing' stamp: 'sw 9/2/1999 15:18'!longPrintString	"Answer a String whose characters are a description of the receiver."	^ String streamContents: [:aStream | self longPrintOn: aStream]! !!Object methodsFor: 'printing' stamp: 'sma 6/1/2000 09:31'!printOn: aStream	"Append to the argument, aStream, a sequence of characters that  	identifies the receiver."	| title |	title _ self class name.	aStream		nextPutAll: (title first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: title! !!Object methodsFor: 'printing' stamp: 'sma 6/1/2000 09:22'!printString	"Answer a String whose characters are a description of the receiver. 	If you want to print without a character limit, use fullPrintString."	^ self printStringLimitedTo: 50000! !!Object methodsFor: 'printing' stamp: 'tk 5/7/1999 16:20'!printStringLimitedTo: limit	"Answer a String whose characters are a description of the receiver.	If you want to print without a character limit, use fullPrintString."	| limitedString |	limitedString _ String streamContents: [:s | self printOn: s] limitedTo: limit.	limitedString size < limit ifTrue: [^ limitedString].	^ limitedString , '...etc...'! !!Object methodsFor: 'message handling' stamp: 'di 3/26/1999 07:52'!perform: aSymbol 	"Send the unary selector, aSymbol, to the receiver.	Fail if the number of arguments expected by the selector is not zero.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol withArguments: (Array new: 0)! !!Object methodsFor: 'message handling' stamp: 'sw 10/30/1998 18:27'!perform: selector orSendTo: otherTarget	"If I wish to intercept and handle selector myself, do it; else send it to otherTarget"	^ otherTarget perform: selector! !!Object methodsFor: 'message handling' stamp: 'di 3/26/1999 07:52'!perform: aSymbol with: anObject 	"Send the selector, aSymbol, to the receiver with anObject as its argument.	Fail if the number of arguments expected by the selector is not one.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: anObject)! !!Object methodsFor: 'message handling' stamp: 'di 3/26/1999 07:52'!perform: aSymbol with: firstObject with: secondObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not two.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol withArguments: (Array with: firstObject with: secondObject)! !!Object methodsFor: 'message handling' stamp: 'di 3/26/1999 07:51'!perform: aSymbol with: firstObject with: secondObject with: thirdObject 	"Send the selector, aSymbol, to the receiver with the given arguments.	Fail if the number of arguments expected by the selector is not three.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 83>	^ self perform: aSymbol		withArguments: (Array with: firstObject with: secondObject with: thirdObject)! !!Object methodsFor: 'message handling' stamp: 'di 3/26/1999 07:55'!perform: selector withArguments: argArray 	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Fail if the number of arguments expected by the selector 	does not match the size of argArray.	Primitive. Optional. See Object documentation whatIsAPrimitive."	<primitive: 84>	^ self perform: selector withArguments: argArray inSuperclass: self class! !!Object methodsFor: 'message handling' stamp: 'di 3/26/1999 08:00'!perform: selector withArguments: argArray inSuperclass: lookupClass	"NOTE:  This is just like perform:withArguments:, except that	the message lookup process begins, not with the receivers's class,	but with the supplied superclass instead.  It will fail if lookupClass	cannot be found among the receiver's superclasses.	Primitive. Essential. See Object documentation whatIsAPrimitive."	<primitive: 100>	(selector isMemberOf: Symbol)		ifFalse: [^ self error: 'selector argument must be a Symbol'].	(selector numArgs = argArray size)		ifFalse: [^ self error: 'incorrect number of arguments'].	(self class == lookupClass or: [self class inheritsFrom: lookupClass])		ifFalse: [^ self error: 'lookupClass is not in my inheritance chain'].	self primitiveFailed! !!Object methodsFor: 'error handling' stamp: 'jm 5/22/2003 19:32'!assert: aBlock	"Raise an error if aBlock does not evaluates to true."	aBlock value ifFalse: [self error: 'Assertion failed.'].! !!Object methodsFor: 'error handling' stamp: 'di 3/19/1999 10:31'!cannotInterpret: aMessage 	 "Handle the fact that there was an attempt to send the given message to the receiver but a null methodDictionary was encountered while looking up the message selector.  Hopefully this is the result of encountering a stub for a swapped out class which induces this exception on purpose.""If this is the result of encountering a swap-out stub, then simulating the lookup in Smalltalk should suffice to install the class properly, and the message may be resent."	| handler errorString |	(self class lookupSelector: aMessage selector) == nil ifFalse:		["Simulated lookup succeeded -- resend the message."		^ aMessage sentTo: self].	"Could not recover by simulated lookup -- it's an error"	errorString _ 'MethodDictionary fault'.	(handler _ Processor activeProcess errorHandler) notNil		ifTrue: [handler value: errorString value: self]		ifFalse: [Debugger openContext: thisContext					label: errorString					contents: thisContext shortStack].	^ aMessage sentTo: self! !!Object methodsFor: 'error handling' stamp: 'sma 5/28/2000 15:48'!confirm: queryString	"Put up a yes/no menu with caption queryString. Answer true if the 	response is yes, false if no. This is a modal question--the user must 	respond yes or no."	"nil confirm: 'Are you hungry?'"	^ PopUpMenu confirm: queryString! !!Object methodsFor: 'error handling' stamp: 'sma 5/28/2000 15:55'!confirm: aString orCancel: cancelBlock	"Put up a yes/no/cancel menu with caption aString. Answer true if  	the response is yes, false if no. If cancel is chosen, evaluate  	cancelBlock. This is a modal question--the user must respond yes or no."	^ PopUpMenu confirm: aString orCancel: cancelBlock! !!Object methodsFor: 'error handling' stamp: 'jm 5/23/2003 12:43'!doesNotUnderstand: aMessage 	 "Error: an attempt was made to send the given message but the receiver does not understand this message. This message is sent by the virtual machine when a message is sent to an object that does not define a method for the message selector."	"Example: 3 width"	self error: 'Message not understood: ', aMessage selector.	^ aMessage sentTo: self! !!Object methodsFor: 'error handling' stamp: 'jm 5/15/2003 20:49'!error: aString	"The default behavior for error: is the same as halt:. The code is 	replicated in order to avoid showing an extra level of message sending 	in the Debugger. This additional message is the one a subclass should 	override in order to change the error handling behavior."	| handler |	(handler _ Processor activeProcess errorHandler) notNil		ifTrue:			[handler  value: aString value: self]		ifFalse: 			[Debugger				openContext: thisContext				label: aString				contents: thisContext shortStack]	"nil error: 'error message'."! !!Object methodsFor: 'error handling' stamp: 'jm 5/22/2003 19:26'!halt	"This message is used to insert breakpoints during debugging."	"Example: nil halt"	self halt: 'Halt encountered.'! !!Object methodsFor: 'error handling' stamp: 'jm 5/23/2003 12:41'!halt: aString	"This is the typical message to use for inserting breakpoints during debugging. It creates and schedules a Debugger with the given string as the label."	"Example: (self halt: 'Hello!!')"	Debugger		openContext: thisContext		label: aString		contents: thisContext shortStack.! !!Object methodsFor: 'user interface' stamp: 'sw 10/4/1999 08:13'!addModelItemsToWindowMenu: aMenu	"aMenu is being constructed to be presented to the user in response to the user's pressing on the menu widget in the title bar of a morphic window.  Here, the model is given the opportunity to add any model-specific items to the menu, whose default target is the SystemWindow itself."! !!Object methodsFor: 'user interface' stamp: 'jm 11/22/2002 19:03'!beep	"Emit a short alert sound. Do nothing if the primitive fails."	<primitive: 140>! !!Object methodsFor: 'user interface' stamp: 'sw 5/8/2000 01:59'!browseHierarchy	^ HierarchyBrowser newFor: self class"(2@7) browseHierarchy"! !!Object methodsFor: 'user interface' stamp: 'jm 5/31/2003 16:45'!defaultBackgroundColor	"Answer the color to be used as the base window color for a window whose model is an object of the receiver's class"		^ Preferences windowColorFor: self class name! !!Object methodsFor: 'user interface' stamp: 'sma 5/28/2000 15:59'!inform: aString	"Display a message for the user to read and then dismiss. 6/9/96 sw"	aString isEmptyOrNil ifFalse: [PopUpMenu inform: aString]! !!Object methodsFor: 'user interface' stamp: 'di 5/11/1999 22:26'!modelSleep	"A window with me as model is being exited or collapsed or closed.	Default response is no-op" ! !!Object methodsFor: 'user interface' stamp: 'di 5/11/1999 22:01'!modelWakeUp	"A window with me as model is being entered or expanded.  Default response is no-op" ! !!Object methodsFor: 'user interface' stamp: 'sw 10/16/1999 22:45'!modelWakeUpIn: aWindow	"A window with me as model is being entered or expanded.  Default response is no-op" 	self modelWakeUp! !!Object methodsFor: 'user interface' stamp: 'sw 3/8/1999 15:27'!mouseUpBalk: evt	"A button I own got a mouseDown, but the user moved out before letting up.  Certain kinds of objects (so-called 'radio buttons', for example, and other structures that must always have some selection, e.g. PaintBoxMorph) wish to take special action in this case; this default does nothing."! !!Object methodsFor: 'user interface' stamp: 'di 6/10/1998 15:06'!windowActiveOnFirstClick	"Return true if my window should be active on first click."	^ false! !!Object methodsFor: 'user interface' stamp: 'di 6/10/1998 15:06'!windowReqNewLabel: labelString	"My window's title has been edited.	Return true if this is OK, and override for further behavior."	^ true! !!Object methodsFor: 'system primitives' stamp: 'jm 5/15/2003 22:35'!become: otherObject 	"Primitive. Swap the object pointers of the receiver and the argument.	All variables in the entire system that used to point to the 	receiver now point to the argument, and vice-versa.	Fails if either object is a SmallInteger"	(Array with: self)		elementsExchangeIdentityWith:			(Array with: otherObject)! !!Object methodsFor: 'system primitives' stamp: 'di 1/9/1999 15:19'!becomeForward: otherObject 	"Primitive. All variables in the entire system that used to point	to the receiver now point to the argument.	Fails if either argument is a SmallInteger."	(Array with: self)		elementsForwardIdentityTo:			(Array with: otherObject)! !!Object methodsFor: 'system primitives' stamp: 'jm 5/15/2003 22:36'!nextInstance	"Primitive. Answer the next instance after the receiver in the 	enumeration of all instances of this class. Fails if all instances have been 	enumerated. Essential. See Object documentation whatIsAPrimitive."	<primitive: 78>	^nil! !!Object methodsFor: 'system primitives' stamp: 'jm 5/15/2003 22:36'!nextObject	"Primitive. Answer the next object after the receiver in the 	enumeration of all objects. Return 0 when all objects have been 	enumerated."	<primitive: 139>	self primitiveFailed.! !!Object methodsFor: 'system primitives' stamp: 'ar 5/25/2000 20:27'!tryNamedPrimitive	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!Object methodsFor: 'system primitives' stamp: 'ar 5/25/2000 20:27'!tryNamedPrimitive: arg1	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!Object methodsFor: 'system primitives' stamp: 'ar 5/25/2000 20:27'!tryNamedPrimitive: arg1 with: arg2	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!Object methodsFor: 'system primitives' stamp: 'ar 5/25/2000 20:27'!tryNamedPrimitive: arg1 with: arg2 with: arg3	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!Object methodsFor: 'system primitives' stamp: 'ar 5/25/2000 20:27'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!Object methodsFor: 'system primitives' stamp: 'ar 5/25/2000 20:27'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4 with: arg5	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!Object methodsFor: 'system primitives' stamp: 'ar 5/25/2000 20:27'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!Object methodsFor: 'system primitives' stamp: 'ar 5/25/2000 20:27'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!Object methodsFor: 'system primitives' stamp: 'ar 5/25/2000 20:27'!tryNamedPrimitive: arg1 with: arg2 with: arg3 with: arg4 with: arg5 with: arg6 with: arg7 with: arg8	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive:'' module:''>	^ ContextPart primitiveFailToken! !!Object methodsFor: 'system primitives' stamp: 'di 2/10/1999 22:16'!tryPrimitive: primIndex withArgs: argumentArray	"This method is a template that the Smalltalk simulator uses to 	execute primitives. See Object documentation whatIsAPrimitive."	<primitive: 118>	^ ContextPart primitiveFailToken! !!Object methodsFor: 'private' stamp: 'di 3/29/1999 12:39'!errorNotIndexable	"Create an error notification that the receiver is not indexable."	self error: (self class name) , 's are not indexable'! !!Object methodsFor: 'private' stamp: 'sma 5/27/2000 17:49'!primitiveError: aString 	"This method is called when the error handling results in a recursion in 	calling on error: or halt or halt:."	| context |	(String		streamContents: 			[:s |			s nextPutAll: '**System error handling failed**'.			s cr; nextPutAll: aString.			context _ thisContext sender sender.			20 timesRepeat: [context == nil ifFalse: [s cr; print: (context _ context sender)]].			s cr; nextPutAll: '**Type CR to enter an emergency evaluator.**'.			s cr; nextPutAll: '**Type any other character to restart.**'])		displayAt: 0 @ 0.	[Sensor keyboardPressed] whileFalse.	Sensor keyboard == Character cr ifTrue: [Transcripter emergencyEvaluator].	Smalltalk isMorphic ifTrue: [^ World install "To init hand events and redisplay world"].	ScheduledControllers searchForActiveController! !!Object methodsFor: 'converting' stamp: 'di 11/9/1998 12:15'!adaptToFloat: rcvr andSend: selector	"If no method has been provided for adapting an object to a Float,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'di 11/9/1998 12:14'!adaptToFraction: rcvr andSend: selector	"If no method has been provided for adapting an object to a Fraction,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'di 11/9/1998 12:15'!adaptToInteger: rcvr andSend: selector	"If no method has been provided for adapting an object to a Integer,	then it may be adequate to simply adapt it to a number."	^ self adaptToNumber: rcvr andSend: selector! !!Object methodsFor: 'converting' stamp: 'sma 5/12/2000 17:39'!asOrderedCollection	"Answer an OrderedCollection with the receiver as its only element."	^ OrderedCollection with: self! !!Object methodsFor: 'converting' stamp: 'RAA 3/31/1999 12:13'!withoutListWrapper	^self! !!Object methodsFor: 'macpal' stamp: 'sw 1/28/1999 17:31'!contentsChanged	self changed: #contents! !!Object methodsFor: 'macpal' stamp: 'sw 1/28/1999 12:02'!currentEvent	"Answer the current Morphic event.  This method never returns nil."	^ self currentHand lastEvent! !!Object methodsFor: 'macpal' stamp: 'di 6/7/1999 15:42'!currentHand	"Return a usable HandMorph -- the one associated with the object's current environment.  This method will always return a hand, even if it has to conjure one up as a last resort.  If a particular hand is actually handling events at the moment (such as a remote hand or a ghost hand), it will be returned."	^ self currentWorld primaryHand! !!Object methodsFor: 'macpal' stamp: 'di 11/27/1999 07:34'!currentWorld	"Answer a morphic world that is the current UI focus.		If in a morphic project, it's that project's world.  		If in an mvc project, it is the topmost morphic-mvc-window's worldMorph. 		If in an mvc project that has no morphic-mvc-windows, then it's just some existing worldmorph instance.		If in an mvc project in a Squeak that has NO WorldMorph instances, one is created.	This method will never return nil, it will always return its best effort at returning a relevant world morph, but if need be -- if there are no worlds anywhere, it will create a new one."	| aView aSubview |	World ifNotNil: [^ World].	aView _ ScheduledControllers controllerSatisfying:		[:ctrl | (aSubview _ ctrl view firstSubView) notNil and:			[aSubview model isMorph and: [aSubview model isWorldMorph]]].	^ aView		ifNotNil:			[aSubview model]		ifNil:			[MVCWiWPasteUpMorph newWorldForProject: nil]! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 16:26'!actAsExecutor	"Prepare the receiver to act as executor for any resources associated with it"	self breakDependents! !!Object methodsFor: 'finalization' stamp: 'ar 3/20/98 22:19'!executor	"Return an object which can act as executor for finalization of the receiver"	^self shallowCopy actAsExecutor! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 16:27'!finalize	"Finalize the resource associated with the receiver. This message should only be sent during the finalization process. There is NO garantuee that the resource associated with the receiver hasn't been free'd before so take care that you don't run into trouble - this all may happen with interrupt priority."! !!Object methodsFor: 'finalization' stamp: 'ar 3/21/98 18:38'!retryWithGC: execBlock until: testBlock	"Retry execBlock as long as testBlock returns false. Do an incremental GC after the first try, a full GC after the second try."	| blockValue |	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollectMost.	blockValue := execBlock value.	(testBlock value: blockValue) ifTrue:[^blockValue].	Smalltalk garbageCollect.	^execBlock value.! !!Object methodsFor: 'initialization' stamp: 'jm 5/29/2003 21:43'!initialize	"Initialize this object. Usually called by new when a new object is created. This default implementation does nothing."! !!Object methodsFor: 'object i/o' stamp: 'jm 9/25/2003 10:53'!initFieldsNamed: varList from: anObjStream	"Initialize my instance variables in the given list from the given object stream."	| allVars |	allVars _ self class allInstVarNames.	varList do: [:varName |		self instVarAt: (allVars indexOf: varName) put: anObjStream nextField].! !!Object methodsFor: 'object i/o' stamp: 'jm 9/25/2003 10:52'!storeFieldsNamed: varList on: anObjStream	"Store the instance variables in the given list on the given object stream."	| allVars |	allVars _ self class allInstVarNames.	varList do: [:varName |		anObjStream putField: (self instVarAt: (allVars indexOf: varName))].! !!Object class methodsFor: 'instance creation' stamp: 'jm 5/29/2003 21:45'!new	^ self basicNew initialize! !!Object class methodsFor: 'instance creation' stamp: 'di 6/9/1999 14:27'!newFrom: aSimilarObject	"Create an object that has similar contents to aSimilarObject.	If the classes have any instance varaibles with the same names, copy them across.	If this is bad for a class, override this method."	^ self basicNew copySameFrom: aSimilarObject! !!Object class methodsFor: 'instance creation' stamp: 'tk 4/18/1999 07:05'!readFrom: aStream	"Create an object based on the contents of aStream."	| object ok |	ok _ (aStream isKindOf: Stream) or: [aStream isKindOf: String].	(ok or: [aStream isKindOf: Text]) ifFalse: [^ self error: 'expected String or Text'].	object _ Compiler evaluate: aStream.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object! !!Object class methodsFor: 'private' stamp: 'sma 2/29/2000 20:12'!initializeDependentsFields	DependentsFields _ IdentityDictionary new	"Object initializeDependentsFields"! !I represent a collection of objects ordered by the collector.!!OrderedCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:39'!size	"Answer how many elements the receiver contains."	^ lastIndex - firstIndex + 1! !!OrderedCollection methodsFor: 'adding' stamp: 'di 3/15/1999 14:01'!add: newObject afterIndex: index 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just after index. Answer newObject."	self insert: newObject before: firstIndex + index.	^ newObject! !!OrderedCollection methodsFor: 'adding' stamp: 'sma 5/12/2000 11:26'!addAll: aCollection 	"Add each element of aCollection at my end. Answer	aCollection."	^ self addAllLast: aCollection! !!OrderedCollection methodsFor: 'removing' stamp: 'sma 5/12/2000 11:24'!removeAllSuchThat: aBlock 	"Evaluate aBlock for each element and remove all that elements from	the receiver for that aBlock evaluates to true."	| index |	index _ firstIndex.	[index <= lastIndex]		whileTrue: 			[(aBlock value: (array at: index))				ifTrue: [self removeIndex: index]				ifFalse: [index _ index + 1]]! !!OrderedCollection methodsFor: 'removing' stamp: 'ar 5/22/2000 12:19'!removeAt: index	| removed |	removed _ self at: index.	self removeIndex: index + firstIndex - 1.	^removed! !!OrderedCollection methodsFor: 'enumerating' stamp: 'sma 2/5/2000 15:22'!collect: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect the 	resulting values into a collection that is like me. Answer the new 	collection. Override superclass in order to use addLast:, not at:put:."	| newCollection |	newCollection _ self species new: self size.	firstIndex to: lastIndex do:		[:index |		newCollection addLast: (aBlock value: (array at: index))].	^ newCollection! !!OrderedCollection methodsFor: 'enumerating' stamp: 'sma 2/5/2000 15:13'!select: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect into	a new collection like the receiver, only those elements for which aBlock	evaluates to true."	| newCollection element |	newCollection _ self copyEmpty.	firstIndex to: lastIndex do:		[:index |		(aBlock value: (element _ array at: index))			ifTrue: [newCollection addLast: element]].	^ newCollection! !!OrderedCollection methodsFor: 'enumerating' stamp: 'di 8/31/1999 13:13'!with: otherCollection collect: twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with 	corresponding elements from this collection and otherCollection."	| result |	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].	result _ self species new: self size.	1 to: self size do:		[:index | result addLast: (twoArgBlock value: (self at: index)									value: (otherCollection at: index))].	^ result! !!OrderedCollection methodsFor: 'private' stamp: 'sma 5/12/2000 11:20'!find: oldObject	| index |	index _ firstIndex.	[index <= lastIndex and: [oldObject ~= (array at: index)]]		whileTrue: [index _ index + 1].	index <= lastIndex		ifTrue: [^ index]		ifFalse: [self errorNotFound: oldObject]! !!OrderedCollection methodsFor: 'private' stamp: 'ar 5/22/2000 12:17'!removeIndex: removedIndex	array 		replaceFrom: removedIndex 		to: lastIndex - 1 		with: array 		startingAt: removedIndex+1.	array at: lastIndex put: nil.	lastIndex _ lastIndex - 1.! !!OrderedCollection methodsFor: 'private' stamp: 'ar 4/16/1999 07:59'!resetTo: index	firstIndex _ index.	lastIndex _ firstIndex - 1! !!OrderedCollection class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 17:41'!new	^ self new: 10! !!OrderedCollection class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 17:42'!new: anInteger 	^ super new setCollection: (Array new: anInteger)! !I am a subclass of ImageReadWriter that reads Portable Network Graphics (PNG) images.Submitted by Duane Maxwell.!!PNGReadWriter methodsFor: 'accessing' stamp: 'jm 10/14/2003 16:49'!nextImage	filtersSeen _ Bag new.	globalDataChunk _ nil.	transparentPixelValue _ nil.	unknownChunks _ Set new.	stream reset.	(stream respondsTo: #binary) ifTrue: [ stream binary] .	stream skip: 8.	[stream atEnd] whileFalse: [		self processNextChunk.	].	chunk _ globalDataChunk.	chunk ifNotNil: [self processIDATChunk].	unknownChunks isEmpty ifFalse: [		"Transcript show: ' ',unknownChunks asSortedCollection asArray printString."	].	Debugging ifTrue: [		Transcript cr; show: 'form = ',form printString.		Transcript cr; show: 'colorType = ',colorType printString.		Transcript cr; show: 'interlaceMethod = ',interlaceMethod printString.		Transcript cr; show: 'filters = ',filtersSeen sortedCounts asArray printString.	].	^ form! !!PNGReadWriter methodsFor: 'accessing' stamp: 'DSM 3/24/2000 01:12'!understandsImageFormat	#(137 80 78 71 13 10 26 10) do: [ :byte |		stream next = byte ifFalse: [^ false]].	^ true! !!PNGReadWriter methodsFor: 'chunks' stamp: 'jm 12/9/2003 18:35'!processBackgroundChunk	| val red green blue max s |	colorType = 3 ifTrue: [		form fillColor: (palette at: chunk first + 1).		^ self].	max _ (2 raisedTo: bitsPerChannel) - 1.	s _ ReadStream on: chunk.	(colorType = 0 or: [colorType = 4]) ifTrue: [		val _ s uint16.		form fillColor: (Color gray: val / max).		^ self].	(colorType = 2 or: [colorType = 6]) ifTrue: [		red _ s uint16.		green _ s uint16.		blue _ s uint16.		form fillColor: (Color r: red/max g: green/max b: blue/max).		^ self]."====The bKGD chunk specifies a default background color to present the image against. Note that viewers are not bound to honor this chunk; a viewer can choose to use a different background.For color type 3 (indexed color), the bKGD chunk contains:	palette index: 1 byteThe value is the palette index of the color to be used as background.For color types 0 and 4 (grayscale, with or without alpha), bKGD contains:	gray: 2 bytes, range 0 .. (2^bitdepth)-1For consistency, 2 bytes are used regardless of the image bit depth. The value is the gray level to be used as background.For color types 2 and 6 (truecolor, with or without alpha), bKGD contains:	red: 2 bytes, range 0 .. (2^bitdepth)-1	green: 2 bytes, range 0 .. (2^bitdepth)-1	blue: 2 bytes, range 0 .. (2^bitdepth)-1For consistency, 2 bytes per sample are used regardless of the image bit depth. This is the RGB color to be used as background.When present, the bKGD chunk must precede the first IDAT chunk, and must follow the PLTE chunk, if any.==="! !!PNGReadWriter methodsFor: 'chunks' stamp: 'RAA 11/4/2000 17:00'!processIDATChunk	interlaceMethod = 0		ifTrue: [ self processNonInterlaced ]		ifFalse: [ self processInterlaced ]! !!PNGReadWriter methodsFor: 'chunks' stamp: 'jm 12/3/2003 11:37'!processIHDRChunk	| s |	s _ ReadStream on: chunk.	width _ s uint32.	height _ s uint32.	bitsPerChannel _ chunk at: 9.	colorType _ chunk at: 10.	"compression _ chunk at: 11." "TODO - validate compression"	"filterMethod _ chunk at: 12." "TODO - validate filterMethod"	interlaceMethod _ chunk at: 13. "TODO - validate interlace method"	(#(2 4 6) includes: colorType)		ifTrue: [			depth _ 32.			form _ Form extent: width@height depth: depth			].	(#(0 3) includes: colorType)		ifTrue: [			depth _ bitsPerChannel min: 8.			form _ ColorForm extent: width@height depth: depth.			colorType = 0 ifTrue: [ "grayscale"				form colors: (self grayColorsFor: depth).				]			].	bitsPerPixel _ (BPP at: colorType+1) at: bitsPerChannel highBit.	bytesPerScanline _ width * bitsPerPixel + 7 // 8.	rowSize _ form width * form depth + 31 >> 5.! !!PNGReadWriter methodsFor: 'chunks' stamp: 'RAA 11/6/2000 22:31'!processInterlaced	| z filter bytesPerPass startingCol colIncrement rowIncrement startingRow cx sc temp |	startingCol _ #(0 4 0 2 0 1 0 ).	colIncrement _ #(8 8 4 4 2 2 1 ).	rowIncrement _ #(8 8 8 4 4 2 2 ).	startingRow _ #(0 0 4 0 2 0 1 ).	z _ ZLibReadStream on: chunk from: 1 to: chunk size.	1 to: 7 do: [:pass |		(self doPass: pass)			ifTrue:				[cx _ colIncrement at: pass.				sc _ startingCol at: pass.				bytesPerPass _ width - sc + cx - 1 // cx * bitsPerPixel + 7 // 8.				prevScanline _ ByteArray new: bytesPerPass.				thisScanline _ ByteArray new: bytesPerScanline.				(startingRow at: pass)					to: height - 1					by: (rowIncrement at: pass)					do: [:y |						filter _ z next.						filtersSeen add: filter.						(filter isNil or: [(filter between: 0 and: 4) not])							ifTrue: [^ self].						thisScanline _ z next: bytesPerPass into: thisScanline startingAt: 1.						self filterScanline: filter count: bytesPerPass.						self copyPixels: y at: sc by: cx.						temp := prevScanline.						prevScanline := thisScanline.						thisScanline := temp.					]				]	].! !!PNGReadWriter methodsFor: 'chunks' stamp: 'RAA 11/4/2000 11:43'!processNextChunk	| length asciiType |	length _ self nextLong.	asciiType _ (self next: 4) asString.	chunk _ self next: length.	"crc _" self nextLong. "TODO - validate crc"	asciiType = 'IEND' ifTrue: [^self	"*should* be the last chunk"].	asciiType = 'sBIT' ifTrue: [^self	"could indicate unusual sample depth in original"].	asciiType = 'gAMA' ifTrue: [^self 	"indicates gamma correction value"].	asciiType = 'bKGD' ifTrue: [^self processBackgroundChunk].	asciiType = 'pHYs' ifTrue: [^self processPhysicalPixelChunk].	asciiType = 'tRNS' ifTrue: [^self processTransparencyChunk].	asciiType = 'IHDR' ifTrue: [^self processIHDRChunk].	asciiType = 'PLTE' ifTrue: [^self processPLTEChunk].	asciiType = 'IDAT' ifTrue: [		"---since the compressed data can span multiple		chunks, stitch them all together first. later,		if memory is an issue, we need to figure out how		to do this on the fly---"		globalDataChunk _ globalDataChunk ifNil: [chunk] ifNotNil:			[globalDataChunk,chunk].		^self	].	unknownChunks add: asciiType.! !!PNGReadWriter methodsFor: 'chunks' stamp: 'RAA 11/6/2000 22:42'!processNonInterlaced	| z filter temp |	z _ ZLibReadStream on: chunk from: 1 to: chunk size.	prevScanline _ ByteArray new: bytesPerScanline.	thisScanline := ByteArray new: bytesPerScanline.	0 to: height-1 do: [ :y |		filter _ (z next: 1) first.		filtersSeen add: filter.		(filter isNil or: [(filter between: 0 and: 4) not])			ifTrue: [^ self].		thisScanline _ z next: bytesPerScanline into: thisScanline startingAt: 1.		self filterScanline: filter count: bytesPerScanline.		self copyPixels: y.		temp := prevScanline.		prevScanline := thisScanline.		thisScanline := temp.		]! !!PNGReadWriter methodsFor: 'chunks' stamp: 'RAA 11/4/2000 11:13'!processPLTEChunk	| colorCount i |	colorCount _ chunk size // 3. "TODO - validate colorCount against depth"	palette _ Array new: colorCount.	0 to: colorCount-1 do: [ :index |		i _ index * 3 + 1.		palette at: index+1 put:			(Color r: (chunk at: i)/255 g: (chunk at: i+1)/255 b: (chunk at: i+2)/255)		].	(form isKindOf: ColorForm) ifTrue: [		form colors: palette	] ifFalse: [		self flag: #bob.		"palette for true color image!!!!"	].! !!PNGReadWriter methodsFor: 'chunks' stamp: 'RAA 11/5/2000 11:24'!processPhysicalPixelChunk	"Transcript show: '  PHYSICAL: ',chunk printString."! !!PNGReadWriter methodsFor: 'chunks' stamp: 'jm 12/9/2003 18:39'!processTransparencyChunk	| s red green blue |	s _ ReadStream on: chunk.	colorType = 0 ifTrue: [		transparentPixelValue _ s uint16.		^ self].	colorType = 2 ifTrue: [		red _ chunk at: 2.		green _ chunk at: 2.		blue _ chunk at: 2.		transparentPixelValue _ 16rFF00 + red << 8 + green << 8 + blue.		^ self].	colorType = 3 ifTrue: [		chunk withIndexDo: [:alpha :index |			palette at: index put: ((palette at: index) alpha: alpha / 255)].		^ self].! !!PNGReadWriter methodsFor: 'filtering' stamp: 'RAA 11/7/2000 09:43'!filterAverage: count	"Use the average of the pixel to the left and the pixel above as a predictor"	| delta |	delta _ bitsPerPixel // 8 max: 1.	1 to: delta do: [:i |		thisScanline at: i put: ((thisScanline at: i) + ((prevScanline at: i) // 2) bitAnd: 255)].	delta + 1 to: count do: [:i |		thisScanline at: i put:			((thisScanline at: i)			+ ((prevScanline at: i)			+ (thisScanline at: i - delta) // 2) bitAnd: 255)]! !!PNGReadWriter methodsFor: 'filtering' stamp: 'DSM 3/25/2000 17:54'!filterHorizontal: count	"Use the pixel to the left as a predictor"	| delta |	delta _ bitsPerPixel // 8 max: 1.	delta+1 to: count do: [ :i |		thisScanline at: i put: (((thisScanline at: i) +(thisScanline at: i-delta)) bitAnd: 255) ]! !!PNGReadWriter methodsFor: 'filtering' stamp: 'DSM 3/25/2000 17:55'!filterNone: count! !!PNGReadWriter methodsFor: 'filtering' stamp: 'RAA 11/7/2000 09:45'!filterPaeth: count	"Select one of (the pixel to the left, the pixel above and the pixel to above left) to	predict the value of this pixel"	| delta |	delta _ bitsPerPixel // 8 max: 1.	1 to: delta do: [ :i |		thisScanline at: i put:			(((thisScanline at: i) + (prevScanline at: i)) bitAnd: 255)].	delta+1 to: count do: [ :i |		thisScanline			at: i			put: (((thisScanline at: i) + (self				paethPredictLeft: (thisScanline at: i-delta)				above: (prevScanline at: i)				aboveLeft: (prevScanline at: i-delta)))					bitAnd: 255)]! !!PNGReadWriter methodsFor: 'filtering' stamp: 'eat 9/11/2000 20:08'!filterScanline: filterType count: count	self		perform: (			#(filterNone: filterHorizontal: filterVertical: filterAverage: filterPaeth:)				at: filterType+1)		with: count.! !!PNGReadWriter methodsFor: 'filtering' stamp: 'DSM 3/25/2000 17:54'!filterVertical: count	"Use the pixel above as a predictor"	1 to: count do: [ :i |		thisScanline at: i put: (((thisScanline at: i) +(prevScanline at: i)) bitAnd: 255) ]! !!PNGReadWriter methodsFor: 'filtering' stamp: 'eat 9/11/2000 20:05'!paethPredictLeft: a above: b aboveLeft: c	"Predicts the value of a pixel based on nearby pixels, based onPaeth (GG II, 1991)"	| pa pb pc |	pa _ b > c ifTrue: [b - c] ifFalse: [c - b].	pb _ a > c ifTrue: [a - c] ifFalse: [c - a].	pc _ a + b - c - c.	pc < 0 ifTrue: [		pc := pc * -1].	((pa <= pb) and: [pa <= pc]) ifTrue: [^ a].	(pb <= pc) ifTrue: [^ b].	^ c! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'DSM 3/26/2000 21:32'!copyPixels: y	"Handle non-interlaced pixels of supported colorTypes"	| s |	s _ #(copyPixelsGray: nil copyPixelsRGB: copyPixelsIndexed:		  copyPixelsGrayAlpha: nil copyPixelsRGBA:) at: colorType+1.	self perform: s asSymbol with: y! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 16:08'!copyPixels: y at: startX by: incX	"Handle interlaced pixels of supported colorTypes"	| s |	s _ #(copyPixelsGray:at:by: nil copyPixelsRGB:at:by: copyPixelsIndexed:at:by:		  copyPixelsGrayAlpha:at:by: nil copyPixelsRGBA:at:by:) at: colorType+1.	self perform: s asSymbol with: y with: startX with: incX! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'jm 6/21/2003 11:23'!copyPixelsGray: y 	"Handle non-interlaced grayscale color mode (colorType = 0)"	| blitter pixPerByte mask shifts pixelNumber rawByte pixel transparentIndex |	blitter _ BitBlt bitPokerToForm: form.	transparentIndex _ form colors size.	bitsPerChannel = 16		ifTrue: [0				to: width - 1				do: [:x | blitter pixelAt: x @ y put: 255							- (thisScanline at: x << 1 + 1)].			^ self]		ifFalse: [bitsPerChannel = 8				ifTrue: [1						to: width						do: [:x | blitter								pixelAt: x - 1 @ y								put: (thisScanline at: x)].					^ self].			bitsPerChannel = 1				ifTrue: [pixPerByte _ 8.					mask _ 1.					shifts _ #(7 6 5 4 3 2 1 0 )].			bitsPerChannel = 2				ifTrue: [pixPerByte _ 4.					mask _ 3.					shifts _ #(6 4 2 0 )].			bitsPerChannel = 4				ifTrue: [pixPerByte _ 2.					mask _ 15.					shifts _ #(4 0 )].			pixelNumber _ 0.			0 to: width - 1 do: [:x | 				rawByte _ thisScanline at: pixelNumber // pixPerByte + 1.				pixel _ rawByte							>> (shifts at: pixelNumber \\ pixPerByte + 1) bitAnd: mask.				pixel = transparentPixelValue ifTrue: [pixel _ transparentIndex].				blitter pixelAt: x @ y put: pixel.				pixelNumber _ pixelNumber + 1			]		]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'jm 6/21/2003 11:24'!copyPixelsGray: y at: startX by: incX	"Handle interlaced grayscale color mode (colorType = 0)"	| b offset bits w pixel mask blitter pixelNumber pixPerByte rawByteshifts |	bitsPerChannel = 16		ifTrue: [			b _ BitBlt bitPokerToForm: form.			startX to: width-1 by: incX do: [ :x |				b pixelAt: x@y put: 255 - (thisScanline at: (x//incX<<1)+1).				].			^ self			].	offset _ y*rowSize+1.	bits _ form bits.	bitsPerChannel = 8 ifTrue: [		startX to: width-1 by: incX do: [ :x |			w _ offset + (x>>2).			b _ 3- (x \\ 4) * 8.			pixel _ (thisScanline at: x // incX + 1)<<b.			mask _ (255<<b) bitInvert32.			bits at: w put: (((bits at: w) bitAnd: mask) bitOr: pixel)		].		^ self	].	bitsPerChannel = 1 ifTrue: [		pixPerByte _ 8.		mask _ 1.		shifts _ #(7 6 5 4 3 2 1 0).	].	bitsPerChannel = 2 ifTrue: [		pixPerByte _ 4.		mask _ 3.		shifts _ #(6 4 2 0).	].	bitsPerChannel = 4 ifTrue: [		pixPerByte _ 2.		mask _ 15.		shifts _ #(4 0).	].	blitter _ BitBlt bitPokerToForm: form.	pixelNumber _ 0.	startX to: width-1 by: incX do: [ :x |		rawByte _ thisScanline at: (pixelNumber // pixPerByte) + 1.		pixel _ (rawByte >> (shifts at: (pixelNumber \\ pixPerByte) + 1)) bitAnd: mask.		blitter pixelAt: (x@y) put: pixel.		pixelNumber _ pixelNumber + 1.	].! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'jm 6/21/2003 11:23'!copyPixelsGrayAlpha: y	"Handle non-interlaced grayscale with alpha color mode (colorType = 4)"	| i pixel gray b |	b _ BitBlt bitPokerToForm: form.	bitsPerChannel = 8		ifTrue: [			0 to: width-1 do: [ :x |				i _ (x << 1) + 1.				gray _ thisScanline at: i.				pixel _ ((thisScanline at: i+1)<<24) + (gray<<16) + (gray<<8) + gray.				b pixelAt: x@y put: pixel.				]			]		ifFalse: [			0 to: width-1 do: [ :x |				i _ (x << 2) + 1.				gray _ thisScanline at: i.				pixel _ ((thisScanline at: i+2)<<24) + (gray<<16) + (gray<<8) + gray.				b pixelAt: x@y put: pixel.				]			]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'jm 6/21/2003 11:23'!copyPixelsGrayAlpha: y at: startX by: incX	"Handle interlaced grayscale with alpha color mode (colorType = 4)"	| i pixel gray b |	b _ BitBlt bitPokerToForm: form.	bitsPerChannel = 8		ifTrue: [			startX to: width-1 by: incX do: [ :x |				i _ (x // incX << 1) + 1.				gray _ thisScanline at: i.				pixel _ ((thisScanline at: i+1)<<24) + (gray<<16) + (gray<<8) + gray.				b pixelAt: x@y put: pixel.				]			]		ifFalse: [			startX to: width-1 by: incX do: [ :x |				i _ (x // incX << 2) + 1.				gray _ thisScanline at: i.				pixel _ ((thisScanline at: i+2)<<24) + (gray<<16) + (gray<<8) + gray.				b pixelAt: x@y put: pixel.				]			]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'jm 6/21/2003 11:23'!copyPixelsIndexed: y	"Handle non-interlaced indexed color mode (colorType = 3)"	| blitter pixPerByte mask shifts pixelNumber rawByte pixel |	blitter _ BitBlt bitPokerToForm: form.	bitsPerChannel = 8		ifTrue:			[1 to: width do: [:x | blitter pixelAt: x - 1 @ y put: (thisScanline at: x)].			^ self].	bitsPerChannel = 1		ifTrue:			[pixPerByte _ 8.			mask _ 1.			shifts _ #(7 6 5 4 3 2 1 0 )].	bitsPerChannel = 2		ifTrue:			[pixPerByte _ 4.			mask _ 3.			shifts _ #(6 4 2 0 )].	bitsPerChannel = 4		ifTrue:			[pixPerByte _ 2.			mask _ 15.			shifts _ #(4 0 )].	pixelNumber _ 0.	0 to: width - 1 do:		[:x |		rawByte _ thisScanline at: pixelNumber // pixPerByte + 1.		pixel _ rawByte >> (shifts at: pixelNumber \\ pixPerByte + 1) bitAnd: mask.		blitter pixelAt: x @ y put: pixel.		pixelNumber _ pixelNumber + 1]! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'jm 6/21/2003 11:23'!copyPixelsIndexed: y at: startX by: incX	"Handle interlaced indexed color mode (colorType = 3)"	| offset b bits w pixel mask pixPerByte shifts blitter pixelNumber rawByte |	offset _ y*rowSize+1.	bits _ form bits.	bitsPerChannel = 8		ifTrue: [			startX to: width-1 by: incX do: [ :x |				w _ offset + (x>>2).				b _ 3 - (x \\ 4) * 8.				pixel _ (thisScanline at: x // incX + 1)<<b.				mask _ (255<<b) bitInvert32.				bits at: w put: (((bits at: w) bitAnd: mask) bitOr: pixel)].			^ self ].	bitsPerChannel = 1 ifTrue: [		pixPerByte _ 8.		mask _ 1.		shifts _ #(7 6 5 4 3 2 1 0).	].	bitsPerChannel = 2 ifTrue: [		pixPerByte _ 4.		mask _ 3.		shifts _ #(6 4 2 0).	].	bitsPerChannel = 4 ifTrue: [		pixPerByte _ 2.		mask _ 15.		shifts _ #(4 0).	].	blitter _ BitBlt bitPokerToForm: form.	pixelNumber _ 0.	startX to: width-1 by: incX do: [ :x |		rawByte _ thisScanline at: (pixelNumber // pixPerByte) + 1.		pixel _ (rawByte >> (shifts at: (pixelNumber \\ pixPerByte) + 1)) bitAnd: mask.		blitter pixelAt: (x@y) put: pixel.		pixelNumber _ pixelNumber + 1.	].! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/7/2000 09:30'!copyPixelsRGB: y	"Handle non-interlaced RGB color mode (colorType = 2)"	| i pixel tempForm tempBits |	tempForm _ Form extent: width@1 depth: 32.	tempBits _ tempForm bits.	pixel := LargePositiveInteger new: 4.	pixel at: 4 put: 16rFF.	bitsPerChannel = 8 ifTrue: [		i := 1.		1 to: width do: [ :x |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: x put: pixel.			i _ i + 3.		]	] ifFalse: [		i := 1.		1 to: width do: [ :x |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: x put: pixel.			i _ i + 6.		]	].	transparentPixelValue ifNotNil: [		1 to: width do: [ :x |			(tempBits at: x) = transparentPixelValue ifTrue: [				tempBits at: x put: 0.			].		].	].	tempForm displayOn: form at: 0@y rule: Form paint.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/5/2000 11:16'!copyPixelsRGB: y at: startX by: incX	"Handle interlaced RGB color mode (colorType = 2)"	| i pixel tempForm tempBits xx loopsToDo |	tempForm _ Form extent: width@1 depth: 32.	tempBits _ tempForm bits.	pixel := LargePositiveInteger new: 4.	pixel at: 4 put: 16rFF.	loopsToDo _ width - startX + incX - 1 // incX.	bitsPerChannel = 8 ifTrue: [		i _ (startX // incX * 3) + 1.		xx _ startX+1.		1 to: loopsToDo do: [ :j |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: xx put: pixel.			i _ i + 3.			xx _ xx + incX.		]	] ifFalse: [		i _ (startX // incX * 6) + 1.		xx _ startX+1.		1 to: loopsToDo do: [ :j |			pixel				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: xx put: pixel.			i _ i + 6.			xx _ xx + incX.		].	].	transparentPixelValue ifNotNil: [		startX to: width-1 by: incX do: [ :x |			(tempBits at: x+1) = transparentPixelValue ifTrue: [				tempBits at: x+1 put: 0.			].		].	].	tempForm displayOn: form at: 0@y rule: Form paint.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 16:20'!copyPixelsRGBA: y	"Handle non-interlaced RGBA color modes (colorType = 6)"	| i pixel tempForm tempBits |	tempForm _ Form extent: width@1 depth: 32.	tempBits _ tempForm bits.	pixel := LargePositiveInteger new: 4.	bitsPerChannel = 8 ifTrue: [		i := -3.		0 to: width-1 do: [ :x |			i := i + 4.			pixel at: 4 put: (thisScanline at: i+3);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: x+1 put: pixel.		]	] ifFalse: [		i := -7.		0 to: width-1 do: [ :x |			i := i + 8.			pixel at: 4 put: (thisScanline at: i+6);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: x+1 put: pixel.		]	].	tempForm displayOn: form at: 0@y rule: Form paint.! !!PNGReadWriter methodsFor: 'pixel copies' stamp: 'RAA 11/4/2000 18:14'!copyPixelsRGBA: y at: startX by: incX	"Handle interlaced RGBA color modes (colorType = 6)"	| i pixel tempForm tempBits |	tempForm _ Form extent: width@1 depth: 32.	tempBits _ tempForm bits.	pixel := LargePositiveInteger new: 4.	bitsPerChannel = 8 ifTrue: [		i _ (startX // incX << 2) + 1.		startX to: width-1 by: incX do: [ :x |			pixel at: 4 put: (thisScanline at: i+3);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+1);				at: 1 put: (thisScanline at: i+2).			tempBits at: x+1 put: pixel.			i _ i + 4.		]	] ifFalse: [		i _ (startX // incX << 3) +1.		startX to: width-1 by: incX do: [ :x |			pixel at: 4 put: (thisScanline at: i+6);				at: 3 put: (thisScanline at: i);				at: 2 put: (thisScanline at: i+2);				at: 1 put: (thisScanline at: i+4).			tempBits at: x+1 put: pixel.			i _ i + 8.		].	].	tempForm displayOn: form at: 0@y rule: Form paint.! !!PNGReadWriter methodsFor: 'miscellaneous' stamp: 'DSM 4/27/2000 13:09'!doPass: pass	"Certain interlace passes are skipped with certain small imagedimensions"	pass = 1 ifTrue: [ ^ true ].	((width = 1) and: [height = 1]) ifTrue: [ ^ false ].	pass = 2 ifTrue: [ ^ width >= 5 ].	pass = 3 ifTrue: [ ^ height >= 5 ].	pass = 4 ifTrue: [ ^ (width >=3 ) or: [height >= 5] ].	pass = 5 ifTrue: [ ^ height >=3 ].	pass = 6 ifTrue: [ ^ width >=2 ].	pass = 7 ifTrue: [ ^ height >=2 ].! !!PNGReadWriter methodsFor: 'miscellaneous' stamp: 'RAA 11/4/2000 12:07'!grayColorsFor: d	"return a color table for a gray image"	palette _ Array new: 1<<d.	d = 1 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: Color white.		^ palette,{Color transparent}		].	d = 2 ifTrue: [		palette at: 1 put: Color black.		palette at: 2 put: (Color gray: 0.3333).		palette at: 3 put: (Color gray: 0.6667).		palette at: 4 put: Color white.		^ palette,{Color transparent}.		].	d = 4 ifTrue: [		0 to: 15 do: [ :g |			palette at: g+1 put: (Color gray: (g/15) asFloat) ].		^ palette,{Color transparent}		].	d = 8 ifTrue: [		0 to: 255 do: [ :g |			palette at: g+1 put: (Color gray: (g/255) asFloat) ].		^ palette		"??transparent??"		].! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'RAA 11/7/2000 09:22'!createAFormFrom: data	| error f |	error _ ''.	f _ [		self formFromStream: (RWBinaryOrTextStream with: data)	] ifError: [ :a :b |		error _ a printString,'  ',b printString.		(StringMorph contents: error) color: Color red; imageForm	].	^{f. error}! !!PNGReadWriter class methodsFor: 'as yet unclassified' stamp: 'jm 10/14/2003 16:50'!initialize	"self initialize"	Debugging _ false.	BPP _ {	#(1 2 4 8 16).			#(0 0 0 0 0).			#(0 0 0 24 48).			#(1 2 4 8 0).			#(0 0 0 16 32).			#(0 0 0 0 0).			#(0 0 0 32 64).			#(0 0 0 0 0) }.	BlockHeight _ #(8 8 4 4 2 2 1).	BlockWidth _ #(8 4 4 2 2 1 1).! !Post Office Protocol.  This is used to download email over the network, usually from an intermittent connection.  To see how to use it, see POPSocket classe>>example.!!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:14'!addProgressObserver: anObserver	"progress will be sent to anObserver.  anObserver should respond to show:, endEntry, cr....  Transcript things"	progressObservers add: anObserver! !!POPSocket methodsFor: 'initialization' stamp: 'ar 5/5/1999 23:25'!initialize: socketType	super initialize: socketType.	progressObservers _ IdentitySet new.! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:10'!password: aString	"set the password to use"	password _ aString ! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:22'!serverName: aString	"set the server name to connect to"	serverName _ aString! !!POPSocket methodsFor: 'initialization' stamp: 'ls 9/7/1998 05:10'!userName: aString	"set the username to use"	userName _ aString! !!POPSocket methodsFor: 'low-level protocol' stamp: 'jm 10/14/1998 12:51'!connectToPOP	"connect to the POP server"	| address response |	Socket initializeNetwork.	address _ NetNameResolver addressForName: serverName timeout: 15.	address = nil ifTrue: [		self error: 'Could not find host address'].	"connect the socket"	self connectTo: address port: 110.	(self waitForConnectionUntil: POPSocket standardDeadline) ifFalse: [		self close.		self reportToObservers: 'failed to connect to server'.		^false ].	"get a hello message"	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close.  ^false ].	"login"	self sendCommand: 'USER ', userName.	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close. ^false ].	self sendCommand: 'PASS ', password.	self reportToObservers: (response _ self getResponse).	(response beginsWith: '+') ifFalse: [ self close. ^false ].	^true! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 01:55'!deleteAllMessages	"delete all messages"	1 to: self numMessages do: [ :num |		self deleteMessage: num ]! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/7/1998 06:07'!deleteMessage: num	"delete the numbered message"	self sendCommand: 'DELE ', num printString.	self reportToObservers: self getResponse.! !!POPSocket methodsFor: 'low-level protocol' stamp: 'jm 10/2/1998 16:05'!disconnectFromPOP	"Send a QUIT message, then disconnect."	self isValid ifFalse: [^ self].  "already closed"	self reportToObservers: 'closing connection'.	numMessages _ nil.	self sendCommand: 'QUIT'.	self reportToObservers: self getResponse.	self closeAndDestroy.! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 01:54'!messagesDo: aBlock	"perform aBlock on each message text"	| thisMessage |	1 to: self numMessages do: [ :num |		thisMessage _ self retrieveMessage: num.		aBlock value: thisMessage.	].	! !!POPSocket methodsFor: 'low-level protocol' stamp: 'mdr 2/16/1999 12:53'!numMessages	"Query the server and answer the number of messages that are in the user's mailbox."	| response answerString |	numMessages ifNotNil: [^ numMessages].  "cached result of earlier query"	self sendCommand: 'STAT'.	response _ self getResponse.	self reportToObservers: response.	(response beginsWith: '+OK') ifFalse: [^ 0].  "error"	answerString _ (response findTokens: Character separators) second.	"NB: It is important to cache the result so that all operations, especially delete and deleteAll, are done on the same set of messages"	numMessages _ answerString asNumber asInteger.	"cache the result"	^ numMessages! !!POPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/7/1998 06:04'!retrieveMessage: number	"retrieve the numbered message"	| response |	self sendCommand: 'RETR ', number printString.	response _ self getResponse.	self reportToObservers: response.	(response beginsWith: '+OK') ifFalse: [		self error: 'error: ', response ].	^self getMultilineResponse.! !!POPSocket methodsFor: 'private' stamp: 'ls 9/10/1998 19:57'!reportToObservers: aString	"send aString to all observers"	progressObservers do: [ :observer |		observer show: aString.		aString last = Character cr ifFalse: [ observer show: String cr ]].! !!POPSocket class methodsFor: 'as yet unclassified' stamp: 'ls 9/10/1998 19:44'!example	"POPSocket example"	"download a user's messages into an OrderedCollection and inspect the OrderedCollection"	| ps messages |	ps _ POPSocket new.	ps serverName: (FillInTheBlank request: 'POP server').	ps userName: (FillInTheBlank request: 'POP username').	ps password: (FillInTheBlank request: 'POP password').	ps addProgressObserver: Transcript.	messages _ OrderedCollection new.	ps connectToPOP.	ps messagesDo: [ :messageText |		messages add: messageText ].	ps disconnectFromPOP.	messages inspect.! !!POPSocket class methodsFor: 'as yet unclassified' stamp: 'jm 10/26/2002 09:59'!example2	"POPSocket example2"	"Download my messages into an OrderedCollection and inspect the OrderedCollection."	| ps messages |	ps _ POPSocket new.	ps serverName: 'pop.earthlink.net'.	ps userName: 'JohnMaloney'.	ps password: (FillInTheBlank request: 'POP password').	ps addProgressObserver: Transcript.	messages _ OrderedCollection new.	ps connectToPOP.	ps messagesDo: [:messageText |messages add: messageText ].	ps disconnectFromPOP.	messages inspect.! !I represent displayable text that has been decoraged with margin alignment, line leading, and tab settings.!!Paragraph methodsFor: 'accessing' stamp: 'ar 5/18/2000 18:34'!replaceFrom: start to: stop with: aText displaying: displayBoolean	"Replace the receiver's text starting at position start, stopping at stop, by 	the characters in aText. It is expected that most requirements for 	modifications to the receiver will call this code. Certainly all cut's or 	paste's." 	| compositionScanner obsoleteLines obsoleteLastLine firstLineIndex lastLineIndex	startLine stopLine replacementRange visibleRectangle startIndex newLine done	newStop obsoleteY newY moveRectangle |	text replaceFrom: start to: stop with: aText.		"Update the text."	lastLine = 0 ifTrue:		["if lines have never been set up, measure them and display		all the lines falling in the visibleRectangle"		self composeAll.		displayBoolean ifTrue: [^ self displayLines: (1 to: lastLine)]].	"save -- things get pretty mashed as we go along"	obsoleteLines _ lines copy.	obsoleteLastLine _ lastLine.	"find the starting and stopping lines"	firstLineIndex _ startLine _ self lineIndexOfCharacterIndex: start.	stopLine _ self lineIndexOfCharacterIndex: stop.	"how many characters being inserted or deleted		-- negative if aText size is < characterInterval size."	replacementRange _ aText size - (stop - start + 1).	"Give ourselves plenty of elbow room."	compositionRectangle _ compositionRectangle withHeight: (textStyle lineGrid * 9999).	"build a boundingBox of the actual screen space in question -- we'll need it later"	visibleRectangle _ (clippingRectangle intersect: compositionRectangle)							intersect: destinationForm boundingBox.	compositionScanner _ CompositionScanner new forParagraph: self.		"Initialize a scanner."	"If the starting line is not also the first line, then measuring must commence from line preceding the one in which characterInterval start appears.  For example, deleting a line with only a carriage return may move characters following the deleted portion of text into the line preceding the deleted line."	startIndex _ (lines at: firstLineIndex) first.	startLine > 1		ifTrue: 	[newLine _ compositionScanner composeLine: startLine - 1						fromCharacterIndex: (lines at: startLine - 1) first						inParagraph: self.				(lines at: startLine - 1) = newLine					ifFalse:	["start in line preceding the one with the starting character"							startLine _ startLine - 1.							self lineAt: startLine put: newLine.							startIndex _ newLine last + 1]].	startIndex > text size ifTrue:		["nil lines after a deletion -- remeasure last line below"		self trimLinesTo: (firstLineIndex - 1 max: 0).		text size = 0 ifTrue:			["entire text deleted -- clear visibleRectangle and return."			displayBoolean ifTrue: [destinationForm fill: visibleRectangle rule: rule fillColor: self backgroundColor].			self updateCompositionHeight.			^self]].	"Now we really get to it."	done _ false.	lastLineIndex _ stopLine.	[done or: [startIndex > text size]]		whileFalse: 		[self lineAt: firstLineIndex put:			(newLine _ compositionScanner composeLine: firstLineIndex							fromCharacterIndex: startIndex inParagraph: self).		[(lastLineIndex > obsoleteLastLine			or: ["no more old lines to compare with?"				newLine last <					(newStop _ (obsoleteLines at: lastLineIndex) last + replacementRange)])			  	or: [done]]			whileFalse: 			[newStop = newLine last				ifTrue:	["got the match"						"get source and dest y's for moving the unchanged lines"						obsoleteY _ self topAtLineIndex: lastLineIndex + 1									using: obsoleteLines and: obsoleteLastLine.						newY _ self topAtLineIndex: firstLineIndex + 1.						stopLine _ firstLineIndex.						done _ true.							"Fill in the new line vector with the old unchanged lines.							Update their starting and stopping indices on the way."						((lastLineIndex _ lastLineIndex + 1) to: obsoleteLastLine) do:							[:upDatedIndex | 							self lineAt: (firstLineIndex _ firstLineIndex + 1) 								put: ((obsoleteLines at: upDatedIndex)							  		slide: replacementRange)].							"trim off obsolete lines, if any"						self trimLinesTo: firstLineIndex]				ifFalse:	[lastLineIndex _ lastLineIndex + 1]].		startIndex _ newLine last + 1.		firstLineIndex _ firstLineIndex + 1].	"Now the lines are up to date -- Whew!!.  What remains is to move	the 'unchanged' lines and display those which have changed."	displayBoolean   "Not much to do if not displaying"		ifFalse: [^ self updateCompositionHeight].	startIndex > text size ifTrue:		["If at the end of previous lines simply display lines from the line in		which the first character of the replacement occured through the		end of the paragraph."		self updateCompositionHeight.		self displayLines:			(startLine to: (stopLine _ firstLineIndex min: lastLine)).		destinationForm  "Clear out area at the bottom"			fill: ((visibleRectangle left @ (self topAtLineIndex: lastLine + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)			rule: rule fillColor: self backgroundColor]		ifFalse:		[newY ~= obsoleteY ifTrue:			["Otherwise first move the unchanged lines within			the visibleRectangle with a good old bitblt."			moveRectangle _				visibleRectangle left @ (obsoleteY max: visibleRectangle top)					corner: visibleRectangle corner.			destinationForm copyBits: moveRectangle from: destinationForm				at: moveRectangle origin + (0 @ (newY-obsoleteY))				clippingBox: visibleRectangle				rule: Form over fillColor: nil].		"Then display the altered lines."		self displayLines: (startLine to: stopLine).		newY < obsoleteY			ifTrue:			[(self topAtLineIndex: obsoleteLastLine+1 using: obsoleteLines and: obsoleteLastLine) > visibleRectangle bottom				ifTrue:				["A deletion may have 'pulled' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle bottom - (obsoleteY - newY))						to: (self lineIndexOfTop: visibleRectangle bottom))].			"Clear out obsolete material at the bottom of the visibleRectangle."			destinationForm				fill: ((visibleRectangle left @ ((self bottomAtLineIndex: lastLine) + 1)						extent: visibleRectangle extent)					intersect: visibleRectangle)  "How about just corner: ??"				rule: rule fillColor: self backgroundColor].		(newY > obsoleteY and: [obsoleteY < visibleRectangle top])			ifTrue:				["An insertion may have 'pushed' previously undisplayed lines				into the visibleRectangle.  If so, display them."				self displayLines:					((self lineIndexOfTop: visibleRectangle top)						to: (self lineIndexOfTop: visibleRectangle top + (newY-obsoleteY)))].		self updateCompositionHeight]! !!Paragraph methodsFor: 'accessing' stamp: 'sw 10/29/1999 18:11'!stringAtLineNumber: aNumber	(aNumber > lastLine or: [aNumber < 1]) ifTrue: [^ nil].	^ (text string copyFrom: (lines at: aNumber) first to: (lines at: aNumber) last) copyWithout: Character cr! !!Paragraph methodsFor: 'display box access' stamp: 'jm 6/15/2003 18:21'!computeBoundingBox	^ offset extent: compositionRectangle extent! !!Paragraph methodsFor: 'composition' stamp: 'ar 5/18/2000 18:34'!composeAll	"Compose a collection of characters into a collection of lines."	| startIndex stopIndex lineIndex maximumRightX compositionScanner |	lines _ Array new: 32.	lastLine _ 0.	maximumRightX _ 0.	text size = 0		ifTrue:			[compositionRectangle _ compositionRectangle withHeight: 0.			^maximumRightX].	startIndex _ lineIndex _ 1.	stopIndex _ text size.	compositionScanner _ CompositionScanner new forParagraph: self.	[startIndex > stopIndex] whileFalse: 		[self lineAt: lineIndex 				put: (compositionScanner composeLine: lineIndex 										fromCharacterIndex: startIndex 										inParagraph: self).		 maximumRightX _ compositionScanner rightX max: maximumRightX.		 startIndex _ (lines at: lineIndex) last + 1.		 lineIndex _ lineIndex + 1].	self updateCompositionHeight.	self trimLinesTo: lineIndex - 1.	^ maximumRightX! !!Paragraph methodsFor: 'character location' stamp: 'ar 5/18/2000 18:33'!characterBlockAtPoint: aPoint 	"Answer a CharacterBlock for characters in the text at point aPoint. It is 	assumed that aPoint has been transformed into coordinates appropriate to 	the receiver's destinationForm rectangle and the compositionRectangle."	^CharacterBlockScanner new characterBlockAtPoint: aPoint in: self! !!Paragraph methodsFor: 'character location' stamp: 'ar 5/18/2000 18:33'!characterBlockForIndex: targetIndex 	"Answer a CharacterBlock for character in the text at targetIndex. The 	coordinates in the CharacterBlock will be appropriate to the intersection 	of the destinationForm rectangle and the compositionRectangle."	^CharacterBlockScanner new characterBlockForIndex: targetIndex in: self! !!Paragraph methodsFor: 'character location' stamp: 'di 10/5/1998 12:59'!defaultCharacterBlock	^ CharacterBlock new stringIndex: 1 text: text			topLeft: compositionRectangle topLeft extent: 0 @ 0! !!Paragraph methodsFor: 'selecting' stamp: 'jm 5/29/2003 18:02'!caretFormForDepth: depth	"Return a caret form for the given depth."	"(Paragraph new caretFormForDepth: Display depth) displayOn: Display at: 0@0 rule: Form reverse"	| box f bb map |	box _ CaretForm boundingBox.	f _ Form extent: box extent depth: depth.	map _ (Color cachedColormapFrom: CaretForm depth to: depth) copy.	map at: 1 put: (Color transparent pixelValueForDepth: depth).	map at: 2 put: (Color quickHighLight: depth) first.  "pixel value for reversing"	bb _ BitBlt toForm: f.	bb		sourceForm: CaretForm;		sourceRect: box;		destOrigin: 0@0;		colorMap: map; 		combinationRule: Form over;		copyBits.	^ f! !!Paragraph methodsFor: 'selecting' stamp: 'sw 12/7/1999 12:26'!clickAt: clickPoint for: model controller: aController	"Give sensitive text a chance to fire.  Display flash: (100@100 extent: 100@100)."	| startBlock action range box boxes |	action _ false.	startBlock _ self characterBlockAtPoint: clickPoint.	(text attributesAt: startBlock stringIndex forStyle: textStyle) 		do: [:att | att mayActOnClick ifTrue:				[range _ text rangeOf: att startingAt: startBlock stringIndex forStyle: textStyle.				boxes _ self selectionRectsFrom: (self characterBlockForIndex: range first) 							to: (self characterBlockForIndex: range last).				box _ boxes detect: [:each | each containsPoint: clickPoint]							ifNone: [^ action].				Utilities awaitMouseUpIn: box repeating: []					ifSucceed: [aController terminateAndInitializeAround:								[(att actOnClickFor: model) ifTrue: [action _ true]]]]].	^ action! !!Paragraph methodsFor: 'selecting' stamp: 'jm 7/1/1999 12:31'!hiliteRect: rect	| highlightColor |	highlightColor _ Color quickHighLight: destinationForm depth.	rect ifNotNil: [		destinationForm			fill: rect			rule: Form reverse			fillColor: highlightColor.		"destinationForm			fill: (rect translateBy: 1@1)			rule: Form reverse			fillColor: highlightColor" ].! !!Paragraph methodsFor: 'private' stamp: 'ar 5/18/2000 18:34'!displayLines: linesInterval affectedRectangle: affectedRectangle	"This is the first level workhorse in the display portion of the TextForm routines.	It checks to see which lines in the interval are actually visible, has the	CharacterScanner display only those, clears out the areas in which display will	occur, and clears any space remaining in the visibleRectangle following the space	occupied by lastLine."	| lineGrid topY firstLineIndex lastLineIndex lastLineIndexBottom |	"Save some time by only displaying visible lines"	firstLineIndex _ self lineIndexOfTop: affectedRectangle top.	firstLineIndex < linesInterval first ifTrue: [firstLineIndex _ linesInterval first].	lastLineIndex _ self lineIndexOfTop: affectedRectangle bottom - 1.	lastLineIndex > linesInterval last ifTrue:			[linesInterval last > lastLine		 		ifTrue: [lastLineIndex _ lastLine]		  		ifFalse: [lastLineIndex _ linesInterval last]].	lastLineIndexBottom _ (self bottomAtLineIndex: lastLineIndex).	((Rectangle 		origin: affectedRectangle left @ (topY _ self topAtLineIndex: firstLineIndex) 		corner: affectedRectangle right @ lastLineIndexBottom)	  intersects: affectedRectangle)		ifTrue: [ " . . . (skip to clear-below if no lines displayed)"				DisplayScanner new					displayLines: (firstLineIndex to: lastLineIndex)					in: self clippedBy: affectedRectangle].	lastLineIndex = lastLine ifTrue: 		 [destinationForm  "Clear out white space below last line"		 	fill: (affectedRectangle left @ (lastLineIndexBottom max: affectedRectangle top)				corner: affectedRectangle bottomRight)		 	rule: rule fillColor: self backgroundColor]! !I am a Controller for editing a Paragraph. I am a kind of ScrollController, so that more text can be created for the Paragraph than can be viewed on the screen. Editing messages are sent by issuing commands from a yellow button menu or from keys on the keyboard. My instances keep control as long as the cursor is within the view when the red or yellow mouse button is pressed; they give up control if the blue button is pressed.!!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 11/30/97 10:13'!resetState 	"Establish the initial conditions for editing the paragraph: place caret 	before first character, set the emphasis to that of the first character,	and save the paragraph for purposes of canceling."	startBlock _ paragraph defaultCharacterBlock.	stopBlock _ startBlock copy.	beginTypeInBlock _ nil.	UndoInterval _ otherInterval _ 1 to: 0.	self setEmphasisHere.	selectionShowing _ false.	initialText _ paragraph text copy! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 5/15/2000 13:51'!stateArray	^ {ChangeText.		FindText.		UndoInterval.		UndoMessage.		UndoParagraph.		UndoSelection.		Undone.		self selectionInterval.		self startOfTyping.		emphasisHere}! !!ParagraphEditor methodsFor: 'initialize-release' stamp: 'di 10/5/1998 17:03'!stateArrayPut: stateArray	| sel |	ChangeText _ stateArray at: 1.	FindText _ stateArray at: 2.	UndoInterval _ stateArray at: 3.	UndoMessage _ stateArray at: 4.	UndoParagraph _ stateArray at: 5.	UndoSelection _ stateArray at: 6.	Undone _ stateArray at: 7.	sel _ stateArray at: 8.	self selectFrom: sel first to: sel last.	beginTypeInBlock _ stateArray at: 9.	emphasisHere _ stateArray at: 10.! !!ParagraphEditor methodsFor: 'accessing' stamp: 'sw 12/7/1999 11:39'!zapSelectionWith: aText	"Deselect, and replace the selection text by aText.	 Remember the resulting selectionInterval in UndoInterval and otherInterval.	 Do not set up for undo."	| start stop |	self deselect.	start _ startBlock stringIndex.	stop _ stopBlock stringIndex.	(aText isEmpty and: [stop > start]) ifTrue:		["If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (paragraph text attributesAt: start forStyle: paragraph textStyle)					select: [:att | att mayBeExtended]].	(start = stop and: [aText size = 0]) ifFalse:		[paragraph			replaceFrom: start			to: stop - 1			with: aText			displaying: true.		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval _ otherInterval _ self selectionInterval]! !!ParagraphEditor methodsFor: 'controlling' stamp: 'sma 3/11/2000 15:17'!normalActivity	self processKeyboard.	self processMouseButtons! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 5/4/2000 13:45'!browseClassFromIt	"Launch a hierarchy browser for the class indicated by the current selection.  If multiple classes matching the selection exist, let the user choose among them."	| aClass |	self lineSelectAndEmptyCheck: [^ self].	aClass _ Utilities classFromPattern: (self selection string copyWithout: Character cr) withCaption: 'choose a class to browse...'.	aClass ifNil: [^ view flash].	self terminateAndInitializeAround:		[Utilities spawnHierarchyForClass: aClass selector: nil]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 4/20/2000 12:18'!browseIt	"Launch a browser for the current selection, if appropriate"	| aSymbol anEntry brow |	Preferences alternativeBrowseIt ifTrue: [^ self browseClassFromIt].	self lineSelectAndEmptyCheck: [^ self].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[aSymbol first isUppercase			ifTrue:				[anEntry _ (Smalltalk					at: aSymbol					ifAbsent:						[Smalltalk browseAllImplementorsOf: aSymbol.						^ nil]).				anEntry isNil ifTrue: [^ view flash].				(anEntry isKindOf: Class)					ifFalse:	[anEntry _ anEntry class].				brow _ Preferences browseToolClass new.				brow setClass: anEntry selector: nil.				brow class					openBrowserView: (brow openEditString: nil)					label: 'System Browser']			ifFalse:				[Smalltalk browseAllImplementorsOf: aSymbol]]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 6/23/1998 11:08'!browseItHere	"Retarget the receiver's window to look at the selected class, if appropriate.  3/1/96 sw"	| aSymbol foundClass b |	(((b _ model) isKindOf: Browser) and: [b couldBrowseAnyClass])		ifFalse: [^ view flash].	model okToChange ifFalse: [^ view flash].	self selectionInterval isEmpty ifTrue: [self selectWord].	(aSymbol _ self selectedSymbol) isNil ifTrue: [^ view flash].	self terminateAndInitializeAround:		[foundClass _ (Smalltalk at: aSymbol ifAbsent: [nil]).			foundClass isNil ifTrue: [^ view flash].			(foundClass isKindOf: Class)				ifTrue:					[model systemCategoryListIndex: 						(model systemCategoryList indexOf: foundClass category).		model classListIndex: (model classList indexOf: foundClass name)]]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 9/27/1999 11:42'!changeEmphasisOrAlignment	| aList reply  |	aList _ #(plain bold italic narrow underlined struckOut leftFlush centered rightFlush justified).	reply _ (SelectionMenu labelList: aList lines: #(6) selections: aList) startUp.	reply ~~ nil ifTrue:		[(#(leftFlush centered rightFlush justified) includes: reply)			ifTrue:				[paragraph perform: reply.				self recomputeInterval]			ifFalse:				[self setEmphasis: reply.				paragraph composeAll.				self recomputeSelection.				self mvcRedisplay]].	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sma 12/30/1999 15:29'!changeStyle	"Let user change styles for the current text pane  	 Moved from experimentalCommand to its own method  "	| aList reply style |	aList _ StrikeFont familyNames remove: 'DefaultTextStyle' ifAbsent: []; asOrderedCollection.	aList addFirst: 'DefaultTextStyle'.	reply _ (SelectionMenu labelList: aList lines: #(1) selections: aList) startUp.	reply ~~ nil ifTrue:		[(style _ TextStyle named: reply) ifNil: [self beep. ^ true].		paragraph textStyle: style copy.		paragraph composeAll.		self recomputeSelection.		self mvcRedisplay].	^ true! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 9/27/1999 11:54'!chooseAlignment	self changeAlignment! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 4/28/1999 11:39'!clipboardText	^ self class clipboardText! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 4/28/1999 11:40'!clipboardTextPut: text	^ self class clipboardTextPut: text! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 11/23/1998 15:21'!compareToClipboard	"Check to see if whether the receiver's text is the same as the text currently on the clipboard, and inform the user."	| s1 s2 |	s1 _ self clipboardText string.	s2 _ paragraph text string.	s1 = s2 ifTrue: [^ self inform: 'Exact match'].	(StringHolder new textContents:		(TextDiffBuilder buildDisplayPatchFrom: s1 to: s2))		openLabel: 'Comparison to Clipboard Text'! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'ls 10/10/199911:36'!explain	"Try to shed some light on what kind of entity the current selectionis. 	The selection must be a single token or construct. Insert the answerafter 	the selection. Send private messages whose names begin with 'explain' 	that return a string if they recognize the selection, else nil."	| string tiVars cgVars selectors delimitors numbers sorry reply symbol|Cursor execute showWhile: 			[sorry _ '"Sorry, I can''t explain that.  Please select a singletoken, construct, or special character.'.			sorry _ sorry , (view canDiscardEdits							ifFalse: ['  Also, please cancel or accept."']							ifTrue: ['"']).			(string _ self selection asString) isEmpty				ifTrue: [reply _ '']				ifFalse: [string _ self explainScan: string.					"Remove space, tab, cr"					"Temps and Instance vars need only test strings that are allletters"					(string detect: [:char | (char isLetter or: [char isDigit]) not]						ifNone: []) ifNil: 							[tiVars _ self explainTemp: string.							tiVars == nil ifTrue: [tiVars _ self explainInst: string]].					(tiVars == nil and: [model respondsTo: #explainSpecial:])						ifTrue: [tiVars _ model explainSpecial: string].					tiVars == nil						ifTrue: [tiVars _ '']						ifFalse: [tiVars _ tiVars , '\' withCRs].					"Context, Class, Pool, and Global vars, and Selectors need 					only test symbols"					(Symbol hasInterned: string ifTrue: [:s | symbol _ s])						ifTrue: [cgVars _ self explainCtxt: symbol.							cgVars == nil								ifTrue: [cgVars _ self explainClass: symbol.									cgVars == nil ifTrue: [cgVars _ self explainGlobal: symbol]].							"See if it is a Selector (sent here or not)"							selectors _ self explainMySel: symbol.							selectors == nil								ifTrue: 									[selectors _ self explainPartSel: string.									selectors == nil ifTrue: [										selectors _ self explainAnySel: symbol]]]						ifFalse: [selectors _ self explainPartSel: string].					cgVars == nil						ifTrue: [cgVars _ '']						ifFalse: [cgVars _ cgVars , '\' withCRs].					selectors == nil						ifTrue: [selectors _ '']						ifFalse: [selectors _ selectors , '\' withCRs].					string size = 1						ifTrue: ["single special characters"							delimitors _ self explainChar: string]						ifFalse: ["matched delimitors"							delimitors _ self explainDelimitor: string].					numbers _ self explainNumber: string.					numbers == nil ifTrue: [numbers _ ''].					delimitors == nil ifTrue: [delimitors _ ''].					reply _ tiVars , cgVars , selectors , delimitors , numbers].			reply size = 0 ifTrue: [reply _ sorry].			self afterSelectionInsertAndSelect: reply]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 9/7/1999 08:41'!fileItIn	"Make a Stream on the text selection and fileIn it.	 1/24/96 sw: moved here from FileController; this function can be useful from any text window that shows stuff in chunk format"	| selection |	selection _ self selection.	self terminateAndInitializeAround:		[(ReadWriteStream on: selection string from: 1 to: selection size) fileIn].! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 10/5/1998 21:55'!find	"Prompt the user for a string to search for, and search the receiver from the current selection onward for it.  1/26/96 sw"	| reply |	reply _ FillInTheBlank request: 'Find what? ' initialAnswer: ''.	reply size == 0 ifTrue: [^ self].	self setSearch: reply.	ChangeText _ FindText.  "Implies no replacement to againOnce: method"	self againOrSame: true	! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sw 11/2/1998 09:43'!lineSelectAndEmptyCheck: returnBlock	"If the current selection is an insertion point, expand it to be the entire current line; if after that's done the selection is still empty, then evaluate the returnBlock, which will typically consist of '[^ self]' in the caller -- check senders of this method to understand this."	self selectLine.  "if current selection is an insertion point, then first select the entire line in which occurs before proceeding"	startBlock = stopBlock ifTrue: [self flash.  ^ returnBlock value]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 4/26/2000 21:57'!pasteRecent	"Paste an item chose from RecentClippings."	| clipping |	(clipping _ self class chooseRecentClipping) ifNil: [^ self].	CurrentSelection _ clipping.	^ self paste! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sma 5/28/2000 09:40'!prettyPrint	self prettyPrint: false! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'sma 5/28/2000 09:41'!prettyPrint: decorated	"Reformat the contents of the receiver's view (a Browser)."	| selectedClass newText |	model selectedMessageCategoryName ifNil: [^ view flash].	selectedClass _ model selectedClassOrMetaClass.	newText _ selectedClass compilerClass new		format: self text		in: selectedClass		notifying: self		decorated: decorated.	newText ifNotNil:		[self deselect; selectInvisiblyFrom: 1 to: paragraph text size.		self replaceSelectionWith: (newText asText makeSelectorBoldIn: selectedClass).		self selectAt: 1]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 6/26/1998 10:04'!referencesToIt	"Open a references browser on the selected symbol"	| aSymbol |	self selectionInterval isEmpty ifTrue: [self selectWord].	((aSymbol _ self selectedSymbol) == nil or:		[(Smalltalk includesKey: aSymbol) not])			ifTrue: [^ view flash].	self terminateAndInitializeAround: [Smalltalk browseAllCallsOn: (Smalltalk associationAt: self selectedSymbol)]! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'dew 3/9/2000 00:15'!saveContentsInFile	| fileName stringToSave parentWindow labelToUse |	stringToSave _ paragraph text string.	stringToSave size == 0 ifTrue: [^ self inform: 'nothing to save.'].	parentWindow _ self model dependents						detect: [:dep | dep isKindOf: SystemWindow]						ifNone: [nil].	parentWindow isNil		ifTrue: [labelToUse _ 'Untitled']		ifFalse: [labelToUse _ parentWindow label].	fileName _ FillInTheBlank request: 'File name? (".text" will be added to end)' 			initialAnswer: labelToUse.	fileName size == 0 ifTrue: [^ self beep].	(fileName asLowercase endsWith: '.text') ifFalse: [fileName _ fileName,'.text'].	(FileStream newFileNamed: fileName)		nextPutAll: stringToSave; close! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'bf 10/13/1999 09:09'!selectedSelector	"Try to make a selector out of the current text selection"	^self selection string findSelector! !!ParagraphEditor methodsFor: 'menu messages' stamp: 'di 9/7/1999 08:44'!spawnWorkspace	| toUse |	self selectLine.	toUse _ self selection asString.	toUse size > 0 ifFalse:		[toUse _ paragraph text string.		toUse size > 0 ifFalse: [^ self flash]].	"NB: BrowserCodeController's version does a cancel here"	self terminateAndInitializeAround:		[Utilities openScratchWorkspaceLabeled: 'Untitled' contents: toUse]! !!ParagraphEditor methodsFor: 'explain' stamp: 'tk 4/14/1999 15:07'!explainChar: string	"Does string start with a special character?"	| char |	char _ string at: 1.	char = $. ifTrue: [^'"Period marks the end of a Smalltalk statement.  A period in the middle of a number means a decimal point.  (The number is an instance of class Float)."'].	char = $' ifTrue: [^'"The characters between two single quotes are made into an instance of class String"'].	char = $" ifTrue: [^'"Double quotes enclose a comment.  Smalltalk ignores everything between double quotes."'].	char = $# ifTrue: [^'"The characters following a hash mark are made into an instance of class Symbol.  If parenthesis follow a hash mark, an instance of class Array is made.  It contains literal constants."'].	(char = $( or: [char = $)]) ifTrue: [^'"Expressions enclosed in parenthesis are evaluated first"'].	(char = $[ or: [char = $]]) ifTrue: [^'"The code inside square brackets is an unevaluated block of code.  It becomes an instance of BlockContext and is usually passed as an argument."'].	(char = $< or: [char = $>]) ifTrue: [^'"<primitive: xx> means that this method is usually preformed directly by the virtual machine.  If this method is primitive, its Smalltalk code is executed only when the primitive fails."'].	char = $^ ifTrue: [^'"Uparrow means return from this method.  The value returned is the expression following the ^"'].	char = $| ifTrue: [^'"Vertical bars enclose the names of the temporary variables used in this method.  In a block, the vertical bar separates the argument names from the rest of the code."'].	char = $_ ifTrue: [^'"Left arrow means assignment.  The value of the expression after the left arrow is stored into the variable before it."'].	char = $; ifTrue: [^'"Semicolon means cascading.  The message after the semicolon is sent to the same object which received the message before the semicolon."'].	char = $: ifTrue: [^'"A colon at the end of a keyword means that an argument is expected to follow.  Methods which take more than one argument have selectors with more than one keyword.  (One keyword, ending with a colon, appears before each argument).', '\\' withCRs, 'A colon before a variable name just inside a block means that the block takes an agrument.  (When the block is evaluated, the argument will be assigned to the variable whose name appears after the colon)."'].	char = $$ ifTrue: [^'"The single character following a dollar sign is made into an instance of class Character"'].	char = $- ifTrue: [^'"A minus sign in front of a number means a negative number."'].	char = $e ifTrue: [^'"An e in the middle of a number means that the exponent follows."'].	char = $r ifTrue: [^'"An r in the middle of a bunch of digits is an instance of Integer expressed in a certain radix.  The digits before the r denote the base and the digits after it express a number in that base."'].	char = Character space ifTrue: [^'"the space Character"'].	char = Character tab ifTrue: [^'"the tab Character"'].	char = Character cr ifTrue: [^'"the carriage return Character"'].	^nil! !!ParagraphEditor methodsFor: 'explain' stamp: 'ar 2/13/1999 21:17'!explainClass: symbol 	"Is symbol a class variable or a pool variable?"	| class reply classes |	(model respondsTo: #selectedClassOrMetaClass) ifFalse: [^ nil].	(class _ model selectedClassOrMetaClass) ifNil: [^nil].	  "no class is selected"	(class isKindOf: Metaclass) ifTrue: [class _ class soleInstance].	classes _ (Array with: class) , class allSuperclasses.	"class variables"	reply _ classes detect: [:each | (each classVarNames			detect: [:name | symbol = name] ifNone: [])			~~ nil] ifNone: [].	reply == nil ifFalse: [^'"is a class variable; defined in class ' , reply printString, '"\' withCRs,		'Smalltalk browseAllCallsOn: (', reply printString, ' classPool associationAt: #', symbol, ').'].	"pool variables"	classes do: [:each | (each sharedPools			detect: [:pool | (pool includesKey: symbol) and: [reply _ pool. true]]			ifNone: []) ~~ nil].	reply == nil ifTrue: [(Undeclared includesKey: symbol) ifTrue: [reply _ Undeclared]].	reply == nil		ifFalse: 			[classes _ WriteStream on: Array new.			Smalltalk allBehaviorsDo: [:each |					(each sharedPools detect: [:pool | pool == reply] ifNone: [])					~~ nil ifTrue: [classes nextPut: each]].			"Perhaps not print whole list of classes if too long. (unlikely)"			^'"is a pool variable from the pool ' , (Smalltalk keyAtIdentityValue: reply),			', which is used by the following classes ' , classes contents printString , '"\' withCRs,			'Smalltalk browseAllCallsOn: (', (Smalltalk keyAtIdentityValue: reply) printString,			' associationAt: #', symbol, ').'].	^nil! !!ParagraphEditor methodsFor: 'explain' stamp: 'tk 4/20/1999 09:48'!explainMySel: symbol 	"Is symbol the selector of this method?  Is it sent by this method?  If 	not, then expalin will call (explainPartSel:) to see if it is a fragment of a 	selector sent here.  If not, explain will call (explainAnySel:) to catch any 	selector. "	| lits classes msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg _ model selectedMessageName) ifNil: [^nil].	"not in a message"	classes _ Smalltalk allClassesImplementing: symbol.	classes size > 12		ifTrue: [classes _ 'many classes']		ifFalse: [classes _ 'these classes ' , classes printString].	msg = symbol		ifTrue: [^ '"' , symbol , ' is the selector of this very method!!  It is defined in ',			classes , '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			[lits _ (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(lits detect: [:each | each == symbol]				ifNone: [])				== nil ifTrue: [^nil].			^ '"' , symbol , ' is a message selector which is defined in ', classes , '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].! !!ParagraphEditor methodsFor: 'explain' stamp: 'apb 1/5/2000 16:56'!explainNumber: string 	"Is string a Number?"	| strm c |	(c _ string at: 1) isDigit ifFalse: [(c = $- and: [string size > 1 and: [(string at: 2) isDigit]])			ifFalse: [^nil]].	strm _ ReadStream on: string.	c _ Number readFrom: strm.	strm atEnd ifFalse: [^nil].	c printString = string		ifTrue: [^'"' , string , ' is a ' , c class name , '"']		ifFalse: [^'"' , string , ' (= ' , c printString , ') is a ' , c class name , '"']! !!ParagraphEditor methodsFor: 'explain' stamp: 'tk 4/20/1999 09:51'!explainPartSel: string 	"Is this a fragment of a multiple-argument selector sent in this method?"	| lits whole reply classes s msg |	(model respondsTo: #selectedMessageName) ifFalse: [^ nil].	(msg _ model selectedMessageName) ifNil: [^ nil].  "not in a message"	string last == $: ifFalse: [^ nil].	"Name of this method"	lits _ Array with: msg.	(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]					ifNone: []) ~~ nil]				ifNone: []) ~~ nil		ifTrue: [reply _ ', which is the selector of this very method!!'.			s _ '.  To see the other definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."']		ifFalse: 			["Selectors called from this method"			lits _ (model selectedClassOrMetaClass compiledMethodAt:				msg) messages.			(whole _ lits detect: [:each | (each keywords detect: [:frag | frag = string]							ifNone: []) ~~ nil]						ifNone: []) ~~ nil				ifFalse: [string = 'primitive:'					ifTrue: [^self explainChar: '<']					ifFalse: [^nil]].			reply _ '.'.			s _ '.  To see the definitions, go to the message list pane, get the menu from the top of the scroll bar, and select ''implementors of...''."'].	classes _ Smalltalk allClassesImplementing: whole.	classes size > 12		ifTrue: [classes _ 'many classes']		ifFalse: [classes _ 'these classes ' , classes printString].	^ '"' , string , ' is one part of the message selector ' , whole, reply , '  It is defined in ' , classes , s! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:40'!cancel: characterStream 	"Cancel unsubmitted changes.  Flushes typeahead.  1/12/96 sw	 1/22/96 sw: put in control terminate/init"	sensor keyboard.	self terminateAndInitializeAround: [self cancel].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 12/7/1999 11:37'!changeEmphasis: characterStream 	"Change the emphasis of the current selection or prepare to accept characters with the change in emphasis. Emphasis change amounts to a font change.  Keeps typeahead."	| keyCode attribute oldAttributes index thisSel colors |		 "control 0..9 -> 0..9"	keyCode _ ('0123456789-=' indexOf: sensor keyboard ifAbsent: [1]) - 1.	oldAttributes _ paragraph text attributesAt: startBlock stringIndex forStyle: paragraph textStyle.	thisSel _ self selection.	"Decipher keyCodes for Command 0-9..."	(keyCode between: 1 and: 5) ifTrue:		[attribute _ TextFontChange fontNumber: keyCode].	keyCode = 6 ifTrue:		[colors _ #(black magenta red yellow green blue cyan white).		index _ (PopUpMenu labelArray: colors , #('Do it' 'Link to comment of class' 'Link to definition of class' 'Link to hierarchy of class' 'Link to method' 'URL' 'Copy hidden info')							lines: (Array with: colors size)) startUp.		index = 0 ifTrue: [^ true].		index <= colors size		ifTrue:			[attribute _ TextColor color: (Color perform: (colors at: index))]		ifFalse:			[index _ index - colors size.			index = 1 ifTrue: [attribute _ TextDoIt new.				thisSel _ attribute analyze: self selection asString].			index = 2 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString with: 'Comment'].			index = 3 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString with: 'Definition'].			index = 4 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString with: 'Hierarchy'].			index = 5 ifTrue: [attribute _ TextLink new. 				thisSel _ attribute analyze: self selection asString].			index = 6 ifTrue: [attribute _ TextURL new. 				thisSel _ attribute analyze: self selection asString].			index = 7 ifTrue: ["Copy hidden info"				self copyHiddenInfo.  ^ true].	"no other action"		thisSel ifNil: [^ true]].	"Could not figure out what to link to"		].	(keyCode between: 7 and: 11) ifTrue:		[sensor leftShiftDown		ifTrue:			[keyCode = 10 ifTrue: [attribute _ TextKern kern: -1].			keyCode = 11 ifTrue: [attribute _ TextKern kern: 1]]		ifFalse:			[attribute _ TextEmphasis perform:					(#(bold italic narrow underlined struckOut) at: keyCode - 6).			oldAttributes do:				[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]]].	(keyCode = 0) ifTrue:		[attribute _ TextEmphasis normal].	beginTypeInBlock ~~ nil		ifTrue:  "only change emphasisHere while typing"			[self insertTypeAhead: characterStream.			emphasisHere _ Text addAttribute: attribute toArray: oldAttributes.			^ true].	self replaceSelectionWith: (thisSel asText addAttribute: attribute).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 11:58'!changeLfToCr: characterStream 	"Replace all LFs by CRs.	Triggered by Cmd-U -- useful when getting code from FTP sites"	| cr lf |	sensor keyboard.		"flush the triggering cmd-key character"	cr _ Character cr.  lf _ Character linefeed.	self replaceSelectionWith: (Text fromString:			(self selection string collect: [:c | c = lf ifTrue: [cr] ifFalse: [c]])).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:31'!compareToClipboard: characterStream 	"Compare the receiver to the text on the clipboard.  Flushes typeahead.  5/1/96 sw"	sensor keyboard.		self terminateAndInitializeAround: [self compareToClipboard].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'bf 3/16/2000 18:25'!copyHiddenInfo	"In TextLinks, TextDoits, TextColor, and TextURLs, there is hiddeninfo.  Copy that to the clipboard.  You can paste it and see what it is.Usually enclosed in <>."	| attrList |	attrList _ paragraph text attributesAt: (startBlock stringIndex +stopBlock stringIndex)//2 forStyle: paragraph textStyle.	attrList do: [:attr |		(attr isKindOf: TextAction) ifTrue:			[^ self clipboardTextPut: ('<', attr info, '>') asText]].	"If none of the above"	attrList do: [:attr |		attr class == TextColor ifTrue:			[^ self clipboardTextPut: attr color printString asText]].	^ self clipboardTextPut: '[No hidden info]' asText! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:23'!doIt: characterStream 	"Called when user hits cmd-d.  Select the current line, if relevant, then evaluate and execute.  2/1/96 sw.	2/29/96 sw: don't call selectLine; it's done by doIt now"	sensor keyboard.		self terminateAndInitializeAround: [self doIt].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:25'!inspectIt: characterStream 	"Inspect the selection -- invoked via cmd-i.  If there is no current selection, use the current line.  1/17/96 sw	 2/29/96 sw: don't call selectLine; it's done by inspectIt now"	sensor keyboard.		"flush character"	self terminateAndInitializeAround: [self inspectIt].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:06'!makeCapitalized: characterStream 	"Force the current selection to uppercase.  Triggered by Cmd-X."	| prev |	sensor keyboard.		"flush the triggering cmd-key character"	prev _ $-.  "not a letter"	self replaceSelectionWith: (Text fromString:			(self selection string collect:				[:c | prev _ prev isLetter ifTrue: [c asLowercase] ifFalse: [c asUppercase]])).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:00'!makeLowercase: characterStream 	"Force the current selection to lowercase.  Triggered by Cmd-X."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asLowercase)).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 5/28/1998 12:00'!makeUppercase: characterStream 	"Force the current selection to uppercase.  Triggered by Cmd-X."	sensor keyboard.		"flush the triggering cmd-key character"	self replaceSelectionWith: (Text fromString: (self selection string asUppercase)).	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'jm 6/9/2003 21:52'!offerFontMenu	"Present a menu of available fonts, and if one is chosen, apply it to the current selection.  	Use only names of Fonts of this paragraph  "	| aList reply |	aList _ paragraph textStyle fontNamesWithHeights.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[self replaceSelectionWith:			(Text string: self selection asString 				attribute: (TextFontChange fontNumber: (aList indexOf: reply)))] ! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:25'!printIt: characterStream 	"Print the results of evaluting the selection -- invoked via cmd-p.  If there is no current selection, use the current line.  1/17/96 sw	 2/29/96 sw: don't call selectLine now, since it's called by doIt"	sensor keyboard.		"flush character"	self terminateAndInitializeAround: [self printIt].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:43'!save: characterStream	"Submit the current text.  Equivalent to 'accept' 1/18/96 sw	 Keeps typeahead."	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self terminateAndInitializeAround: [self accept].	^ true! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'sw 12/7/1999 11:38'!setEmphasis: emphasisSymbol	"Change the emphasis of the current selection."	| oldAttributes attribute |	oldAttributes _ paragraph text attributesAt: startBlock stringIndex forStyle: paragraph textStyle.	(emphasisSymbol == #plain) 		ifTrue:			[attribute _ TextEmphasis normal]		ifFalse:			[attribute _ TextEmphasis perform: emphasisSymbol.			oldAttributes do:				[:att | (att dominates: attribute) ifTrue: [attribute turnOff]]].	self replaceSelectionWith: (self selection addAttribute: attribute)! !!ParagraphEditor methodsFor: 'editing keys' stamp: 'di 9/7/1999 08:43'!spawnIt: characterStream	"Triggered by Cmd-o; spawn a new code window, if it makes sense."	sensor keyboard.	self terminateAndInitializeAround: [self spawn].	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:51'!comment	"All key actions that are neither editing nor typing actions have to	send closeTypeIn at first. See comment in openTypeIn closeTypeIn"! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:31'!cursorDown: characterStream "Private - Move cursor from position in current line to same position innext line. If next line too short, put at end. If shift key down,select."	| shift string right left start position textSize|	self closeTypeIn: characterStream.	shift := sensor leftShiftDown.	sensor keyboard.	string _ paragraph text string.	textSize _ string size.	left _ right _ stopBlock stringIndex.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	position _ stopBlock stringIndex - left.	[right < textSize and: [(string at: right) ~= Character cr]] whileTrue:[right _ right + 1].	right _ start _ right + 1.	[right < textSize and: [(string at: right) ~= Character cr]] whileTrue:[right _ right + 1].	shift		ifTrue: 			[			start + position > right				ifTrue: [self selectFrom: startBlock stringIndex to: right - 1]				ifFalse: [self selectFrom: startBlock stringIndex to: start +position - 1]			]		ifFalse: 			[			start + position > right				ifTrue: [self selectFrom: right to: right - 1]				ifFalse: [self selectFrom: start + position to: start + position -1]			].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/22/2000 17:42'!cursorEnd: characterStream "Private - Move cursor end of current line. If cursor already at end ofline, put cursor at end of text"	| string right stringSize |	self closeTypeIn: characterStream.	sensor keyboard.	string _ paragraph text string.	stringSize _ string size.	right _ stopBlock stringIndex.	[right <= stringSize and: [(string at: right) ~= Character cr]]		whileTrue: [right _ right + 1].	sensor commandKeyPressed ifTrue: [right _ stringSize + 1].	sensor leftShiftDown		ifTrue: [self selectFrom: startBlock stringIndex to: right - 1]		ifFalse: [self selectAt: right].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/22/2000 17:42'!cursorHome: characterStream "Private - Move cursor from position in current line to beginning ofcurrent line. If cursor already at beginning of line, put cursor atbeginning of text"	| string left |	self closeTypeIn: characterStream.	sensor keyboard.	string _ paragraph text string.	left _ startBlock stringIndex.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]]		whileTrue: [left _ left - 1].	sensor commandKeyPressed ifTrue: [left _ 1].	sensor leftShiftDown		ifTrue: [self selectFrom: left to: stopBlock stringIndex - 1]		ifFalse: [self selectAt: left].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:54'!cursorLeft: characterStream 	"Private - Move cursor left one character if nothing selected, otherwise 	move cursor to beginning of selection. If the shift key is down, start 	selecting or extending current selection. Don't allow cursor past 	beginning of text"	| shift left |	self closeTypeIn: characterStream.	shift _ sensor leftShiftDown.	left _ startBlock stringIndex - 1.	sensor controlKeyPressed ifTrue: [left _ self previousWord: left].	sensor keyboard.	shift		ifTrue: [startBlock stringIndex > 1			ifTrue: [self selectFrom: left to: stopBlock stringIndex - 1]]		ifFalse: [(startBlock stringIndex == stopBlock stringIndex and: [startBlock stringIndex > 1])			ifTrue: [self selectAt: left]			ifFalse: [self selectAt: startBlock stringIndex]].	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'sbw 10/12/1999 12:11'!cursorPageDown: characterStream 	^self cursorPageJump: characterStream down: true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!cursorPageJump: characterStream down: aBoolean"Private - Move cursor from position in current line to same position in the line on the next page up or down (direction is controlled by <aBoolean>. If next line too short, put at end. If shift key down, select.  This method is similar to #cursorDown:.  Haven't figured out how to intercept the shift key yet.See Utilities createPageTestWorkspace to create a test MVC workspace."	| string right left start position textSize currentLineNumber howManyLines visibleHeight totalHeight ratio deltaLines targetLine offsetAtTargetLine |	self closeTypeIn: characterStream.	sensor keyboard.  "Eat the key stroke."	string _ paragraph text string.	textSize _ string size.	left _ right _ stopBlock stringIndex.	"Calculate the position of the left edge."	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue: [left _ left - 1].	"Calculate the offset from the left edge where cursor is now."	position _ stopBlock stringIndex - left.	"Calculate the current line number."	currentLineNumber _ paragraph lineIndexOfCharacterIndex: stopBlock stringIndex.	howManyLines _ paragraph numberOfLines.	visibleHeight _ self visibleHeight.	totalHeight _ self totalTextHeight.	ratio _ visibleHeight / totalHeight.	deltaLines _ (ratio * howManyLines) rounded - 2.	targetLine _ aBoolean		ifTrue: [(currentLineNumber + deltaLines) min: howManyLines]		ifFalse: [(currentLineNumber - deltaLines) max: 1].	offsetAtTargetLine _ (paragraph lines at: targetLine) first.	"Calculate the position of the right edge of text of target line."	right _ offsetAtTargetLine.	[right < textSize and: [(string at: right) ~= Character cr]] whileTrue: [right _ right + 1].	start _ offsetAtTargetLine.	start + position > right			ifTrue: [self selectForTopFrom: right to: right - 1]			ifFalse: [self selectForTopFrom: start + position to: start + position - 1].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'sbw 10/12/1999 12:11'!cursorPageUp: characterStream 	^self cursorPageJump: characterStream down: false! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!cursorRight: characterStream 	"Private - Move cursor right one character if nothing selected, 	otherwise move cursor to end of selection. If the shift key is down, 	start selecting characters or extending already selected characters. 	Don't allow cursor past end of text"	| shift right |	self closeTypeIn: characterStream.	shift _ sensor leftShiftDown.	right _ stopBlock stringIndex + 1.	sensor controlKeyPressed ifTrue: [right _ self nextWord: right].	sensor keyboard.	shift		ifTrue: [self selectFrom: startBlock stringIndex to: right - 1]		ifFalse: [startBlock stringIndex == stopBlock stringIndex				ifTrue: [self selectAt: right]				ifFalse: [self selectAt: stopBlock stringIndex]].	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!cursorUp: characterStream "Private - Move cursor from position in current line to same position inprior line. If prior line too short, put at end"	| shift string left position start |	self closeTypeIn: characterStream.	shift := sensor leftShiftDown.	sensor keyboard.	string _ paragraph text string.	left _ startBlock stringIndex.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	position _ startBlock stringIndex - left.	start _ left.	left _ left - 1.	[left > 1 and: [(string at: (left - 1)) ~= Character cr]] whileTrue:[left _ left - 1].	left < 1 ifTrue: [left _ 1].	start = 1 ifTrue: [position _ 0].	shift		ifTrue: 			[			(start - left < position and: [start > 1])				ifTrue: [self selectFrom: start - 1 to: stopBlock stringIndex - 1]				ifFalse: [self selectFrom: left + position to: stopBlock stringIndex- 1]			]		ifFalse: 			[			(start - left < position and: [start > 1])				ifTrue: [self selectFrom: start - 1 to: start - 2]				ifFalse: [self selectFrom: left + position to: left + position - 1]			].	^true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!selectCurrentTypeIn: characterStream 	"Select what would be replaced by an undo (e.g., the last typeIn)."	| prior |	self closeTypeIn: characterStream.	prior _ otherInterval.	sensor keyboard.		"flush character"	self closeTypeIn: characterStream.	self selectInterval: UndoInterval.	otherInterval _ prior.	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'sma 12/15/1999 11:46'!selectWord: characterStream	sensor keyboard.	self closeTypeIn: characterStream.	self selectWord.	^ true! !!ParagraphEditor methodsFor: 'nonediting/nontyping keys' stamp: 'th 1/21/2000 18:55'!setSearchString: characterStream	"Establish the current selection as the current search string."	| aString |	self closeTypeIn: characterStream.	sensor keyboard.	self lineSelectAndEmptyCheck: [^ true].	aString _  self selection string.	aString size == 0		ifTrue:			[self flash]		ifFalse:			[self setSearch: aString].	^ true! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'sma 2/12/2000 20:17'!backspace: characterStream 	"Backspace over the last character."	| startIndex |	sensor leftShiftDown ifTrue: [^ self backWord: characterStream].	characterStream isEmpty		ifTrue:			[startIndex _ startBlock stringIndex +				(startBlock = stopBlock ifTrue: [0] ifFalse: [1]).			[sensor keyboardPressed and:			 [sensor keyboardPeek asciiValue = 8]] whileTrue: [				"process multiple backspaces"				sensor keyboard.				startIndex _ 1 max: startIndex - 1.			].			self backTo: startIndex]		ifFalse:			[sensor keyboard.			characterStream skip: -1].	^false! !!ParagraphEditor methodsFor: 'typing/selecting keys' stamp: 'sma 12/15/1999 12:20'!forwardDelete: characterStream	"Delete forward over the next character.	  Make Undo work on the whole type-in, not just the one char.	wod 11/3/1998: If there was a selection use #zapSelectionWith: rather than #backspace: which was 'one off' in deleting the selection. Handling of things like undo or typeIn area were not fully considered."	| startIndex usel upara uinterval ind stopIndex |	startIndex _ startBlock stringIndex.	startIndex > paragraph text size ifTrue:		[sensor keyboard.		^ false].	startIndex = stopBlock stringIndex ifFalse:		["there was a selection"		sensor keyboard.		self zapSelectionWith: self nullText.		^ false].	"Null selection - do the delete forward"	beginTypeInBlock == nil	"no previous typing.  openTypeIn"		ifTrue: [self openTypeIn. UndoSelection _ self nullText].	uinterval _ UndoInterval deepCopy.	"umes _ UndoMessage deepCopy.	Set already by openTypeIn"	"usel _ UndoSelection deepCopy."	upara _ UndoParagraph deepCopy.	stopIndex := startIndex.	(sensor keyboard asciiValue = 127 and: [sensor leftShiftDown])		ifTrue: [stopIndex := (self nextWord: stopIndex) - 1].	self selectFrom: startIndex to: stopIndex.	self replaceSelectionWith: self nullText.	self selectFrom: startIndex to: startIndex-1.	UndoParagraph _ upara.  UndoInterval _ uinterval.	UndoMessage selector == #noUndoer ifTrue: [		(UndoSelection isText) ifTrue: [			usel _ UndoSelection.			ind _ startIndex. "UndoInterval startIndex"			usel replaceFrom: usel size + 1 to: usel size with:				(UndoParagraph text copyFrom: ind to: ind).			UndoParagraph text replaceFrom: ind to: ind with:self nullText]].	^false! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:43'!backTo: startIndex	"During typing, backspace to startIndex.  Deleted characters fall into three	 clusters, from left to right in the text: (1) preexisting characters that were	 backed over; (2) newly typed characters that were backed over (excluding	 typeahead, which never even appears); (3) preexisting characters that	 were highlighted before typing began.  If typing has not yet been opened,	 open it and watch for the first and third cluster.  If typing has been opened,	 watch for the first and second cluster.  Save characters from the first and third	 cluster in UndoSelection.  Tally characters from the first cluster in UndoMessage's parameter.	 Delete all the clusters.  Do not alter Undoer or UndoInterval (except via	 openTypeIn).  The code is shorter than the comment."	| saveLimit newBackovers |	saveLimit _ beginTypeInBlock == nil		ifTrue: [self openTypeIn. UndoSelection _ self nullText. stopBlock stringIndex]		ifFalse: [self startOfTyping].	startBlock _ paragraph characterBlockForIndex: startIndex.	startIndex < saveLimit ifTrue:		[newBackovers _ self startOfTyping - startIndex.		beginTypeInBlock _ startBlock stringIndex.		UndoSelection replaceFrom: 1 to: 0 with:			(paragraph text copyFrom: startIndex to: saveLimit - 1).		UndoMessage argument: (UndoMessage argument ifNil: [1]) + newBackovers].	self zapSelectionWith: self nullText.	startBlock _ stopBlock copy! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:31'!closeTypeIn	"See comment in openTypeIn.  It is important to call closeTypeIn before executing	 any non-typing key, making a new selection, etc.  It is called automatically for	 menu commands.	 Typing commands can call 'closeTypeIn: aCharacterStream' instead of this to	 save typeahead.  Undoer & Redoer: undoAndReselect:redoAndReselect:."	| begin start stop |	beginTypeInBlock == nil ifFalse:		[(UndoMessage sends: #noUndoer) ifTrue: "should always be true, but just in case..."			[begin _ self startOfTyping.			start _ startBlock stringIndex.			stop _ stopBlock stringIndex.			self undoer: #undoAndReselect:redoAndReselect:				with: (begin + UndoMessage argument to: begin + UndoSelection size - 1)				with: (stop to: stop - 1).			UndoInterval _ begin to: stop - 1].		beginTypeInBlock _ nil]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'sma 12/15/1999 13:21'!dispatchOnCharacter: char with: typeAheadStream	"Carry out the action associated with this character, if any.	Type-ahead is passed so some routines can flush or use it."	| honorCommandKeys |	((honorCommandKeys _ Preferences cmdKeysInText) and: [char = Character enter])		ifTrue: [^ self dispatchOnEnterWith: typeAheadStream].	"Special keys overwrite crtl+key combinations - at least on Windows. To resolve this	conflict, assume that keys other than cursor keys aren't used together with Crtl." 	((self class specialShiftCmdKeys includes: char asciiValue) and: [char asciiValue < 27])		ifTrue: [^ sensor controlKeyPressed			ifTrue: [self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse: [self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"backspace, and escape keys (ascii 8 and 27) are command keys"	((honorCommandKeys and: [sensor commandKeyPressed]) or: [self class specialShiftCmdKeys includes: char asciiValue]) ifTrue:		[^ sensor leftShiftDown			ifTrue:				[self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream]			ifFalse:				[self perform: (CmdActions at: char asciiValue + 1) with: typeAheadStream]].	"the control key can be used to invoke shift-cmd shortcuts"	(honorCommandKeys and: [sensor controlKeyPressed])		ifTrue:			[^ self perform: (ShiftCmdActions at: char asciiValue + 1) with: typeAheadStream].	^ self perform: #normalCharacter: with: typeAheadStream! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 9/7/1999 11:26'!dispatchOnEnterWith: typeAheadStream	"Enter key hit.  Treat is as an 'accept', viz a synonym for cmd-s.  If cmd key is down, treat is as a synonym for print-it. "	sensor keyboard.  "consume enter key"	self terminateAndInitializeAround: [	sensor commandKeyPressed		ifTrue:			[self printIt.]		ifFalse: 			[self closeTypeIn: typeAheadStream.			self accept].	].	^ true! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 6/14/1998 13:08'!doneTyping	beginTypeInBlock _ nil! !!ParagraphEditor methodsFor: 'typing support' stamp: 'sma 4/22/2000 17:21'!insertTypeAhead: typeAhead	typeAhead position = 0 ifFalse:		[self zapSelectionWith: (Text string: typeAhead contents emphasis: emphasisHere).		typeAhead reset.		startBlock _ stopBlock copy]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:39'!openTypeIn	"Set up UndoSelection to null text (to be added to by readKeyboard and backTo:),	 beginTypeInBlock to keep track of the leftmost backspace, and UndoParameter to tally	 how many deleted characters were backspaced over rather than 'cut'.	 You can't undo typing until after closeTypeIn."	beginTypeInBlock == nil ifTrue:		[UndoSelection _ self nullText.		self undoer: #noUndoer with: 0.		beginTypeInBlock _ startBlock stringIndex]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 6/14/1998 13:08'!readKeyboard	"Key struck on the keyboard. Find out which one and, if special, carry 	out the associated special action. Otherwise, add the character to the 	stream of characters.  Undoer & Redoer: see closeTypeIn."	| typeAhead char |	typeAhead _ WriteStream on: (String new: 128).	[sensor keyboardPressed] whileTrue: 		[self deselect.		 [sensor keyboardPressed] whileTrue: 			[char _ sensor keyboardPeek.			(self dispatchOnCharacter: char with: typeAhead) ifTrue:				[self doneTyping.				^self selectAndScroll; updateMarker].			self openTypeIn].		startBlock = stopBlock ifFalse: "save highlighted characters"			[UndoSelection _ self selection]. 		self zapSelectionWith: 			(Text string: typeAhead contents emphasis: emphasisHere).		typeAhead reset.		startBlock _ stopBlock copy.		sensor keyboardPressed ifFalse: 			[self selectAndScroll.			sensor keyboardPressed				ifFalse: [self updateMarker]]]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'sw 12/7/1999 11:39'!setEmphasisHere	emphasisHere _ (paragraph text attributesAt: (startBlock stringIndex-1 max: 1) forStyle: paragraph textStyle)					select: [:att | att mayBeExtended]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'sw 12/16/1998 13:14'!simulatedKeystroke: char	"Accept char as if it were struck on the keyboard.  This version does not yet deal with command keys, and achieves update in the receiver's typically inactive window via the sledge-hammer of uncache-bits."	self deselect.	self openTypeIn.	startBlock = stopBlock ifFalse: [UndoSelection _ self selection].	self zapSelectionWith:		(Text string: char asString emphasis: emphasisHere).	self userHasEdited.	startBlock _ stopBlock copy.	self selectAndScroll.	self updateMarker.	view ifNotNil:		[view topView uncacheBits		"in mvc, this makes sure the recognized character shows up in the pane right now; in morphic, a different mechanism is used for the same effect -- see TextMorphEditor method #recognizeCharactersWhileMouseIn:"]! !!ParagraphEditor methodsFor: 'typing support' stamp: 'di 10/6/1998 08:45'!startOfTyping	"Compatibility during change from characterBlock to integer"	beginTypeInBlock == nil ifTrue: [^ nil].	beginTypeInBlock isNumber ifTrue: [^ beginTypeInBlock].	"Last line for compatibility during change from CharacterBlock to Integer."	^ beginTypeInBlock stringIndex	! !!ParagraphEditor methodsFor: 'current selection' stamp: 'sbw 10/12/1999 16:51'!selectAndScrollToTop	"Scroll until the selection is in the view and then highlight it."	| lineHeight deltaY clippingRectangle |	self select.	lineHeight _ paragraph textStyle lineGrid.	clippingRectangle _ paragraph clippingRectangle.	deltaY _ stopBlock top - clippingRectangle top.	deltaY ~= 0 		ifTrue: [self scrollBy: (deltaY abs + lineHeight - 1 truncateTo: lineHeight)									* deltaY sign]! !!ParagraphEditor methodsFor: 'new selection' stamp: 'di 12/17/1998 09:41'!insertAndSelect: aString at: anInteger	self replace: (anInteger to: anInteger - 1)		with: (Text string: (' ' , aString)					attributes: emphasisHere)		and: [self selectAndScroll]! !!ParagraphEditor methodsFor: 'private' stamp: 'sw 9/24/1999 15:41'!againOnce: indices	"Find the next occurrence of FindText.  If none, answer false.	Append the start index of the occurrence to the stream indices, and, if	ChangeText is not the same object as FindText, replace the occurrence by it.	Note that the search is case-sensitive for replacements, otherwise not."	| where |	where _ paragraph text findString: FindText startingAt: stopBlock stringIndex				caseSensitive: ((ChangeText ~~ FindText) or: [Preferences caseSensitiveFinds]).	where = 0 ifTrue: [^ false].	self deselect; selectInvisiblyFrom: where to: where + FindText size - 1.	ChangeText ~~ FindText ifTrue: [self zapSelectionWith: ChangeText].	indices nextPut: where.	self selectAndScroll.	^ true! !!ParagraphEditor methodsFor: 'private' stamp: 'rhi 4/27/2000 09:03'!getPluggableYellowButtonMenu: shiftKeyState	| customMenu |	^(customMenu _ view getMenu: shiftKeyState) notNil		ifTrue: [customMenu]		ifFalse:			[shiftKeyState				ifTrue: [self class shiftedYellowButtonMenu]				ifFalse: [self class yellowButtonMenu]]! !!ParagraphEditor methodsFor: 'private' stamp: 'sma 12/15/1999 11:32'!nextWord: position	| string index |	string _ paragraph text string.	index _ position.	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric]]		whileTrue: [index _ index + 1].	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric not]]		whileTrue: [index _ index + 1].	^ index! !!ParagraphEditor methodsFor: 'private' stamp: 'sma 12/15/1999 11:33'!previousWord: position	| string index |	string _ paragraph text string.	index _ position.	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric not]]		whileTrue: [index _ index - 1].	[(index between: 1 and: string size) and: [(string at: index) isAlphaNumeric]]		whileTrue: [index _ index - 1].	^ index + 1! !!ParagraphEditor methodsFor: 'do-its' stamp: 'sw 12/24/1998 12:42'!evaluateSelection	"Treat the current selection as an expression; evaluate it and return the result"	| result rcvr ctxt |	self lineSelectAndEmptyCheck: [^ ''].	(model respondsTo: #doItReceiver) 		ifTrue: [FakeClassPool adopt: model selectedClass.  "Include model pool vars if any"				rcvr _ model doItReceiver.				ctxt _ model doItContext]		ifFalse: [rcvr _ ctxt _ nil].	result _ rcvr class evaluatorClass new evaluate: self selectionAsStream				in: ctxt to: rcvr notifying: self				ifFail: [FakeClassPool adopt: nil.						^ #failedDoit].	FakeClassPool adopt: nil.	Smalltalk logChange: self selection string.	^ result! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 9/7/1999 11:25'!inspectIt	"1/13/96 sw: minor fixup"	| result |	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])			ifTrue: [view flash]			ifFalse: [result inspect].! !!ParagraphEditor methodsFor: 'do-its' stamp: 'di 9/7/1999 08:42'!objectsReferencingIt	"Open a list inspector on all objects that reference the object that results when the current selection is evaluated.  "	| result |	self terminateAndInitializeAround: [	result _ self evaluateSelection.	((result isKindOf: FakeClassPool) or: [result == #failedDoit])		ifTrue: [view flash]		ifFalse: [Smalltalk					browseAllObjectReferencesTo: result					except: #()					ifNone: [:obj | view topView flash]].	]! !!ParagraphEditor methodsFor: 'as yet unclassified' stamp: 'sbw 10/13/1999 22:40'!totalTextHeight	^paragraph boundingBox height! !!ParagraphEditor methodsFor: 'as yet unclassified' stamp: 'sbw 10/13/1999 22:33'!visibleHeight	^paragraph clippingRectangle height! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'di 4/17/1999 01:25'!initialize 	"Initialize the keyboard shortcut maps and the shared buffers	for copying text across views and managing again and undo.	Marked this method changed to trigger reinit"  	"ParagraphEditor initialize"	CurrentSelection _ UndoSelection _ FindText _ ChangeText _ Text new.	UndoMessage _ Message selector: #halt.	self initializeCmdKeyShortcuts.	self initializeShiftCmdKeyShortcuts.	self initializeTextEditorMenus! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'di 4/26/2000 20:32'!initializeTextEditorMenus   "ParagraphEditor initializeTextEditorMenus"		"Initialize the yellow button pop-up menu and corresponding messages."	TextEditorYellowButtonMenu _ SelectionMenu		labels: 'find...(f)find again (g)set search string (h)do again (j)undo (z)copy (c)cut (x)paste (v)paste...do it (d)print it (p)inspect it (i)accept (s)cancel (l)show bytecodesmore...' 		lines: #(3 5 9 12 14 15)		selections: #(find findAgain setSearchString again undo copySelection cut paste pasteRecent doIt printIt inspectIt accept cancel showBytecodes shiftedYellowButtonActivity)! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'jm 5/31/2003 15:56'!shiftedYellowButtonMenu	"Answer the menu to be presented when the yellow button is pressed while the shift key is down."	^ SelectionMenu fromArray: #(		('set font... (k)'					offerFontMenu)		('set style... (K)'					changeStyle)		('set alignment...'				chooseAlignment)		-		('explain'						explain)		('pretty print'					prettyPrint)		('file it in'						fileItIn)		('spawn (o)'						spawn)		-		('browse it (b)'					browseIt)		('senders of it (n)'				sendersOfIt)		('implementors of it (m)'		implementorsOfIt)		('references to it (N)'			referencesToIt)		('selectors containing it (W)'		methodNamesContainingIt)		('method strings with it (E)'		methodStringsContainingit)		('method source with it'			methodSourceContainingIt)		-		('save contents to file...'			saveContentsInFile)		-		('more...'						yellowButtonActivity))! !!ParagraphEditor class methodsFor: 'class initialization' stamp: 'di 4/17/1999 00:33'!yellowButtonMessages	^ TextEditorYellowButtonMenu selections! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jm 10/13/2002 11:51'!initializeCmdKeyShortcuts	"Initialize the (unshifted) command-key shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"ParagraphEditor initialize"	| cmdMap cmds |	cmdMap _ Array new: 256 withAll: #noop:.  "use temp in case of a crash"	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.			"end key"	cmdMap at: ( 8 + 1) put: #backspace:.			"ctrl-H or delete key"	cmdMap at: (11 + 1) put: #cursorPageUp:.			"page up key"	cmdMap at: (12 + 1) put: #cursorPageDown:.		"page down key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"cmd-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (32 + 1) put: #selectWord:.			"space bar key"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	'0123456789-=' do: [ :char | cmdMap at: (char asciiValue + 1) put: #changeEmphasis: ].	'([{''"<' do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose: ].	cmdMap at: ($, asciiValue + 1) put: #shiftEnclose:.	cmds _ #(		$a	selectAll:		$b	browseIt:		$c	copySelection:		$d	doIt:		$e	exchange:		$f	find:		$g	findAgain:		$h	setSearchString:		$i	inspectIt:		$j	doAgainOnce:		$k  offerFontMenu:		$l	cancel:		$m	implementorsOfIt:		$n	sendersOfIt:		$o	spawnIt:		$p	printIt:		$q	querySymbol:		$s	save:		$u	align:		$v	paste:		$w	backWord:		$x	cut:		$y	swapChars:		$z	undo:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1) put: (cmds at: i + 1).	].	CmdActions _ cmdMap! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'jm 12/9/2003 09:23'!initializeShiftCmdKeyShortcuts	"Initialize the shift-command-key (or control-key) shortcut table."	"NOTE: if you don't know what your keyboard generates, use Sensor kbdTest"	"wod 11/3/1998: Fix setting of cmdMap for shifted keys to actually use the 	capitalized versions of the letters.	TPR 2/18/99: add the plain ascii values back in for those VMs that don't return the shifted values."	| cmdMap cmds |	"shift-command and control shortcuts"	cmdMap _ Array new: 256 withAll: #noop:.  "use temp in case of a crash"	cmdMap at: ( 1 + 1) put: #cursorHome:.			"home key"	cmdMap at: ( 4 + 1) put: #cursorEnd:.			"end key"	cmdMap at: ( 8 + 1) put: #forwardDelete:.		"ctrl-H or delete key"	cmdMap at: (11 + 1) put: #cursorPageUp:.			"page up key"	cmdMap at: (12 + 1) put: #cursorPageDown:.		"page down key"	cmdMap at: (13 + 1) put: #crWithIndent:.			"ctrl-Return"	cmdMap at: (27 + 1) put: #selectCurrentTypeIn:.	"escape key"	cmdMap at: (28 + 1) put: #cursorLeft:.			"left arrow key"	cmdMap at: (29 + 1) put: #cursorRight:.			"right arrow key"	cmdMap at: (30 + 1) put: #cursorUp:.				"up arrow key"	cmdMap at: (31 + 1) put: #cursorDown:.			"down arrow key"	cmdMap at: (32 + 1) put: #selectWord:.			"space bar key"	cmdMap at: (45 + 1) put: #changeEmphasis:.		"cmd-sh-minus"	cmdMap at: (61 + 1) put: #changeEmphasis:.		"cmd-sh-plus"	cmdMap at: (127 + 1) put: #forwardDelete:.		"del key"	"Note: Command key overrides shift key, so, for example, cmd-shift-9 produces $9 not $("	'9[,''' do: [ :char | cmdMap at: (char asciiValue + 1) put: #shiftEnclose: ].	"({< and double-quote"	"Note: Must use cmd-9 or ctrl-9 to get '()' since cmd-shift-9 is a Mac FKey command."	cmdMap at: (27 + 1) put: #shiftEnclose:.	"ctrl-["	"'""''(' do: [ :char | cmdMap at: (char asciiValue + 1) put: #enclose:]."	cmds _ #(		$a	argAdvance:		$b	browseItHere:		$c	compareToClipboard:		$d	duplicate:		$e	methodStringsContainingIt:		$f	displayIfFalse:		$j	doAgainMany:		$k	changeStyle:		$n	referencesToIt:		$r	indent:		$l	outdent:		$s	search:		$t	displayIfTrue:		$u	changeLfToCr:		$v	pasteInitials:		$w	methodNamesContainingIt:		$x	makeLowercase:		$y	makeUppercase:		$z	makeCapitalized:	).	1 to: cmds size by: 2 do: [ :i |		cmdMap at: ((cmds at: i) asciiValue + 1) put: (cmds at: i + 1).			"plain keys"		cmdMap at: ((cmds at: i) asciiValue - 32 + 1) put: (cmds at: i + 1).		"shifted keys"		cmdMap at: ((cmds at: i) asciiValue - 96 + 1) put: (cmds at: i + 1)].	"ctrl keys"	ShiftCmdActions _ cmdMap.! !!ParagraphEditor class methodsFor: 'keyboard shortcut tables' stamp: 'sbw 10/8/1999 21:42'!specialShiftCmdKeys"Private - return array of key codes that represent single keys actingas if shift-command were also being pressed"^#(	1	"home"	3	"enter"	4	"end"	8	"backspace"	11	"page up"	12	"page down"	27	"escape"	28	"left arrow"	29	"right arrow"	30	"up arrow"	31	"down arrow"	127	"delete"	)! !!ParagraphEditor class methodsFor: 'clipboard access' stamp: 'di 4/26/2000 21:55'!chooseRecentClipping  "ParagraphEditor chooseRecentClipping"	"Choose by menu from among the recent clippings"	RecentClippings ifNil: [^ nil].	^ (SelectionMenu		labelList: (RecentClippings collect: [:txt | ((txt asString contractTo: 50)									copyReplaceAll: Character cr asString with: '\')									copyReplaceAll: Character tab asString with: '|'])		selections: RecentClippings) startUp.! !!ParagraphEditor class methodsFor: 'clipboard access' stamp: 'di 4/28/1999 11:30'!clipboardText	"Return the text currently in the clipboard. If the system clipboard is empty, or if it differs from the Smalltalk clipboard text, use the Smalltalk clipboard. This is done since (a) the Mac clipboard gives up on very large chunks of text and (b) since not all platforms support the notion of a clipboard."	| s |	s _ Smalltalk clipboardText.	(s isEmpty or: [s = CurrentSelection string])		ifTrue: [^ CurrentSelection]		ifFalse: [^ s asText]! !!ParagraphEditor class methodsFor: 'clipboard access' stamp: 'di 4/26/2000 20:54'!clipboardTextPut: text	"Set text currently on the clipboard.  Also export to Mac"	CurrentSelection _ text.	self noteRecentClipping: text.	Smalltalk clipboardText: CurrentSelection string! !!ParagraphEditor class methodsFor: 'clipboard access' stamp: 'di 4/26/2000 22:29'!noteRecentClipping: text	"Keep most recent clippings in a queue for pasteRecent (paste... command)"	text isEmpty ifTrue: [^ self].	text size > 50000 ifTrue: [^ self].	RecentClippings ifNil: [RecentClippings _ OrderedCollection new].	(RecentClippings includes: text) ifTrue: [^ self].	RecentClippings addFirst: text.	[RecentClippings size > 5] whileTrue: [RecentClippings removeLast].! !I appear as the actual parameter in a HatBlockMorph. ParameterReferenceMorphs can be pulled out of me by dragging. The parameter name can be changed by shift-clicking either on me or on any of the ParameterReferenceMorphs that refer to me.!!ParameterMorph methodsFor: 'initialization' stamp: 'jm 8/24/2003 17:39'!initialize	super initialize.	self		isPartsBin: true;		color: Color transparent;		borderWidth: 0.! !!ParameterMorph methodsFor: 'accessing' stamp: 'jm 8/24/2003 17:39'!name	^ name! !!ParameterMorph methodsFor: 'accessing' stamp: 'jm 8/24/2003 17:39'!name: aString	name _ aString.! !!ParameterMorph methodsFor: 'event handling' stamp: 'jm 8/24/2003 17:42'!handlesMouseDown: evt	^ evt yellowButtonPressed! !!ParameterMorph methodsFor: 'event handling' stamp: 'jm 8/24/2003 17:43'!mouseDown: evt	| menu |	menu _ CustomMenu new.	menu add: 'remove parameter' action: #removeParameter.	menu invokeOn: self.! !!ParameterMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:30'!fieldsVersion	^ 1! !!ParameterMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:30'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		name	) from: anObjStream.! !!ParameterMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:30'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		name	) on: anObjStream.! !!ParameterMorph methodsFor: 'other' stamp: 'jm 8/24/2003 20:21'!fixParameterLayout	| paramRefMorph |	paramRefMorph _ self submorphs detect: [:m | m isKindOf: ParameterReferenceMorph] ifNone: [^ self].	paramRefMorph fixArgLayout.	self extent: paramRefMorph extent.! !!ParameterMorph methodsFor: 'other' stamp: 'jm 8/24/2003 17:46'!removeParameter	"Remove this parameter from its HatBlockMorph."	self owner removeParameter: self.! !!ParameterMorph methodsFor: 'other' stamp: 'jm 8/24/2003 17:51'!wantsDroppedMorph: aMorph event: evt	^ false! !I represent the use of a parameter within a script.!!ParameterReferenceMorph methodsFor: 'initialization' stamp: 'jm 8/24/2003 19:48'!initialize	super initialize.	self		color: (Color r: 0.4 g: 1.0 b: 0.4);		borderWidth: 1;		borderColor: (Color r: 0 g: 0.65 b: 0);		extent: 20@17.	labelMorph _ (UpdatingStringMorph contents: '')		getSelector: #name;		putSelector: #name:;		useStringFormat.	self addMorph: labelMorph.! !!ParameterReferenceMorph methodsFor: 'accessing' stamp: 'jm 8/24/2003 19:34'!isReporter	^ true! !!ParameterReferenceMorph methodsFor: 'accessing' stamp: 'jm 8/24/2003 19:32'!parameter	labelMorph ifNil: [^ nil].	^ labelMorph target! !!ParameterReferenceMorph methodsFor: 'accessing' stamp: 'jm 8/24/2003 19:47'!parameter: aParameterMorph	labelMorph target: aParameterMorph.	labelMorph startStepping.	self fixArgLayout.! !!ParameterReferenceMorph methodsFor: 'dropping/grabbing' stamp: 'jm 8/24/2003 19:41'!aboutToBeGrabbedBy: aHandMorph	"If I'm being used as an argument, replace myself with an appropriate argument morph. Copied from WatcherMorph."	| m |	(owner isKindOf: CommandBlockMorph) ifTrue: [		"if I was being used as argument, replace myself with a generic argument morph"		m _ owner argMorphToReplace: self.		m ifNotNil: [owner replaceArgMorph: self by: m]].! !!ParameterReferenceMorph methodsFor: 'dropping/grabbing' stamp: 'jm 8/24/2003 17:59'!rootForGrabOf: aMorph	"Allow myself to be extracted."	(owner notNil and: [owner isPartsBin])		ifTrue: [^ super rootForGrabOf: aMorph]		ifFalse: [^ self].! !!ParameterReferenceMorph methodsFor: 'event handling' stamp: 'jm 8/24/2003 19:47'!fixArgLayout	self width: labelMorph width + 6.	labelMorph position: self position + (3@2).! !!ParameterReferenceMorph methodsFor: 'event handling' stamp: 'jm 8/24/2003 20:25'!handlesMouseDown: evt	^ evt yellowButtonPressed! !!ParameterReferenceMorph methodsFor: 'event handling' stamp: 'jm 8/24/2003 20:24'!mouseDown: evt	| menu |	menu _ CustomMenu new.	menu add: 'delete' action: #delete.	menu invokeOn: self.! !!ParameterReferenceMorph methodsFor: 'event handling' stamp: 'jm 8/24/2003 19:45'!wantsKeyboardFocusFor: aSubmorph	"Indicates that we don't want keyboard focus unless the shift key is pressed.  That way we don't allow editing the name of the parameter unless the user presses shift."	^ Sensor shiftPressed and: [aSubmorph wouldAcceptKeyboardFocus]! !This superclass of most compiler/decompiler classes declares common class variables, default messages, and the code emitters for jumps. Some of the class variables are initialized here; the rest are initialized in class VariableNode.!!ParseNode methodsFor: 'testing' stamp: 'tk 8/2/1999 18:39'!isSelfPseudoVariable		"Overridden in VariableNode."	^false! !!ParseNode methodsFor: 'testing' stamp: 'di 10/12/1999 15:28'!isTemp	^ false! !!ParseNode methodsFor: 'printing' stamp: 'sw 11/15/1999 22:23'!printCommentOn: aStream indent: indent 	| thisComment |	comment == nil ifTrue: [^ self].	aStream withAttributes: (Preferences syntaxAttributesFor: #comment)		do: [1 to: comment size do: 				[:index | 				index > 1 ifTrue: [aStream crtab: indent].				aStream nextPut: $".				thisComment _ comment at: index.				self printSingleComment: thisComment					on: aStream					indent: indent.				aStream nextPut: $"]].	comment _ nil! !!ParseNode methodsFor: 'private' stamp: 'sma 5/28/2000 10:47'!nextWordFrom: aStream setCharacter: aBlock	| outStream char |	outStream _ WriteStream on: (String new: 16).	[(aStream peekFor: Character space) 		or: [aStream peekFor: Character tab]] whileTrue.	[aStream atEnd		or:			[char _ aStream next.			char = Character cr or: [char = Character space]]]		whileFalse: [outStream nextPut: char].	aBlock value: char.	^ outStream contents! !!ParseNode methodsFor: 'private' stamp: 'sma 5/28/2000 10:45'!printSingleComment: aString on: aStream indent: indent 	"Print the comment string, assuming it has been indented indent tabs.	Break the string at word breaks, given the widths in the default	font, at 450 points."	| readStream word position lineBreak font wordWidth tabWidth spaceWidth lastChar |	readStream _ ReadStream on: aString.	font _ TextStyle default defaultFont.	tabWidth _ TextConstants at: #DefaultTab.	spaceWidth _ font widthOf: Character space.	position _ indent * tabWidth.	lineBreak _ 450.	[readStream atEnd]		whileFalse: 			[word _ self nextWordFrom: readStream setCharacter: [:lc | lastChar _ lc].			wordWidth _ word inject: 0 into: [:width :char | width + (font widthOf: char)].			position _ position + wordWidth.			position > lineBreak				ifTrue: 					[aStream crtab: indent.					position _ indent * tabWidth + wordWidth + spaceWidth.					lastChar = Character cr						ifTrue: [[readStream peekFor: Character tab] whileTrue].					word isEmpty ifFalse: [aStream nextPutAll: word; space]]				ifFalse: 					[aStream nextPutAll: word.					readStream atEnd						ifFalse: 							[position _ position + spaceWidth.							aStream space].					lastChar = Character cr						ifTrue: 							[aStream crtab: indent.							position _ indent * tabWidth.							[readStream peekFor: Character tab] whileTrue]]]! !I keep track of the current and high position of the stack that will be needed by code being compiled.!I parse Smalltalk syntax and create a MethodNode that is the root of the parse tree. I look one token ahead.!!Parser methodsFor: 'public access' stamp: 'jm 5/23/2003 11:31'!parse: sourceStream class: class noPattern: noPattern context: ctxt notifying: req ifFail: aBlock 	"Answer a MethodNode for the argument, sourceStream, that is the root of 	a parse tree. Parsing is done with respect to the argument, class, to find 	instance, class, and pool variables; and with respect to the argument, 	ctxt, to find temporary variables. Errors in parsing are reported to the 	argument, req, if not nil; otherwise aBlock is evaluated. The argument 	noPattern is a Boolean that is true if the the sourceStream does not 	contain a method header (i.e., for DoIts)."	 | meth |	self init: sourceStream notifying: req failBlock: [^aBlock value].	doitFlag _ noPattern.	encoder _ Encoder new init: class context: ctxt notifying: self.	failBlock _ aBlock.	meth _ self method: noPattern context: ctxt.	encoder _ failBlock _ requestor _ parseNode _ nil. "break cycles & mitigate refct overflow"	^ meth! !!Parser methodsFor: 'public access' stamp: 'tk 2/4/2000 18:39'!parseArgsAndTemps: aString notifying: req 	"Parse the argument, aString, notifying req if an error occurs. Otherwise, 	answer a two-element Array containing Arrays of strings (the argument 	names and temporary variable names)."	aString == nil ifTrue: [^#()].	doitFlag _ false.		"Don't really know if a doit or not!!"	^self		initPattern: aString		notifying: req		return: [:pattern | (pattern at: 2) , self temporaries]! !!Parser methodsFor: 'expression types' stamp: 'sma 2/27/2000 22:38'!blockExpression	"[ ({:var} |) (| {temps} |) (statements) ] => BlockNode."	| variableNodes temporaryBlockVariables |	variableNodes _ OrderedCollection new.	"Gather parameters."	[self match: #colon] whileTrue: [variableNodes addLast: (encoder autoBind: self argumentName)].	(variableNodes size > 0 & (hereType ~~ #rightBracket) and: [(self match: #verticalBar) not]) ifTrue: [^self expected: 'Vertical bar'].	temporaryBlockVariables _ self temporaryBlockVariables.	self statements: variableNodes innerBlock: true.	parseNode temporaries: temporaryBlockVariables.	(self match: #rightBracket) ifFalse: [^self expected: 'Period or right bracket'].	"The scope of the parameters and temporary block variables is no longer active."	temporaryBlockVariables do: [:variable | variable scope: -1].	variableNodes do: [:variable | variable scope: -1]! !!Parser methodsFor: 'expression types' stamp: 'di 3/8/2000 09:36'!braceExpression	" { elements } => BraceNode."	| elements locations loc more |	elements _ OrderedCollection new.	locations _ OrderedCollection new.	self advance.	more _ hereType ~~ #rightBrace.	[more]		whileTrue: 			[loc _ hereMark + requestorOffset.			self expression				ifTrue: 					[elements addLast: parseNode.					locations addLast: loc]				ifFalse:					[^self expected: 'Variable or expression'].			(self match: #period)				ifTrue: [more _ hereType ~~ #rightBrace]				ifFalse: [more _ false]].	parseNode _ BraceNode new elements: elements sourceLocations: locations.	(self match: #rightBrace)		ifFalse: [^self expected: 'Period or right brace'].	^true! !!Parser methodsFor: 'expression types' stamp: 'di 11/19/1999 07:43'!expression	(hereType == #word and: [tokenType == #leftArrow])		ifTrue: [^ self assignment: self variable].	hereType == #leftBrace		ifTrue: [self braceExpression]		ifFalse: [self primaryExpression ifFalse: [^ false]].	(self messagePart: 3 repeat: true)		ifTrue: [hereType == #semicolon ifTrue: [self cascade]].	^ true! !!Parser methodsFor: 'expression types' stamp: 'sma 2/10/2000 23:29'!pattern: fromDoit inContext: ctxt 	" unarySelector | binarySelector arg | keyword arg {keyword arg} => 	{selector, arguments, precedence}."	| args selector |	doitFlag _ fromDoit.	fromDoit 		ifTrue: 			[ctxt == nil				ifTrue: [^Array with: #DoIt with: #() with: 1]				ifFalse: [^Array 							with: #DoItIn: 							with: (Array 									with: (encoder encodeVariable: 'homeContext')) 									with: 3]].	hereType == #word 		ifTrue: [^Array with: self advance asSymbol with: #() with: 1].	(hereType == #binary or: [hereType == #verticalBar])		ifTrue: 			[selector _ self advance asSymbol.			args _ Array with: (encoder bindArg: self argumentName).			^Array with: selector with: args with: 2].	hereType == #keyword		ifTrue: 			[selector _ WriteStream on: (String new: 32).			args _ OrderedCollection new.			[hereType == #keyword]				whileTrue: 					[selector nextPutAll: self advance.					args addLast: (encoder bindArg: self argumentName)].			^Array with: selector contents asSymbol with: args with: 3].	^self expected: 'Message pattern'! !!Parser methodsFor: 'expression types' stamp: 'tk 1/3/2000 13:56'!temporaries	" [ '|' (variable)* '|' ]"	| vars theActualText |	(self match: #verticalBar) ifFalse: 		["no temps"		doitFlag ifTrue: [requestor				ifNil: [tempsMark _ 1]				ifNotNil: [tempsMark _ requestor selectionInterval first].			^ #()].		tempsMark _ prevMark + prevToken.		tempsMark > 0 ifTrue:			[theActualText _ source contents.			[tempsMark < theActualText size and: [(theActualText at: tempsMark) isSeparator]]				whileTrue: [tempsMark _ tempsMark + 1]].			^ #()].	vars _ OrderedCollection new.	[hereType == #word]		whileTrue: [vars addLast: (encoder bindTemp: self advance)].	(self match: #verticalBar) ifTrue: 		[tempsMark _ prevMark.		^ vars].	^ self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types' stamp: 'crl 2/26/1999 12:22'!temporaryBlockVariables	"Scan and answer temporary block variables."	| variables |	(self match: #verticalBar) ifFalse: [		"There are't any temporary variables."		^#()].	variables _ OrderedCollection new.	[hereType == #word] whileTrue: [variables addLast: (encoder bindBlockTemp: self advance)].	(self match: #verticalBar) ifTrue: [^variables].	^self expected: 'Vertical bar'! !!Parser methodsFor: 'expression types' stamp: 'di 12/4/1999 21:04'!variable	| varName varStart varEnd |	varStart _ self startOfNextToken + requestorOffset.	varName _ self advance.	varEnd _ self endOfLastToken + requestorOffset.	^ encoder encodeVariable: varName		sourceRange: (varStart to: varEnd)		ifUnknown: [self correctVariable: varName interval: (varStart to: varEnd)]! !!Parser methodsFor: 'scanning' stamp: 'sn 9/19/97 19:32'!advance    | this |    prevMark _ hereMark.    prevToken _ "Now means prev size"        self previousTokenSize.    this _ here.    here _ token.    hereType _ tokenType.    hereMark _ mark.    self scanToken.    ^this! !!Parser methodsFor: 'error handling'!notify: string at: location	requestor isNil		ifTrue: [(encoder == self or: [encoder isNil]) ifTrue: [^ self fail  "failure setting up syntax error"].				SyntaxError 					errorInClass: encoder classEncoding					withCode: 						(source contents							copyReplaceFrom: location							to: location - 1							with: string , ' ->')					doitFlag: doitFlag]		ifFalse: [requestor					notify: string , ' ->'					at: location					in: source].	^self fail! !!Parser methodsFor: 'error handling' stamp: 'di 2/9/1999 15:43'!offEnd: aString 	"Notify a problem beyond 'here' (in lookAhead token). Don't be offEnded!!"	requestorOffset == nil		ifTrue: [^ self notify: aString at: mark]		ifFalse: [^ self notify: aString at: mark + requestorOffset]! !!Parser methodsFor: 'error correction' stamp: 'tk 8/11/1998 21:52'!correctSelector: proposedKeyword wordIntervals: spots exprInterval: expInt ifAbort: abortAction fullSearch: tryHard 	"Correct the proposedKeyword to some selector symbol, correcting the original text if such action is indicated.  abortAction is invoked if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| alternatives aStream choice correctSelector userSelection lines firstLine |	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [ ^ proposedKeyword asSymbol ].	userSelection _ requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	requestor select.	alternatives _ tryHard		ifFalse: [ Symbol possibleSelectorsFor: proposedKeyword ]		ifTrue: [ Symbol morePossibleSelectorsFor: proposedKeyword ].	aStream _ WriteStream on: (String new: 200).	aStream nextPutAll: (proposedKeyword contractTo: 35); cr.	firstLine _ 1. 	alternatives do:		[:sel | aStream nextPutAll: (sel contractTo: 35); nextPut: Character cr].	aStream nextPutAll: 'cancel'.	lines _ Array with: firstLine with: (alternatives size + firstLine).	tryHard ifFalse:		[aStream cr; nextPutAll: 'try harder'.		lines _ lines copyWith: (alternatives size + firstLine + 1)].		choice _ (PopUpMenu labels: aStream contents lines: lines)		startUpWithCaption: 'Unknown selector, please confirm, correct, or cancel'.	tryHard not & (choice > lines last) ifTrue:		[^ self correctSelector: proposedKeyword wordIntervals: spots				exprInterval: expInt ifAbort: abortAction fullSearch: true ]. 	(choice = 0) | (choice > (lines at: 2))		ifTrue: [ ^ abortAction value ].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice = 1 ifTrue: [ ^ proposedKeyword asSymbol ].	correctSelector _ alternatives at: choice - 1.	self substituteSelector: correctSelector keywords wordIntervals: spots.	((proposedKeyword last ~~ $:) and: [correctSelector last == $:]) ifTrue: [		^ abortAction value].	^ correctSelector.! !!Parser methodsFor: 'error correction' stamp: 'sw 11/10/1999 13:26'!correctVariable: proposedVariable interval: spot	"Correct the proposedVariable to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps, and uppercase variables as Globals or ClassVars,	depending on whether the context is nil (class=UndefinedObject).	Spot is the interval within the test stream of the variable."	| alternatives aStream choice userSelection temp binding globalToo |	"If we can't ask the user for correction, make it undeclared"	self interactive ifFalse: [^ encoder undeclared: proposedVariable].	temp _ proposedVariable first isLowercase.	"First check to see if the requestor knows anything about the variable"	(temp and: [(binding _ requestor bindingOf: proposedVariable) notNil])		ifTrue: [^ encoder global: binding name: proposedVariable].	userSelection _ requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	alternatives _ encoder possibleVariablesFor: proposedVariable.	aStream _ WriteStream on: (String new: 200).	globalToo _ 0.	aStream nextPutAll: 'declare ' ,		(temp ifTrue: ['temp']			ifFalse: [encoder classEncoding == UndefinedObject					ifTrue: ['Global']					ifFalse: [globalToo _ 1.  'Class Variable']]); cr.	globalToo = 1 ifTrue: [aStream nextPutAll: 'declare Global'; cr].	alternatives do:		[:sel | aStream nextPutAll: sel; cr].	aStream nextPutAll: 'cancel'.	choice _ (PopUpMenu				labels: aStream contents				lines: (Array with: (globalToo + 1) with: (globalToo + alternatives size + 1)))		startUpWithCaption:(('Unknown variable: ', proposedVariable, 'please correct, or cancel:') asText makeBoldFrom: 19 to: 19 + proposedVariable size).	(choice = 0) | (choice > (globalToo + alternatives size + 1))		ifTrue: [^ self fail].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice =1 ifTrue:			[temp ifTrue: [^ self declareTempAndPaste: proposedVariable]				ifFalse: [encoder classEncoding == UndefinedObject					ifTrue: [^ self declareGlobal: proposedVariable]					ifFalse: [^ self declareClassVar: proposedVariable]]].	(choice = 2) & (globalToo = 1) ifTrue: [^ self declareGlobal: proposedVariable].	"Spelling correction"	self substituteWord: (alternatives at: choice-1-globalToo)			wordInterval: spot			offset: 0.	^ encoder encodeVariable: (alternatives at: choice-1-globalToo)! !!Parser methodsFor: 'error correction' stamp: 'di 10/12/1999 15:17'!declareTempAndPaste: name	| insertion tabbed |	(requestor text string at: tempsMark) = $|				ifTrue:  "Paste it before the second vertical bar"					[insertion _ name, ' '.					(requestor text string at: tempsMark-1) isSeparator						ifFalse: [insertion _ ' ', insertion].					tempsMark _ tempsMark +						(self substituteWord: insertion							wordInterval: (tempsMark to: tempsMark-1)							offset: 0)]				ifFalse:  "No bars - insert some with CR, tab"					[insertion _ '| ' , name , ' |'.					tabbed _ tempsMark > 1						and: [(requestor text string at: tempsMark-1) = Character tab].					tabbed						ifTrue: [insertion _ insertion , (String with: Character tab)].					tempsMark _ tempsMark +						(self substituteWord: insertion							wordInterval: (tempsMark to: tempsMark-1)							offset: 0)						- (tabbed ifTrue: [3] ifFalse: [2])].			^ encoder bindAndJuggle: name! !!Parser methodsFor: 'error correction' stamp: 'jm 5/23/2003 11:36'!removeUnusedTemps 	| str end start | 	str _ requestor text string.	((tempsMark between: 1 and: str size)		and: [(str at: tempsMark) = $|]) ifFalse: [^ self].	encoder unusedTempNames do:		[:temp |		((PopUpMenu labels: 'yes\no' withCRs) startUpWithCaption:			((temp , ' appears to beunused in this method.OK to remove it?') asText makeBoldFrom: 1 to: temp size))			= 1		ifTrue:		[(encoder encodeVariable: temp) isUndefTemp			ifTrue:			[end _ tempsMark.			["Beginning at right temp marker..."			start _ end - temp size + 1.			end < temp size or: [temp = (str copyFrom: start to: end)					and: [(str at: start-1) isSeparator & (str at: end+1) isSeparator]]]			whileFalse:				["Search left for the unused temp"				end _ requestor nextTokenFrom: end direction: -1].			end < temp size ifFalse:				[(str at: start-1) = $  ifTrue: [start _ start-1].				requestor correctFrom: start to: end with: ''.				str _ str copyReplaceFrom: start to: end with: ''. 				tempsMark _ tempsMark - (end-start+1)]]			ifFalse:			[PopUpMenu notify:'You''ll first have to remove thestatement where it''s stored into']]]! !!Parser methodsFor: 'private' stamp: 'di 3/29/1999 13:10'!previousTokenSize	"Answer the size of the previous token. Bugfix for Strings."	| hereSize |	hereType == #number ifTrue: [^ mark - prevMark].	hereSize _ here ifNil: [0] ifNotNil: [here size].	hereType == #string ifTrue: [^ hereSize + 2].   "One for each single quote"	^ hereSize! !!Parser methodsFor: 'primitives' stamp: 'jm 10/30/2002 19:28'!primitiveDeclarations	| prim module |	(self matchToken: 'primitive:') ifFalse: [^ self expected: 'primitive:'].	prim _ here.	(self match: #number) ifTrue: [^ prim].	"indexed primitives"	(self match: #string) ifFalse: [^ self expected: 'Integer or String'].	(self matchToken: 'module:') ifTrue: [		module _ here.		(self match: #string) ifFalse: [^ self expected: 'String'].		module _ module asSymbol].	encoder litIndex: (Array with: module with: prim asSymbol with: 0 with: 0).	^ 117! !A morph whose submorphs comprise a paste-up of rectangular subparts which "show through".Facilities commonly needed on pages of graphical presentations and on simulation playfields, such as the painting of new objects, turtle trails, gradient fills, background paintings, parts-bin behavior, collision-detection, etc., are (or will be) provided.A World, the entire Smalltalk screen, is a PasteUpMorph.  A World responds true to isWorld.  Morph subclasses that have specialized menus (BookMorph) build them in the message addBookMenuItemsTo:hand:.  A PasteUpMorph that is a world, builds its menu in HandMorph buildWorldMenu.This class is young and still under construction, and a number of its (many) instance variables are not yet fully deployed.!!PasteUpMorph methodsFor: 'initialization' stamp: 'jm 2/4/2003 13:30'!initialize	super initialize.	borderColor _ Color r: 0.861 g: 1.0 b: 0.722.	color _ Color r: 0.8 g: 1.0 b: 0.6.	bounds _ 0@0 corner: 50@40.	cursor _ 1.	padding _ 3.	autoLineLayout _ false.	self enableDragNDrop: true.! !!PasteUpMorph methodsFor: 'initialization' stamp: 'jm 7/17/2003 23:05'!releaseCachedState	super releaseCachedState.	turtleTrailsForm ifNotNil: [turtleTrailsForm hibernate].! !!PasteUpMorph methodsFor: 'classification' stamp: 'di 7/27/1999 10:46'!isWorldMorph	^ worldState notNil! !!PasteUpMorph methodsFor: 'classification' stamp: 'di 7/27/1999 10:46'!world	worldState == nil ifTrue: [^ super world].	^ self! !!PasteUpMorph methodsFor: 'cursor' stamp: 'di 7/27/1999 10:24'!cursor 	^ cursor! !!PasteUpMorph methodsFor: 'cursor' stamp: 'jm 11/24/2002 18:47'!valueAtCursor: aMorph	submorphs isEmpty ifTrue: [^ self].	cursor _ ((cursor truncated max: 1) min: submorphs size).	self replaceSubmorph: self valueAtCursor by: aMorph.! !!PasteUpMorph methodsFor: 'display' stamp: 'jm 7/19/2003 14:55'!drawOn: aCanvas	"Update and draw the turtleTrails form. See the comment in updateTrailsForm."	super drawOn: aCanvas.	self updateTrailsForm.	turtleTrailsForm ifNotNil: [		(aCanvas copyClipRect: self bounds)			paintImage: turtleTrailsForm at: self position].	(submorphs size > 0 and: [self indicateCursor]) ifTrue: [		aCanvas			frameRectangle: self selectedRect			width: 2			color: Color black].! !!PasteUpMorph methodsFor: 'display' stamp: 'ar 5/29/1999 05:03'!drawSubmorphsOn: aCanvas	aCanvas clipBy: self innerBounds			during:[:clippedCanvas| super drawSubmorphsOn: clippedCanvas].! !!PasteUpMorph methodsFor: 'display' stamp: 'jm 11/24/2002 10:35'!pseudoDraw: aRectangle on: aCanvas	| c |	c _ aCanvas copyClipRect: aRectangle.	color isTranslucent ifTrue: [c fillColor: Color black].	c fillRectangle: bounds color: color.	turtleTrailsForm ifNotNil: [c paintImage: turtleTrailsForm at: 0@0].	^ c! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'jm 10/13/2002 19:26'!acceptDroppingMorph: aMorph event: evt	self isWorldMorph		ifTrue:			["Add the given morph to this world and start stepping it if it wants to be."			self addMorphFront: aMorph.			(aMorph fullBounds intersects: ("0@0 extent:" self viewBox "extent")) ifFalse:				[self beep.  aMorph position: self bounds center]]		ifFalse:			[self privateAddMorph: aMorph atIndex: (self insertionIndexFor: aMorph).			self changed.			self layoutChanged].	aMorph submorphsDo: [:m | (m isKindOf: HaloMorph) ifTrue: [m delete]].	self autoLineLayout ifTrue: [self fixLayout].	self isPartsBin		ifTrue:			[aMorph isPartsDonor: true.			aMorph allMorphsDo: [:m | m stopStepping]]		ifFalse:			[self world startSteppingSubmorphsOf: aMorph].! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'panda 4/25/2000 15:48'!allowSubmorphExtraction	^self dragNDropEnabled and: [isPartsBin ~~ true]! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'sw 5/17/2000 12:05'!repelsMorph: aMorph event: ev	aMorph willingToBeEmbeddedUponLanding ifFalse: [^ false].	self dragNDropEnabled ifFalse: [^ true].	(self wantsDroppedMorph: aMorph event: ev) ifFalse: [^ true].	^ super repelsMorph: aMorph event: ev "consults #repelling flag"! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'jm 12/8/2003 11:41'!rootForGrabOf: aMorph	"If open to drag-n-drop, allow the given submorph to be extracted. If I am a parts bin answer a new copy of it."	| root |	root _ aMorph.	[root = self] whileFalse: [		root owner == self ifTrue: [			self isPartsBin ifTrue: [^ root fullCopy].			self dragNDropEnabled ifTrue: [^ root]].		root _ root owner].	^ super rootForGrabOf: aMorph! !!PasteUpMorph methodsFor: 'dropping/grabbing' stamp: 'jm 10/13/2002 18:23'!wantsDroppedMorph: aMorph event: evt	aMorph willingToBeEmbeddedUponLanding ifFalse: [^ false].	self isHidden ifTrue: [^ false].	self dragNDropEnabled ifFalse: [^ false].	(self bounds containsPoint: (self pointFromWorld: evt cursorPoint)) ifFalse: [^ false].	^ true! !!PasteUpMorph methodsFor: 'layout' stamp: 'sw 3/24/1999 14:11'!addCenteredAtBottom: aMorph offset: anOffset	"Add aMorph beneath all other morphs currently in the receiver, centered horizontally, with the vertical offset from the bottom of the previous morph given by anOffset"	| curBot |	curBot _ 0.	submorphs do: [:m | curBot _ curBot max: m bottom].	self addMorphBack: aMorph.	aMorph position: ((self center x - (aMorph width // 2)) @ (curBot + anOffset))! !!PasteUpMorph methodsFor: 'layout' stamp: 'sw 6/4/2000 23:58'!fixLayout	"Pack my submorphs into rows that fit within my width, if autoLineLayout is true."	| nextY i morphsForThisRow |	self invalidRect: bounds.	self autoLineLayout ifTrue:		[nextY _ bounds top + borderWidth.		i _ 1.		[i <= submorphs size] whileTrue:			[morphsForThisRow _ self rowMorphsStartingAt: i.			nextY _ self layoutRow: morphsForThisRow lastRowBase: nextY.			i _ i + morphsForThisRow size]]! !!PasteUpMorph methodsFor: 'layout' stamp: 'sw 8/3/1998 13:43'!laySubpartsOutInOneRow	| aPosition |	aPosition _ 0 @ padding.	submorphs do:	[:aMorph |		aMorph position: (aPosition + (padding @ 0)).		aPosition _ aMorph topRight]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'jm 7/20/2003 20:39'!addCustomMenuItems: menu hand: aHandMorph	super addCustomMenuItems: menu hand: aHandMorph.	menu add: 'clear pen trails' action: #clearTurtleTrails.	menu add: 'playfield options...' target: self action: #presentPlayfieldMenu.! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/11/1999 16:58'!autoLineLayoutString	^ self autoLineLayout		ifTrue:			['stop doing auto-line-layout']		ifFalse:			['start doing auto-line-layout']! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 1/10/2000 16:44'!defersHaloOnClickTo: aSubMorph	"If a cmd-click on aSubMorph would make it a preferred recipient of the halo, answer true"	^ true	! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/11/1999 16:54'!indicateCursorString	^ self indicateCursor		ifTrue:			['stop indicating cursor']		ifFalse:			['start indicating cursor']! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'jm 2/4/2003 13:36'!isOpenForDragNDropString	^ self dragNDropEnabled		ifTrue: ['stop being open to drag & drop']		ifFalse: ['start being open to drag & drop'].! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/11/1999 16:55'!isPartsBinString	^ self isPartsBin		ifTrue:			['stop being a parts bin']		ifFalse:			['start being a parts bin']! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 6/11/1999 15:05'!mouseOverHalosString	^ self wantsMouseOverHalos		ifTrue:			['stop using mouse-over halos']		ifFalse:			['start using mouse-over halos']! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'jm 12/8/2003 11:49'!playfieldOptionsMenu	| aMenu isWorld |	isWorld _ self isWorldMorph.	aMenu _ MenuMorph new defaultTarget: self.	aMenu addStayUpItem.	#(	(autoLineLayoutString	toggleAutoLineLayout			'whether submorphs should automatically be laid out in lines')		(indicateCursorString	toggleIndicateCursor			'whether the "current" submorph should be indicated with a dark black border')		(isPartsBinString		toggleIsPartsBin			'whether dragging an object from the interior should produce a COPY of the object')		(isOpenForDragNDropString	toggleDragNDrop			'whether objects can be dropped into and dragged out of me')		(mouseOverHalosString	toggleMouseOverHalos			'whether objects should put up halos when the mouse is over them')	) do: [:triplet |		(isWorld not or: [#toggleMouseOverHalos = triplet second]) ifTrue: [			aMenu addUpdating: triplet first action: triplet second.			aMenu balloonTextForLastItem: triplet third]]. 	isWorld ifFalse: [		aMenu add: 'behave like a Holder' action: #becomeLikeAHolder.		aMenu balloonTextForLastItem:			'Set properties to make this object nicely set up to hold frames of a scripted animation.'].	aMenu addTitle: 'playfield options...'.	^ aMenu! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'jm 5/31/2003 16:31'!presentPlayfieldMenu	self playfieldOptionsMenu popUpForHand: self activeHand.! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 12/30/1999 19:51'!seeksOutHalo	"Answer whether the receiver is an eager recipient of the halo"	^ false! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'jm 10/13/2002 18:23'!wantsHaloFor: aSubMorph	"Answer whether the receiver wishes for a mouse-over halo to be produced for aSubMorph"	^ wantsMouseOverHalos == true and:	  [self isHidden not and:	  [isPartsBin ~~ true and:	  [self dragNDropEnabled and:	  [self isWorldMorph not]]]]! !!PasteUpMorph methodsFor: 'menu & halo' stamp: 'sw 1/25/2000 17:44'!wantsHaloFromClick	^ (owner isKindOf: SystemWindow) not! !!PasteUpMorph methodsFor: 'model' stamp: 'jm 3/13/2003 17:04'!model	"Return nil. Models are being eliminated from PasteUpMorph."	^ nil! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/16/1999 14:06'!becomeLikeAHolder	(self autoLineLayout and: [self indicateCursor])		ifTrue:			[^ self inform: 'This view is ALREADYbehaving like a holder, whichis to say, it is set to indicate thecursor and to have auto-line-layout.']. 	self behaveLikeHolder	! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/16/1999 14:06'!behaveLikeHolder 	self resizeToFit: true; autoLineLayout: true; indicateCursor: true;		fixLayout; layoutChanged	! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/3/2000 01:08'!resizeToFit	"Answer whether the receiver exhibits the #resizeToFit property.  Formerly of greater use, this is an obscure backwater not meriting much attention.  For most practical purposes, this is just always false.  The feature doesn't quite work right even where used, e.g. in the Tabs sorter"	^ resizeToFit ifNil: [resizeToFit _ false]! !!PasteUpMorph methodsFor: 'options' stamp: 'jm 2/4/2003 13:32'!setPartsBinStatusTo: aBoolean	isPartsBin _ aBoolean.	isPartsBin		ifTrue: [			self enableDragNDrop: true.			submorphs do: [:m | m stopStepping; isPartsDonor: true]]		ifFalse: [			submorphs do: [:m | m isPartsDonor: false].			self world ifNotNil: [self world startSteppingSubmorphsOf: self]].! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/16/1999 09:06'!toggleIndicateCursor	indicateCursor _ self indicateCursor not.	self fixLayout.	self layoutChanged.	self changed.! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 9/30/1998 17:24'!toggleIsPartsBin	"Not entirely happy with the openToDragNDrop not being directly manipulable etc, but still living with it for now."	self setPartsBinStatusTo: self isPartsBin not! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 1/27/2000 14:51'!toggleMouseOverHalos	wantsMouseOverHalos _ self wantsMouseOverHalos not! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/5/1998 18:13'!wantsMouseOverHalos	^ wantsMouseOverHalos == true! !!PasteUpMorph methodsFor: 'options' stamp: 'sw 6/5/1998 18:13'!wantsMouseOverHalos: aBoolean	wantsMouseOverHalos _ aBoolean! !!PasteUpMorph methodsFor: 'painting' stamp: 'jm 12/9/2003 16:55'!paintingBoundsAround: aPoint	"Return a rectangle for painting centered on the given point. Both the argument point and the result rectangle are in world coordinates."	| paintExtent maxPaintArea myBnds |	paintExtent _ 1024 @ 768.	maxPaintArea _ paintExtent x * paintExtent y.	myBnds _ self boundsInWorld.	(myBnds area <= maxPaintArea) ifTrue: [^ myBnds].	^ (aPoint - (paintExtent // 2) extent: paintExtent) intersect: myBnds! !!PasteUpMorph methodsFor: 'pen' stamp: 'jm 7/17/2003 23:03'!clearTurtleTrails	"Remove my turtle trails Form. It will be recreated if it is needed."	turtleTrailsForm _ nil.	self changed.! !!PasteUpMorph methodsFor: 'pen' stamp: 'jm 7/19/2003 14:52'!createOrResizeTrailsForm	"If necessary, create a new turtleTrailsForm or resize the existing one to fill my bounds. On return, turtleTrailsForm will be an 8-bit Form of the correct size."	| newForm |	turtleTrailsForm ifNil: [		turtleTrailsForm _ Form extent: self extent depth: 8.		^ self].	turtleTrailsForm extent = self extent ifFalse: [  "resize trails Form to my current exent"		newForm _ Form extent: self extent depth: 8.		newForm			copy: turtleTrailsForm boundingBox			from: turtleTrailsForm			to: 0@0			rule: Form paint.		turtleTrailsForm _ newForm].! !!PasteUpMorph methodsFor: 'pen' stamp: 'jm 8/7/2003 13:52'!drawPenTrailFor: aMorph from: oldPoint to: newPoint	"Draw a pen trail between the given points for the given morph using its pen size and color."	"The turtleTrailsForm is created on demand when the first pen is put down and removed (to save space) when turtle trails are cleared."	| pen penSize centering |	oldPoint = newPoint ifTrue: [^ self].  "no movement"	self createOrResizeTrailsForm.	pen _ Pen newOnForm: turtleTrailsForm.	penSize _ aMorph penSize.	aMorph penSize ~= 1 ifTrue: [pen squareNib: penSize].	centering _ penSize / 2.0.	pen color: aMorph penColor.	pen drawFrom: (oldPoint - centering) truncated to: (newPoint - centering) truncated.	self invalidRect:		(((oldPoint rect: newPoint) truncated expandBy: penSize + 1) translateBy: self topLeft).! !!PasteUpMorph methodsFor: 'pen' stamp: 'jm 7/17/2003 23:42'!penUpOrDownChangeFor: aMorph	"The pen up/down state for the given morph may have changed; update lastTurtlePositions accordingly."	aMorph penDown		ifTrue: [			lastTurtlePositions ifNil: [lastTurtlePositions _ IdentityDictionary new].			(lastTurtlePositions includes: aMorph) ifFalse: [lastTurtlePositions at: aMorph put: aMorph referencePosition - self topLeft]]		ifFalse: [			lastTurtlePositions ifNil: [^ self].			lastTurtlePositions removeKey: aMorph ifAbsent: [].			lastTurtlePositions size = 0 ifTrue: [lastTurtlePositions _ nil]].! !!PasteUpMorph methodsFor: 'pen' stamp: 'jm 7/17/2003 23:43'!updateTrailsForm 	"Update the turtle-trails form using the current positions of all morphs with their pens down."	"Details: The positions of all morphs with their pens down are recorded by my draw method. If the list from the last display update isn't empty, then trails are drawn from the old to the current positions of all such morphs on the turtle-trails form. The turtle-trails form is created on demand when the first pen is put down and removed (to save space) when the turtle trails are cleared."	| morphsToRemove m oldPoint newPoint |	(lastTurtlePositions isNil or: [lastTurtlePositions size = 0]) ifTrue: [^ self].	morphsToRemove _ OrderedCollection new.	lastTurtlePositions associationsDo: [:assoc |		m _ assoc key.		(m penDown and: [m owner == self])			ifTrue: [				oldPoint _ assoc value.				newPoint _ m referencePosition - self topLeft.				newPoint = oldPoint ifFalse: [					self drawPenTrailFor: m from: oldPoint to: newPoint.					assoc value: newPoint]]			ifFalse: [morphsToRemove add: m]].	"remove morphs that are not longer owned by me or whose pens are up"	morphsToRemove do: [:key | lastTurtlePositions removeKey: key ifAbsent: []].! !!PasteUpMorph methodsFor: 'misc' stamp: 'jm 10/13/2002 18:22'!drawInvalidAreasOn: aCanvas 	"Redraw the damaged areas of the given canvas and clear the damage list.	Return a collection of the areas that were redrawn."	| rectList c i n mm morphs rects rectToFill remnants rect |	rectList _ self damageRecorder invalidRectsFullBounds: self viewBox.	self damageRecorder reset.	self updateTrailsForm.	n _ self submorphs size.	morphs _ OrderedCollection new: n*2.	rects _ OrderedCollection new: n*2.	rectList do: [:r |		true		ifTrue:			["Experimental top-down drawing --			Traverses top to bottom, stopping if the entire area is filled.			If only a single rectangle remains, then continue with the reduced rectangle."			rectToFill _ r.			i _ 1.			[rectToFill == nil or: [i > n]] whileFalse:				[mm _ submorphs at: i.				((mm fullBounds intersects: r) and: [mm isHidden not]) ifTrue:					[morphs addLast: mm.  rects addLast: rectToFill.					remnants _ mm areasRemainingToFill: rectToFill.					remnants size = 1 ifTrue: [rectToFill _ remnants first].					remnants size = 0 ifTrue: [rectToFill _ nil]].				i _ i+1].			"Now paint from bottom to top, but using the reduced rectangles."			rectToFill ifNotNil:				[c _ self pseudoDraw: rectToFill on: aCanvas].			[morphs isEmpty] whileFalse:				[(rect _ rects removeLast) == rectToFill ifFalse:					[c _ aCanvas copyClipRect: (rectToFill _ rect)].				morphs removeLast fullDrawOn: c].			morphs reset.  rects reset]		ifFalse: [c _ self pseudoDraw: r on: aCanvas.				submorphs reverseDo: [:m | m fullDrawOn: c]]		].	^ rectList! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/5/2000 18:09'!fullBounds	| result oldBounds |	(fullBounds == nil and: [self autoLineLayout]) ifTrue:		[oldBounds _ bounds.		self fixLayout.		self resizeToFit ifTrue:			[result _ self boundingBoxOfSubmorphs.			bounds _ bounds withBottom: result bottom].		fullBounds _ bounds.		self invalidRect: oldBounds.		self changed.		^ bounds].  "compute fullBounds before calling changed to avoid infinite recursion!!"	^ fullBounds _ bounds! !!PasteUpMorph methodsFor: 'misc' stamp: 'ar 3/14/2000 16:04'!invalidRect: damageRect	"Clip damage reports to my bounds, since drawing is clipped to my bounds."	self isWorldMorph		ifTrue: [self damageRecorder ifNotNil:					[self damageRecorder recordInvalidRect: damageRect]]		ifFalse: [super invalidRect: (damageRect intersect: bounds)]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/3/2000 00:54'!morphsAt: aPoint addTo: mList	"Overridden to exclude spurious hits on extralimital submorphs."	(self containsPoint: aPoint) ifTrue:		[submorphs size > 0 ifTrue:			[submorphs do: [:m | m morphsAt: aPoint addTo: mList]].		mList addLast: self].	^ mList! !!PasteUpMorph methodsFor: 'misc' stamp: 'bf 9/22/1999 14:55'!position: aPoint	"Prevent moving a world (e.g. via HandMorph>>specialGesture:)"	self isWorldMorph ifFalse: [super position: aPoint]! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/5/1998 22:53'!replaceSubmorph: oldMorph by: newMorph	super replaceSubmorph: oldMorph by: newMorph.	self autoLineLayout		ifTrue:			[self fixLayout]! !!PasteUpMorph methodsFor: 'misc' stamp: 'jm 10/14/2002 08:57'!unhideHiddenObjects	self allMorphsDo: [:m | m isHidden: false].! !!PasteUpMorph methodsFor: 'misc' stamp: 'sw 6/4/2000 21:42'!unlockedMorphsAt: aPoint addTo: mList	"Overridden to exclude spurious hits on extralimital submorphs."	((self containsPoint: aPoint) and: [self isLocked not]) ifTrue:		[submorphs size > 0 ifTrue:			[submorphs do: [:m | m unlockedMorphsAt: aPoint addTo: mList]].		mList addLast: self].	^ mList! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!activeHand	^ worldState ifNotNil: [worldState activeHand] ifNil: [super activeHand]! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!activeHand: x	worldState activeHand: x! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!canvas	^ worldState canvas! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!canvas: x	worldState canvas: x.! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!damageRecorder	^ worldState damageRecorder! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!firstHand	^ worldState hands first! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!hands	^ worldState hands! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!hands: x	worldState hands: x! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!handsDo: aBlock	^ worldState hands do: aBlock! !!PasteUpMorph methodsFor: 'project state' stamp: 'sw 10/9/1999 22:51'!isStepping: aMorph	^ worldState isStepping: aMorph! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!lastCycleTime	^ worldState lastCycleTime! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!lastCycleTime: x	worldState lastCycleTime: x! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!lastStepTime	^ worldState lastStepTime! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!lastStepTime: x	worldState lastStepTime: x! !!PasteUpMorph methodsFor: 'project state' stamp: 'jm 10/15/2002 15:32'!modelWakeUp	| aWindow |	"I am the model of a SystemWindow, that has just been activated"	owner == nil ifTrue: [^ self].  "Not in Morphic world"	(aWindow _ self containingWindow) ifNotNil:		[self viewBox = aWindow panelRect ifFalse:			[self viewBox: aWindow panelRect]].! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!stepList	^ worldState stepList! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!stepList: x	worldState stepList: x! !!PasteUpMorph methodsFor: 'project state' stamp: 'jm 12/9/2003 16:48'!viewBox	"This tortured workaround arises from a situation encountered in which a PasteUpMorph was directliy lodged as a submorph of another PasteUpMorph of identical size, with the former bearing flaps but the latter being the world."	^ worldState		ifNotNil: [worldState viewBox]		ifNil: [(self ownerThatIsA: PasteUpMorph) viewBox]! !!PasteUpMorph methodsFor: 'project state' stamp: 'di 7/27/1999 10:46'!viewBox: newViewBox	| vb |	((vb _ self viewBox) == nil or: [vb extent ~= newViewBox extent])		ifTrue: [self canvas: nil].	worldState viewBox: newViewBox.	bounds _ 0@0 extent: newViewBox extent.	"Paragraph problem workaround; clear selections to avoid screen droppings:"	self handsDo: [:h | h newKeyboardFocus: nil].	self fullRepaintNeeded.! !!PasteUpMorph methodsFor: 'stepping' stamp: 'tk 3/7/2000 22:48'!cleanseStepList	"Remove morphs from the step list that are not in this World.  Often were in a flap that has moved on to another world."	| deletions morphToStep |	deletions _ nil.	self stepList do: [:entry |		morphToStep _ entry at: 1.		morphToStep world == self			ifFalse:				[deletions ifNil: [deletions _ OrderedCollection new].				deletions addLast: morphToStep]].	deletions ifNotNil:		[deletions do: [:deletedM |			self stopStepping: deletedM.			deletedM stopStepping]].! !!PasteUpMorph methodsFor: 'stepping' stamp: 'sw 10/20/1999 15:50'!runStepMethods	"Run morph 'step' methods whose time has come. Purge any morphs that are no longer in this world.	ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."	| now deletions wakeupTime morphToStep |	self stepList size = 0 ifTrue: [^ self].	now _ Time millisecondClockValue.	((now < self lastStepTime) or: [(now - self lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"	deletions _ nil.	"Note: Put the following into an error handler to prevent errors happening on stepping"	[self stepList do: [:entry |		wakeupTime _ entry at: 2.		morphToStep _ entry at: 1.		morphToStep world == self			ifTrue:				[wakeupTime <= now					ifTrue:						[morphToStep stepAt: now.						entry at: 2 put: now + morphToStep stepTime]]			ifFalse:				[deletions ifNil: [deletions _ OrderedCollection new].				deletions addLast: morphToStep]]] 	ifError: [:err :rcvr |		self stopStepping: morphToStep. "Stop this guy right now"		morphToStep setProperty: #errorOnStep toValue: true. "Remember stepping"		Processor activeProcess errorHandler: nil. "So we don't handle this guy twice"		rcvr error: err. "And re-raise the error from here so the stack is still valid"].	deletions ifNotNil:		[deletions do: [:deletedM |			self stopStepping: deletedM.			deletedM stopStepping]].	self lastStepTime: now.! !!PasteUpMorph methodsFor: 'stepping' stamp: 'di 7/15/1999 09:51'!startStepping: aMorph	"Add the given morph to the step list. Do nothing if it is already being stepped."	self stepList do: [:entry | entry first = aMorph ifTrue: [^ self]].  "already stepping"	self adjustWakeupTimesIfNecessary.	self stepList add:		(Array with: aMorph with: Time millisecondClockValue).! !!PasteUpMorph methodsFor: 'stepping' stamp: 'di 7/15/1999 09:51'!stopStepping: aMorph	"Remove the given morph from the step list."	self stepList copy do: [:entry |		entry first == aMorph ifTrue: [self stepList remove: entry ifAbsent: []]].! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!abandonAllHalos	self haloMorphs do: [:m | m delete]! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!addAllMorphs: array	super addAllMorphs: array.	self isWorldMorph		ifTrue: [array do: [:m | self startSteppingSubmorphsOf: m]].! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!addHand: aHandMorph	"Add the given hand to the list of hands for this world."	self hands: (self hands copyWith: aHandMorph).	aHandMorph privateOwner: self.! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!addMorph: aMorph centeredNear: aPoint	"Add the given morph to this world, attempting to keep its center as close to the given point possible while also keeping the it entirely within the bounds of this world."	| trialRect delta |	trialRect _ Rectangle center: aPoint extent: aMorph fullBounds extent.	delta _ trialRect amountToTranslateWithin: bounds.	aMorph position: trialRect origin + delta.	self addMorph: aMorph.! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!allMorphsDo: aBlock	"Enumerate all morphs in the world, including those held in hands."	super allMorphsDo: aBlock.	self isWorldMorph		ifTrue: [self hands reverseDo: [:h | h allMorphsDo: aBlock]].! !!PasteUpMorph methodsFor: 'world state' stamp: 'jm 11/24/2002 10:49'!assuredCanvas	(self canvas == nil or:	 [(self canvas extent ~= self viewBox extent)		or: [self canvas form depth ~= Display depth]])		ifTrue:			["allocate a new offscreen canvas the size of the window"			self canvas: (FormCanvas extent: self viewBox extent)].	^ self canvas! !!PasteUpMorph methodsFor: 'world state' stamp: 'jm 10/4/2002 09:24'!beWorldForProject: aProject	self privateOwner: nil.	worldState _ WorldState new.	self addHand: HandMorph new.	self startSteppingSubmorphsOf: self.! !!PasteUpMorph methodsFor: 'world state' stamp: 'bf 1/5/2000 19:25'!chooseClickTarget	Cursor crossHair showWhile:		[Sensor waitButton].	Cursor down showWhile:		[Sensor anyButtonPressed].	^ (self morphsAt: Sensor cursorPoint) first! !!PasteUpMorph methodsFor: 'world state' stamp: 'jm 11/24/2002 12:19'!colorAt: aPoint belowMorph: aMorph	"Return the color of the pixel immediately behind the given morph at the given point."	"NOTE: due to some bounds wobble in flexing, take the middle of 3x3 patch."	^ (self patchAt: (aPoint-1 extent: 3) without: aMorph andNothingAbove: true)		colorAt: 1@1! !!PasteUpMorph methodsFor: 'world state' stamp: 'jm 5/30/2003 11:19'!displayWorld	"Update this world's display."	| deferredUpdateMode updateNeeded worldDamageRects handsToDraw handDamageRects allDamage |	submorphs do: [:m | m fullBounds].  "force re-layout if needed"	updateNeeded _ self damageRecorder updateIsNeeded.	updateNeeded ifFalse: [		self handsDo: [:h |			(h hasChanged and: [h needsToBeDrawn])				ifTrue: [updateNeeded _ true]]].	updateNeeded ifFalse: [^ self].  "display is already up-to-date"	deferredUpdateMode _ self doDeferredUpdating.	deferredUpdateMode ifFalse: [self assuredCanvas].	worldDamageRects _ self drawInvalidAreasOn: self canvas.  "repair world's damage on canvas""Uncomment for Dakota:		self remoteServer ifNotNil: [self remoteServer processDamageList: worldDamageRects]."	handsToDraw _ self selectHandsToDrawForDamage: worldDamageRects.	handDamageRects _ handsToDraw collect: [:h | h savePatchFrom: self canvas].	allDamage _ worldDamageRects, handDamageRects.	handsToDraw reverseDo: [:h | h fullDrawOn: self canvas].  "draw hands onto world canvas"	false ifTrue: [  "*make this true to flash damaged areas for testing*"		self flashRects: allDamage color: Color black].	"quickly copy altered rects of canvas to Display:"	deferredUpdateMode		ifTrue: [allDamage do: [:r | Display forceToScreen: (r "translateBy: self viewBox origin")]]		ifFalse: [self canvas showAt: self viewBox origin invalidRects: allDamage].	handsToDraw do: [:h | h restoreSavedPatchOn: self canvas].  "restore world canvas under hands"	Display deferUpdates: false; forceDisplayUpdate.! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 5/25/2000 18:00'!displayWorldAsTwoTone	"Display the world in living black-and-white. (This is typically done to save space.)"	| f |	f _ ColorForm extent: self viewBox extent depth: 1.	f colors: (Array with: color dominantColor with: Color black).	self canvas: (f getCanvas).	"force the entire canvas to be redrawn"	self fullRepaintNeeded.	self drawInvalidAreasOn: self canvas.  "redraw on offscreen canvas"	self canvas showAt: self viewBox origin.  "copy redrawn areas to Display"	Display forceDisplayUpdate.	self canvas: nil.  "forget my canvas to save space"! !!PasteUpMorph methodsFor: 'world state' stamp: 'jm 11/24/2002 10:49'!displayWorldNonIncrementally	"Display the morph world non-incrementally. Used for testing."	(self canvas == nil or:	 [(self canvas extent ~= self viewBox extent) or:	 [self canvas form depth ~= Display depth]]) ifTrue: [		"allocate a new offscreen canvas the size of the window"		self canvas: (FormCanvas extent: self viewBox extent)].	self canvas fillColor: color.	submorphs reverseDo: [:m | m fullDrawOn: self canvas].	self hands reverseDo: [:h | h fullDrawOn: self canvas].	self canvas form displayOn: Display at: self viewBox origin.	self fullRepaintNeeded.  "don't collect damage"	Display forceDisplayUpdate.! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!displayWorldSafely	"Update this world's display and keep track of errors during draw methods."	| oldHandler errCtx errMorph |	oldHandler _ Processor activeProcess errorHandler.	[self displayWorld] ifError:[:err :rcvr|		"Handle a drawing error"		errCtx _ thisContext.		[errCtx _ errCtx sender.		"Search the sender chain to find the morph causing the problem"		[errCtx notNil and:[(errCtx receiver isKindOf: Morph) not]] 			whileTrue:[errCtx _ errCtx sender].		"If we're at the root of the context chain then we have a fatal drawing problem"		errCtx == nil ifTrue:[^self handleFatalDrawingError: err].		errMorph _ errCtx receiver.		"If the morph causing the problem has already the #drawError flag set,		then search for the next morph above in the caller chain."		errMorph hasProperty: #errorOnDraw] whileTrue.		errMorph setProperty: #errorOnDraw toValue: true.		"Install the old error handler, so we can re-raise the error"		Processor activeProcess errorHandler: oldHandler.		rcvr error: err.	].! !!PasteUpMorph methodsFor: 'world state' stamp: 'ar 5/25/2000 18:03'!doDeferredUpdating	"If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	DisableDeferredUpdates ifNil: [DisableDeferredUpdates _ false].	DisableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	self == World		ifTrue: [  "this world fills the entire Display"			((self canvas == nil) or: [self canvas form ~~ Display]) ifTrue: [				self canvas: (Display getCanvas).				self viewBox: Display boundingBox]]		ifFalse: [  "this world is inside an MVC window"			((self canvas == nil) or:			 [(self canvas form ~~ Display) or:			 [(self canvas origin ~= self viewBox origin)]]) ifTrue: [				self canvas:					((Display getCanvas)						copyOffset: self viewBox origin clipRect: self viewBox)]].	^ true! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!doOneCycle	self interCyclePause: MinCycleLapse.	self doOneCycleNow.! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!doOneSubCycle	"Like doOneCycle, but preserves activeHand."	| currentHand |	currentHand _ self activeHand.	self interCyclePause: MinCycleLapse.	self doOneCycleNow.	self activeHand: currentHand! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 11/27/1999 10:11'!exit	Project current exit.! !!PasteUpMorph methodsFor: 'world state' stamp: 'jm 5/29/2003 18:02'!flashRects: rectangleList color: aColor	"For testing. Flashes the given list of rectangles on the Display so you can watch incremental redisplay at work."	"Details: Uses two reverses so that the display is restored to its original state. This is necessary when in deferred update mode."	| blt screenRect |	blt _ (BitBlt toForm: Display)		sourceForm: nil;		sourceOrigin: 0@0;		clipRect: self viewBox;		combinationRule: Form reverse.	rectangleList do: [:r |		screenRect _ r "translateBy: self viewBox origin".		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate.		(Delay forMilliseconds: 15) wait.		blt destRect: screenRect; copyBits.		Display forceToScreen: screenRect; forceDisplayUpdate].! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 8/10/1999 09:30'!fullRepaintNeeded	self damageRecorder doFullRepaint.	SystemWindow windowsIn: self		satisfying: [:w | w makeMeVisible. false].! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 11/27/1999 10:11'!goBack	Project returnToPreviousProject.! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!haloMorphOrNil	| m |	^ (m _ self haloMorphs) size > 0 ifTrue: [m first] ifFalse: [nil]! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!haloMorphs	^ submorphs select: [:m | m isKindOf: HaloMorph]! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/27/1999 10:46'!handleFatalDrawingError: errMsg	"Handle a fatal drawing error."	Smalltalk isMorphic ifFalse:[^self error: errMsg]. "Can still handle it from MVC"	Display deferUpdates: false. "Just in case"	self primitiveError: errMsg.	"Hm... we should jump into a 'safe' worldState here, but how do we find it?!!"! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!handlesMouseDown: evt	self isWorldMorph		ifTrue: [^ true]		ifFalse: [^ super handlesMouseDown: evt]! !!PasteUpMorph methodsFor: 'world state' stamp: 'jm 10/4/2002 07:36'!initForProject: aWorldState	worldState _ aWorldState.	color _ (Color r:0.937 g: 0.937 b: 0.937).	self addHand: HandMorph new.! !!PasteUpMorph methodsFor: 'world state' stamp: 'jm 10/5/2002 06:38'!install	submorphs do: [:ss | ss owner == nil ifTrue: [ss privateOwner: self]].		"Transcript that was in outPointers and then got deleted."	self viewBox: Display boundingBox.	self handsDo: [:h | h initForEvents].	SystemWindow noteTopWindowIn: self.	self displayWorldSafely.! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 4/27/2000 21:04'!interCyclePause: milliSecs	"delay enough that the next interaction cycle won't happen too soon after the original; thus, if all the system is doing is polling for interaction, the overall CPU usage of Squeak will be low"	| currentTime wait |	currentTime _ Time millisecondClockValue.	self lastCycleTime ifNotNil: [ 		wait _ self lastCycleTime + milliSecs - currentTime.		wait > 0 ifTrue: [ 			wait < milliSecs  "big waits happen after a snapshot"				ifTrue: [DisplayScreen checkForNewScreenSize.						(Delay forMilliseconds: wait) wait ]. ]. ].	self lastCycleTime: currentTime! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 11/27/1999 10:20'!jumpToProject	Project jumpToProject.! !!PasteUpMorph methodsFor: 'world state' stamp: 'jm 8/11/2003 21:59'!mouseDown: evt	"Handle a mouse down event."	self isWorldMorph ifFalse: [^ super mouseDown: evt].	evt hand newKeyboardFocus: nil.	evt hand invokeMetaMenu: evt.! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!nextPage	"backstop for smart next-page buttons that look up the containment hierarchy until they find somone who is willing to field this command.  If we get here, the 'next' button was not embedded in a book, so we can do nothing useful"	self beep! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!open	"Open a view on this WorldMorph."	MorphWorldView openOn: self.! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!openWithTitle: aString cautionOnClose: aBoolean	"Open a view on this WorldMorph with the given title."	MorphWorldView openOn: self label: aString cautionOnClose: aBoolean! !!PasteUpMorph methodsFor: 'world state' stamp: 'jm 9/27/2003 21:44'!patchAt: patchRect without: stopMorph andNothingAbove: stopThere	"Return a complete rendering of this patch of the display screen without drawing stopMorph and, if stopThere is true, without drawing any morph above it."	| c morphsToDraw i |	c _ FormCanvas extent: patchRect extent depth: Display depth.	c _ c copyOrigin: patchRect topLeft negated clipRect: (0@0 extent: patchRect extent).	(self bounds containsRect: patchRect) ifFalse: [		"fill areas of patchRect outside my bounds with black"		c form fillColor: Color black].	(self bounds intersects: patchRect) ifFalse: [^ c form].  "entirely out of bounds"	"draw all morphs intersecting the given patch, stopping at the given morph"	c fillRectangle: self bounds color: color.  "draw world color"	morphsToDraw _ submorphs reversed asOrderedCollection.	(i _ morphsToDraw indexOf: stopMorph) > 0 ifTrue: [		stopThere			ifTrue: [morphsToDraw _ morphsToDraw copyFrom: 1 to: i - 1]  "stop at stopMorph"			ifFalse: [morphsToDraw removeIndex: i]].  "skip stopMorph"	morphsToDraw do: [:m | m fullDrawOn: c].	^ c form! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!previousPage	"backstop for smartprev-page buttons that look up the containment hierarchy until they find somone who is willing to field this command.  If we get here, the button was not embedded in a book, so we can do nothing useful"	self beep! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!removeHand: aHandMorph	"Remove the given hand from the list of hands for this world."	(self hands includes: aHandMorph) ifTrue: [		aHandMorph dropMorphsEvent: MorphicEvent new.		self hands: (self hands copyWithout: aHandMorph).		self invalidRect: aHandMorph fullBounds.		self activeHand == aHandMorph ifTrue: [self activeHand: nil]].! !!PasteUpMorph methodsFor: 'world state' stamp: 'jm 10/14/2002 07:48'!restoreDisplay	self == World ifTrue: [  "otherwise, we're a morphic window in MVC and the restoreDisplay was, unusually, issued from that world's menu rather than from the MVC screen menu"		DisplayScreen startUp.		self extent: Display extent.		self viewBox: Display boundingBox].	self fullRepaintNeeded.! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!selectHandsToDrawForDamage: damageList	"Select the set of hands that must be redrawn because either (a) the hand itself has changed or (b) the hand intersects some damage rectangle."	| result hBnds |	result _ OrderedCollection new.	self handsDo: [:h |		h needsToBeDrawn ifTrue: [			h hasChanged				ifTrue: [result add: h]				ifFalse: [					hBnds _ h fullBounds.					(damageList detect: [:r | r intersects: hBnds] ifNone: [nil])						ifNotNil: [result add: h]]]].	^ result! !!PasteUpMorph methodsFor: 'world state' stamp: 'jm 7/17/2003 23:02'!sleep	"Minimize space. Typically called when exiting a project."	self canvas ifNil: [^ self].  "already cleaned up"	Cursor normal show.  "restore the normal cursor"	(turtleTrailsForm notNil and:	 [self confirm: 'May I clear the pen trails?'])		ifTrue: [self clearTurtleTrails].	self canvas: nil.  "free my canvas to save space"	self allMorphsDo: [:m | m releaseCachedState].! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!standardSystemController	^ ScheduledControllers controllerSatisfying:		[:c | (c view subViews size > 0) and:			[c view firstSubView model == self]].! !!PasteUpMorph methodsFor: 'world state' stamp: 'di 7/15/1999 09:51'!startSteppingSubmorphsOf: aMorph	"Ensure that all submorphs of the given morph that want to be stepped are added to the step list.   Typically used after adding a morph to the world."	aMorph allMorphsDo: [:m |		m wantsSteps ifTrue: [m arrangeToStartSteppingIn: self]]! !!PasteUpMorph methodsFor: 'project' stamp: 'di 7/15/1999 09:51'!adjustWakeupTimes	"Fix the wakeup times in my step list. This is necessary when this world has been restarted after a pause, say because some other view had control, after a snapshot, or because the millisecond clock has wrapped around. (The latter is a rare occurence with a 32-bit clock!!)"	| earliestTime t now m oldWakeupTime |	"find earliest wakeup time"	earliestTime _ SmallInteger maxVal.	self stepList do: [:entry |		t _ entry at: 2.		t < earliestTime ifTrue: [earliestTime _ t]].	"recompute all wakeup times, using earliestTime as the origin"	now _ Time millisecondClockValue.	self stepList do: [:entry |		m _ entry at: 1.		oldWakeupTime _ entry at: 2.		entry at: 2 put: now + ((oldWakeupTime - earliestTime) min: m stepTime)].	self lastStepTime: now.! !!PasteUpMorph methodsFor: 'project' stamp: 'di 7/15/1999 09:51'!adjustWakeupTimesIfNecessary	"Fix the wakeup times in my step list if necessary. This is needed after a snapshot, after a long pause (say because some other view had control or because the user was selecting from an MVC-style menu) or when the millisecond clock wraps around (a very rare occurence with a 32-bit clock!!)."	| now |	now _ Time millisecondClockValue.	((now < self lastStepTime) or: [(now - self lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"! !!PasteUpMorph methodsFor: 'project' stamp: 'tk 9/3/1999 12:07'!project	"Find the project that owns me.  Not efficient to call this."	^ Project ofWorld: self! !!PasteUpMorph methodsFor: 'interaction loop' stamp: 'jm 8/7/2003 11:28'!cycleWhileWaitingMSecs: waitMSecs doInput: doInputFlag doSteps: doStepFlag	"Perform the interactive loop repeatedly for the given number of milliseconds."	| startT now |	startT _ Time millisecondClockValue.	[((now _ Time millisecondClockValue) < startT) or:	 [(now - startT) < waitMSecs]] whileTrue: [		doInputFlag ifTrue: [			"process user input events"			self handsDo: [:h |				self activeHand: h.				h processEvents.				self activeHand: nil]].		doStepFlag ifTrue: [self runStepMethods].		self displayWorldSafely].! !!PasteUpMorph methodsFor: 'interaction loop' stamp: 'TIS 6/18/2003 17:20'!doOneCycleNoInput	"Do one cycle of the display and step loop without user input."	self runStepMethods.	self displayWorldSafely.! !!PasteUpMorph methodsFor: 'interaction loop' stamp: 'jm 10/4/2002 18:21'!doOneCycleNow	"Do one cycle of the interactive loop. This method is called repeatedly when the world is running."	"process user input events"	self handsDo: [:h |		self activeHand: h.		h processEvents.		self activeHand: nil].	self runStepMethods.	self displayWorldSafely.! !!PasteUpMorph methodsFor: 'WiW support' stamp: 'RAA 11/27/1999 15:41'!restartWorldCycleWithEvent: evt	"RAA 27 Nov 99 - redispatch that click picked up from our inner world"	evt ifNotNil: [		self primaryHand handleEvent: (evt setHand: self primaryHand).	].	Project current spawnNewProcessAndTerminateOld: true! !!PasteUpMorph methodsFor: 'remote connections' stamp: 'jm 11/24/2002 19:13'!remoteServer	^ worldState remoteServer! !!PasteUpMorph methodsFor: 'remote connections' stamp: 'jm 11/24/2002 19:18'!remoteServer: aNebraskaServerOrNil	worldState remoteServer: aNebraskaServerOrNil.! !!PasteUpMorph methodsFor: 'private' stamp: 'jm 10/13/2002 18:22'!boundingBoxOfSubmorphs	"Answer a rectangle that just encloses all of my non-hidden submorphs."	| r |	r _ bounds origin extent: self minimumExtent.  "so won't end up with something empty"	submorphs do: [:m | m isHidden ifFalse: [r _ r quickMerge: m fullBounds]].	^ r! !!PasteUpMorph methodsFor: 'private' stamp: 'ar 3/14/2000 23:20'!privateFullMoveBy: delta	"Private. Overridden to prevent drawing turtle trails when a playfield is moved"	self setProperty: #turtleTrailsDelta toValue: delta.	super privateFullMoveBy: delta.	self removeProperty: #turtleTrailsDelta.! !!PasteUpMorph class methodsFor: 'as yet unclassified' stamp: 'jm 5/31/2003 20:03'!includeInNewMorphMenu	^ true! !!PasteUpMorph class methodsFor: 'as yet unclassified' stamp: 'jm 10/4/2002 09:25'!newWorldForProject: projectOrNil 	"Return a new pasteUpMorph configured as a world."	^ self new initForProject: WorldState new! !!PasteUpMorph class methodsFor: 'project' stamp: 'di 7/15/1999 09:51'!MinCycleLapse: milliseconds	"set the minimum amount of time that may transpire between two calls to doOneCycle"	MinCycleLapse _ milliseconds ifNotNil: [ milliseconds rounded ].! !!PasteUpMorph class methodsFor: 'project' stamp: 'di 7/15/1999 09:51'!disableDeferredUpdates: aBoolean	"If the argument is true, disable deferred screen updating."	"Details: When deferred updating is used, Morphic performs double-buffered screen updates by telling the VM to de-couple the Display from the hardware display buffer, drawing directly into the Display, and then forcing the changed regions of the Display to be copied to the screen. This saves both time (an extra BitBlt is avoided) and space (an extra display buffer is avoided). However, on platforms on which the Display points directly to the hardware screen buffer, deferred updating can't be used (you'd see ugly flashing as the layers of the drawing were assembled). In this case, the drawing is composited into an offscreen FormCanvas  and then copied to the hardware display buffer."	DisableDeferredUpdates _ aBoolean.! !!PasteUpMorph class methodsFor: 'project' stamp: 'di 7/15/1999 09:51'!initialize	"WorldMorph initialize"	self MinCycleLapse: 20.		"allows 50 frames per second..."! !!PasteUpMorph class methodsFor: 'project' stamp: 'jm 1/1/2004 11:18'!startUp	Smalltalk isMorphic ifTrue: [World restoreDisplay].! !!Pen methodsFor: 'operations' stamp: 'di 6/21/1998 09:37'!fill: drawBlock color: color	| region tileForm tilePen shape saveColor recorder |	drawBlock value: (recorder _ self as: PenPointRecorder).	region _ Rectangle encompassing: recorder points.	tileForm _ Form extent: region extent+6.	tilePen _ Pen newOnForm: tileForm.	tilePen location: location-(region origin-3)		direction: direction		penDown: penDown.	drawBlock value: tilePen.  "Draw the shape in B/W"	saveColor _ halftoneForm.	drawBlock value: self.	halftoneForm _ saveColor.	shape _ (tileForm findShapeAroundSeedBlock: [:f | f borderWidth: 1]) reverse.	shape copy: shape boundingBox from: tileForm to: 0@0 rule: Form erase.	destForm fillShape: shape fillColor: color at: region origin-3! !!Pen methodsFor: 'operations' stamp: 'jm 5/29/2003 18:03'!print: str withFont: font	"Print the given string in the given font at the current heading"	| lineStart form charStart rowStart scale wasDown bb pix |	scale _ sourceForm width.	wasDown _ penDown.	lineStart _ location.	str do:		[:char |		char = Character cr ifTrue:			[self place: lineStart; up; turn: 90; go: font height*scale; turn: -90; down]		ifFalse:			[form _ font characterFormAt: char.			charStart _ location.wasDown ifTrue: [			self up; turn: -90; go: font descent*scale; turn: 90; down.			0 to: form height-1 do:				[:y |				rowStart _ location.				bb _ BitBlt bitPeekerFromForm: form.				pix _ RunArray newFrom:					((0 to: form width-1) collect: [:x | bb pixelAt: x@y]).				pix runs with: pix values do:					[:run :value |					value = 0						ifTrue: [self up; go: run*scale; down]						ifFalse: [self go: run*scale]].				self place: rowStart; up; turn: 90; go: scale; turn: -90; down].].			self place: charStart; up; go: form width*scale; down].			].	wasDown ifFalse: [self up]"Display restoreAfter:[Pen new squareNib: 2; color: Color red; turn: 45;	print: 'The owl and the pussycat went to seain a beautiful pea green boat.' withFont: TextStyle defaultFont]"! !!Pen methodsFor: 'geometric designs' stamp: 'di 6/11/1998 22:01'!dragon: n  "Display restoreAfter: [Display fillWhite. Pen new dragon: 10]."	"Display restoreAfter: [Display fillWhite. 1 to: 4 do:				[:i | Pen new color: i; turn: 90*i; dragon: 10]]"	"Draw a dragon curve of order n in the center of the screen."	n = 0		ifTrue: [self go: 5]		ifFalse: [n > 0				ifTrue: [self dragon: n - 1; turn: 90; dragon: 1 - n]				ifFalse: [self dragon: -1 - n; turn: -90; dragon: 1 + n]]! !!Pen methodsFor: 'geometric designs' stamp: 'di 6/14/1998 13:42'!filberts: n side: s   "Display restoreAfter: [Pen new filberts: 4 side: 5]"	"Two Hilbert curve fragments form a Hilbert tile. Draw four interlocking 	tiles of order n and sides length s."	| n2 |	Display fillWhite.	n2 _ 1 bitShift: n - 1.	self up; go: 0 - n2 * s; down.	1 to: 4 do: 		[:i | 		self fill: [:p |				p hilbert: n side: s.				p go: s.				p hilbert: n side: s.				p go: s.				p up.				p go: n2 - 1 * s.				p turn: -90.				p go: n2 * s.				p turn: 180.				p down]			color: (Color perform: (#(yellow red green blue) at: i))]! !!Pen methodsFor: 'private' stamp: 'di 6/11/1998 16:09'!location: aPoint direction: aFloat penDown: aBoolean	location _ aPoint.	direction _ aFloat.	penDown _ aBoolean! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jm 5/29/2003 18:02'!feltTip: width cellSize: cellSize	"Warning: This example potentially uses a large amount of memory--it creates a Form with cellSize squared bits for every Display pixel."	"In this example, all drawing is done into a large, monochrome Form and then scaled down onto the Display using smoothing. The larger the cell size, the more possible shades of gray can be generated, and the smoother the resulting line appears. A cell size of 8 yields 64 possible grays, while a cell size of 16 gives 256 levels, which is about the maximum number of grays that the human visual system can distinguish. The width parameter determines the maximum line thickness. Requires the optional tablet support primitives which may not be supported on all platforms. Works best in full screen mode. Shift-mouse to exit." 	"Pen feltTip: 2.7 cellSize: 8"	| tabletScale bitForm pen warp p srcR dstR nibSize startP r |	tabletScale _ self tabletScaleFactor.	bitForm _ Form extent: Display extent * cellSize depth: 1.	pen _ Pen newOnForm: bitForm.	pen color: Color black.	warp _ (WarpBlt toForm: Display)		sourceForm: bitForm;		colorMap: (bitForm colormapIfNeededForDepth: Display depth);		cellSize: cellSize;		combinationRule: Form over.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			p _ (Sensor tabletPoint * cellSize * tabletScale) rounded.			nibSize _ (Sensor tabletPressure * (cellSize * width)) rounded.		     nibSize > 0				ifTrue: [					pen squareNib: nibSize.					startP _ pen location.					pen goto: p.					r _ startP rect: pen location.					dstR _ (r origin // cellSize) corner: ((r corner + nibSize + (cellSize - 1)) // cellSize).					srcR _ (dstR origin * cellSize) corner: (dstR corner * cellSize).					warp copyQuad: srcR innerCorners toRect: dstR]				ifFalse: [					pen place: p]]].! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jm 4/13/1999 11:20'!inkBrush	"Similar to simplePressurePen, but this example uses the average of the recent pen pressure values. The effect is that of a Japanese ink brush that comes up gradually off the paper as the brush is lifted, causing end (and beginning) of each stroke to taper. Requires the optional tablet support primitives which may not be supported on all platforms. Works best in full screen mode. Shift-mouse to exit." 	"Pen inkBrush"	| tabletScale historyMSecs pressureHistory pen now currentPressure sum averagePressure p |	tabletScale _ self tabletScaleFactor.	historyMSecs _ 120.	pressureHistory _ OrderedCollection new.	pen _ Pen newOnForm: Display.	pen color: Color black.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			"compute the average pressure over last historyMSecs milliseconds"			now _ Time millisecondClockValue.			currentPressure _ (20.0 * Sensor tabletPressure) rounded.			pressureHistory addLast: (Array with: now with: currentPressure).			[pressureHistory size > 0 and:			 [(pressureHistory first first + historyMSecs) < now]]				whileTrue: [pressureHistory removeFirst].  "prune old entries"			sum _ pressureHistory inject: 0 into: [:t :e | t + e last].			averagePressure _ sum // pressureHistory size.			p _ (Sensor tabletPoint * tabletScale) rounded.		     averagePressure > 0				ifTrue: [					pen roundNib: averagePressure.					pen goto: p]				ifFalse: [					pen place: p]]].! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jm 4/13/1999 11:13'!simplePressurePen	"An example of using a pressure sensitive pen to control the thickness of the pen. This requires the optional tablet support primitives which may not be supported on all platforms. Works best in full screen mode. Shift-mouse to exit." 	"Pen simplePressurePen"	| tabletScale pen pressure p |	tabletScale _ self tabletScaleFactor.	pen _ Pen newOnForm: Display.	pen color: Color black.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			p _ (Sensor tabletPoint * tabletScale) rounded.			pressure _ (15.0 * Sensor tabletPressure) rounded.		     pressure > 0				ifTrue: [					pen roundNib: pressure.					pen goto: p]				ifFalse: [					pen place: p]]].! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jm 4/13/1999 11:12'!tabletScaleFactor	"Answer a Point that scales tablet coordinates to Display coordinates, where the full extent of the tablet maps to the extent of the entire Display."	| tabletExtent |	tabletExtent _ Sensor tabletExtent.	^ (Display width asFloat / tabletExtent x) @ (Display height asFloat / tabletExtent y)! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jm 4/12/1999 12:51'!testMouseTracking	"A very simple example of drawing using the mouse. Compare the tracking speed of this example with that of testTabletTracking. Mouse down to draw a stroke, shift-mouse to exit." 	"Pen testMouseTracking"	| pen p |	pen _ Pen newOnForm: Display.	pen roundNib: 8.	pen color: Color black.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			p _ Sensor cursorPoint.		     Sensor anyButtonPressed				ifTrue: [pen goto: p]				ifFalse: [					pen color: Color random.					pen place: p]]].! !!Pen class methodsFor: 'tablet drawing examples' stamp: 'jm 4/13/1999 11:21'!testTabletTracking	"A very simple example of drawing using the pen of a digitizing tablet such as a Wacom ArtZ tablet. This requires the optional tablet support primitives which may not be supported on all platforms. Compare the tracking speed of this example with that of testMouseTracking. On a Macintosh, the tablet primitives provide roughly 120 samples/second versus only 60 mouse samples/second, and the difference is noticable. Works best in full screen mode. Mouse down to draw a stroke, shift-mouse to exit." 	"Pen testTabletTracking"	| tabletScale pen p |	tabletScale _ self tabletScaleFactor.	pen _ Pen newOnForm: Display.	pen roundNib: 8.	pen color: Color black.	Display fillColor: Color white.	Display restoreAfter: [		[Sensor shiftPressed and: [Sensor anyButtonPressed]] whileFalse: [			p _ (Sensor tabletPoint * tabletScale) rounded.		     Sensor tabletPressure > 0				ifTrue: [pen goto: p]				ifFalse: [					pen color: Color random.					pen place: p]]].! !This class is a special kind of Pen that instead of actually drawing lines records the destination points for those lines. These points can later be accessed through my accessing method #points.This can be useful when determining the boundaries of a drawing session.Example:| pen |pen _ PenPointRecorder new.pen up; goto: 100@100; down; goto: 120@120.Transcript cr;	show: 'Bounding box for drawing: ';	show: (Rectangle encompassing: pen points)Implementation note: Shouldn't we override #drawFrom:to:withFirstPoint: instead, and what about #drawLoopX:Y:? Aren't we missing those calls?!!PenPointRecorder methodsFor: 'accessing' stamp: 'di 6/21/1998 09:35'!points	^ points! !!PenPointRecorder methodsFor: 'line drawing' stamp: 'sma 2/26/2000 19:03'!drawFrom: p1 to: p2.	"Overridden to skip drawing but track bounds of the region traversed."	points ifNil: [points _ OrderedCollection with: p1].	points addLast: p2! !I represent one key of a PianoKeyboardMorph. I respond to mouse down and drag events by telling my target (the keyboard) to play a note given by my midiKey.!!PianoKeyMorph methodsFor: 'initialization' stamp: 'jm 10/9/2002 08:44'!initialize	super initialize.	borderWidth _ 1.	midiKey _ 60.	target _ nil.! !!PianoKeyMorph methodsFor: 'accessing' stamp: 'jm 10/9/2002 08:47'!midiKey	^ midiKey! !!PianoKeyMorph methodsFor: 'accessing' stamp: 'jm 10/9/2002 09:48'!midiKey: anInteger	"Set my midiKey, which determines the pitch of this note. Middle-C is 60."	midiKey _ anInteger.	self setKeyColor.! !!PianoKeyMorph methodsFor: 'accessing' stamp: 'jm 10/9/2002 09:42'!setKeyColor	"Set my key color based on my midiKey."	| isBlackKey |	isBlackKey _ #(1 3 6 8 10) includes: (midiKey \\ 12).	isBlackKey		ifTrue: [self color: BlackKeyColor]		ifFalse: [self color: WhiteKeyColor]! !!PianoKeyMorph methodsFor: 'accessing' stamp: 'jm 10/9/2002 08:50'!target: anObjectOrNil	"Set my target to the given object. Non-nil targets are sent the messages turnOnNote: and turnOffNote."	target _ anObjectOrNil.! !!PianoKeyMorph methodsFor: 'event handling' stamp: 'jm 10/9/2002 08:33'!handlesMouseDown: evt	^ true! !!PianoKeyMorph methodsFor: 'event handling' stamp: 'jm 10/9/2002 08:12'!handlesMouseOverDragging: evt	^ true! !!PianoKeyMorph methodsFor: 'event handling' stamp: 'jm 10/9/2002 08:51'!mouseDown: evt	self color: KeyDownColor.	target ifNotNil: [target turnOnNote: midiKey].! !!PianoKeyMorph methodsFor: 'event handling' stamp: 'jm 10/9/2002 08:33'!mouseEnterDragging: evt	evt hand hasSubmorphs ifTrue: [^ self].  "do nothing if dragging a morph"	self mouseDown: evt.! !!PianoKeyMorph methodsFor: 'event handling' stamp: 'jm 10/9/2002 08:33'!mouseLeaveDragging: evt	self mouseUp: evt.! !!PianoKeyMorph methodsFor: 'event handling' stamp: 'jm 10/9/2002 08:46'!mouseUp: evt	self setKeyColor.	target ifNotNil: [target turnOffNote].! !!PianoKeyMorph class methodsFor: 'class initialization' stamp: 'jm 10/26/2002 10:46'!initialize	BlackKeyColor _ Color black.	WhiteKeyColor _ Color gray: 0.95.	KeyDownColor _ Color yellow.! !I am a collection of PianoKeyMorphs arranged in a piano keyboard. I can play with Squeak internal sounds or via MIDI. I can transpose up or down by any number of half-steps and I can make myself larger or smaller.!!PianoKeyboardMorph methodsFor: 'initialization' stamp: 'jm 10/26/2002 10:56'!buildKeyboard: nOctaves baseOctave: baseOctave keyWidth: whiteW	"Build keyboard for the given number of octaves starting with the given octave."	| whiteH blackW blackH octaveStart octavePt nWhite nBlack noteR key xOffset |	self removeAllMorphs.	self extent: 5@5.  "adjusted later"	whiteH _ (3.3 * whiteW) rounded.	blackW _ (0.57 * whiteW) rounded.	blackW even ifTrue: [blackW _ blackW - 1].	blackH _ (0.6 * whiteH) rounded.	0 to: nOctaves do: [:i |		octaveStart _ 12 * (baseOctave + i).		octavePt _ self innerBounds topLeft + (((7 * whiteW * i) - 1) @ -1).		i < nOctaves			ifTrue: [nWhite _ 7. nBlack _ 5]			ifFalse: [nWhite _ 1. nBlack _ 0].  "only one 'C' key in top octave"		1 to: nWhite do: [:j | 			noteR _ (octavePt + (((j - 1) * whiteW) @ 0)) extent: (whiteW + 1) @ whiteH.			key _ PianoKeyMorph newBounds: noteR.			key target: self; midiKey: octaveStart + (#(0 2 4 5 7 9 11) at: j).			self addMorph: key].		1 to: nBlack do: [:j |			xOffset _ (whiteW * (#(1 2 4 5 6) at: j)) - (blackW // 2).			noteR _ (octavePt + (xOffset @ 0)) extent: blackW @ blackH.			key _ PianoKeyMorph newBounds: noteR.			key target: self; midiKey: octaveStart + (#(1 3 6 8 10) at: j).			self addMorph: key]].	self extent: (self fullBounds extent + borderWidth - 1).! !!PianoKeyboardMorph methodsFor: 'initialization' stamp: 'jm 10/26/2002 10:59'!initialize	super initialize.	soundPrototype _ FMSound bassoon1.	midiTranspose _ 0.	self buildKeyboard: 6 baseOctave: 2 keyWidth: 10.! !!PianoKeyboardMorph methodsFor: 'accessing' stamp: 'jm 10/9/2002 09:52'!soundPrototype: aSound	soundPrototype _ aSound.! !!PianoKeyboardMorph methodsFor: 'menus' stamp: 'jm 10/26/2002 11:03'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'transpose' action: #setTranspose.	aCustomMenu add: 'bigger keyboard' action: #makeKeysLarger.	aCustomMenu add: 'smaller keyboard' action: #makeKeysSmaller.	midiPort		ifNil: [			SimpleMIDIPort midiIsSupported ifTrue: [				aCustomMenu add: 'play via MIDI' action: #openMIDIPort]]		ifNotNil: [			aCustomMenu add: 'play via built in synth' action: #closeMIDIPort.			aCustomMenu add: 'set midi instrument' action: #setMidiInstrument.			aCustomMenu add: 'new MIDI controller' action: #makeMIDIController:].! !!PianoKeyboardMorph methodsFor: 'menus' stamp: 'jm 10/26/2002 11:06'!makeKeysLarger	self buildKeyboard: 6 baseOctave: 2 keyWidth: ((submorphs last width) * 1.25) rounded.! !!PianoKeyboardMorph methodsFor: 'menus' stamp: 'jm 10/26/2002 11:06'!makeKeysSmaller	self buildKeyboard: 6 baseOctave: 2 keyWidth: ((submorphs last width) / 1.25) rounded.! !!PianoKeyboardMorph methodsFor: 'menus' stamp: 'jm 10/9/2002 10:09'!makeMIDIController: evt	self world activeHand attachMorph:		(MIDIControllerMorph new midiPort: midiPort).! !!PianoKeyboardMorph methodsFor: 'menus' stamp: 'jm 10/23/2002 22:25'!setMidiInstrument	"Send a MIDI command to change my instrument to the one specified by the user."	| response instNum |	response _ FillInTheBlank request: 'Instrument Number (1 to 128)?' initialAnswer: '1'.	response size = 0 ifTrue: [^ self].	instNum _ response asNumber asInteger.	((instNum < 1) or: [instNum > 128]) ifTrue: [^ self].	midiPort midiCmd: 16rC0 channel: 1 byte: instNum - 1.! !!PianoKeyboardMorph methodsFor: 'menus' stamp: 'jm 10/23/2002 22:31'!setTranspose	"Send a MIDI command to change my instrument to the one specified by the user."	| response |	response _ FillInTheBlank request: 'Transpose half-steps?' initialAnswer: midiTranspose printString.	response size = 0 ifTrue: [^ self].	midiTranspose _ response asNumber asInteger.! !!PianoKeyboardMorph methodsFor: 'private' stamp: 'jm 10/9/2002 10:04'!closeMIDIPort	midiPort _ nil.! !!PianoKeyboardMorph methodsFor: 'private' stamp: 'jm 10/9/2002 10:03'!openMIDIPort	| portNum |	portNum _ SimpleMIDIPort outputPortNumFromUser.	portNum ifNil: [^ self].	midiPort _ SimpleMIDIPort openOnPortNumber: portNum.! !!PianoKeyboardMorph methodsFor: 'private' stamp: 'jm 10/9/2002 10:02'!turnOffNote	soundPlaying ifNil: [^ self].  "no note playing"	midiPort		ifNil: [soundPlaying stopGracefully]		ifNotNil: [			soundPlaying isInteger ifTrue: [				midiPort midiCmd: 16r90 channel: 1 byte: soundPlaying byte: 0]].	soundPlaying _ nil.! !!PianoKeyboardMorph methodsFor: 'private' stamp: 'jm 10/26/2002 11:09'!turnOnNote: midiKey	| transposedKey pitch |	transposedKey _ midiKey + midiTranspose.	midiPort		ifNil: [			soundPlaying ifNotNil: [soundPlaying stopGracefully].			pitch _ AbstractSound pitchForMIDIKey: transposedKey.			soundPlaying _ soundPrototype soundForPitch: pitch dur: 100.0 loudness: 0.3.			SoundPlayer resumePlaying: soundPlaying quickStart: true]		ifNotNil: [			soundPlaying ifNotNil: [self turnOffNote].			midiPort midiCmd: 16r90 channel: 1 byte: transposedKey byte: 127.			soundPlaying _ transposedKey].! !!PianoKeyboardMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:05'!includeInNewMorphMenu	^ true! !A PianoRollNoteMorph is drawn as a simple mroph, but it carries the necessary state to locate its source sound event via its owner (a PianorRollScoreMorph) and the score therein.  Simple editing of pitch and time placement is provided here.!!PianoRollNoteMorph methodsFor: 'initialization' stamp: 'di 6/17/1999 10:46'!trackIndex: ti indexInTrack: i	trackIndex _ ti.	indexInTrack _ i.	selected _ false! !!PianoRollNoteMorph methodsFor: 'accessing' stamp: 'di 6/17/1999 11:17'!indexInTrack	^ indexInTrack! !!PianoRollNoteMorph methodsFor: 'accessing' stamp: 'di 6/17/1999 11:16'!trackIndex	^ trackIndex! !!PianoRollNoteMorph methodsFor: 'drawing' stamp: 'di 6/17/1999 10:56'!drawOn: aCanvas	selected		ifTrue: [aCanvas frameAndFillRectangle: self fullBounds fillColor: color borderWidth: 1 borderColor: Color black]		ifFalse: [aCanvas fillRectangle: self bounds color: color].! !!PianoRollNoteMorph methodsFor: 'geometry' stamp: 'di 6/17/1999 10:55'!fullBounds	selected		ifTrue: [^ bounds expandBy: 1]		ifFalse: [^ bounds]! !!PianoRollNoteMorph methodsFor: 'event handling' stamp: 'di 6/15/1999 14:55'!handlesMouseDown: evt	^ owner scorePlayer isPlaying not! !!PianoRollNoteMorph methodsFor: 'event handling' stamp: 'di 6/19/1999 10:26'!mouseDown: evt	hitLoc _ evt cursorPoint.	editMode _ nil.	owner submorphsDo:		[:m | (m isKindOf: PianoRollNoteMorph) ifTrue: [m deselect]].	selected _ true.	self changed.	owner selection: (Array with: trackIndex with: indexInTrack with: indexInTrack).	self playSound! !!PianoRollNoteMorph methodsFor: 'event handling' stamp: 'di 6/20/1999 12:37'!mouseMove: evt	| delta offsetEvt |	editMode == nil ifTrue:		["First movement determines edit mode"		((delta _ evt cursorPoint - hitLoc) dist: 0@0) <= 2 ifTrue:			[^ self  "No significant movement yet."].		delta x abs > delta y abs			ifTrue: [delta x > 0  "Horizontal drag"						ifTrue: [editMode _ #selectNotes]						ifFalse: [self playSound: nil.								offsetEvt _ evt copy setCursorPoint: evt cursorPoint + (20@0).								self invokeNoteMenu: offsetEvt]]			ifFalse: [editMode _ #editPitch  "Vertical drag"]].	editMode == #editPitch ifTrue: [self editPitch: evt].	editMode == #selectNotes ifTrue: [self selectNotes: evt].! !!PianoRollNoteMorph methodsFor: 'event handling' stamp: 'di 6/19/1999 08:29'!mouseUp: evt	self playSound: nil! !!PianoRollNoteMorph methodsFor: 'note playing' stamp: 'di 6/17/1999 11:48'!noteInScore	^ (owner score tracks at: trackIndex) at: indexInTrack! !!PianoRollNoteMorph methodsFor: 'note playing' stamp: 'di 6/17/1999 11:48'!noteOfDuration: duration	| note |	note _ self noteInScore.	^ (owner scorePlayer instrumentForTrack: trackIndex)			soundForMidiKey: note midiKey			dur: duration			loudness: (note velocity asFloat / 127.0)! !!PianoRollNoteMorph methodsFor: 'note playing' stamp: 'di 6/19/1999 08:19'!playSound	"This STARTS a single long sound.  It must be stopped by playing another or nil."	^ self playSound: (self soundOfDuration: 999.0)! !!PianoRollNoteMorph methodsFor: 'note playing' stamp: 'di 6/19/1999 08:13'!playSound: aSoundOrNil	SoundPlaying ifNotNil: [SoundPlaying stopGracefully].	SoundPlaying _ aSoundOrNil.	SoundPlaying ifNotNil: [SoundPlaying play].! !!PianoRollNoteMorph methodsFor: 'note playing' stamp: 'di 6/19/1999 08:03'!soundOfDuration: duration	| sound |	sound _ MixedSound new.	sound add: (self noteOfDuration: duration)		pan: (owner scorePlayer panForTrack: trackIndex)		volume: owner scorePlayer overallVolume *				(owner scorePlayer volumeForTrack: trackIndex).	^ sound! !!PianoRollNoteMorph methodsFor: 'menu' stamp: 'di 6/20/1999 13:22'!invokeNoteMenu: evt	"Invoke the note's edit menu."	| menu |	menu _ MenuMorph new defaultTarget: self.	menu addList:		#(('grid to next quarter'		gridToNextQuarter)		('grid to prev quarter'		gridToPrevQuarter)).	evt hand invokeMenu: menu event: evt.! !!PianoRollNoteMorph methodsFor: 'selecting' stamp: 'di 6/17/1999 12:16'!deselect	selected ifFalse: [^ self].	self changed.	selected _ false.! !!PianoRollNoteMorph methodsFor: 'selecting' stamp: 'di 6/17/1999 12:16'!select	selected ifTrue: [^ self].	selected _ true.	self changed! !!PianoRollNoteMorph methodsFor: 'selecting' stamp: 'di 6/17/1999 12:30'!selectFrom: selection	(trackIndex = (selection at: 1)		and: [indexInTrack >= (selection at: 2)		and: [indexInTrack <= (selection at: 3)]])		ifTrue: [selected ifFalse: [self select]]		ifFalse: [selected ifTrue: [self deselect]]! !!PianoRollNoteMorph methodsFor: 'selecting' stamp: 'di 6/19/1999 10:24'!selectNotes: evt	| lastMorph oldEnd saveOwner |	saveOwner _ owner.	(owner autoScrollForX: evt cursorPoint x) ifTrue:		["If scroll talkes place I will be deleted and my x-pos will become invalid."		owner _ saveOwner.		bounds _ bounds withLeft: (owner xForTime: self noteInScore time)].	oldEnd _ owner selection last.	(owner notesInRect: (evt cursorPoint x @ owner top corner: owner bottomRight))		do: [:m | m trackIndex = trackIndex ifTrue: [m deselect]].	self select.  lastMorph _ self.	(owner notesInRect: (self left @ owner top corner: evt cursorPoint x @ owner bottom))		do: [:m | m trackIndex = trackIndex ifTrue: [m select.  lastMorph _ m]].	owner selection: (Array with: trackIndex with: indexInTrack with: lastMorph indexInTrack).	lastMorph indexInTrack ~= oldEnd ifTrue:		["Play last note as selection grows or shrinks"		owner ifNotNil: [lastMorph playSound]]! !!PianoRollNoteMorph methodsFor: 'selecting' stamp: 'di 6/20/1999 11:44'!selected	^ selected! !!PianoRollNoteMorph methodsFor: 'editing' stamp: 'di 6/19/1999 08:14'!editPitch: evt	| mk note |	mk _ owner midiKeyForY: evt cursorPoint y.	note _ (owner score tracks at: trackIndex) at: indexInTrack.	note midiKey = mk ifTrue: [^ self].	note midiKey: mk.	self playSound: (self soundOfDuration: 999.0).	self position: self position x @ ((owner yForMidiKey: mk) - 1)! !!PianoRollNoteMorph methodsFor: 'editing' stamp: 'di 6/17/1999 16:08'!gridToNextQuarter	owner score gridTrack: trackIndex toQuarter: 1 at: indexInTrack.	owner rebuildFromScore! !!PianoRollNoteMorph methodsFor: 'editing' stamp: 'di 6/17/1999 16:08'!gridToPrevQuarter	owner score gridTrack: trackIndex toQuarter: -1 at: indexInTrack.	owner rebuildFromScore! !A PianoRollScoreMorph displays a score such as a MIDIScore, and will scroll through it tracking the porgress of a ScorePlayerMorph (from which it is usually spawned).timeScale is in pixels per score tick.Currently the ambient track (for synchronizing thumbnails, eg) is treated specially here and in the score.  This should be cleaned up by adding a trackType or something like it in the score.!!PianoRollScoreMorph methodsFor: 'initialization' stamp: 'di 6/20/1999 16:20'!initialize	super initialize.	borderWidth _ 1.	color _ Color white.	self extent: 400@300.	showMeasureLines _ true.	showBeatLines _ false.	self timeSignature: 4 over: 4.! !!PianoRollScoreMorph methodsFor: 'initialization' stamp: 'di 6/20/1999 00:53'!on: aScorePlayer	scorePlayer _ aScorePlayer.	score _ aScorePlayer score.	colorForTrack _ Color wheel: score tracks size.	leftEdgeTime _ 0.	timeScale _ 0.1.	indexInTrack _ Array new: score tracks size withAll: 1.	lastUpdateTick _ -1.	self updateLowestNote! !!PianoRollScoreMorph methodsFor: 'initialization' stamp: 'di 6/20/1999 12:25'!updateLowestNote	"find the actual lowest note in the score"	| n |	lowestNote _ 128 - (self innerBounds height // 3).	score tracks do: [:track |		1 to: track size do: [:i |			n _ track at: i.			(n isNoteEvent and: [n midiKey < lowestNote])				ifTrue: [lowestNote _ n midiKey - 4]]].! !!PianoRollScoreMorph methodsFor: 'accessing' stamp: 'di 6/20/1999 16:25'!beatsPerMeasure: n	^ self timeSignature: n over: notePerBeat! !!PianoRollScoreMorph methodsFor: 'accessing' stamp: 'di 6/20/1999 16:25'!notePerBeat: n	^ self timeSignature: beatsPerMeasure over: n! !!PianoRollScoreMorph methodsFor: 'accessing' stamp: 'di 6/15/1999 15:46'!score	^ score! !!PianoRollScoreMorph methodsFor: 'accessing' stamp: 'di 6/15/1999 14:52'!scorePlayer	^ scorePlayer! !!PianoRollScoreMorph methodsFor: 'accessing' stamp: 'di 6/20/1999 01:00'!selection	"Returns an array of 3 elements:		trackIndex		indexInTrack of first note		indexInTrack of last note"	| trackIndex track |	selection ifNil:  "If no selection, return last event of 1st non-muted track (or nil)"		[trackIndex _ (1 to: score tracks size)			detect: [:i | (scorePlayer mutedForTrack: i) not] ifNone: [^ nil].		track _ score tracks at: trackIndex.		^ Array with: trackIndex with: track size with: track size].	(scorePlayer mutedForTrack: selection first)		ifTrue: [selection _ nil.  ^ self selection].	^ selection! !!PianoRollScoreMorph methodsFor: 'accessing' stamp: 'di 6/17/1999 11:38'!selection: anArray	selection _ anArray! !!PianoRollScoreMorph methodsFor: 'accessing' stamp: 'di 6/20/1999 20:48'!timeSignature: num over: denom	beatsPerMeasure _ num.	notePerBeat _ denom.  "a number like 2, 4, 8"	self changed! !!PianoRollScoreMorph methodsFor: 'drawing' stamp: 'di 6/20/1999 16:35'!drawMeasureLinesOn: aCanvas	| ticksPerMeas x measureLineColor inner |	showBeatLines ifNil: [showBeatLines _ false].	showMeasureLines ifNil: [showMeasureLines _ true].	notePerBeat ifNil: [self timeSignature: 4 over: 4].	showBeatLines ifTrue:		[measureLineColor _ Color gray: 0.8.		ticksPerMeas _ score ticksPerQuarterNote.		inner _ self innerBounds.		(leftEdgeTime + ticksPerMeas truncateTo: ticksPerMeas)			to: ((self timeForX: self right - borderWidth) truncateTo: ticksPerMeas)			by: ticksPerMeas			do: [:tickTime | x _ self xForTime: tickTime.				aCanvas fillRectangle: (x @ inner top extent: 1 @ inner height)						color: measureLineColor]].	showMeasureLines ifTrue:		[measureLineColor _ Color gray: 0.7.		ticksPerMeas _ beatsPerMeasure*score ticksPerQuarterNote*4//notePerBeat.		inner _ self innerBounds.		(leftEdgeTime + ticksPerMeas truncateTo: ticksPerMeas)			to: ((self timeForX: self right - borderWidth) truncateTo: ticksPerMeas)			by: ticksPerMeas			do: [:tickTime | x _ self xForTime: tickTime.				aCanvas fillRectangle: (x @ inner top extent: 1 @ inner height)						color: measureLineColor]].! !!PianoRollScoreMorph methodsFor: 'drawing' stamp: 'jm 5/30/1999 17:56'!drawOn: aCanvas	super drawOn: aCanvas.	self drawStaffOn: aCanvas.! !!PianoRollScoreMorph methodsFor: 'drawing' stamp: 'di 6/20/1999 12:24'!drawStaffOn: aCanvas	| blackKeyColor l r topEdge y |	self drawMeasureLinesOn: aCanvas.	blackKeyColor _ Color gray: 0.5.	l _ self left + borderWidth.	r _ self right - borderWidth.	topEdge _ self top + borderWidth + 3.	lowestNote to: 127 do: [:k |		y _ self yForMidiKey: k.		y <= topEdge ifTrue: [^ self].  "over the top!!"		(self isBlackKey: k) ifTrue: [			aCanvas				fillRectangle: (l@y corner: r@(y + 1))				color: blackKeyColor]].! !!PianoRollScoreMorph methodsFor: 'drawing' stamp: 'jm 6/1/1998 07:52'!isBlackKey: midiKey	"Answer true if the given MIDI key corresponds to a black key on the piano keyboard."	| note |	note _ midiKey \\ 12.	note = 1 ifTrue: [^ true].	note = 3 ifTrue: [^ true].	note = 6 ifTrue: [^ true].	note = 8 ifTrue: [^ true].	note = 10 ifTrue: [^ true].	^ false! !!PianoRollScoreMorph methodsFor: 'drawing' stamp: 'di 6/20/1999 12:23'!rebuildFromScore	"Rebuild my submorphs from the score. This method should be invoked after changing the time scale, the color or visibility of a track, the extent of this morph, etc."	score ifNil: [^ self].	self addNotes.! !!PianoRollScoreMorph methodsFor: 'geometry' stamp: 'jm 5/30/1999 17:28'!contractTime	timeScale _ timeScale / 1.5.	self rebuildFromScore.! !!PianoRollScoreMorph methodsFor: 'geometry' stamp: 'jm 5/30/1999 17:29'!expandTime	timeScale _ timeScale * 1.5.	self rebuildFromScore.! !!PianoRollScoreMorph methodsFor: 'geometry' stamp: 'di 6/20/1999 15:25'!extent: aPoint	"Force rebuild when re-sized."	super extent: aPoint. 	score ifNotNil: [self updateLowestNote].	self rebuildFromScore.! !!PianoRollScoreMorph methodsFor: 'geometry' stamp: 'jm 9/11/1998 09:33'!fullBounds	"Overridden to clip submorph hit detection to my bounds."	fullBounds ifNil: [fullBounds _ bounds].	^ bounds! !!PianoRollScoreMorph methodsFor: 'geometry' stamp: 'jm 9/11/1998 09:20'!layoutChanged	"Override this to avoid propagating 'layoutChanged' when just adding/removing note objects."	fullBounds = bounds ifTrue: [^ self].	super layoutChanged.! !!PianoRollScoreMorph methodsFor: 'geometry' stamp: 'di 6/15/1999 14:48'!midiKeyForY: y	^ lowestNote - ((y - (bounds bottom - borderWidth - 4)) // 3)! !!PianoRollScoreMorph methodsFor: 'geometry' stamp: 'di 8/3/1998 21:35'!timeForX: aNumber	^ ((aNumber - bounds left - borderWidth) asFloat / timeScale + leftEdgeTime) asInteger! !!PianoRollScoreMorph methodsFor: 'geometry' stamp: 'di 8/3/1998 21:29'!xForTime: aNumber	^ ((aNumber - leftEdgeTime) asFloat * timeScale) asInteger + bounds left + borderWidth! !!PianoRollScoreMorph methodsFor: 'geometry' stamp: 'jm 7/10/1998 14:35'!yForMidiKey: midiKey	^ (bounds bottom - borderWidth - 4) - (3 * (midiKey - lowestNote))! !!PianoRollScoreMorph methodsFor: 'submorphs-add/remove' stamp: 'jm 10/30/2002 18:32'!addNotes	| visibleMorphs rightEdge topEdge track trackColor i done n nLeft nTop nRight |	visibleMorphs _ OrderedCollection new: 500.	rightEdge _ self right - borderWidth.	topEdge _ self top + borderWidth + 1.	1 to: score tracks size do:		[:trackIndex |		track _ score tracks at: trackIndex.		trackColor _ colorForTrack at: trackIndex.		i _ indexInTrack at: trackIndex.		done _ i > track size or: [scorePlayer mutedForTrack: trackIndex].		[done | (i > track size)] whileFalse: [			n _ track at: i.			(n isNoteEvent and: [n midiKey >= lowestNote]) ifTrue: [				nLeft _ self xForTime: n time.				nLeft > rightEdge					ifTrue: [done _ true]					ifFalse: [						nTop _ (self yForMidiKey: n midiKey) - 1.						nTop > topEdge ifTrue: [							nRight _ nLeft + (n duration * timeScale) truncated - 1.							visibleMorphs add:								((PianoRollNoteMorph									newBounds: (nLeft@nTop corner: nRight@(nTop + 3))									color: trackColor)									trackIndex: trackIndex indexInTrack: i)]]].			i _ i + 1].			(selection notNil				and: [trackIndex = selection first				and: [i >= selection second and: [(indexInTrack at: trackIndex) <= selection third]]])				ifTrue: [visibleMorphs do:						[:vm | (vm isKindOf: PianoRollNoteMorph) ifTrue: [vm selectFrom: selection]]].			].	"Add the cursor morph in front of all notes."	cursor ifNil: [  "create the cursor if needed; this is for legacy PianoRollScoreMorphs..."		cursor _			Morph newBounds: (self topLeft extent: 1@1)  "height and position are set later"			color: Color red].	visibleMorphs addFirst: cursor.	self changed.	self removeAllMorphs.	self addAllMorphs: visibleMorphs.! !!PianoRollScoreMorph methodsFor: 'event handling' stamp: 'di 6/17/1999 12:40'!handlesMouseDown: evt	^ true! !!PianoRollScoreMorph methodsFor: 'event handling' stamp: 'di 6/19/1999 09:02'!mouseDown: evt	| noteMorphs chordRect sound |	(self notesInRect: ((evt cursorPoint extent: 1@0) expandBy: 2@30)) isEmpty		ifTrue: ["If not near a note, then put up score edit menu"				^ self invokeScoreMenu: evt].	"Clicked near (but not on) a note, so play all notes at the cursor time"	noteMorphs _ self notesInRect: ((evt cursorPoint extent: 1@0) expandBy: 0@self height).	chordRect _ (self innerBounds withLeft: evt cursorPoint x) withWidth: 1.	soundsPlayingMorph _ Morph newBounds: chordRect color: Color green.	self addMorphBack: soundsPlayingMorph.		soundsPlaying _ IdentityDictionary new.	noteMorphs do:		[:m | sound _ m soundOfDuration: 999.0.		soundsPlaying at: m put: sound.		sound play].! !!PianoRollScoreMorph methodsFor: 'event handling' stamp: 'di 6/19/1999 09:02'!mouseMove: evt	| noteMorphs chordRect sound |	soundsPlaying ifNil: [^ self].	self autoScrollForX: evt cursorPoint x.	"Play all notes at the cursor time"	noteMorphs _ self notesInRect: ((evt cursorPoint extent: 1@0) expandBy: 0@self height).	chordRect _ (self innerBounds withLeft: evt cursorPoint x) withWidth: 1.	soundsPlayingMorph delete.	soundsPlayingMorph _ Morph newBounds: chordRect color: Color green.	self addMorphBack: soundsPlayingMorph.		noteMorphs do:		[:m |  "Add any new sounds"		(soundsPlaying includesKey: m)			ifFalse: [sound _ m soundOfDuration: 999.0.					soundsPlaying at: m put: sound.					sound play]].	soundsPlaying keys do:		[:m |  "Remove any sounds no longer in selection."		(noteMorphs includes: m)			ifFalse: [(soundsPlaying at: m) stopGracefully.					soundsPlaying removeKey: m]].! !!PianoRollScoreMorph methodsFor: 'event handling' stamp: 'di 6/18/1999 08:37'!mouseUp: evt	soundsPlayingMorph ifNotNil: [soundsPlayingMorph delete].	soundsPlaying ifNotNil: [soundsPlaying do: [:s | s stopGracefully]].	soundsPlayingMorph _ soundsPlaying _ nil! !!PianoRollScoreMorph methodsFor: 'menu' stamp: 'jm 2/4/2003 13:34'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'expand time' action: #expandTime.	aCustomMenu add: 'contract time' action: #contractTime.	(self valueOfProperty: #dragNDropEnabled) == true		ifTrue: [aCustomMenu add: 'close drag and drop' action: #toggleDragNDrop]		ifFalse: [aCustomMenu add: 'open drag and drop' action: #toggleDragNDrop].! !!PianoRollScoreMorph methodsFor: 'menu' stamp: 'di 6/18/1999 15:55'!addKeyboard	(KeyboardMorphForInput new pianoRoll: self) openInWorld! !!PianoRollScoreMorph methodsFor: 'menu' stamp: 'di 6/18/1999 16:04'!beatLinesOnOff	showBeatLines _ showBeatLines not.	self changed! !!PianoRollScoreMorph methodsFor: 'menu' stamp: 'di 6/20/1999 23:34'!invokeScoreMenu: evt	"Invoke the score's edit menu."	| menu subMenu |	menu _ MenuMorph new defaultTarget: self.	menu addList:		#(('cut'		cutSelection)		('copy'		copySelection)		('paste'		insertSelection)		('paste...'	insertTransposed)).	menu addLine.	menu addList:		#(('legato'		selectionBeLegato)		('staccato'		selectionBeStaccato)		('normal'		selectionBeNormal)).	menu addLine.	menu addList:		#(('expand time'		expandTime)		('contract time'		contractTime)).	menu addLine.	subMenu _ MenuMorph new defaultTarget: self.		(2 to: 12) do: [:i | subMenu add: i printString selector: #beatsPerMeasure: argument: i].		menu add: 'time   ', beatsPerMeasure printString subMenu: subMenu.	subMenu _ MenuMorph new defaultTarget: self.		#(2 4 8) do: [:i | subMenu add: i printString selector: #notePerBeat: argument: i].		menu add: 'sig     ', notePerBeat printString subMenu: subMenu.	menu addLine.	showMeasureLines		ifTrue: [menu add: 'hide measure lines' action: #measureLinesOnOff]		ifFalse: [menu add: 'show measure lines' action: #measureLinesOnOff].	showBeatLines		ifTrue: [menu add: 'hide beat lines' action: #beatLinesOnOff]		ifFalse: [menu add: 'show beat lines' action: #beatLinesOnOff].	menu addLine.	menu add: 'add keyboard' action: #addKeyboard.	evt hand invokeMenu: menu event: evt.! !!PianoRollScoreMorph methodsFor: 'menu' stamp: 'di 6/17/1999 22:10'!measureLinesOnOff	showMeasureLines _ showMeasureLines not.	self changed! !!PianoRollScoreMorph methodsFor: 'editing' stamp: 'di 6/20/1999 23:16'!appendEvent: noteEvent fullDuration: fullDuration 	| sel x |	score appendEvent: noteEvent fullDuration: fullDuration at: (sel _ self selection).	noteEvent midiKey = -1 ifFalse:  "Unless it is a rest..."		["Advance the selection to the note just entered"		selection _ Array with: sel first with: sel third + 1 with: sel third + 1].	"This is all horribly inefficient..."	scorePlayer updateDuration.	(x _ self xForTime: noteEvent endTime) > (self right - 30) ifTrue:		[self autoScrollForX: x + (30 + self width // 4)].	self updateLowestNote.	self rebuildFromScore! !!PianoRollScoreMorph methodsFor: 'editing' stamp: 'di 6/17/1999 12:58'!copySelection	selection == nil ifTrue: [^ self].	NotePasteBuffer _ (score tracks at: selection first)		copyFrom: selection second to: selection third! !!PianoRollScoreMorph methodsFor: 'editing' stamp: 'di 6/20/1999 00:25'!cutSelection	selection == nil ifTrue: [^ self].	self copySelection.	self deleteSelection! !!PianoRollScoreMorph methodsFor: 'editing' stamp: 'jm 10/11/2002 06:30'!deleteSelection	| selMorphs priorEvent x |	(selection == nil or: [selection second = 0]) ifTrue: [^ self].	score cutSelection: selection.	selection second > 1		ifTrue: [selection at: 2 put: selection second - 1.				selection at: 3 put: selection second.				priorEvent _ (score tracks at: selection first) at: selection second.				(x _ self xForTime: priorEvent time) < (self left + 30) ifTrue:					[self autoScrollForX: x - (30 + self width // 4)]]		ifFalse: [selection _ nil].	scorePlayer updateDuration.	self rebuildFromScore.	selMorphs _ self submorphs select:		[:m | (m isKindOf: PianoRollNoteMorph) and: [m selected]].	selMorphs isEmpty ifFalse: [(selMorphs last noteOfDuration: 0.3) play]! !!PianoRollScoreMorph methodsFor: 'editing' stamp: 'di 6/21/1999 10:49'!insertSelection	self selection == nil ifTrue: [^ self].	score insertEvents: NotePasteBuffer at: self selection.	scorePlayer updateDuration.	self rebuildFromScore ! !!PianoRollScoreMorph methodsFor: 'editing' stamp: 'di 6/20/1999 23:37'!insertTransposed	| delta transposedNotes |	(delta _ (SelectionMenu selections: ((12 to: -12 by: -1) collect: [:i | i printString]))			startUpWithCaption: 'offset...') ifNil: [^ self].	transposedNotes _ NotePasteBuffer collect: [:note | note copy midiKey: note midiKey + delta].	selection == nil ifTrue: [^ self].	score insertEvents: transposedNotes at: self selection.	scorePlayer updateDuration.	self rebuildFromScore! !!PianoRollScoreMorph methodsFor: 'scrolling' stamp: 'di 6/19/1999 10:56'!autoScrollForX: x	"Scroll by the amount x lies outside of my innerBounds.  Return true if this happens."	| d ticks |	((d _ x - self innerBounds right) > 0		or: [(d _ x - self innerBounds left) < 0])		ifTrue: [ticks _ (self timeForX: self bounds center x + d+1)						min: score durationInTicks max: 0.				self moveCursorToTime: ticks.				scorePlayer ticksSinceStart: ticks.				^ true].	^ false! !!PianoRollScoreMorph methodsFor: 'scrolling' stamp: 'di 6/19/1999 09:30'!goToTime: scoreTime	| track trackSize index newLeftEdgeTime |	newLeftEdgeTime _ scoreTime asInteger.	newLeftEdgeTime < leftEdgeTime		ifTrue: [indexInTrack _ Array new: score tracks size+1 withAll: 1].	leftEdgeTime _ newLeftEdgeTime.	1 to: score tracks size do: [:trackIndex |		track _ score tracks at: trackIndex.		index _ indexInTrack at: trackIndex.		trackSize _ track size.		[(index < trackSize) and:		 [(track at: index) endTime < leftEdgeTime]]			whileTrue: [index _ index + 1].		indexInTrack at: trackIndex put: index].	self addNotes.! !!PianoRollScoreMorph methodsFor: 'scrolling' stamp: 'di 6/19/1999 09:29'!moveCursorToTime: scoreTime	| cursorOffset desiredCursorHeight |	scorePlayer isPlaying		ifTrue:			[cursorOffset _ ((scoreTime - leftEdgeTime) asFloat * timeScale) asInteger.			(cursorOffset < 0				or: [cursorOffset > (self width-20)])				ifTrue:				[self goToTime: scoreTime - (20/timeScale).				cursorOffset _ ((scoreTime - leftEdgeTime) asFloat * timeScale) asInteger]]		ifFalse:			[self goToTime: scoreTime - (self width//2 / timeScale).			cursorOffset _ ((scoreTime - leftEdgeTime) asFloat * timeScale) asInteger].	cursor position: (self left + borderWidth + cursorOffset)@(self top + borderWidth).	desiredCursorHeight _ self height.	cursor height ~= desiredCursorHeight ifTrue: [cursor extent: 1@desiredCursorHeight].! !!PianoRollScoreMorph methodsFor: 'scrolling' stamp: 'jm 10/11/2002 06:31'!notesInRect: timeSlice	^ self submorphs select:		[:m | (timeSlice intersects: m bounds)				and: [m isKindOf: PianoRollNoteMorph]]! !!PianoRollScoreMorph methodsFor: 'stepping' stamp: 'jm 5/30/1999 18:01'!step	| t |	score ifNil: [^ self].	lastMutedState ~= scorePlayer mutedState ifTrue: [		self rebuildFromScore.		lastMutedState _ scorePlayer mutedState copy].	t _ scorePlayer ticksSinceStart.	t = lastUpdateTick ifFalse: [		self moveCursorToTime: t.		lastUpdateTick _ t].! !!PianoRollScoreMorph methodsFor: 'stepping' stamp: 'jm 6/1/1998 09:07'!stepTime	^ 0! !!PianoRollScoreMorph methodsFor: 'as yet unclassified' stamp: 'ar 5/29/1999 05:03'!drawSubmorphsOn: aCanvas	aCanvas clipBy: self innerBounds			during:[:clippedCanvas| super drawSubmorphsOn: clippedCanvas].! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!bend	^ bend! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!bend: midiPitchBend	bend _ midiPitchBend.! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!bend: midiPitchBend channel: midiChannel	bend _ midiPitchBend.	channel _ midiChannel.! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel	^ channel! !!PitchBendEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel: midiChannel	channel _ midiChannel.! !!PitchBendEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:45'!isPitchBend	^ true! !!PitchBendEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port."	aMidiPort		midiCmd: 16rE0		channel: channel		byte: (bend bitAnd: 16r7F)		byte: (bend bitShift: -7).! !!PitchBendEvent methodsFor: 'printing' stamp: 'jm 9/10/1998 09:42'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': bend '.	bend printOn: aStream.	aStream nextPut: $).! !m _ PlotterMorph openm plotX: 0.5 y: 0 color: Color blue(-1.0 to: 1.0 by: 0.01) do: [:x |	y _ (Float pi * 2 * x) sin + (Float pi * 2 * x) cos.	m plotX: x y: y / 2 color: Color red].r _ Random new.m clear.5000 timesRepeat: [	x _ (2.0 * r next) - 1.0.	y _ (2.0 * r next) - 1.0.	m plotX: x y: y color: Color random].m inspect!!PlotterMorph methodsFor: 'as yet unclassified' stamp: 'jm 8/7/2003 21:31'!clear	points _ points species new.	functions _ functions species new.	self changed.! !!PlotterMorph methodsFor: 'as yet unclassified' stamp: 'jm 8/7/2003 21:31'!clearFunctions	functions _ functions species new.	self changed.! !!PlotterMorph methodsFor: 'as yet unclassified' stamp: 'jm 8/7/2003 21:31'!clearPoints	points _ points species new.	self changed.! !!PlotterMorph methodsFor: 'as yet unclassified' stamp: 'jm 8/7/2003 21:30'!drawOn: aCanvas	| nibSize drawExtent xScale yScale x y clipCanvas |	super drawOn: aCanvas.	nibSize _ 3.	drawExtent _ self innerBounds extent - nibSize.	xScale _ drawExtent x asFloat / (xMax - xMin) asFloat.	yScale _ drawExtent y asFloat / (yMax - yMin) asFloat.	clipCanvas _ aCanvas copyClipRect: self innerBounds.	points do: [:entry |		x _ self left + borderWidth + (xScale * ((entry at: 1) - xMin)) rounded.		y _ self bottom - borderWidth - nibSize - (yScale * ((entry at: 2) - yMin)) rounded.		clipCanvas fillRectangle: (x@y extent: 3) color: entry last].! !!PlotterMorph methodsFor: 'as yet unclassified' stamp: 'jm 8/7/2003 18:26'!initialize	super initialize.	self color: Color white.	xMin _ -1.0.	xMax _ 1.0.	yMin _ -1.0.	yMax _ 1.0.	points _ OrderedCollection new.	functions _ OrderedCollection new.! !!PlotterMorph methodsFor: 'as yet unclassified' stamp: 'jm 8/7/2003 21:31'!plotFunction: aString color: aColor	functions addLast: (Array with: aString with: aColor).	self changed.! !!PlotterMorph methodsFor: 'as yet unclassified' stamp: 'jm 8/7/2003 21:31'!plotX: x y: y color: aColor	points addLast: (Array with: x with: y with: aColor).	self changed.! !!PluckedSound methodsFor: 'initialization' stamp: 'jm 7/6/1998 17:09'!setPitch: pitchNameOrNumber dur: d loudness: vol	| p sz |	super setPitch: pitchNameOrNumber dur: d loudness: vol.	p _ self nameOrNumberToPitch: pitchNameOrNumber.	initialCount _ (d * self samplingRate asFloat) asInteger.	ring _ SoundBuffer newMonoSampleCount:		(((2.0 * self samplingRate) / p) asInteger max: 2).	sz _ ring monoSampleCount.	scaledIndexLimit _ (sz + 1) * ScaleFactor.	scaledIndexIncr _ (p * sz * ScaleFactor) // (2.0 * self samplingRate).	self reset.! !!PluckedSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:07'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate! !!PluckedSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:40'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 9/8/1998 16:18'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"The Karplus-Strong plucked string algorithm: start with a buffer full of random noise and repeatedly play the contents of that buffer while averaging adjacent samples. High harmonics damp out more quickly, transfering their energy to lower ones. The length of the buffer corresponds to the length of the string."	"(PluckedSound pitch: 220.0 dur: 6.0 loudness: 0.8) play"	| lastIndex scaledThisIndex scaledNextIndex average sample i s |	<primitive: 181>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #ring declareC: 'short int *ring'.	lastIndex _ (startIndex + n) - 1.	scaledThisIndex _ scaledNextIndex _ scaledIndex.	startIndex to: lastIndex do: [:sliceIndex |		scaledNextIndex _ scaledThisIndex + scaledIndexIncr.		scaledNextIndex >= scaledIndexLimit			ifTrue: [scaledNextIndex _ ScaleFactor + (scaledNextIndex - scaledIndexLimit)].		average _			((ring at: scaledThisIndex // ScaleFactor) +			 (ring at: scaledNextIndex // ScaleFactor)) // 2.		ring at: scaledThisIndex // ScaleFactor put: average.		sample _ (average * scaledVol) // ScaleFactor.  "scale by volume"		scaledThisIndex _ scaledNextIndex.		leftVol > 0 ifTrue: [			i _ (2 * sliceIndex) - 1.			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i _ 2 * sliceIndex.			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0]]].	scaledIndex _ scaledNextIndex.	count _ count - n.! !!PluckedSound methodsFor: 'sound generation' stamp: 'jm 9/9/1998 21:58'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!PluggableButtonController methodsFor: 'basic control sequence' stamp: 'acg 3/13/2000 08:49'!controlInitialize 	"Provide feedback indicating that button has been entered with the mouse down. If triggerOnMouseDown is true, then do the button action on mouse down--and don't bother with the feedback since the action happens immediately."	sensor anyButtonPressed ifFalse: [^ self].	view triggerOnMouseDown		ifTrue: [sensor yellowButtonPressed 			ifTrue: [self yellowButtonActivity]			ifFalse: [view performAction]]		ifFalse: [view toggleMouseOverFeedback.				 shownAsComplemented _ true]! !!PluggableButtonController methodsFor: 'basic control sequence' stamp: 'acg 3/13/2000 08:44'!controlTerminate 	"Reverse the feedback displayed by controlInitialize, if any. Perform the button action if necessary."	view ifNotNil:		[view triggerOnMouseDown			ifFalse:				[shownAsComplemented ifTrue: [view toggleMouseOverFeedback].				self viewHasCursor ifTrue: [view performAction]]]! !!PluggableButtonController methodsFor: 'control defaults' stamp: 'sma 5/28/2000 16:29'!controlActivity 	shownAsComplemented ifNil: [^ self].	shownAsComplemented = self viewHasCursor		ifFalse:			[view ifNotNil: [view toggleMouseOverFeedback]. 			shownAsComplemented _ shownAsComplemented not]! !!PluggableButtonController methodsFor: 'control defaults' stamp: 'acg 3/13/2000 08:26'!isControlActive 	^ sensor anyButtonPressed! !!PluggableButtonController methodsFor: 'button activity' stamp: 'di 9/7/1999 08:44'!yellowButtonActivity	"Invoke the model's menu.  This is option-click, NOT the normal button press."	| menu |	menu _ view getMenu: false.	menu == nil		ifTrue: [sensor waitNoButton]		ifFalse: [self terminateAndInitializeAround: [menu invokeOn: model]].! !!PluggableButtonMorph methodsFor: 'accessing'!action: aSymbol 	"Set actionSelector to be the action defined by aSymbol."	actionSelector _ aSymbol.! !!PluggableButtonMorph methodsFor: 'accessing' stamp: 'sw 10/25/1999 14:36'!offColor	^ offColor! !!PluggableButtonMorph methodsFor: 'private' stamp: 'di 6/26/1998 09:40'!getMenu: shiftPressed	"Answer the menu for this button, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ MenuMorph new defaultTarget: model.	getMenuSelector numArgs = 1 ifTrue:		[^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2 ifTrue:		[^ model perform: getMenuSelector with: menu with: shiftPressed].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonMorph methodsFor: 'private' stamp: 'sma 6/5/2000 13:31'!invokeMenu: evt	"Invoke my menu in response to the given event."	| menu |	menu _ self getMenu: evt shiftPressed.	menu ifNotNil: [menu popUpEvent: evt]! !!PluggableButtonMorph methodsFor: 'private' stamp: 'tk 10/30/1999 08:31'!performAction	"Inform the model that this button has been pressed. Sent by the controller when this button is pressed."	askBeforeChanging ifTrue: [model okToChange ifFalse: [^ self]].	actionSelector ifNotNil: [model perform: actionSelector].! !!PluggableButtonMorph class methodsFor: 'instance creation'!on: anObject	^ self on: anObject getState: #isOn action: #switch! !!PluggableButtonView methodsFor: 'accessing' stamp: 'jrm 6/1/1998 21:53'!action: aSymbol 	"Set actionSelector to be the action defined by aSymbol."	actionSelector _ aSymbol! !!PluggableButtonView methodsFor: 'accessing' stamp: 'di 5/10/1999 17:51'!label: aStringOrDisplayObject 	"Label this button with the given String or DisplayObject."	((aStringOrDisplayObject isKindOf: Paragraph)	or: [aStringOrDisplayObject isKindOf: Form])		ifTrue: [label _ aStringOrDisplayObject]		ifFalse: [label _ aStringOrDisplayObject asParagraph].	self centerLabel.! !!PluggableButtonView methodsFor: 'displaying' stamp: 'acg 2/23/2000 00:18'!displayView	"Displays this switch and its label, if any."	self clearInside.	label ifNotNil: [		(label isKindOf: Paragraph) ifTrue: [			label foregroundColor: self foregroundColor				 backgroundColor: self backgroundColor].		label displayOn: Display				at: label boundingBox topLeft				clippingBox: self insetDisplayBox].	complemented _ false.! !!PluggableButtonView methodsFor: 'displaying' stamp: 'jm 5/26/2003 01:34'!toggleMouseOverFeedback	"Complement the label (or a portion of the displayBox if no label is defined) to show that the mouse is over this button. This feedback can be removed by a second call to this method."	Display reverse: self insetDisplayBox.	Display reverse: (self insetDisplayBox insetBy: 2).! !!PluggableButtonView methodsFor: 'private' stamp: 'acg 2/23/2000 00:16'!centerAlignLabelWith: aPoint	"Align the center of the label with aPoint."	| alignPt |	alignPt _ label boundingBox center.	(label isKindOf: Paragraph) ifTrue: 		[alignPt _ alignPt + (0@(label textStyle leading))]. 	label align: alignPt with: aPoint! !!PluggableButtonView methodsFor: 'private' stamp: 'acg 2/23/2000 00:10'!centerLabel	"If there is a label, align its center with the center of the insetDisplayBox"	label ifNotNil: 		[self centerAlignLabelWith: self insetDisplayBox center].! !!PluggableButtonView methodsFor: 'private' stamp: 'di 6/26/1998 11:04'!getMenu: shiftKeyDown	"Answer the menu for this view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableButtonView methodsFor: 'private' stamp: 'acg 2/23/2000 00:09'!insetDisplayBox	"Answer the receiver's inset display box. The inset display box is the 	intersection of the receiver's window, tranformed to display coordinates, 	and the inset display box of the superView, inset by the border width. 	The inset display box represents the region of the display screen in 	which the inside of the receiver (all except the border) is displayed. If 	the receiver is totally clipped by the display screen and its superView, 	the resulting Rectangle will be invalid."	insetDisplayBox ifNil: 		[insetDisplayBox _ self computeInsetDisplayBox.		 self centerLabel].	^insetDisplayBox! !!PluggableButtonView class methodsFor: 'instance creation' stamp: 'jm 8/14/1998 16:19'!on: anObject	^ self on: anObject getState: #isOn action: #switch! !Class PluggableDictionary allows the redefinition of hashing and equality by clients. This is in particular useful if the clients know about specific properties of the objects stored in the dictionary. See the class comment of PluggableSet for an example.Instance variables:	hashBlock	<BlockContext>	A one argument block used for hashing the elements.	equalBlock	<BlockContext>	A two argument block used for comparing the elements.!!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!equalBlock	"Return the block used for comparing the elements in the receiver."	^equalBlock! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/27/1998 23:55'!equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered to be equal, false otherwise"	equalBlock _ aBlock.! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!hashBlock	"Return the block used for hashing the elements in the receiver."	^hashBlock! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:46'!hashBlock: aBlock	"Set a new hash block. The block must accept one argument and must return the hash value of the given argument."	hashBlock _ aBlock.! !!PluggableDictionary methodsFor: 'accessing' stamp: 'ar 11/20/1998 16:24'!keys	"Answer a Set containing the receiver's keys."	| aSet |	aSet _ PluggableSet new: self size.	aSet equalBlock: self equalBlock fixTemps.	aSet hashBlock: self hashBlock fixTemps.	self keysDo: [:key | aSet add: key].	^ aSet! !!PluggableDictionary methodsFor: 'copying' stamp: 'ar 11/12/1998 18:48'!copy	^super copy postCopyBlocks! !!PluggableDictionary methodsFor: 'copying' stamp: 'ar 11/12/1998 18:48'!postCopyBlocks	hashBlock _ hashBlock copy.	equalBlock _ equalBlock copy.	"Fix temps in case we're referring to outside stuff"	hashBlock fixTemps.	equalBlock fixTemps.! !!PluggableDictionary methodsFor: 'private' stamp: 'ar 11/12/1998 18:45'!init: n	super init: n.	hashBlock _ [:element| element hash].	equalBlock _ [:element1 :element2| element1 = element2].! !!PluggableDictionary methodsFor: 'private' stamp: 'ar 11/20/1998 16:08'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ ((hashBlock value: anObject) \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [					equalBlock value: element key value: anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [			equalBlock value: element key value: anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!PluggableDictionary class methodsFor: 'as yet unclassified' stamp: 'di 6/12/2000 22:13'!integerDictionary	"A stopgap, until we get the pluggable init code."	^ Dictionary new: 500! !!PluggableListController methodsFor: 'initialization' stamp: 'di 5/25/1998 10:15'!initialize	super initialize.	self terminateDuringSelect: false! !!PluggableListController methodsFor: 'private' stamp: 'di 5/25/1998 10:20'!changeModelSelection: anInteger	"Let the view handle this."	terminateDuringSelect ifTrue: [self controlTerminate].	view changeModelSelection: anInteger.	terminateDuringSelect ifTrue: [self controlInitialize].! !!PluggableListController methodsFor: 'private' stamp: 'sma 3/11/2000 15:38'!processKeyboard	sensor keyboardPressed		ifTrue: [view handleKeystroke: sensor keyboard]		ifFalse: [super processKeyboard]! !!PluggableListController methodsFor: 'private' stamp: 'di 5/25/1998 10:14'!terminateDuringSelect: trueOrFalse	terminateDuringSelect _ trueOrFalse! !!PluggableListControllerOfMany methodsFor: 'control defaults' stamp: 'tk 4/8/98 11:08'!redButtonActivity	| selection firstHit turningOn lastSelection pt scrollFlag |	model okToChange ifFalse: [^ self].		"Don't change selection if model refuses to unlock"	firstHit _ true.	scrollFlag _ false.	lastSelection _ 0.	[sensor redButtonPressed] whileTrue: 		[selection _ view findSelection: (pt _ sensor cursorPoint).		selection == nil ifTrue:  "Maybe out of box - check for auto-scroll"			[pt y < view insetDisplayBox top ifTrue:				[self scrollView: view list lineGrid.				scrollFlag _ true.				selection _ view firstShown].			pt y > view insetDisplayBox bottom ifTrue:				[self scrollView: view list lineGrid negated.				scrollFlag _ true.				selection _ view lastShown]].		(selection == nil or: [selection = lastSelection]) ifFalse: 			[firstHit ifTrue:				[firstHit _ false.				turningOn _ (model listSelectionAt: selection) not].			view selection: selection.			(model listSelectionAt: selection) == turningOn ifFalse:				[view displaySelectionBox.				model listSelectionAt: selection put: turningOn].			lastSelection _ selection]].	selection notNil ifTrue:		["Normal protocol delivers change, so unchange first (ugh)"		model listSelectionAt: selection put: (model listSelectionAt: selection) not.		self changeModelSelection: selection].	scrollFlag ifTrue: [self moveMarker]! !When a PluggableListMorph is in focus, type in a letter (or severalletters quickly) to go to the next item that begins with that letter.Arrow and navigation keys are also supported (up, down, home, etc.).!!PluggableListMorph methodsFor: 'initialization' stamp: 'jm 10/12/2002 05:53'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	self color: Color white.	self model: anObject.	getListSelector _ getListSel.	getIndexSelector _ getSelectionSel.	setIndexSelector _ setSelectionSel.	getMenuSelector _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self borderWidth: 1.	self list: self getList.	self selectionIndex: self getCurrentSelectionIndex.	lastKeystrokeTime _ 0.	lastKeystrokes _ ''.! !!PluggableListMorph methodsFor: 'accessing' stamp: 'jm 10/12/2002 05:56'!autoDeselect: aBoolean	"Enable/disable autoDeselect."	autoDeselect _ aBoolean.! !!PluggableListMorph methodsFor: 'accessing' stamp: 'jm 10/11/2002 19:32'!doubleClickSelector: aSelectorOrNil	aSelectorOrNil		ifNil: [doubleClickSelector _ nil]		ifNotNil: [doubleClickSelector _ aSelectorOrNil asSymbol].! !!PluggableListMorph methodsFor: 'accessing' stamp: 'jm 9/20/1998 17:28'!font	^ font! !!PluggableListMorph methodsFor: 'accessing' stamp: 'jm 9/20/1998 19:48'!font: aFontOrNil	font _ aFontOrNil.	self list: self getList.  "update display"! !!PluggableListMorph methodsFor: 'accessing' stamp: 'jm 12/12/2003 11:03'!list: listOfStrings	| morphList h loc index |	listHasChanged _ true.  "used by mouseMove:"	scroller removeAllMorphs.	list _ listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [self setScrollDeltas.  ^ self selectedMorph: nil].	"NOTE: we will want a quick StringMorph init message, possibly even		combined with event install and positioning"	font ifNil: [font _ Preferences standardListFont].	morphList _ list collect:		[:item | item isText			ifTrue: [StringMorph contents: item font: font emphasis: (item emphasisAt: 1)]			ifFalse: [StringMorph contents: item font: font]].	"Lay items out vertically and install them in the scroller"	h _ morphList first height "self listItemHeight".	loc _ 0@0.	morphList do: [:m | m bounds: (loc extent: 9999@h).  loc _ loc + (0@h)].	scroller addAllMorphs: morphList.	index _ self getCurrentSelectionIndex.	self selectedMorph: ((index = 0 or: [index > morphList size]) ifTrue: [nil] ifFalse: [morphList at: index]).	self setScrollDeltas.	scrollBar setValue: 0.0.! !!PluggableListMorph methodsFor: 'accessing' stamp: 'di 5/22/1998 00:32'!listItemHeight	"This should be cleaned up.  The list should get spaced by this parameter."	^ 12! !!PluggableListMorph methodsFor: 'drawing' stamp: 'ar 11/15/1998 23:45'!drawOn: aCanvas	super drawOn: aCanvas.	selectedMorph ifNotNil:		[aCanvas fillRectangle:			(((scroller transformFrom: self) localBoundsToGlobal: selectedMorph bounds)						intersect: scroller bounds)				color: color darker]! !!PluggableListMorph methodsFor: 'drawing'!highlightSelection	selectedMorph ifNotNil: [selectedMorph color: Color red]! !!PluggableListMorph methodsFor: 'drawing'!unhighlightSelection	selectedMorph ifNotNil: [selectedMorph color: Color black]! !!PluggableListMorph methodsFor: 'events-mouse' stamp: 'jm 10/12/2002 05:49'!handlesMouseDown: evt	^ true! !!PluggableListMorph methodsFor: 'events-mouse' stamp: 'jm 12/12/2003 11:03'!mouseDown: evt	| adjustedPoint hitItem |	adjustedPoint _ (evt transformedBy: (scroller transformFrom: self)) cursorPoint.	hitItem _ scroller submorphs detect: [:m | m containsPoint: adjustedPoint] ifNone: [^ self beep].	listHasChanged _ false.	self mouseDown: evt onItem: hitItem.! !!PluggableListMorph methodsFor: 'events-mouse' stamp: 'di 6/26/1998 13:33'!mouseDown: event onItem: aMorph	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	model okToChange ifFalse: [^ self].  "No change if model is locked"	((autoDeselect == nil or: [autoDeselect]) and: [aMorph == selectedMorph])		ifTrue: [self setSelectedMorph: nil]		ifFalse: [self setSelectedMorph: aMorph].! !!PluggableListMorph methodsFor: 'events-mouse' stamp: 'jm 12/12/2003 11:05'!mouseMove: evt	"Allow dragging of the selection."	| adjustedPoint hitItem |	evt yellowButtonPressed | listHasChanged ifTrue: [^ self].	adjustedPoint _ (evt transformedBy: (scroller transformFrom: self)) cursorPoint.	hitItem _ scroller submorphs detect: [:m | m containsPoint: adjustedPoint] ifNone: [^ self].	selectedMorph = hitItem ifFalse: [self mouseDown: evt onItem: hitItem].! !!PluggableListMorph methodsFor: 'events-keyboard' stamp: 'JLM 10/8/1999 03:49'!basicKeyPressed: aChar 	| oldSelection nextSelection max milliSeconds nextSelectionList nextSelectionText |	nextSelection _ oldSelection _ self getCurrentSelectionIndex.	max _ self maximumSelection.	milliSeconds _ Time millisecondClockValue.	milliSeconds - lastKeystrokeTime > 300 ifTrue: ["just use the one current character for selecting"		lastKeystrokes _ ''].	lastKeystrokes _ lastKeystrokes , aChar asLowercase asString.	lastKeystrokeTime _ milliSeconds.	nextSelectionList _ OrderedCollection newFrom: (list copyFrom: oldSelection + 1 to: max).	nextSelectionList addAll: (list copyFrom: 1 to: oldSelection).	"Get rid of blanks and style used in some lists"	nextSelectionText _ nextSelectionList detect: [:a | a asString withBlanksTrimmed asLowercase beginsWith: lastKeystrokes]				ifNone: [^ self flash"match not found"].	model okToChange ifFalse: [^ self].	nextSelection _ list findFirst: [:a | a == nextSelectionText].	"No change if model is locked"	oldSelection == nextSelection ifTrue: [^ self flash].	^ self changeModelSelection: nextSelection! !!PluggableListMorph methodsFor: 'events-keyboard' stamp: 'jm 10/12/2002 06:05'!keyStroke: event 	"Process the given keystroke event. Three categories of keystokes:		a. special keys (ascii values < 32; includes control keys)		b. modifier keys (keystroke with a modifier key such as cmd, alt, or option)		c. basic (plain, ordinary keystrokes)"	| char ascii |	char _ event keyCharacter.	ascii _ char asciiValue.	ascii < 32 ifTrue: [^ self specialKeyPressed: ascii].	event anyModifierKeyPressed ifTrue: [^ self modifierKeyPressed: char].	self basicKeyPressed: char.! !!PluggableListMorph methodsFor: 'events-keyboard' stamp: 'jm 10/12/2002 06:09'!modifierKeyPressed: aChar	"Ask the model to process a modifier key."	| args |	model ifNil: [^ self].	keystrokeActionSelector ifNil: [^ self].	args _ keystrokeActionSelector numArgs.	args = 1 ifTrue: [^ model perform: keystrokeActionSelector with: aChar].	args = 2 ifTrue: [		^ model			perform: keystrokeActionSelector			with: aChar			with: self].	^ self error: 'keystrokeActionSelector must be a 1- or 2-keyword symbol'! !!PluggableListMorph methodsFor: 'events-keyboard' stamp: 'jm 10/12/2002 06:43'!mouseEnter: evt	"Grab keyboard focus when the mouse is over me."	super mouseEnter: evt.	evt hand newKeyboardFocus: self.! !!PluggableListMorph methodsFor: 'events-keyboard' stamp: 'JLM 10/8/1999 03:50'!specialKeyPressed: asciiValue 	| oldSelection nextSelection max howManyItemsShowing |	nextSelection _ oldSelection _ self getCurrentSelectionIndex.	max _ self maximumSelection.	asciiValue == 31		ifTrue: 			[" down arrow"			nextSelection _ oldSelection + 1.			nextSelection > max ifTrue: [nextSelection _ 1]].	asciiValue == 30		ifTrue: 			[" up arrow"			nextSelection _ oldSelection - 1.			nextSelection < 1 ifTrue: [nextSelection _ max]].	asciiValue == 1 ifTrue: [" home"		nextSelection _ 1].	asciiValue == 4 ifTrue: [" end"		nextSelection _ max].	howManyItemsShowing _ self numSelectionsInView.	asciiValue == 11 ifTrue: [" page up"		nextSelection _ 1 max: oldSelection - howManyItemsShowing].	asciiValue == 12 ifTrue: [" page down"		nextSelection _ oldSelection + howManyItemsShowing min: max].	model okToChange ifFalse: [^ self].	"No change if model is locked"	oldSelection == nextSelection ifTrue: [^ self flash].	^ self changeModelSelection: nextSelection! !!PluggableListMorph methodsFor: 'events-keyboard' stamp: 'jm 10/12/2002 06:12'!wantsKeyboardFocusFor: aMorph	"Don't allow editing of my submorphs."	^ false! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 6/21/1998 22:19'!getListSelector	^ getListSelector! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 5/22/1998 00:21'!maximumSelection	^ list size! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 5/22/1998 00:20'!minimumSelection	^ 1! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 5/22/1998 00:32'!numSelectionsInView	^ self height // self listItemHeight! !!PluggableListMorph methodsFor: 'selection'!selectedMorph: aMorph	self unhighlightSelection.	selectedMorph _ aMorph.	selection _ aMorph ifNil: [nil] ifNotNil: [aMorph contents].	self highlightSelection! !!PluggableListMorph methodsFor: 'selection'!selection 	^ selection! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 5/6/1998 11:03'!selection: item	"Called from outside to request setting a new selection.	Assumes scroller submorphs is exactly our list.	Note: won't work right if list includes repeated items"	self selectionIndex: (scroller submorphs findFirst: [:m | m contents = item])! !!PluggableListMorph methodsFor: 'selection' stamp: 'dew 2/19/1999 18:47'!selectionIndex: index	"Called internally to select the index-th item."	| theMorph range |	(index isNil or: [index > scroller submorphs size]) ifTrue: [^ self].	(theMorph _ index = 0 ifTrue: [nil] ifFalse: [scroller submorphs at: index])		ifNotNil:		[((theMorph bounds top - scroller offset y) >= 0			and: [(theMorph bounds bottom - scroller offset y) <= bounds height]) ifFalse:			["Scroll into view -- should be elsewhere"			range _ self leftoverScrollRange.			scrollBar value: (range > 0				ifTrue: [((index-1 * theMorph height) / self leftoverScrollRange)									truncateTo: scrollBar scrollDelta]				ifFalse: [0]).			scroller offset: -3 @ (range * scrollBar value)]].	self selectedMorph: theMorph! !!PluggableListMorph methodsFor: 'selection' stamp: 'di 5/6/1998 21:20'!setSelectedMorph: aMorph	self changeModelSelection: (scroller submorphs indexOf: aMorph)! !!PluggableListMorph methodsFor: 'model access' stamp: 'di 5/6/1998 21:18'!changeModelSelection: anInteger	"Change the model's selected item index to be anInteger."	setIndexSelector ifNotNil:		[model perform: setIndexSelector with: anInteger].! !!PluggableListMorph methodsFor: 'model access' stamp: 'di 5/6/1998 21:18'!getCurrentSelectionIndex	"Answer the index of the current selection."	getIndexSelector == nil ifTrue: [^ 0].	^ model perform: getIndexSelector! !!PluggableListMorph methodsFor: 'model access' stamp: 'jlm 10/4/1999 23:45'!getList	"Answer the list to be displayed."	| lst |	getListSelector == nil ifTrue: [^ #()].	lst _ model perform: getListSelector.	lst == nil ifTrue: [^ #()].	^ lst! !!PluggableListMorph methodsFor: 'updating' stamp: 'di 5/6/1998 21:21'!update: aSymbol 	"Refer to the comment in View|update:."	aSymbol == getListSelector ifTrue: 		[self list: self getList.		^ self].	aSymbol == getIndexSelector ifTrue:		[self selectionIndex: self getCurrentSelectionIndex.		^ self].! !!PluggableListMorph methodsFor: 'updating'!verifyContents	| newList existingSelection anIndex |	"Called periodically, or at least on window reactivation to react to possible structural changes.  Update contents if necessary."	newList _ self getList.	((list == newList) "fastest" or: [list = newList]) ifTrue: [^ self].	self flash.  "list has changed beneath us; could get annoying, but hell"	existingSelection _ selection.	self list: newList.	(anIndex _ newList indexOf: existingSelection ifAbsent: [nil])		ifNotNil:			[model noteSelectionIndex: anIndex for: getListSelector.			self selectionIndex: anIndex]		ifNil:			[self changeModelSelection: 0]! !!PluggableListMorph methodsFor: 'geometry' stamp: 'dew 2/19/1999 17:09'!scrollDeltaHeight	"Return the increment in pixels which this pane should be scrolled."	^ scroller firstSubmorph height! !!PluggableListMorph class methodsFor: 'instance creation' stamp: 'di 5/22/1998 00:17'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See ListView>>aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: nil		keystroke: #arrowKey:from:		"default"! !!PluggableListMorph class methodsFor: 'instance creation' stamp: 'di 5/22/1998 00:17'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See ListView>>aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: #arrowKey:from:		"default"! !!PluggableListMorph class methodsFor: 'instance creation' stamp: 'di 5/6/1998 21:45'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel	"Create a 'pluggable' list view on the given model parameterized by the given message selectors. See ListView>>aboutPluggability comment."	^ self new		on: anObject		list: getListSel		selected: getSelectionSel		changeSelected: setSelectionSel		menu: getMenuSel		keystroke: keyActionSel! !!PluggableListMorph class methodsFor: 'example' stamp: 'jm 10/12/2002 05:33'!example	"PluggableListMorph example"	| model listMorph |	model _ PluggableTest new initialize.	model musicType: 1.	listMorph _		PluggableListMorph on: model			list: #artistList			selected: #artist			changeSelected: #artist:			menu: nil			keystroke: #artistKeystroke:.	listMorph openInWorld.! !!PluggableListMorph class methodsFor: 'example' stamp: 'jm 12/2/2003 12:19'!example2	"PluggableListMorph example2"	| model list1 list2 row display col |	model _ PluggableTest new.	list1 _ PluggableListMorph on: model			list: #musicTypeList			selected: #musicType			changeSelected: #musicType:			menu: #musicTypeMenu:			keystroke: #musicTypeKeystroke:.	list1 menuTitleSelector: #musicTypeListTitle.	list2 _ PluggableListMorph on: model			list: #artistList			selected: #artist			changeSelected: #artist:			menu: nil			keystroke: #artistKeystroke:.	display _ UpdatingStringMorph on: model selector: #artistName.	display useStringFormat; contents: '<no selection>'.	"make scroll bars stay up"	list1 retractable: false.	list2 retractable: false.	row _ AlignmentMorph newRow.	row addMorphBack: list1; addMorphBack: list2.	col _ AlignmentMorph newColumn.	col borderWidth: 2; inset: 5; extent: 5@5.	col addMorphBack: row; addMorphBack: display.	col openInWorld.! !!PluggableListMorphByItem methodsFor: 'as yet unclassified' stamp: 'jm 8/20/1998 09:44'!changeModelSelection: anInteger	"Change the model's selected item to be the one at the given index."	| item |	setIndexSelector ifNotNil: [		item _ (anInteger = 0 ifTrue: [nil] ifFalse: [itemList at: anInteger]).		model perform: setIndexSelector with: item].	self update: getIndexSelector.! !!PluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'ar 11/15/1998 23:45'!drawOn: aCanvas	| onMorph |	super drawOn: aCanvas.	1 to: list size do:  "NOTE: should be optimized to only visible morphs"		[:index |		(model listSelectionAt: index) ifTrue:			[onMorph _ scroller submorphs at: index.			aCanvas fillRectangle:				(((scroller transformFrom: self) localBoundsToGlobal: onMorph bounds)						intersect: scroller bounds)				color: color darker]]! !!PluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'jm 10/12/2002 06:57'!list: listOfStrings	scroller removeAllMorphs.	list _ listOfStrings ifNil: [Array new].	list isEmpty ifTrue: [^ self selectedMorph: nil].	super list: listOfStrings.! !!PluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'di 1/15/1999 01:03'!mouseDown: event onItem: aMorph	| index oldIndex oldVal |	event yellowButtonPressed ifTrue: [^ self yellowButtonActivity: event shiftPressed].	model okToChange ifFalse: [^ self].  "No change if model is locked"	index _ scroller submorphs indexOf: aMorph.	index = 0 ifTrue: [^ self  "minimize chance of selecting with a pane border drag"].	"Set meaning for subsequent dragging of selection"	dragOnOrOff _ (model listSelectionAt: index) not.	oldIndex _ self getCurrentSelectionIndex.	oldIndex ~= 0 ifTrue: [oldVal _ model listSelectionAt: oldIndex].	"Set or clear new primary selection (listIndex)"	dragOnOrOff		ifTrue: [self setSelectedMorph: aMorph]		ifFalse: [self setSelectedMorph: nil].	"Need to restore the old one, due to how model works, and set new one."	oldIndex ~= 0 ifTrue: [model listSelectionAt: oldIndex put: oldVal].	model listSelectionAt: index put: dragOnOrOff.	aMorph changed! !!PluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'di 11/10/1998 14:47'!mouseUp: event onItem: aMorph	dragOnOrOff _ nil.  "So improperly started drags will have not effect"! !!PluggableListMorphOfMany methodsFor: 'as yet unclassified' stamp: 'di 11/10/1998 14:44'!update: aSymbol 	aSymbol == #allSelections ifTrue:		[self selectionIndex: self getCurrentSelectionIndex.		^ self changed].	^ super update: aSymbol! !!PluggableListView methodsFor: 'initialization' stamp: 'jm 10/12/2002 05:56'!autoDeselect: aBoolean	"Enable/disable autoDeselect."	autoDeselect _ aBoolean.! !!PluggableListView methodsFor: 'initialization' stamp: 'jm 9/20/1998 19:48'!font: aFontOrNil	super font: aFontOrNil.	self list: self getList.  "update display"! !!PluggableListView methodsFor: 'initialization' stamp: 'sw 12/9/1999 18:06'!list: arrayOfStrings	"Set the receivers items to be the given list of strings	The instance variable 'items' holds the original list. The instance variable 'list' is a paragraph constructed from this list."	((items == arrayOfStrings) "fastest" or: [items = arrayOfStrings]) ifTrue: [^ self].	items _ arrayOfStrings.	isEmpty _ arrayOfStrings isEmpty.	"add top and bottom delimiters"	list _ ListParagraph		withArray:			(Array streamContents: [:s |				s nextPut: topDelimiter.				arrayOfStrings do: [:item | item == nil ifFalse: [s nextPut: item]].				s nextPut: bottomDelimiter])		 style: self assuredTextStyle.	selection _ self getCurrentSelectionIndex.	self positionList.! !!PluggableListView methodsFor: 'initialization' stamp: 'sw 8/18/1998 12:04'!menuTitleSelector: getMenuTitleSel	getMenuTitleSelector _ getMenuTitleSel! !!PluggableListView methodsFor: 'model access' stamp: 'sw 8/18/1998 12:07'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue:			[aMenu _ model perform: getMenuSelector with: menu.			getMenuTitleSelector ifNotNil: [aMenu title: (model perform: getMenuTitleSelector)].			^ aMenu].	getMenuSelector numArgs = 2		ifTrue: [aMenu _ model perform: getMenuSelector with: menu with: shiftKeyDown.				getMenuTitleSelector ifNotNil: [aMenu title: (model perform: getMenuTitleSelector)].				^ aMenu].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableListView methodsFor: 'model access' stamp: 'sw 10/9/1998 08:24'!setSelectionSelectorIs: aSelector	^ aSelector == setSelectionSelector! !!PluggableListView methodsFor: 'updating' stamp: 'di 5/25/1998 10:24'!update: aSymbol 	"Refer to the comment in View|update:."	aSymbol == getListSelector ifTrue:		[self list: self getList.		self displayView.		self displaySelectionBox.		^self].	aSymbol == getSelectionSelector ifTrue:		[^ self moveSelectionBox: self getCurrentSelectionIndex].! !!PluggableListView methodsFor: 'updating' stamp: 'sw 10/31/1999 00:04'!verifyContents	| newItems existingSelection anIndex |	"Called on window reactivation to react to possible structural changes.  Update contents if necessary."	newItems _ self getList.	((items == newItems) "fastest" or: [items = newItems]) ifTrue: [^ self].	self flash.  "list has changed beneath us; could get annoying, but hell"	existingSelection _ list stringAtLineNumber: (selection + 1).  "account for cursed ------ row"	self list: newItems.	(newItems size > 0 and: [newItems first isKindOf: Symbol]) ifTrue:		[existingSelection _ existingSelection asSymbol].	(anIndex _ newItems indexOf: existingSelection ifAbsent: [nil])		ifNotNil:			[model noteSelectionIndex: anIndex for: getListSelector.			self update: getSelectionSelector.			self topView displayEmphasized]		ifNil:			[self changeModelSelection: 0]! !!PluggableListViewByItem methodsFor: 'as yet unclassified' stamp: 'sw 12/9/1999 18:07'!list: arrayOfStrings	"Set the receivers items to be the given list of strings."	"Note: the instance variable 'items' holds the original list.	 The instance variable 'list' is a paragraph constructed from	 this list."	itemList _ arrayOfStrings.	isEmpty _ arrayOfStrings isEmpty.	"add top and bottom delimiters"	list _ ListParagraph		withArray:			(Array streamContents: [:s |				s nextPut: topDelimiter.				arrayOfStrings do: [:item | item == nil ifFalse: [s nextPut: item]].				s nextPut: bottomDelimiter])		 style: self assuredTextStyle.	selection _ self getCurrentSelectionIndex.	self positionList.! !A variant of PluggableListMorph designed specially for efficient handling of the --all-- feature in message-list panes.  In order to be able *quickly* to check whether there has been an external change to the list, we cache the raw list for identity comparison (the actual list is a combination of the --all-- element and the the actual list).!!PluggableMessageCategoryListMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/18/1999 11:59'!getList	"Differs from the generic in that here we obtain and cache the raw list, then cons it together with the special '-- all --' item to produce the list to be used in the browser.  This special handling is done in order to avoid excessive and unnecessary reformulation of the list in the step method"	getRawListSelector == nil ifTrue: ["should not happen!!" priorRawList _ nil.  ^ #()].	model classListIndex = 0 ifTrue: [^ priorRawList _ Array new].	priorRawList _ model perform: getRawListSelector.	^ (Array with: ClassOrganizer allCategory), priorRawList! !!PluggableMessageCategoryListMorph methodsFor: 'as yet unclassified' stamp: 'jm 10/12/2002 05:54'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel getRawListSelector: getRawSel	self model: anObject.	getListSelector _ getListSel.	getIndexSelector _ getSelectionSel.	setIndexSelector _ setSelectionSel.	getMenuSelector _ getMenuSel.	keystrokeActionSelector _ keyActionSel.	autoDeselect _ true.	self borderWidth: 1.	getRawListSelector _ getRawSel.	self list: self getList.	self selectionIndex: self getCurrentSelectionIndex.	lastKeystrokeTime _ 0.	lastKeystrokes _ ''.! !!PluggableMessageCategoryListMorph methodsFor: 'as yet unclassified' stamp: 'sw 10/30/1999 23:02'!verifyContents		| newList existingSelection anIndex newRawList |	(model editSelection == #editComment) ifTrue: [^ self].	model classListIndex = 0 ifTrue: [^ self].	newRawList _ model perform: getRawListSelector.	newRawList == priorRawList ifTrue: [^ self].  "The usual case; very fast"	priorRawList _ newRawList.	newList _ (Array with: ClassOrganizer allCategory), priorRawList.	list = newList ifTrue: [^ self].	self flash.  "could get annoying, but hell"	existingSelection _ selection.	self list: newList.	(anIndex _ newList indexOf: existingSelection ifAbsent: [nil])		ifNotNil:			[model noteSelectionIndex: anIndex for: getListSelector.			self selectionIndex: anIndex]		ifNil:			[self changeModelSelection: 0]! !!PluggableMessageCategoryListMorph class methodsFor: 'as yet unclassified' stamp: 'sw 10/16/1999 22:39'!on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel getRawListSelector: getRawSel.	^ self new on: anObject list: getListSel selected: getSelectionSel changeSelected: setSelectionSel menu: getMenuSel keystroke: keyActionSel getRawListSelector: getRawSel! !PluggableSets allow the redefinition of hashing and equality by clients. This is in particular useful if the clients know about specific properties of the objects stored in the set which in turn can heavily improve the performance of sets and dictionaries.Instance variables:	hashBlock	<BlockContext>	A one argument block used for hashing the elements.	equalBlock	<BlockContext>	A two argument block used for comparing the elements.Example: Adding 1000 integer points in the range (0@0) to: (100@100) to a set.	| rnd set max pt |	set _ Set new: 1000.	rnd _ Random new.	max _ 100.	Time millisecondsToRun:[		1 to: 1000 do:[:i|			pt _ (rnd next * max) truncated @ (rnd next * max) truncated.			set add: pt.		].	].The above is way slow since the default hashing function of points leads to an awful lot of collisions in the set. And now the same, with a somewhat different hash function:	| rnd set max pt |	set _ PluggableSet new: 1000.	set hashBlock:[:item| (item x bitShift: 16) + item y].	rnd _ Random new.	max _ 100.	Time millisecondsToRun:[		1 to: 1000 do:[:i|			pt _ (rnd next * max) truncated @ (rnd next * max) truncated.			set add: pt.		].	].!!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:43'!equalBlock	"Return the block used for comparing the elements in the receiver."	^equalBlock! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/27/1998 23:55'!equalBlock: aBlock	"Set a new equality block. The block must accept two arguments and return true if the argumets are considered equal, false otherwise"	equalBlock _ aBlock.! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 18:43'!hashBlock	"Return the block used for hashing the elements in the receiver."	^hashBlock! !!PluggableSet methodsFor: 'accessing' stamp: 'ar 11/12/1998 19:02'!hashBlock: aBlock	"Set a new hash block. The block must accept one argument and return the hash value of the given argument."	hashBlock _ aBlock.! !!PluggableSet methodsFor: 'copying' stamp: 'ar 11/12/1998 18:47'!copy	^super copy postCopyBlocks! !!PluggableSet methodsFor: 'copying' stamp: 'ar 11/12/1998 18:48'!postCopyBlocks	hashBlock _ hashBlock copy.	equalBlock _ equalBlock copy.	"Fix temps in case we're referring to outside stuff"	hashBlock fixTemps.	equalBlock fixTemps.! !!PluggableSet methodsFor: 'private' stamp: 'ar 11/12/1998 18:45'!init: n	super init: n.	hashBlock _ [:element| element hash].	equalBlock _ [:element1 :element2| element1 = element2]! !!PluggableSet methodsFor: 'private' stamp: 'ar 11/12/1998 18:40'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ ((hashBlock value: anObject) \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil or: [					equalBlock value: element value: anObject])			ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil or: [			equalBlock value: element value: anObject])			ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!PluggableSet class methodsFor: 'as yet unclassified' stamp: 'di 6/12/2000 22:14'!integerSet	"A stopgap, until we get the pluggable init code."	^ Set new: 500! !!PluggableTest methodsFor: 'music type pane' stamp: 'jm 10/12/2002 05:37'!musicTypeListTitle	^ 'Choose a command'! !!PluggableTest methodsFor: 'menu commands' stamp: 'jm 10/12/2002 05:36'!perform: sel orSendTo: otherObject	"Handle the given action myself, if I can, or let otherObject handle it."	(self respondsTo: sel)		ifTrue: [self perform: sel]		ifFalse: [otherObject perform: sel].! !!PluggableTest class methodsFor: 'example' stamp: 'jm 10/12/2002 05:34'!example	"PluggableTest example"	| model listView1 topView listView2 |	model _ self new initialize.	listView1 _		PluggableListView on: model			list: #musicTypeList			selected: #musicType			changeSelected: #musicType:			menu: #musicTypeMenu:			keystroke: #musicTypeKeystroke:.	listView1  menuTitleSelector: #musicTypeListTitle.	listView2 _		PluggableListView on: model			list: #artistList			selected: #artist			changeSelected: #artist:			menu: nil			keystroke: #artistKeystroke:.	topView _ StandardSystemView new		label: 'Pluggable Test';		minimumSize: 300@200;		borderWidth: 1;		addSubView: listView1;		addSubView: listView2 toRightOf: listView1.	topView borderWidth: 1.	topView controller open.! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 6/3/1998 20:46'!appendEntry	"Append the text in the model's writeStream to the editable text. "	self deselect.	paragraph text size > model characterLimit ifTrue:		["Knock off first half of text"		self selectInvisiblyFrom: 1 to: paragraph text size // 2.		self replaceSelectionWith: Text new].	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size.	self replaceSelectionWith: model contents asText.	self selectInvisiblyFrom: paragraph text size + 1 to: paragraph text size! !!PluggableTextController methodsFor: 'transcript' stamp: 'sma 3/15/2000 21:39'!bsText	self changeText: (self text copyFrom: 1 to: (self text size - 1 max: 0))! !!PluggableTextController methodsFor: 'transcript' stamp: 'di 6/3/1998 20:42'!doOccluded: actionBlock	| paneRect rectSet bottomStrip |	paneRect _ paragraph clippingRectangle.	paragraph withClippingRectangle: (paneRect withHeight: 0)		do: [actionBlock value.			self scrollIn: paneRect].	view topView isCollapsed ifTrue: [^ self].	rectSet _ self visibleAreas.	bottomStrip _ paneRect withTop: paragraph compositionRectangle bottom + 1.	rectSet do:		[:rect |		(bottomStrip intersects: rect) ifTrue:			["The subsequent displayOn should clear this strip but it doesnt"			Display fill: (bottomStrip intersect: rect)					fillColor: paragraph backgroundColor].		paragraph withClippingRectangle: rect				do: [paragraph displayOn: Display]]! !!PluggableTextController methodsFor: 'as yet unclassified' stamp: 'sw 10/29/1999 21:08'!accept 	view hasUnacceptedEdits ifFalse: [^ view flash].	view hasEditingConflicts ifTrue:		[(self confirm: 'Caution!! This method has been changed elsewheresince you started editing it here.  Accept anyway?') ifFalse: [^ self flash]].	(view setText: paragraph text from: self) ifTrue:		[initialText _ paragraph text copy.		view ifNotNil: [view hasUnacceptedEdits: false]]    .! !!PluggableTextController methodsFor: 'as yet unclassified' stamp: 'sbw 10/12/1999 16:46'!selectForTopFrom: start to: stop	"Deselect, then select the specified characters inclusive.	 Be sure the selection is in view."	(start = startBlock stringIndex and: [stop + 1 = stopBlock stringIndex]) ifFalse:		[view superView ifNotNil: [self deselect].		self selectInvisiblyFrom: start to: stop].	view superView ifNotNil: [self selectAndScrollToTop]! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'di 9/11/1998 15:46'!acceptOnCR: trueOrFalse	textMorph acceptOnCR: trueOrFalse! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'dew 2/21/1999 03:07'!extent: newExtent	super extent: (newExtent max: 36@16).	textMorph ifNotNil:		[textMorph extent: (self innerBounds width-6)@self height].	self setScrollDeltas! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'bolot 11/2/1999 03:18'!font: aFont	textMorph beAllFont: aFont! !!PluggableTextMorph methodsFor: 'initialization' stamp: 'jm 11/24/2002 10:25'!initialize	super initialize.	color _ Color white.	hasUnacceptedEdits _ false.	hasEditingConflicts _ false.	askBeforeDiscardingEdits _ true! !!PluggableTextMorph methodsFor: 'model access' stamp: 'di 1/29/2000 14:34'!getText 	"Retrieve the current model text"	| newText |	getTextSelector == nil ifTrue: [^ Text new].	newText _ model perform: getTextSelector.	newText ifNil: [^Text new].	^ newText shallowCopy! !!PluggableTextMorph methodsFor: 'model access' stamp: 'di 6/22/1998 01:32'!selectionInterval: sel	selectionInterval _ sel! !!PluggableTextMorph methodsFor: 'model access' stamp: 'jm 11/14/2003 10:17'!setSelection: sel	| editor |	selectionInterval _ sel.	(editor _ textMorph editor) ifNotNil: [editor selectFrom: sel first to: sel last].	self scrollSelectionIntoView ifFalse: [scroller changed].! !!PluggableTextMorph methodsFor: 'model access' stamp: 'ls 7/20/1998 22:50'!setText: aText	scrollBar setValue: 0.0.	textMorph		ifNil: [textMorph _ TextMorphForEditView new						contents: aText wrappedTo: self innerBounds width-6.				textMorph setEditView: self.				scroller addMorph: textMorph]		ifNotNil: [textMorph newContents: aText].	self hasUnacceptedEdits: false.	self setScrollDeltas.! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'sw 10/14/1999 07:42'!accept	"Inform the model of text to be accepted, and return true if OK."	| textToAccept ok |	self canDiscardEdits ifTrue: [^ self flash].	self hasEditingConflicts ifTrue:		[(self confirm: 'Caution!! This method has been changed elsewheresince you started editing it here.  Accept anyway?') ifFalse: [^ self flash]].	textToAccept _ textMorph asText.	ok _ (setTextSelector == nil) or:		[setTextSelector numArgs = 2			ifTrue: [model perform: setTextSelector with: textToAccept with: self]			ifFalse: [model perform: setTextSelector with: textToAccept]].	ok ifTrue:		[self setText: self getText.		self hasUnacceptedEdits: false]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'sw 9/27/1999 11:57'!chooseAlignment	self handleEdit: [textMorph editor changeAlignment]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 16:02'!fileItIn	self handleEdit: [textMorph editor fileItIn]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 16:02'!implementorsOfIt	self handleEdit: [textMorph editor implementorsOfIt]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 16:01'!methodNamesContainingIt	self handleEdit: [textMorph editor methodNamesContainingIt]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 16:01'!methodSourceContainingIt	self handleEdit: [textMorph editor methodSourceContainingIt]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 16:01'!methodStringsContainingit	self handleEdit: [textMorph editor methodStringsContainingit]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 4/26/2000 22:22'!pasteRecent	"Paste an item chosen from RecentClippings."	| clipping |	(clipping _ ParagraphEditor chooseRecentClipping) ifNil: [^ self].	ParagraphEditor clipboardTextPut: clipping.	^ self handleEdit: [textMorph editor paste]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'sw 11/7/1999 00:01'!prettyPrint	self handleEdit: [textMorph editor prettyPrint]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'RAA 6/13/2000 10:55'!printIt	| result oldEditor |	textMorph editor selectFrom: selectionInterval first to: selectionInterval last;						model: model.  "For, eg, evaluateSelection"	textMorph handleEdit: [result _ (oldEditor _ textMorph editor) evaluateSelection].	((result isKindOf: FakeClassPool) or: [result == #failedDoit]) ifTrue: [^self flash].	selectionInterval _ oldEditor selectionInterval.	textMorph installEditorToReplace: oldEditor.	textMorph handleEdit: [oldEditor afterSelectionInsertAndSelect: result printString].	selectionInterval _ oldEditor selectionInterval.		textMorph editor selectFrom: selectionInterval first to: selectionInterval last.	self scrollSelectionIntoView.! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 15:59'!referencesToIt	self handleEdit: [textMorph editor referencesToIt]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'dew 3/7/2000 21:15'!saveContentsInFile	self handleEdit: [textMorph editor saveContentsInFile]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'sma 6/5/2000 13:33'!scrollBarMenuButtonPressed: event	| menu |	(menu _ self getMenu: event shiftPressed) ifNotNil:		["Set up to use perform:orSendTo: for model/view dispatch"		menu setInvokingView: self.		menu popUpEvent: event]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'di 11/2/1998 15:31'!sendersOfIt	self handleEdit: [textMorph editor sendersOfIt]! !!PluggableTextMorph methodsFor: 'menu commands' stamp: 'sma 6/5/2000 13:33'!yellowButtonActivity	"Called when the shifted-menu's 'more' item is chosen"	| menu |	(menu _ self getMenu: false) ifNotNil:		["Set up to use perform:orSendTo: for model/view dispatch"		menu setInvokingView: self.		menu popUpEvent: self currentEvent]! !!PluggableTextMorph methodsFor: 'updating' stamp: 'dew 6/11/2000 02:21'!update: aSymbol	aSymbol ifNil: [^ self].	aSymbol == #flash ifTrue: [^ self flash].	aSymbol == getTextSelector ifTrue:			[self setText: self getText.			^ self setSelection: self getSelection].	aSymbol == getSelectionSelector ifTrue: [^ self setSelection: self getSelection].	(aSymbol == #autoSelect and: [getSelectionSelector ~~ nil]) ifTrue:			[self handleEdit:				[textMorph editor setSearch: model autoSelectString;							againOrSame: true]].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	aSymbol == #wantToChange ifTrue:			[self canDiscardEdits ifFalse: [^ self promptForCancel].			^ self].	aSymbol == #appendEntry ifTrue:			[self handleEdit: [self appendEntry].			^ self refreshWorld].	aSymbol == #clearText ifTrue:			[self handleEdit: [self changeText: Text new].			^ self refreshWorld].	aSymbol == #bs ifTrue:			[self handleEdit: [self bsText].			^ self refreshWorld].	aSymbol == #codeChangedElsewhere ifTrue:			[self hasEditingConflicts: true.			^ self changed]! !!PluggableTextMorph methodsFor: 'drawing' stamp: 'sw 10/10/1999 23:26'!drawOn: aCanvas 	"Include a thin red inset border for unaccepted edits, or, if the unaccepted edits are known to conflict with a change made somewhere else to the same method (typically), put a thick red frame"	super drawOn: aCanvas. 	self hasEditingConflicts		ifTrue:			[aCanvas frameRectangle: self innerBounds width: 3 color: Color red] 		ifFalse:			[self hasUnacceptedEdits ifTrue:				[aCanvas frameRectangle: self innerBounds width: 1 color: Color red]]! !!PluggableTextMorph methodsFor: 'unaccepted edits' stamp: 'sw 10/10/1999 22:55'!hasEditingConflicts	"Return true if a conflicting edit to the same code (typically) is known to have occurred after the current contents started getting edited"	^ hasEditingConflicts == true! !!PluggableTextMorph methodsFor: 'unaccepted edits' stamp: 'sw 10/10/1999 22:55'!hasEditingConflicts: aBoolean	hasEditingConflicts _ aBoolean! !!PluggableTextMorph methodsFor: 'unaccepted edits' stamp: 'sw 10/10/1999 23:06'!hasUnacceptedEdits: aBoolean	"Set the hasUnacceptedEdits flag to the given value. "	aBoolean == hasUnacceptedEdits ifFalse:		[hasUnacceptedEdits _ aBoolean.		self changed].	aBoolean ifFalse: [hasEditingConflicts _ false]! !!PluggableTextMorph methodsFor: 'interactive error protocol' stamp: 'di 6/22/1998 15:15'!correctFrom: start to: stop with: aString	^ self handleEdit: [textMorph editor correctFrom: start to: stop with: aString]! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'di 11/2/1998 15:57'!handleEdit: editBlock	| result |	textMorph editor selectFrom: selectionInterval first to: selectionInterval last;						model: model.  "For, eg, evaluateSelection"	textMorph handleEdit: [result _ editBlock value].   "Update selection after edit"	self scrollSelectionIntoView.	^ result! !!PluggableTextMorph methodsFor: 'editor access' stamp: 'ar 11/15/1998 23:45'!scrollSelectionIntoView: event 	"Scroll my text into view if necessary and return true, else return false"	| selRects delta selRect rectToTest transform cpHere |	selectionInterval _ textMorph editor selectionInterval.	selRects _ textMorph paragraph selectionRects.	selRects isEmpty ifTrue: [^ false].	rectToTest _ selRects first merge: selRects last.	transform _ scroller transformFrom: self.	(event notNil and: [event anyButtonPressed]) ifTrue:  "Check for autoscroll"		[cpHere _ transform localPointToGlobal: event cursorPoint.		cpHere y <= self top			ifTrue: [rectToTest _ selRects first topLeft extent: 2@2]			ifFalse: [cpHere y >= self bottom					ifTrue: [rectToTest _ selRects last bottomRight extent: 2@2]					ifFalse: [^ false]]].	selRect _ transform localBoundsToGlobal: rectToTest.	selRect height > bounds height		ifTrue: [^ false].  "Would not fit, even if we tried to scroll"	(delta _ selRect amountToTranslateWithin: self bounds) y ~= 0 ifTrue:		["Scroll end of selection into view if necessary"		self scrollBy: 0@delta y.		^ true].	^ false! !!PluggableTextMorph methodsFor: 'transcript' stamp: 'sma 3/15/2000 21:40'!bsText	self changeText: (self text copyFrom: 1 to: (self text size - 1 max: 0))! !!PluggableTextMorph methodsFor: 'pane events' stamp: 'tk 4/5/1999 03:12'!mouseEnter: event	super mouseEnter: event.	selectionInterval ifNotNil:		[textMorph handleEdit: [textMorph editor selectInterval: selectionInterval.			textMorph editor setEmphasisHere]].	event hand newKeyboardFocus: textMorph! !!PluggableTextMorph methodsFor: 'pane events' stamp: 'jm 8/20/1998 08:39'!mouseLeave: event	textMorph ifNotNil: [selectionInterval _ textMorph editor selectionInterval].	super mouseLeave: event.	event hand newKeyboardFocus: nil.! !!PluggableTextMorph methodsFor: 'geometry' stamp: 'kfr 6/8/2000 22:38'!resetExtent	"Reset the extent while maintaining the current selection.  Needed when resizing while the editor is active (when inside the pane)."	| tempSelection |	textMorph notNil ifTrue:		["the current selection gets munged by resetting the extent, so store it"		tempSelection _ self selectionInterval.				"don't reset it if it's not active"		tempSelection = (Interval from: 1 to: 0) 						ifTrue: [retractableScrollBar							ifTrue:[ ^ self]].		self extent: self extent.		self setSelection: tempSelection]! !!PluggableTextMorph methodsFor: 'geometry' stamp: 'dew 2/19/1999 17:08'!scrollDeltaHeight	"Return the increment in pixels which this pane should be scrolled."	^ scroller firstSubmorph defaultLineHeight! !!PluggableTextMorph methodsFor: 'accessing' stamp: 'sr 4/25/2000 07:21'!getTextSelector	^getTextSelector! !!PluggableTextView methodsFor: 'initialization' stamp: 'sw 10/29/1999 21:02'!initialize 	super initialize.	hasEditingConflicts _ false! !!PluggableTextView methodsFor: 'model access' stamp: 'di 6/26/1998 11:06'!getMenu: shiftKeyDown	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu |	getMenuSelector == nil ifTrue: [^ nil].	menu _ CustomMenu new.	getMenuSelector numArgs = 1		ifTrue: [^ model perform: getMenuSelector with: menu].	getMenuSelector numArgs = 2		ifTrue: [^ model perform: getMenuSelector with: menu with: shiftKeyDown].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!PluggableTextView methodsFor: 'model access' stamp: 'sw 1/16/1999 14:31'!getSelection	"Answer the model's selection interval."	getSelectionSelector == nil ifTrue: [^ 1 to: 0].  "null selection"	^ getSelectionSelector ifNotNil: [model perform: getSelectionSelector]! !!PluggableTextView methodsFor: 'model access' stamp: 'jm 8/20/1998 11:55'!model: aLockedModel 	"Refer to the comment in View|model:." 	self model: aLockedModel controller: controller.	self editString: self getText.! !!PluggableTextView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:03'!hasEditingConflicts	"Return true if a conflicting edit to the same code (typically) is known to have occurred after the current contents started getting edited"	^ hasEditingConflicts == true! !!PluggableTextView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:04'!hasEditingConflicts: aBoolean	hasEditingConflicts _ aBoolean! !!PluggableTextView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:04'!hasUnacceptedEdits: aBoolean	super hasUnacceptedEdits: aBoolean.	aBoolean ifFalse: [hasEditingConflicts _ false]! !!PluggableTextView methodsFor: 'updating' stamp: 'sma 3/15/2000 21:39'!update: aSymbol	"Refer to the comment in View|update:. Do nothing if the given symbol does not match any action. "	aSymbol == #wantToChange ifTrue:			[self canDiscardEdits ifFalse: [self promptForCancel].  ^ self].	aSymbol == #flash ifTrue: [^ controller flash].	aSymbol == getTextSelector ifTrue: [^ self updateDisplayContents].	aSymbol == getSelectionSelector ifTrue: [^ self setSelection: self getSelection].	aSymbol == #clearUserEdits ifTrue: [^ self hasUnacceptedEdits: false].	(aSymbol == #autoSelect and: [getSelectionSelector ~~ nil]) ifTrue:			[^ controller setSearch: model autoSelectString;					againOrSame: true].	aSymbol == #appendEntry ifTrue:			[^ controller doOccluded: [controller appendEntry]].	aSymbol == #clearText ifTrue:			[^ controller doOccluded:				[controller changeText: Text new]].	aSymbol == #bs ifTrue:			[^ controller doOccluded:				[controller bsText]].	aSymbol == #codeChangedElsewhere ifTrue:			[^ self hasEditingConflicts: true]! !I represent an x-y pair of numbers usually designating a location on the screen.!!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:01'!* arg 	"Answer a Point that is the product of the receiver and arg."	arg isPoint ifTrue: [^ (x * arg x) @ (y * arg y)].	^ arg adaptToPoint: self andSend: #*! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:01'!+ arg 	"Answer a Point that is the sum of the receiver and arg."	arg isPoint ifTrue: [^ (x + arg x) @ (y + arg y)].	^ arg adaptToPoint: self andSend: #+! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!- arg 	"Answer a Point that is the difference of the receiver and arg."	arg isPoint ifTrue: [^ (x - arg x) @ (y - arg y)].	^ arg adaptToPoint: self andSend: #-! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!/ arg 	"Answer a Point that is the quotient of the receiver and arg."	arg isPoint ifTrue: [^ (x / arg x) @ (y / arg y)].	^ arg adaptToPoint: self andSend: #/! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!// arg 	"Answer a Point that is the quotient of the receiver and arg."	arg isPoint ifTrue: [^ (x // arg x) @ (y // arg y)].	^ arg adaptToPoint: self andSend: #//! !!Point methodsFor: 'arithmetic' stamp: 'di 11/6/1998 14:02'!\\ arg 	"Answer a Point that is the mod of the receiver and arg."	arg isPoint ifTrue: [^ (x \\ arg x) @ (y \\ arg y)].	^ arg adaptToPoint: self andSend: #\\! !!Point methodsFor: 'converting' stamp: 'di 11/9/1998 12:44'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with an Integer, convert it to a Point."	^ rcvr@rcvr perform: selector with: self! !!Point methodsFor: 'converting' stamp: 'jm 6/29/2003 22:29'!asPoint	"Answer the receiver itself."	^ self! !!Point methodsFor: 'converting' stamp: 'di 11/6/1998 07:45'!isPoint	^ true! !!Point methodsFor: 'geometry' stamp: 'laza 1/6/2000 10:30'!sideOf: otherPoint 	"Returns #left, #right or #center if the otherPoint lies to the left, right 	or on the line given by the vector from 0@0 to self"	| side |	side _ (self crossProduct: otherPoint) sign.	^ {#right. #center. #left} at: side + 2! !!Point methodsFor: 'geometry' stamp: 'ar 4/6/2000 18:37'!to: end1 intersects: start2 to: end2 	"Returns true if the linesegment from start1 (=self) to end1 intersects      	    with the segment from start2 to end2, otherwise false."	| start1 sideStart sideEnd |	start1 _ self.	(((start1 = start2 or: [end1 = end2])		or: [start1 = end2])		or: [start2 = end1])		ifTrue: [^ true].	sideStart _ start1 to: end1 sideOf: start2.	sideEnd _ start1 to: end1 sideOf: end2.	sideStart = sideEnd ifTrue: [^ false].	sideStart _ start2 to: end2 sideOf: start1.	sideEnd _ start2 to: end2 sideOf: end1.	sideStart = sideEnd ifTrue: [^ false].	^ true! !!Point methodsFor: 'geometry' stamp: 'laza 1/5/2000 11:50'!to: end sideOf: otherPoint 	"Returns #left, #right, #center if the otherPoint lies to the left, right or on the line given by the vector from self to end"	^ end - self sideOf: otherPoint - self! !!Point methodsFor: 'point functions' stamp: 'ar 10/30/1998 03:05'!crossProduct: aPoint 	"Answer a number that is the cross product of the receiver and the 	argument, aPoint."	^ (x * aPoint y) - (y * aPoint x)! !!Point methodsFor: 'point functions' stamp: 'di 9/11/1998 16:22'!dotProduct: aPoint 	"Answer a number that is the dot product of the receiver and the 	argument, aPoint. That is, the two points are multipled and the 	coordinates of the result summed."	^ (x * aPoint x) + (y * aPoint y)! !!Point methodsFor: 'private' stamp: 'di 5/16/2000 22:05'!setR: rho degrees: theta 	| radians |	radians _ theta asFloat degreesToRadians.	x _ rho asFloat * radians cos.	y _ rho asFloat * radians sin.! !!Point methodsFor: 'private' stamp: 'sw 3/21/2000 13:24'!setX: xValue setY: yValue	x _ xValue.	y _ yValue! !!Point methodsFor: 'truncation and round off' stamp: 'jm 6/3/1998 12:21'!rounded	"Answer a Point that is the receiver's x and y rounded. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x rounded @ y rounded! !!Point methodsFor: 'truncation and round off' stamp: 'jm 5/29/1998 15:53'!truncated	"Answer a Point whose x and y coordinates are integers. Answer the receiver if its coordinates are already integral."	(x isInteger and: [y isInteger]) ifTrue: [^ self].	^ x truncated @ y truncated! !I can search for reasons why a certain object isn't garbage collected.  I'm a quick port of a VisualWorks program written by Hans-Martin Mosner.  Call me as shown below.  I'll search for a path from a global variable to the given object, presenting it in a small morphic UI.Examples:	PointerFinder on: self currentHand	PointerFinder on: StandardSystemView someInstanceNow, let's see why this image contains more HandMorphs as expected...HandMorph allInstancesDo: [:e | PointerFinder on: e]!!PointerFinder methodsFor: 'application' stamp: 'sma 6/6/2000 18:58'!buildList	| list obj parent object key |	list := OrderedCollection new.	obj := goal.		[list addFirst: obj.	obj := parents at: obj ifAbsent: [].	obj == nil] whileFalse.	list removeFirst.	parent := Smalltalk.	objectList := OrderedCollection new.	pointerList := OrderedCollection new.	[list isEmpty]		whileFalse: 			[object := list removeFirst.			key := nil.			(parent isKindOf: Dictionary)				ifTrue: [list size >= 2						ifTrue: 							[key := parent keyAtValue: list second ifAbsent: [].							key == nil								ifFalse: 									[object := list removeFirst; removeFirst.									pointerList add: key printString , ' -> ' , object class name]]].			key == nil				ifTrue: 					[parent class == object ifTrue: [key := 'CLASS'].					key == nil ifTrue: [1 to: parent class instSize do: [:i | key == nil ifTrue: [(parent instVarAt: i)									== object ifTrue: [key := parent class allInstVarNames at: i]]]].					key == nil ifTrue: [1 to: parent basicSize do: [:i | key == nil ifTrue: [(parent basicAt: i)									== object ifTrue: [key := i printString]]]].					key == nil ifTrue: [(parent isMorph and: [object isKindOf: Array]) ifTrue: [key := 'submorphs?']].					key == nil ifTrue: [key := '???'].					pointerList add: key , ': ' , object class name].			objectList add: object.			parent := object]! !!PointerFinder methodsFor: 'application' stamp: 'sma 6/6/2000 23:08'!follow: anObject from: parentObject	anObject == goal		ifTrue: 			[parents at: anObject put: parentObject.			^ true].	anObject isLiteral ifTrue: [^ false].	anObject class isPointers ifFalse: [^ false].	anObject class isWeak ifTrue: [^ false].	(parents includesKey: anObject)		ifTrue: [^ false].	parents at: anObject put: parentObject.	toDoNext add: anObject.	^ false! !!PointerFinder methodsFor: 'application' stamp: 'sma 6/6/2000 10:01'!followObject: anObject	(self follow: anObject class from: anObject)		ifTrue: [^ true].	1 to: anObject class instSize do:		[:i |		(self follow: (anObject instVarAt: i) from: anObject)			ifTrue: [^ true]].	1 to: anObject basicSize do:		[:i |		(self follow: (anObject basicAt: i) from: anObject)			ifTrue: [^ true]].	^ false! !!PointerFinder methodsFor: 'application' stamp: 'sma 6/6/2000 09:52'!goal: anObject	goal _ anObject! !!PointerFinder methodsFor: 'application' stamp: 'sma 6/7/2000 00:19'!initialize	parents _ IdentityDictionary new: 20000.	parents at: Smalltalk put: nil.	parents at: Processor put: nil.	parents at: self put: nil.	toDo _ OrderedCollection new: 5000.	toDo add: Smalltalk.	toDoNext _ OrderedCollection new: 5000! !!PointerFinder methodsFor: 'application' stamp: 'sma 6/7/2000 00:19'!isLiteral	"Horrible hack to omit other Pointer Finders from scanning."	^ true! !!PointerFinder methodsFor: 'application' stamp: 'sma 6/7/2000 00:17'!search	Smalltalk garbageCollect.	self initialize.		Cursor wait showWhile: [		[[toDo isEmpty or: [self followObject: toDo removeFirst]] whileFalse.		toDo isEmpty and: [toDoNext isEmpty not]]			whileTrue: 				[toDo _ toDoNext.				toDoNext _ OrderedCollection new: 5000]].	self buildList! !!PointerFinder methodsFor: 'application' stamp: 'sma 6/6/2000 19:10'!update	('done: ' , parents size asString , ' todo: ' , toDo size asString , '   ') displayAt: 0@0! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/7/2000 00:23'!arrowKey: key from: aController	key = $i ifTrue: [^ self inspectObject].	^ super arrowKey: key from: aController! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/6/2000 23:48'!initialExtent	^ 300 @ 300! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/6/2000 23:26'!inspectObject	pointerListIndex = 0 ifTrue: [^ self beep].	(objectList at: pointerListIndex) inspect! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/7/2000 00:09'!menu: aMenu shifted: shifted	^ MenuMorph new		defaultTarget: self;		add: 'Inspect (i)' action: #inspectObject;		balloonTextForLastItem: 'Live long and prosper!!';		addLine;		add: 'Search again' action: #searchAgain;		balloonTextForLastItem: 'Search again\for the same object' withCRs;		yourself! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/6/2000 23:52'!open	| window list |	window _ (SystemWindow labelled: 'Pointer Finder')		model: self.	list _ PluggableListMorph			on: self			list: #pointerList			selected: #pointerListIndex			changeSelected: #pointerListIndex:			menu: #menu:shifted:.	list doubleClickSelector: #inspectObject.	window addMorph: list frame: (0@0 extent: 1@1).	list color: Color lightMagenta.	window openInWorld! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/7/2000 00:15'!perform: selector orSendTo: otherTarget	selector == #inspectObject ifTrue: [^ self inspectObject].	selector == #searchAgain ifTrue: [^ self searchAgain].	^ super perform: selector orSendTo: otherTarget! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/6/2000 23:49'!pointerList	^ pointerList asArray! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/6/2000 23:27'!pointerListIndex	^ pointerListIndex ifNil: [0]! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/6/2000 23:51'!pointerListIndex: anInteger	pointerListIndex _ anInteger.	self changed: #pointerListIndex! !!PointerFinder methodsFor: 'morphic ui' stamp: 'sma 6/7/2000 00:16'!searchAgain	self pointerListIndex: 0.	self search.	self changed: #pointerList! !!PointerFinder class methodsFor: 'instance creation' stamp: 'sma 6/6/2000 23:52'!on: anObject	^ self new goal: anObject; search; open! !I represent an arbitrary polygonal figure with a border and straight sides. My shape can be edited by showing my handles.When I am set to be an 'open' polygon, I be used to draw multi-segment lines with optional arrowheads on one or both ends.I have two fill modes: 'fast' and 'proper'. Fast mode sometimes does the wrong thing with concave figures but is fast. Polygons and curves use a 1-bit shape form to make display reasonably fast. This could be further optimized by going to a 2-bit form and including the border. It would also be simple to compute an inner rectangle, as with ellipses.!!PolygonMorph methodsFor: 'initialization' stamp: 'jm 10/9/2002 05:54'!initialize	super initialize.	color _ Color orange.	vertices _ Array with: 20@20 with: 40@30 with: 20@40.	borderWidth _ 2.	borderColor _ Color magenta.	closed _ true.	quickFill _ true.	arrows _ #none.	self computeBounds.! !!PolygonMorph methodsFor: 'access' stamp: 'di 2/10/1999 21:13'!borderColor: aColor	(borderColor isColor and: [borderColor isTranslucentColor])		== (aColor isColor and: [aColor isTranslucentColor])		ifTrue: [super borderColor: aColor]		ifFalse: ["Need to recompute fillForm and borderForm					if translucency of border changes."				super borderColor: aColor.				self releaseCachedState]! !!PolygonMorph methodsFor: 'access' stamp: 'di 2/10/1999 16:32'!makeClosed	closed _ true.	handles ifNotNil: [self removeHandles; addHandles].	self computeBounds! !!PolygonMorph methodsFor: 'access' stamp: 'di 2/10/1999 16:34'!makeOpen	closed _ false.	handles ifNotNil: [self removeHandles; addHandles].	self computeBounds! !!PolygonMorph methodsFor: 'access' stamp: 'di 6/21/1998 12:23'!quickFill: trueOrFalse	quickFill _ trueOrFalse.	filledForm _ nil.	self changed! !!PolygonMorph methodsFor: 'geometry' stamp: 'di 12/17/1998 12:32'!containsPoint: aPoint	(super containsPoint: aPoint) ifFalse: [^ false].	closed & color isTransparent not ifTrue:		[^ (self filledForm pixelValueAt: aPoint - bounds topLeft + 1) > 0].	self lineSegmentsDo:		[:p1 :p2 |		(aPoint onLineFrom: p1 to: p2 within: (2 max: borderWidth+1//2) asFloat)				ifTrue: [^ true]].	self arrowForms do:		[:f | (f pixelValueAt: aPoint - f offset) > 0 ifTrue: [^ true]].	^ false! !!PolygonMorph methodsFor: 'geometry' stamp: 'jm 5/29/2003 18:51'!inset: amt	"Only works if I am made of rectangles (every segment of me is horizontal or vertical). Inset each vertex by amt. Uses containsPoint."	| delta four cnt offset |	delta _ amt asPoint.	four _ {delta.  -1@1 * delta.  -1@-1 * delta.  1@-1 * delta}.	self setVertices: (vertices collect: [:vv | 		cnt _ 0.		offset _ (four collect: [:del | 			(self containsPoint: del+vv) ifTrue: [cnt _ cnt + 1. del] ifFalse: [0@0]]) sum.		cnt = 2 ifTrue: [offset _ offset // 2].		vv + offset]).! !!PolygonMorph methodsFor: 'geometry' stamp: 'jm 10/9/2002 07:31'!isRectangular	^ false! !!PolygonMorph methodsFor: 'drawing' stamp: 'jm 7/17/2003 22:53'!drawBorderOn: aCanvas	"Display my border on the canvas."	| lineColor bevel topLeftColor bottomRightColor bigClipRect brush p1i p2i |	(borderColor == nil or: [borderColor isColor and: [borderColor isTransparent]])		ifTrue: [^ self].	lineColor _ borderColor.	bevel _ false.	"Border colors for bevelled effects depend on CW ordering of vertices"	borderColor == #raised ifTrue: 			[topLeftColor _ color lighter.			bottomRightColor _ color darker.			bevel _ true].	borderColor == #inset ifTrue: 			[topLeftColor _ owner colorForInsets darker.			bottomRightColor _ owner colorForInsets lighter.			bevel _ true].	bigClipRect _ aCanvas clipRect expandBy: self borderWidth + 1 // 2.	brush _ nil.	self		lineSegmentsDo: 			[:p1 :p2 | 			p1i _ p1 truncated.			p2i _ p2 truncated.			(closed or: ["bigClipRect intersects: (p1i rect: p2i) optimized:"				((p1i min: p2i)					max: bigClipRect origin)					<= ((p1i max: p2i)							min: bigClipRect corner)])				ifTrue: 					[bevel						ifTrue: [(p1i quadrantOf: p2i)								> 2								ifTrue: [lineColor _ topLeftColor]								ifFalse: [lineColor _ bottomRightColor]].					(borderWidth > 3 and: [borderColor isColor])						ifTrue: 							[brush == nil ifTrue: [brush _ (ColorForm dotOfSize: borderWidth)											colors: (Array with: Color transparent with: borderColor)].							aCanvas								line: p1i								to: p2i								brushForm: brush]						ifFalse: [aCanvas								line: p1i								to: p2i								width: borderWidth								color: lineColor]]].! !!PolygonMorph methodsFor: 'drawing' stamp: 'jm 10/3/2002 18:45'!drawOn: aCanvas 	"Display the receiver, a spline curve, approximated by straight line segments."	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].	closed & color isTransparent not		ifTrue: [aCanvas stencil: self filledForm at: bounds topLeft - 1 color: color].	(borderColor isColor and: [borderColor isTranslucentColor])		ifTrue: [aCanvas stencil: self borderForm at: bounds topLeft						color: borderColor]		ifFalse: [self drawBorderOn: aCanvas].	self arrowForms do:		[:f | aCanvas stencil: f at: f offset			color: (borderColor isColor ifTrue: [borderColor] ifFalse: [color])]! !!PolygonMorph methodsFor: 'drawing'!drawOnFormCanvas: aCanvas 	"Display the receiver, a spline curve, approximated by straight line segments."	| |	vertices size < 1 ifTrue: [self error: 'a polygon must have at least one point'].	closed & color isTransparent not		ifTrue: [aCanvas stencil: self filledForm at: bounds topLeft - 1 color: color].	(borderColor isColor and: [borderColor isTranslucentColor])		ifTrue: [aCanvas stencil: self borderForm at: bounds topLeft						color: borderColor]		ifFalse: [self drawBorderOn: aCanvas].	self arrowForms do:		[:f | aCanvas stencil: f at: f offset			color: (borderColor isColor ifTrue: [borderColor] ifFalse: [color])]! !!PolygonMorph methodsFor: 'editing' stamp: 'di 10/9/1998 14:35'!dropVertex: evt fromHandle: handle vertIndex: ix	| p |	p _ vertices at: ix.	(((vertices atWrap: ix-1) dist: p) < 3 or:		[((vertices atWrap: ix+1) dist: p) < 3])		ifTrue: ["Drag a vertex onto its neighbor means delete"				self setVertices: (vertices copyReplaceFrom: ix to: ix with: Array new)].	self addHandles! !!PolygonMorph methodsFor: 'editing' stamp: 'jm 6/3/1998 14:29'!newVertex: evt fromHandle: handle afterVert: ix	"Insert a new vertex and fix everything up!! Install the drag-handle of the new vertex as recipient of further mouse events."	| pt |	pt _ evt cursorPoint.	self setVertices: (vertices copyReplaceFrom: ix + 1 to: ix with: (Array with: pt)).	evt hand newMouseFocus: (handles at: ((ix + 1) * 2) - 1).! !!PolygonMorph methodsFor: 'menu' stamp: 'jm 10/9/2002 05:56'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	handles		ifNil: [aCustomMenu add: 'show handles' action: #addHandles]		ifNotNil: [aCustomMenu add: 'hide handles' action: #removeHandles].	closed		ifTrue: [			aCustomMenu add: 'open polygon' action: #makeOpen.			quickFill				ifTrue: [aCustomMenu add: 'proper fill' selector: #quickFill: argument: false]				ifFalse: [aCustomMenu add: 'quick fill' selector: #quickFill: argument: true]]		ifFalse: [			aCustomMenu add: 'close polygon' action: #makeClosed.			arrows == #none ifFalse: [aCustomMenu add: '---' action: #makeNoArrows].			arrows == #forward ifFalse: [aCustomMenu add: '-->' action: #makeForwardArrow].			arrows == #back ifFalse: [aCustomMenu add: '<--' action: #makeBackArrow].			arrows == #both ifFalse: [aCustomMenu add: '<-->' action: #makeBothArrows]].! !!PolygonMorph methodsFor: 'menu' stamp: 'jm 10/11/2002 13:43'!addHandles	| handle newVert |	self removeHandles.	handles _ OrderedCollection new.	vertices withIndexDo: [:vertPt :vertIndex |		"vertex handle"		handle _ MouseHandleMorph			newBounds: (Rectangle center: vertPt extent: 8@8)			color: Color yellow.		handle			target: self argument: vertIndex;			mouseMoveSelector: #dragVertex:fromHandle:vertIndex:;			mouseUpSelector: #dropVertex:fromHandle:vertIndex:.		handles addLast: handle.		"handle to create a new vertex"		(closed or: [vertIndex < vertices size]) ifTrue: [			newVert _ MouseHandleMorph				newBounds: (Rectangle center: (vertPt + (vertices atWrap: vertIndex+1) // 2) extent: 8@8)				color: Color green.			newVert				target: self argument: vertIndex;				mouseDownSelector: #newVertex:fromHandle:afterVert:.			handles addLast: newVert]].	self addAllMorphs: handles.	self changed.! !!PolygonMorph methodsFor: 'private' stamp: 'di 12/17/1998 12:31'!arrowForms	"ArrowForms are computed only upon demand"	arrowForms ifNotNil: [^ arrowForms].	arrowForms _ Array new.	(closed or: [arrows == #none or: [vertices size < 2]]) ifTrue:		[^ arrowForms].	(arrows == #forward or: [arrows == #both]) ifTrue:		[arrowForms _ arrowForms copyWith:			(self computeArrowFormAt: vertices last from: self nextToLastPoint)].	(arrows == #back or: [arrows == #both]) ifTrue:		[arrowForms _ arrowForms copyWith:			(self computeArrowFormAt: vertices first from: self nextToFirstPoint)].	^ arrowForms! !!PolygonMorph methodsFor: 'private' stamp: 'jm 11/24/2002 10:49'!borderForm	"A form must be created for drawing the border whenever the borderColor is translucent."	| borderCanvas |	borderForm ifNotNil: [^ borderForm].	borderCanvas _ (FormCanvas extent: bounds extent depth: 1)		shadowColor: Color black.	borderCanvas translateBy: bounds topLeft negated		during:[:tempCanvas| self drawBorderOn: tempCanvas].	borderForm _ borderCanvas form.	self arrowForms do:		[:f |  "Eliminate overlap between line and arrowheads if transparent."		borderForm copy: f boundingBox from: f to: f offset - self position rule: Form erase].	^ borderForm! !!PolygonMorph methodsFor: 'private' stamp: 'jm 7/17/2003 22:53'!computeArrowFormAt: endPoint from: priorPoint	"Compute a triangle oriented along the line from priorPoint to endPoint.	Then draw those lines in a form and return that form, with appropriate offset"	| d v p1 pts box arrowForm bb origin angle |	d _ borderWidth max: 1.	v _ endPoint - priorPoint.	angle _ v theta radiansToDegrees.	pts _ Array with: (endPoint + (borderWidth//2) + (Point r: d*5 degrees: angle))				with: (endPoint + (borderWidth//2) + (Point r: d*4 degrees: angle + 135.0))				with: (endPoint + (borderWidth//2) + (Point r: d*4 degrees: angle - 135.0)).	box _ ((pts first rect: pts last) encompass: (pts at: 2)) expandBy: 1.	arrowForm _ Form extent: box extent truncated.	bb _ (BitBlt toForm: arrowForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ box topLeft.	p1 _ pts last - origin.	pts do: [:p | bb drawFrom: p1 to: p-origin.  p1 _ p-origin].	arrowForm convexShapeFill: Color black.	^ arrowForm offset: box topLeft! !!PolygonMorph methodsFor: 'private' stamp: 'di 12/17/1998 13:09'!computeBounds	self changed.	self releaseCachedState.	bounds _ self curveBounds.	self arrowForms do:		[:f | bounds _ bounds merge: (f offset extent: f extent)].	handles ifNotNil: [self updateHandles].	self layoutChanged.	self changed! !!PolygonMorph methodsFor: 'private' stamp: 'di 6/21/1998 15:24'!curveBounds	^ (Rectangle encompassing: vertices) expandBy: borderWidth+1//2! !!PolygonMorph methodsFor: 'private' stamp: 'jm 7/17/2003 22:53'!filledForm	"Note: The filled form is actually 2 pixels bigger than bounds, and the point corresponding to this morphs' position is at 1@1 in the form.  This is due to the details of the fillig routines, at least one of which requires an extra 1-pixel margin around the outside.  Computation of the filled form is done only on demand."	| bb origin |	closed ifFalse: [^ filledForm _ nil].	filledForm ifNotNil: [^ filledForm].	filledForm _ Form extent: bounds extent+2.	"Draw the border..."	bb _ (BitBlt toForm: filledForm) sourceForm: nil; fillColor: Color black;			combinationRule: Form over; width: 1; height: 1.	origin _ bounds topLeft truncated-1.	self lineSegmentsDo: [:p1 :p2 | bb drawFrom: p1 truncated-origin										to: p2 truncated-origin].	"Fill it in..."	quickFill ifTrue: [filledForm convexShapeFill: Color black]			ifFalse: [filledForm _ filledForm anyShapeFill].	(borderColor isColor and: [borderColor isTranslucentColor]) ifTrue:		["If border is stored as a form, then erase any overlap now."		filledForm copy: self borderForm boundingBox from: self borderForm			to: 1@1 rule: Form erase].	^ filledForm! !!PolygonMorph methodsFor: 'private' stamp: 'ar 6/18/1999 09:35'!getVertices	^vertices! !!PolygonMorph methodsFor: 'private' stamp: 'di 12/17/1998 12:33'!privateMoveBy: delta	super privateMoveBy: delta.	vertices _ vertices collect: [:p | p + delta].	self arrowForms do: [:f | f offset: f offset + delta]! !!PolygonMorph methodsFor: 'private' stamp: 'ar 11/8/1999 17:14'!releaseCachedState	super releaseCachedState.	filledForm _ nil.	arrowForms _ nil.	borderForm _ nil! !!PolygonMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:01'!includeInNewMorphMenu	^ true! !!PolygonMorph class methodsFor: 'instance creation' stamp: 'di 6/21/1998 10:24'!shapeFromPen: penBlock color: c borderWidth: bw borderColor: bc	"World addMorph: (PolygonMorph		shapeFromPen: [:p |				p hilbert: 4 side: 5.				p go: 5.				p hilbert: 4 side: 5.				p go: 5.]		color: Color red borderWidth: 1 borderColor: Color black)"	| pen |	penBlock value: (pen _ PenPointRecorder new).	^ (self vertices: pen points color: c borderWidth: bw borderColor: bc)		quickFill: false! !I provide a pop-up menu of options.!!PopUpChoiceMorph methodsFor: 'as yet unclassified' stamp: 'jm 10/13/2002 17:39'!initialize	super initialize.	self contents: 'PopUpChoice of Colors'.	target _ Color.	actionSelector _ nil.	arguments _ Array empty.	getItemsSelector _ #colorNames.	getItemsArgs _ Array empty.! !!PopUpChoiceMorph methodsFor: 'as yet unclassified' stamp: 'ee 7/2/2003 15:08'!mouseDown: evt	| items menu selectedItem |	(target == nil or: [getItemsSelector == nil]) ifTrue: [^ self].	items _ target perform: getItemsSelector withArguments: getItemsArgs.	menu _ CustomMenu new.	items do: [:item | menu add: item action: item].	selectedItem _ menu startUp.	selectedItem ifNil: [^ self].	self contentsClipped: ''.  "Client can override this if necess"	actionSelector ifNotNil: [		target			perform: actionSelector			withArguments: (arguments copyWith: selectedItem)].! !!PopUpChoiceMorph methodsFor: 'as yet unclassified' stamp: 'ee 7/2/2003 14:35'!preemptsMouseDown: evt	^ true.! !I represent a list of items. My instances are presented on the display screen in a rectangular area. The user points to an item, pressing a mouse button; the item is highlighted. When the button is released, the highlighted item indicates the selection.!!PopUpMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 11:44'!center	"Answer the point at the center of the receiver's rectangular area."	^ frame center! !!PopUpMenu methodsFor: 'accessing' stamp: 'di 4/20/1999 14:33'!frameHeight	"Designed to avoid the entire frame computation (includes MVC form),	since the menu may well end up being displayed in Morphic anyway."	| nItems |	frame ifNotNil: [^ frame height].	nItems _ 1 + (labelString occurrencesOf: Character cr).	^ (nItems * MenuStyle lineGrid) + 4 "border width"! !!PopUpMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 14:55'!labelString	^ labelString! !!PopUpMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 14:55'!lineArray	^ lineArray! !!PopUpMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 12:32'!nItems	^ (labelString occurrencesOf: Character cr) + 1! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sma 6/1/2000 13:04'!controlActivity	"Do whatever a menu must do - now with keyboard support."	| didNotMove downPos |	didNotMove _ true.	Sensor anyButtonPressed		ifFalse:			[didNotMove _ false.			Sensor waitButtonOrKeyboard]. 		Sensor keyboardPressed ifFalse: [self manageMarker].	(didNotMove and: [selection = 0])		ifTrue:			[downPos _ Sensor cursorPoint.			[didNotMove and: [Sensor anyButtonPressed]]				whileTrue:					[(downPos dist: Sensor cursorPoint) < 2 ifFalse: [didNotMove _ false]].			didNotMove ifTrue: [Sensor waitButtonOrKeyboard]].	[Sensor keyboardPressed] whileTrue:		[self readKeyboard ifTrue: [^ self].		Sensor waitButtonOrKeyboard].	[Sensor anyButtonPressed] whileTrue: [self manageMarker]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sma 6/1/2000 10:55'!readKeyboard	"Keyboard support for menus. ESC will abort the menu, Space or CR	will select an item. Cursor up and cursor down will change the	selection. Any other key will either select an item whose label starts	with that character or select the next matching label.	Answer true if the menu should be closed and false otherwise."	| ch labels occurences |	ch _ Sensor keyboard asciiValue.	(ch = 13 or: [ch = 32]) ifTrue: [^ true].	ch = 27 ifTrue: [self setSelection: 0. ^ true].	ch = 30		ifTrue:			[self setSelection: (selection <= 1				ifTrue: [self nItems]				ifFalse: [selection - 1])].	ch = 31 ifTrue: [self setSelection: selection \\ self nItems + 1].	ch _ ch asCharacter asLowercase.	labels _ labelString findTokens: Character cr asString.	occurences _ 0.	1 + selection to: selection + labels size do:		[:index |		| i | i _ index - 1 \\ labels size + 1.		(labels at: i) withBlanksTrimmed first asLowercase = ch			ifTrue: [(occurences _ occurences + 1) = 1 ifTrue: [self setSelection: i]]].	^ occurences = 1! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sma 4/30/2000 10:04'!startUpCenteredWithCaption: captionOrNil	"Differs from startUpWithCaption: by appearing with cursor in the menu,	and thus ready to act on mouseUp, without requiring user tweak to confirm"	| cursorPoint |	cursorPoint _ Smalltalk isMorphic 			ifTrue: [World cursorPoint]			ifFalse: [Sensor cursorPoint].	^ self startUpWithCaption: captionOrNil at: cursorPoint - (20@0)! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'JDD 8/8/199913:05'!startUpSegmented: segmentHeight withCaption: captionOrNil at: location	"This menu is too big to fit comfortably on the screen.	Break it up into smaller chunks, and manage the relative indices.	Inspired by a special-case solution by Reinier van Loon.""(PopUpMenu labels: (String streamContents: [:s | 1 to: 100 do: [:i | s print: i; cr]. s skip: -1])		lines: (5 to: 100 by: 5)) startUpWithCaption: 'Give it a whirl...'."	| nLines nLinesPer allLabels from to subset subLines index |	frame ifNil: [self computeForm].	allLabels := labelString findTokens: Character cr asString.	nLines _ allLabels size.	lineArray ifNil: [lineArray _ Array new].	nLinesPer _ segmentHeight // marker height - 3.	from := 1.	[ true ] whileTrue:		[to := (from + nLinesPer) min: nLines.		subset := allLabels copyFrom: from to: to.		subset add: (to = nLines ifTrue: ['start over...'] ifFalse: ['more...'])			before: subset first.		subLines _ lineArray select: [:n | n >= from] thenCollect: [:n | n - (from-1) + 1].		subLines _ (Array with: 1) , subLines.		index := (PopUpMenu labels: subset asStringWithCr lines: subLines)					startUpWithCaption: captionOrNil at: location.		index = 1			ifTrue: [from := to + 1.					from > nLines ifTrue: [ from := 1 ]]			ifFalse: [index = 0 ifTrue: [^ 0].					^ from + index - 2]]! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sma 4/30/2000 10:05'!startUpWithCaption: captionOrNil	"Display the menu, slightly offset from the cursor,	so that a slight tweak is required to confirm any action."	^ self startUpWithCaption: captionOrNil		at: (Smalltalk isMorphic 			ifTrue: [World cursorPoint]			ifFalse: [Sensor cursorPoint])! !!PopUpMenu methodsFor: 'basic control sequence' stamp: 'sma 5/28/2000 12:11'!startUpWithCaption: captionOrNil at: location	"Display the menu, with caption if supplied. Wait for the mouse button to go down,	then track the selection as long as the button is pressed. When the button is released, 	answer the index of the current selection, or zero if the mouse is not released over 	any menu item. Location specifies the desired topLeft of the menu body rectangle."	| maxHeight |	maxHeight _ Display height*3//4.	self frameHeight > maxHeight ifTrue:		[^ self			startUpSegmented: maxHeight			withCaption: captionOrNil			at: location].	Smalltalk isMorphic		ifTrue:			[selection _ Cursor normal showWhile:				[(MVCMenuMorph from: self title: captionOrNil) invokeAt: location in: World].			^ selection].	frame ifNil: [self computeForm].	Cursor normal showWhile:		[self			displayAt: location			withCaption: captionOrNil			during: [self controlActivity]].	^ selection! !!PopUpMenu methodsFor: 'displaying' stamp: 'sw 12/10/1999 09:55'!displayAt: aPoint withCaption: captionOrNil during: aBlock	"Display the receiver just to the right of aPoint while aBlock is evaluated.  If the receiver is forced off screen, display it just to the right."	| delta savedArea captionForm captionSave outerFrame captionText tFrame frameSaveLoc captionBox |	marker ifNil: [self computeForm].	frame _ frame align: marker leftCenter with: aPoint + (2@0).	outerFrame _ frame.	captionOrNil notNil ifTrue:		[captionText _ (DisplayText				text: captionOrNil asText				textStyle: MenuStyle copy centered)					foregroundColor: Color black					backgroundColor: Color white.		tFrame _ captionText boundingBox insetBy: -2.		outerFrame _ frame merge: (tFrame align: tFrame bottomCenter					with: frame topCenter + (0@2))].	delta _ outerFrame amountToTranslateWithin: Display boundingBox.	frame right > Display boundingBox right		ifTrue: [delta _ 0 - frame width @ delta y].	frame _ frame translateBy: delta.	captionOrNil notNil ifTrue:		[captionForm _ captionText form.		captionBox _ captionForm boundingBox expandBy: 4.		captionBox _ captionBox align: captionBox bottomCenter								with: frame topCenter + (0@2).		captionSave _ Form fromDisplay: captionBox.		Display border: captionBox width: 4 fillColor: Color white.		Display border: captionBox width: 2 fillColor: Color black.		captionForm displayAt: captionBox topLeft + 4].	marker _ marker align: marker leftCenter with: aPoint + delta +  (2@0).	savedArea _ Form fromDisplay: frame.	self menuForm displayOn: Display at: (frameSaveLoc _ frame topLeft).	selection ~= 0 ifTrue: [Display reverse: marker].	Cursor normal showWhile: [aBlock value].	savedArea displayOn: Display at: frameSaveLoc.	captionOrNil notNil ifTrue:		[captionSave displayOn: Display at: captionBox topLeft]! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'di 4/13/1999 17:42'!manageMarker	"If the cursor is inside the receiver's frame, then highlight the marked 	item. Otherwise no item is to be marked."	| pt |	"Don't let pt get far from display box, so scrolling will go all the way"	pt _ Sensor cursorPoint adhereTo: (Display boundingBox expandBy: 1).	(frame inside containsPoint: pt)		ifTrue: ["Need to cache the form for reasonable scrolling performance"				((Display boundingBox insetBy: 0@3) containsPoint: pt)					ifFalse: [pt _ pt - (self scrollIntoView: pt)].				self markerOn: pt]		ifFalse: [self markerOff]! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'sma 5/28/2000 15:27'!markerOff	"No item is selected. Reverse the highlight if any item has been marked 	as selected."	self setSelection: 0! !!PopUpMenu methodsFor: 'marker adjustment' stamp: 'sma 6/1/2000 13:01'!markerOn: aPoint 	"The item whose bounding area contains aPoint should be marked as 	selected. Highlight its area and set the selection to its index."	selection = 0 | (marker containsPoint: aPoint) not 		ifTrue: [selection = 0 & (marker containsPoint: aPoint)					ifTrue: [Display reverse: marker]					ifFalse: 						[selection > 0 ifTrue: [Display reverse: marker].						marker _ 							marker 								align: marker topLeft 								with: marker left @ (self markerTop: aPoint).						Display reverse: marker]].	selection _ marker top - frame top // marker height + 1! !!PopUpMenu methodsFor: 'private' stamp: 'sma 6/1/2000 12:59'!computeForm	"Compute and answer a Form to be displayed for this menu."	| borderInset paraForm menuForm inside |	borderInset _ 4@4.	paraForm _ (DisplayText text: labelString asText textStyle: MenuStyle) form.	menuForm _ Form extent: paraForm extent + (borderInset * 2).	menuForm borderWidth: 2.	paraForm displayOn: menuForm at: borderInset.	lineArray == nil ifFalse:		[lineArray do:			[ :line |			menuForm fillBlack: (4 @ ((line * font height) + borderInset y)				extent: (menuForm width - 8 @ 1))]].	frame _ Quadrangle new.	frame region: menuForm boundingBox.	frame borderWidth: 4.	inside _ frame inside.	marker _ inside topLeft extent: (inside width @ MenuStyle lineGrid).	selection _ 1.	^ form _ menuForm! !!PopUpMenu methodsFor: 'private' stamp: 'di 4/13/1999 16:21'!labels: aString font: aFont lines: anArray	labelString _ aString.	font _ aFont.	lineArray _ anArray.! !!PopUpMenu methodsFor: 'private' stamp: 'di 4/13/1999 17:51'!menuForm	"Answer a Form to be displayed for this menu."	form == nil ifTrue: [self computeForm].	^ form! !!PopUpMenu methodsFor: 'private' stamp: 'sma 2/5/2000 11:56'!rescan	"Cause my form to be recomputed after a font change."	labelString == nil ifTrue: [labelString _ 'NoText!!'].	self labels: labelString font: (MenuStyle fontAt: 1) lines: lineArray.	frame _ marker _ form _ nil.	"PopUpMenu allSubInstancesDo: [:m | m rescan]"! !!PopUpMenu methodsFor: 'selecting' stamp: 'sma 5/28/2000 12:27'!selection	"Answer the current selection."	^ selection! !!PopUpMenu methodsFor: 'selecting' stamp: 'sma 6/1/2000 11:01'!setSelection: index	| newSelection |	selection = index ifTrue: [^ self].	newSelection _ (0 max: index) min: frame height // marker height.	selection > 0 ifTrue: [Display reverse: marker].	marker _ marker translateBy: 0 @ (newSelection - selection * marker height).	selection _ newSelection.	selection > 0 ifTrue: [Display reverse: marker]! !!PopUpMenu class methodsFor: 'class initialization' stamp: 'sw 12/6/1999 13:08'!initialize  "PopUpMenu initialize"	(MenuStyle _ TextStyle default copy)		gridForFont: TextStyle default defaultFontIndex withLead: 0;		centered.	PopUpMenu allSubInstancesDo: [:m | m rescan]! !!PopUpMenu class methodsFor: 'class initialization' stamp: 'jm 10/5/2002 06:56'!setMenuFontTo: aFont	MenuStyle _ aFont textStyle copy consistOnlyOf: aFont.	MenuStyle 		gridForFont: 1 withLead: 0;		centered.	self allSubInstancesDo: [:m | m rescan].! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 15:44'!labelArray: labelArray	"Answer an instance of me whose items are in labelArray."	^ self labelArray: labelArray lines: nil! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 15:43'!labelArray: labelArray lines: lineArray	"Answer an instance of me whose items are in labelArray, with lines 	drawn after each item indexed by anArray. 2/1/96 sw"	labelArray isEmpty ifTrue: [self error: 'Menu must not be zero size'].	^ self		labels: (String streamContents: 			[:stream |			labelArray do: [:each | stream nextPutAll: each; cr].			stream skip: -1 "remove last CR"])		lines: lineArray"Example:	(PopUpMenu labelArray: #('frog' 'and' 'toad') lines: #()) startUp"! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 15:36'!labels: aString	"Answer an instance of me whose items are in aString."	^ self labels: aString lines: nil! !!PopUpMenu class methodsFor: 'instance creation' stamp: 'sw 12/6/1999 17:55'!labels: aString lines: anArray	"Answer an instance of me whose items are in aString, with lines drawn 	after each item indexed by anArray."	^ self new		labels: aString		font: MenuStyle defaultFont		lines: anArray! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'sma 5/28/2000 15:48'!confirm: queryString	"Put up a yes/no menu with caption queryString. Answer true if the 	response is yes, false if no. This is a modal question--the user must 	respond yes or no."	"PopUpMenu confirm: 'Are you hungry?'"	^ self confirm: queryString trueChoice: 'Yes' falseChoice: 'No'! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'sma 6/5/2000 09:11'!confirm: queryString orCancel: cancelBlock	"Put up a yes/no/cancel menu with caption aString. Answer true if  	the response is yes, false if no. If cancel is chosen, evaluate  	cancelBlock. This is a modal question--the user must respond yes or no."	"PopUpMenu confirm: 'Reboot universe' orCancel: [^'Nevermind']"	| menu choice |	menu _ PopUpMenu labelArray: {'Yes'. 'No'. 'Cancel'}.	choice _ menu startUpWithCaption: queryString.	choice = 1 ifTrue: [^ true].	choice = 2 ifTrue: [^ false].	^ cancelBlock value! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'sma 6/5/2000 09:12'!confirm: queryString trueChoice: trueChoice falseChoice: falseChoice	"Put up a yes/no menu with caption queryString. The actual wording 	for the two choices will be as provided in the trueChoice and 	falseChoice parameters. Answer true if the response is the true-choice, 	false if it's the false-choice.	This is a modal question -- the user must respond one way or the other."	"PopUpMenu 		confirm: 'Are you hungry?'		trueChoice: 'yes, I''m famished'		falseChoice: 'no, I just ate'"	| menu choice |	menu _ PopUpMenu labelArray: {trueChoice. falseChoice}.	[(choice _ menu startUpWithCaption: queryString) isNil] whileTrue.	^ choice = 1! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'sma 5/28/2000 15:57'!inform: aString	"PopUpMenu inform: 'I like Squeak'"	(PopUpMenu labels: ' OK ') startUpWithCaption: aString! !!PopUpMenu class methodsFor: 'dialogs' stamp: 'sma 5/28/2000 15:57'!notify: message	"Deprecated. Use #inform: instead."	self inform: message! !I represent a position argument for a command block.  Clicking on me and then another point on the screen allows the user to my position value to the position value of the point on the screen.!!PositionArgMorph methodsFor: 'initialize' stamp: 'jm 1/1/2004 14:54'!initialize	super initialize.	self borderInset.	self borderWidth: 1.	self color: Color white.	self extent: 20@17.	labelMorph _ StringMorph new.	self addMorph: labelMorph.	position _ 0@0.	self morphPos: (self formatedPointString: 0@0).! !!PositionArgMorph methodsFor: 'event handling' stamp: 'jm 6/30/2003 07:26'!handlesMouseDown: evt	^ true! !!PositionArgMorph methodsFor: 'event handling' stamp: 'jm 1/1/2004 14:55'!mouseUp: evt	"Let the user select a point on the screen."	Cursor crossHair showWhile: [		[Sensor anyButtonPressed] whileFalse: [self world doOneCycleNoInput].		position _ Sensor cursorPoint.		Sensor waitNoButton.		self morphPos: (self formatedPointString: position)].! !!PositionArgMorph methodsFor: 'evaluation' stamp: 'DaveF 7/11/2003 18:37'!evaluate	^ position! !!PositionArgMorph methodsFor: 'evaluation' stamp: 'jm 1/1/2004 14:54'!formatedPointString: aPoint	"Answer a string of the form (x, y) for the given point."	^ '(', aPoint x printString, ', ', aPoint y printString, ')'! !!PositionArgMorph methodsFor: 'evaluation' stamp: 'jm 8/24/2003 17:17'!morphPos: aString	labelMorph contents: aString.	self width: labelMorph width + 6.	labelMorph position: self position + (3@2).! !!PositionArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:32'!fieldsVersion	^ 1! !!PositionArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:33'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		position	) from: anObjStream.! !!PositionArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:33'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		position	) on: anObjStream.! !I represent an accessor for a sequence of objects (a collection) that are externally named by indices so that the point of access can be repositioned. I am abstract in that I do not implement the messages next and nextPut: which are inherited from my superclass Stream.!!PositionableStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 14:58'!next: n into: aCollection	"Read n objects into the given collection.	Return aCollection or a partial copy if less than	n elements have been read."	^self next: n into: aCollection startingAt: 1! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 14:54'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	| obj |	0 to: n-1 do:[:i|		(obj _ self next) == nil ifTrue:[^aCollection copyFrom: 1 to: startIndex+i-1].		aCollection at: startIndex+i put: obj].	^aCollection! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 1/2/2000 15:32'!next: anInteger putAll: aCollection	"Store the next anInteger elements from the given collection."	^self next: anInteger putAll: aCollection startingAt: 1! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 1/2/2000 15:32'!next: anInteger putAll: aCollection startingAt: startIndex	"Store the next anInteger elements from the given collection."	0 to: anInteger-1 do:[:i|		self nextPut: (aCollection at: startIndex + i).	].	^aCollection! !!PositionableStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 14:53'!nextInto: aCollection	"Read the next elements of the receiver into aCollection.	Return aCollection or a partial copy if less than aCollection	size elements have been read."	^self next: aCollection size into: aCollection startingAt: 1.! !!PositionableStream methodsFor: 'accessing' stamp: 'jm 12/3/2003 08:44'!nextWordsInto: aBitmap 	"Fill the word based buffer from my collection. Stored on stream as little-endian. Optimized for speed."	| blt pos mainX mainY frontX frontY little source |	(collection class isBytes) ifTrue: [		"1 to: aBitmap size do: [:index | aBitmap at: index put: (self nextNumber: 4)]"		little _ Smalltalk isBigEndian not.		collection basicSize \\ 4 = 0 			ifTrue: [source _ collection. 					pos _ self position.					self skip: aBitmap size * aBitmap bytesPerElement "1, 2, or 4"]			ifFalse: [source _ self next: aBitmap size * aBitmap bytesPerElement.						"forced to copy it into a buffer"					pos _ 0].		mainX _ pos \\ 4.		mainY _ pos // 4.	"two Blts required if not word aligned"		frontX _ 0.		frontY _ mainY + 1.		blt _ (BitBlt toForm: (Form new hackBits: aBitmap)) 					sourceForm: (Form new hackBits: source).		blt combinationRule: Form over.  "store"		blt sourceX: mainX; sourceY: mainY; height: aBitmap basicSize; width: 4-mainX.		blt destX: 0; destY: 0.		little ifTrue: [blt sourceX: 0; destX: mainX].	"just happens to be this way!!"		blt copyBits.		mainX = 0 ifTrue: [^ aBitmap].		"second piece when not word aligned"		blt sourceX: frontX; sourceY: frontY; height: aBitmap size; width: mainX.		blt destX: 4-mainX; destY: 0.		little ifTrue: [blt sourceX: 4-mainX; destX: frontX].	"draw picture to understand this"		blt copyBits.		^ aBitmap].	^ self next: aBitmap size into: aBitmap startingAt: 1! !!PositionableStream methodsFor: 'accessing' stamp: 'tk 7/18/1999 17:10'!upToAll: aCollection	"Answer a subcollection from the current access position to the occurrence (if any, but not inclusive) of aCollection. If aCollection is not in the stream, answer the entire rest of the stream."	| startPos endMatch result |	startPos _ self position.	(self match: aCollection) 		ifTrue: [endMatch _ self position.			self position: startPos.			result _ self next: endMatch - startPos - aCollection size.			self position: endMatch.			^ result]		ifFalse: [self position: startPos.			^ self upToEnd]! !!PositionableStream methodsFor: 'testing' stamp: 'ar 1/2/2000 17:24'!isBinary	"Return true if the receiver is a binary byte stream"	^collection class == ByteArray! !!PositionableStream methodsFor: 'positioning' stamp: 'hmm 10/22/1999 21:18'!match: subCollection	"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."	| pattern startMatch |	pattern _ ReadStream on: subCollection.	startMatch _ nil.	[pattern atEnd] whileFalse: 		[self atEnd ifTrue: [^ false].		(self next) = (pattern next) 			ifTrue: [pattern position = 1 ifTrue: [startMatch _ self position]]			ifFalse: [pattern position: 0.					startMatch ifNotNil: [						self position: startMatch.						startMatch _ nil]]].	^ true! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 10/5/2001 12:09'!boolean	"Answer the next boolean value from this (binary) stream."	^ self next ~= 0! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 10/5/2001 12:11'!boolean: aBoolean	"Store the given boolean value on this (binary) stream."	self nextPut: (aBoolean ifTrue: [1] ifFalse: [0]).! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 7/16/2001 14:43'!int16	"Answer the next signed, 16-bit integer from this (binary) stream."	| n |	n _ self next.	n _ (n bitShift: 8) + (self next).	n >= 16r8000 ifTrue: [n _ n - 16r10000].	^ n! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 7/16/2001 14:44'!int16: anInteger	"Store the given signed, 16-bit integer on this (binary) stream."	| n |	(anInteger < -16r8000) | (anInteger >= 16r8000)		ifTrue: [self error: 'outside 16-bit integer range'].	anInteger < 0		ifTrue: [n _ 16r10000 + anInteger]		ifFalse: [n _ anInteger].	self nextPut: (n digitAt: 2).	self nextPut: (n digitAt: 1).! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 7/16/2001 15:15'!int32	"Answer the next signed, 32-bit integer from this (binary) stream."	"Details: As a fast check for negative number, check the high bit of the first digit"	| n firstDigit |	n _ firstDigit _ self next.	n _ (n bitShift: 8) + self next.	n _ (n bitShift: 8) + self next.	n _ (n bitShift: 8) + self next.	firstDigit >= 128 ifTrue: [n _ -16r100000000 + n].  "decode negative 32-bit integer"	^ n! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 7/16/2001 14:46'!int32: anInteger	"Store the given signed, 32-bit integer on this (binary) stream."	| n |	(anInteger < -16r80000000) | (anInteger >= 16r80000000)		ifTrue: [self error: 'outside 32-bit integer range'].	anInteger < 0		ifTrue: [n _ 16r100000000 + anInteger]		ifFalse: [n _ anInteger].	self nextPut: (n digitAt: 4).	self nextPut: (n digitAt: 3).	self nextPut: (n digitAt: 2).	self nextPut: (n digitAt: 1).! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 12/3/2003 14:31'!littleEndianUint16	"Answer the next unsigned, little-endian 16-bit integer from this (binary) stream."	| n |	n _ self next.	^ (self next bitShift: 8) + n! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 12/3/2003 14:33'!littleEndianUint16: anInteger	"Store the given unsigned, 16-bit integer on this (binary) stream least-significant byte first."	(anInteger < 0) | (anInteger >= 16r10000)		ifTrue: [self error: 'outside unsigned 16-bit integer range'].	self nextPut: (anInteger digitAt: 1).	self nextPut: (anInteger digitAt: 2).! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 12/3/2003 16:03'!littleEndianUint24	"Answer the next unsigned, little-endian 24-bit integer from this (binary) stream."	| bytes |	bytes _ self next: 3.	^ (bytes at: 1) + ((bytes at: 2) bitShift: 8) + ((bytes at: 3) bitShift: 16)! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 12/3/2003 16:02'!littleEndianUint24: anInteger	"Store the given unsigned, 24-bit integer on this (binary) stream least-significant byte first."	(anInteger < 0) | (anInteger >= 16r1000000)		ifTrue: [self error: 'outside unsigned 24-bit integer range'].	self nextPut: (anInteger digitAt: 1).	self nextPut: (anInteger digitAt: 2).	self nextPut: (anInteger digitAt: 3).! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 12/3/2003 14:46'!littleEndianUint32	"Answer the next unsigned, little-endian 32-bit integer from this (binary) stream."	"Add the most-signficant byte in last to avoid extra large-integer operations."	| bytes |	bytes _ self next: 4.	^ ((bytes at: 1) + ((bytes at: 2) bitShift: 8) + ((bytes at: 3) bitShift: 16)) +		((bytes at: 4) bitShift: 24)! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 12/3/2003 14:34'!littleEndianUint32: anInteger	"Store the given unsigned, 32-bit integer on this (binary) stream least-significant byte first."	(anInteger < 0) | (anInteger >= 16r100000000)		ifTrue: [self error: 'outside unsigned 32-bit integer range'].	self nextPut: (anInteger digitAt: 1).	self nextPut: (anInteger digitAt: 2).	self nextPut: (anInteger digitAt: 3).	self nextPut: (anInteger digitAt: 4).! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 9/5/2001 07:35'!string	"Answer the next string from this (binary) stream."	| size |	size _ self uint16.	^ (self next: size) asString! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 9/5/2001 12:09'!string: aString	"Store the given string on this (binary) stream. The string must contain 65535 or fewer characters."	aString size > 16rFFFF ifTrue: [self error: 'string too long for this format'].	self uint16: aString size.	self nextPutAll: aString asByteArray.! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 8/20/2001 07:53'!uint16	"Answer the next unsigned, 16-bit integer from this (binary) stream."	| n |	n _ self next.	n _ (n bitShift: 8) + (self next).	^ n! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 8/20/2001 07:53'!uint16: anInteger	"Store the given unsigned, 16-bit integer on this (binary) stream."	(anInteger < 0) | (anInteger >= 16r10000)		ifTrue: [self error: 'outside unsigned 16-bit integer range'].	self nextPut: (anInteger digitAt: 2).	self nextPut: (anInteger digitAt: 1).! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 8/20/2001 08:07'!uint24	"Answer the next unsigned, 24-bit integer from this (binary) stream."	| n |	n _ self next.	n _ (n bitShift: 8) + self next.	n _ (n bitShift: 8) + self next.	^ n! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 8/20/2001 08:07'!uint24: anInteger	"Store the given unsigned, 24-bit integer on this (binary) stream."	(anInteger < 0) | (anInteger >= 16r1000000)		ifTrue: [self error: 'outside unsigned 24-bit integer range'].	self nextPut: (anInteger digitAt: 3).	self nextPut: (anInteger digitAt: 2).	self nextPut: (anInteger digitAt: 1).! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 8/20/2001 07:53'!uint32	"Answer the next unsigned, 32-bit integer from this (binary) stream."	| n |	n _ self next.	n _ (n bitShift: 8) + self next.	n _ (n bitShift: 8) + self next.	n _ (n bitShift: 8) + self next.	^ n! !!PositionableStream methodsFor: 'data get/put' stamp: 'jm 8/20/2001 07:52'!uint32: anInteger	"Store the given unsigned, 32-bit integer on this (binary) stream."	(anInteger < 0) | (anInteger >= 16r100000000)		ifTrue: [self error: 'outside unsigned 32-bit integer range'].	self nextPut: (anInteger digitAt: 4).	self nextPut: (anInteger digitAt: 3).	self nextPut: (anInteger digitAt: 2).	self nextPut: (anInteger digitAt: 1).! !!PositionableStream methodsFor: 'private' stamp: 'jm 12/3/2003 16:14'!on: aCollection	collection _ aCollection.	readLimit _ aCollection size.	position _ 0.	self reset.! !!PositionableStream methodsFor: 'private' stamp: 'jm 12/3/2003 16:14'!positionError	"Since I am not necessarily writable, it is up to my subclasses to override position: if expanding the collection is preferrable to giving this error."	self error: 'Attempt to set the position of a PositionableStream out of bounds'! !!PositionableStream methodsFor: 'private' stamp: 'jm 12/3/2003 16:14'!setFrom: newStart to: newStop	position _ newStart - 1.	readLimit _ newStop.! !!PreDebugWindow methodsFor: 'as yet unclassified' stamp: 'sw 9/29/1999 07:37'!adjustBookControls	| inner |	proceedButton ifNil: [^ self].	proceedButton align: proceedButton topLeft with: (inner _ self innerBounds) topLeft + (35@-4).	debugButton align: debugButton topRight with: inner topRight - (16@4).! !!PreDebugWindow methodsFor: 'as yet unclassified' stamp: 'sw 10/15/1998 13:00'!debug	model debug! !!PreDebugWindow methodsFor: 'as yet unclassified' stamp: 'sw 11/4/1998 09:50'!extent: newExtent	super extent: (newExtent max: 100 @ 50).	self adjustBookControls! !!PreDebugWindow methodsFor: 'as yet unclassified' stamp: 'sw 12/6/1999 18:06'!initialize	| aFont proceedLabel debugLabel aWidth |	super initialize.	true "Preferences optionalMorphicButtons" ifFalse:		[(aWidth _ self widthOfFullLabelText) > 280 ifTrue: [^ self].   "No proceed/debug buttons if title too long"		aWidth > 210			ifTrue: "Abbreviated buttons if title pretty long"				[proceedLabel _ 'p'.				debugLabel _ 'd']			ifFalse: "Full buttons if title short enough"				[proceedLabel _ 'proceed'.				debugLabel _ 'debug'].		aFont _  Preferences standardButtonFont.		self addMorph: (proceedButton _ SimpleButtonMorph new borderWidth: 0;				label: proceedLabel font: aFont; color: Color transparent;				actionSelector: #proceed; target: self).		proceedButton setBalloonText: 'continue execution'.		self addMorph: (debugButton _ SimpleButtonMorph new borderWidth: 0;				label: debugLabel font: aFont; color: Color transparent;				actionSelector: #debug; target: self).		debugButton setBalloonText: 'bring up a debugger'.		proceedButton submorphs first color: Color blue.		debugButton submorphs first color: Color red].	self adjustBookControls! !!PreDebugWindow methodsFor: 'as yet unclassified' stamp: 'sw 10/15/1998 13:00'!proceed	model proceed! !!PreDebugWindow methodsFor: 'as yet unclassified' stamp: 'tk 1/3/2000 12:54'!setLabelWidgetAllowance	^ labelWidgetAllowance _ (Smalltalk isMorphic | Preferences optionalButtons)		ifTrue:			[super setLabelWidgetAllowance]		ifFalse:			[180]! !A general mechanism to store preference choices.  The default setup treats any symbol as a potential boolean flag; flags unknown to the preference dictionary are always returned as false.  It is also possible to store non-boolean data in the preference table.  sw 8/91!!Preferences class methodsFor: 'initialization' stamp: 'sw 2/15/2000 18:40'!absorbAdditions	"Preferences absorbAdditions"	self initializeAddedPreferences.	self initializeHelpMessages.	self resetCategoryInfo! !!Preferences class methodsFor: 'initialization' stamp: 'sw 1/12/2000 22:34'!allPreferenceInitializationSpecs	"Preferences allPreferenceInitializationSpecs"	| aList additions |	aList _ OrderedCollection new.	(self class organization listAtCategoryNamed: 'initial values' asSymbol) do:		[:aSelector | aSelector numArgs = 0 ifTrue:			[additions _ self perform: aSelector.			(additions isKindOf: Collection) ifFalse: [self error: 'method in "initial values" categories must return collections'].			aList addAll: additions]].	^ aList			! !!Preferences class methodsFor: 'initialization' stamp: 'sw 1/13/2000 14:03'!callHelpMessageInitializers	| listOfPairs |	"Preferences callHelpMessageInitializers"	(self class organization listAtCategoryNamed: #help) do:		[:aSelector | aSelector numArgs = 0 ifTrue:			[((listOfPairs _ self perform: aSelector) isKindOf: Collection)				ifTrue:					[listOfPairs do:						[:pair | HelpDictionary at: pair first put: 					(pair first, ':		', pair last)]]]]! !!Preferences class methodsFor: 'initialization' stamp: 'sw 1/13/2000 14:17'!chooseInitialSettings	"Restore the default choices for Preferences."	"Preferences chooseInitialSettings"	self allPreferenceInitializationSpecs do:		[:aSpec |			aSpec second == #true				ifTrue:					[self enable: aSpec first]				ifFalse:					[self disable: aSpec first]].	self resetCategoryInfo! !!Preferences class methodsFor: 'initialization' stamp: 'sw 7/1/1999 23:17'!compileAccessMethodFor: prefSymbol	self class compileProgrammatically: (prefSymbol, '	^ self valueOfFlag: #', prefSymbol) classified: 'standard preferences'! !!Preferences class methodsFor: 'initialization' stamp: 'sw 9/19/1998 22:47'!initialize	"Preferences initialize"	"Sometimes placed in a change-set even though unchanged, to trigger reinitialization upon update."	FlagDictionary _ Dictionary new.	self chooseInitialSettings.! !!Preferences class methodsFor: 'initialization' stamp: 'sw 1/13/2000 14:16'!initializeAddedPreferences	"Initialize any preference not yet known to the prefs dictionary as per descriptions in the 'initial values' category, but don't change the setting of any existing preference.	Also, compile accessor methods for retrieving any preference that lacks one"	"Preferences initializeAddedPreferences"	| sym |	self allPreferenceInitializationSpecs do:		[:triplet |			(self class selectors includes: (sym _ triplet first))				ifFalse:					[self compileAccessMethodFor: sym].			(FlagDictionary includesKey: sym) ifFalse:				[triplet second == #true					ifTrue:						[self enable: sym]					ifFalse:						[self disable: sym]]].	self resetCategoryInfo! !!Preferences class methodsFor: 'initialization' stamp: 'sw 1/13/2000 13:49'!initializeHelpMessages	"Preferences initializeHelpMessages"  	HelpDictionary _ Dictionary new.	self callHelpMessageInitializers! !!Preferences class methodsFor: 'parameters' stamp: 'sw 10/19/1999 22:39'!annotationInfo 	^ #(		(timeStamp			'The time stamp of the last submission of the method.')		(messageCategory	'Which method category the method lies in')		(sendersCount		'A report of how many senders there of the message.')		(implementorsCount	'A report of how many implementors there are of the message.')		(recentChangeSet	'The most recent change set bearing the method.')		(allChangeSets		'A list of all change sets bearing the method.')		(priorVersionsCount	'A report of how many previous versions there are of the method' )		(priorTimeStamp		'The time stamp of the penultimate submission of the method, if any'))! !!Preferences class methodsFor: 'parameters' stamp: 'jm 6/15/2003 12:35'!defaultAnnotationRequests	(Parameters includesKey: #MethodAnnotations) ifFalse: [		Parameters			at: #MethodAnnotations			put: #(timeStamp messageCategory implementorsCount allChangeSets)].	^ Parameters at: #MethodAnnotations! !!Preferences class methodsFor: 'parameters' stamp: 'jm 6/15/2003 12:36'!defaultAnnotationRequests: newList	^ Parameters at: #MethodAnnotations put: newList! !!Preferences class methodsFor: 'parameters' stamp: 'sw 9/7/1999 12:45'!initializeParameters	"Preferences initializeParameters"	Parameters _ IdentityDictionary new.	self restoreDefaultMenuParameters.	Parameters at: #maxBalloonHelpLineLength put: 28.	self initializeTextHighlightingParameters! !!Preferences class methodsFor: 'parameters' stamp: 'sw 11/5/1998 16:49'!maxBalloonHelpLineLength	^ Parameters at: #maxBalloonHelpLineLength! !!Preferences class methodsFor: 'parameters' stamp: 'sw 1/27/2000 23:02'!parameterAt: aKey	^ Parameters at: aKey ifAbsent: [nil]! !!Preferences class methodsFor: 'parameters' stamp: 'stp 01/13/2000 13:29'!setParameter: paramName to: paramValue	"Set the given field in the parameters dictionary."	Parameters at: paramName put: paramValue! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 1/19/2000 13:52'!disable: preferenceNameSymbol	"Shorthand access"	self setPreference: preferenceNameSymbol toValue: false.	self resetCategoryInfo "in case this call introduced a new pref"! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'jm 5/23/2003 12:44'!doesNotUnderstand: aMessage	"If the given message is unary, look up it's selector as a flag."	aMessage arguments size > 0 ifTrue: [^ super doesNotUnderstand: aMessage].	^ self valueOfFlag: aMessage selector! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 1/19/2000 13:53'!enable: preferenceNameSymbol	"Shorthand access"	self setPreference: preferenceNameSymbol toValue: true.	self resetCategoryInfo  "in case this call introduced a new pref"! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'jm 10/5/2002 06:54'!noteThatFlag: prefSymbol justChangedTo: aBoolean	"Provides a hook so that a user's toggling of a preference might precipitate some immediate action."	prefSymbol == #roundedWindowCorners ifTrue: [		Smalltalk isMorphic ifTrue: [World fullRepaintNeeded]].	(prefSymbol == #smartUpdating) ifTrue:		[SystemWindow allSubInstancesDo:			[:aWindow | aWindow amendSteppingStatus]].! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'jm 10/16/2002 13:02'!openPreferencesInspector	"Open a window on the current set of preferences choices, allowing the user to view and change their settings. If there is no Morphic in this image, use a dictionary inspector."		Smalltalk hasMorphic		ifFalse:	[FlagDictionary inspectWithLabel: 'Preferences']		ifTrue:	[self openPreferencesControlPanel].! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'jm 5/29/2003 19:28'!orphanedHelpEntries	"Answer a list of all the keys in the help dictionary that are not represented by actual preferences"	"Preferences orphanedHelpEntries"	| allFlags |	allFlags _ self allPreferenceFlagKeys.	^ HelpDictionary keys asArray sort select: [:k | (allFlags includes: k) not]! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'sw 1/13/2000 11:12'!preferencesLackingHelp	^ self allPreferenceFlagKeys select:		[:aKey | (self helpMessageOrNilForPreference: aKey) == nil]"Preferences preferencesLackingHelp"! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'jm 5/29/2003 19:31'!preferencesLackingInitializers	"Preferences preferencesLackingInitializers"	| initializedPrefs |	initializedPrefs _ self allPreferenceInitializationSpecs collect: [:info | info first].	^ self allPreferenceFlagKeys select: [:k | (initializedPrefs includes: k) not]! !!Preferences class methodsFor: 'preferences dictionary' stamp: 'jm 10/5/2002 06:56'!setPreference: prefSymbol toValue: aBoolean	(FlagDictionary at: prefSymbol ifAbsent: [nil]) ~~ aBoolean		ifTrue: [			FlagDictionary at: prefSymbol put: aBoolean.			self noteThatFlag: prefSymbol justChangedTo: aBoolean].! !!Preferences class methodsFor: 'preferences panel' stamp: 'jm 6/5/2003 21:28'!addHaloControlsTo: controlPage	controlPage addTransparentSpacerOfSize: (0 @ 4).	controlPage addMorphBack: self haloThemeRadioButtons.	controlPage addTransparentSpacerOfSize: (0 @ 4).! !!Preferences class methodsFor: 'preferences panel' stamp: 'jm 5/29/2003 19:03'!allPreferenceFlagKeys	"Preferences allPreferenceFlagKeys"	^ FlagDictionary keys asArray sort! !!Preferences class methodsFor: 'preferences panel' stamp: 'jm 6/15/2003 16:43'!defaultBackgroundColor	"The background for the preferences control panel."	^ Color white! !!Preferences class methodsFor: 'preferences panel' stamp: 'jm 5/29/2003 19:02'!factoredCategories	"Preferences factoredCategories"	"CategoryInfo _ nil"	| prefsWithoutInits extraItem |	CategoryInfo ifNil: [CategoryInfo _ self initialCategoryInfo].	((prefsWithoutInits _ self preferencesLackingInitializers) size > 0)		ifTrue: [extraItem _ (Array with: 'uncategorized' with: prefsWithoutInits copy asArray sort)].	^ extraItem		ifNil: [CategoryInfo]		ifNotNil: [CategoryInfo, (Array with: extraItem)]! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 1/13/2000 11:07'!helpMessageForPreference: aSymbol	^ (self helpMessageOrNilForPreference: aSymbol) ifNil:		['No help available for ', aSymbol]! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 1/13/2000 11:07'!helpMessageOrNilForPreference: aSymbol	"If the HelpDictionary has a help message prepared for aSymbol, return it, else return nil"	HelpDictionary ifNil: [self initializeHelpMessages].	^ HelpDictionary at: aSymbol ifAbsent: [nil]! !!Preferences class methodsFor: 'preferences panel' stamp: 'jm 5/29/2003 19:04'!initialCategoryInfo	| categories |	categories _ IdentityDictionary new.	self allPreferenceInitializationSpecs do: [:spec |		spec size > 2 ifTrue: [			spec third do: [:sym | 				(categories includesKey: sym) ifFalse:					[categories at: sym put: OrderedCollection new].				(categories at: sym) add: spec first]]].	^ categories keys copy asArray sort collect: [:k |		Array with: k with: (categories at: k) copy asArray sort]! !!Preferences class methodsFor: 'preferences panel' stamp: 'jm 12/7/2002 18:10'!openPreferencesControlPanel	"Preferences openPreferencesControlPanel"	| panels panelColor panel prefsPanel window |	panels _ Dictionary new.	panelColor _ Color r: 0.645 g: 1.0 b: 1.0.	self factoredCategories do: [:entry |			panel _ (AlignmentMorph newColumn isSticky: true) color: panelColor.			panel borderColor: panelColor; inset: 4.			entry second do: [:pref |				panel addMorphBack: (Preferences buttonRepresenting: pref wording: pref color: nil)].			entry first == #halos ifTrue: [self addHaloControlsTo: panel].			panels at: entry first put: panel].	prefsPanel _ CategorizedControlPanel new panels: panels.	prefsPanel currentCategory: 'general'.	prefsPanel extent: 194@212.	Smalltalk isMorphic		ifTrue: [			window _ (SystemWindow labelled: 'Preferences') model: nil.			window bounds: (0@0 extent: 220@270).			window addMorph: prefsPanel frame: (0@0 extent: 1@1).			window updatePaneColors.			window setProperty: #minimumExtent toValue: 220@270.			self currentHand attachMorph: window.			self currentWorld startSteppingSubmorphsOf: window]		ifFalse: [			(window _ MVCWiWPasteUpMorph newWorldForProject: nil) addMorph: prefsPanel.			window startSteppingSubmorphsOf: prefsPanel.			MorphWorldView openOn: window label: 'Preferences' extent: prefsPanel extent + 2].! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 1/19/2000 13:43'!resetCategoryInfo	"Preferences resetCategoryInfo"	CategoryInfo _ nil! !!Preferences class methodsFor: 'preferences panel' stamp: 'sw 11/11/1998 16:39'!setHelpFor: prefName toString: aString	HelpDictionary ifNil: [self initializeHelpMessages].	HelpDictionary at: prefName put: aString! !!Preferences class methodsFor: 'menu parameters' stamp: 'di 1/14/1999 20:16'!menuBorderColor	Display depth <= 2 ifTrue: [^ Color black].	^ Parameters at: #menuBorderColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:16'!menuBorderWidth	^ Parameters at: #menuBorderWidth! !!Preferences class methodsFor: 'menu parameters' stamp: 'di 1/14/1999 20:17'!menuColor	Display depth <= 2 ifTrue: [^ Color white].	^ Parameters at: #menuColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:37'!menuLineLowerColor	^ Parameters at: #menuLineLowerColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:36'!menuLineUpperColor	^ Parameters at: #menuLineUpperColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'di 1/14/1999 20:19'!menuTitleBorderColor	Display depth <= 2 ifTrue: [^ Color black].	^ Parameters at: #menuTitleBorderColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:16'!menuTitleBorderWidth	^ Parameters at: #menuTitleBorderWidth! !!Preferences class methodsFor: 'menu parameters' stamp: 'di 1/14/1999 20:18'!menuTitleColor	Display depth = 1 ifTrue: [^ Color white].	Display depth = 2 ifTrue: [^ Color gray].	^ Parameters at: #menuTitleColor! !!Preferences class methodsFor: 'menu parameters' stamp: 'sw 11/3/1998 11:33'!restoreDefaultMenuParameters	"Preferences restoreDefaultMenuParameters"	"Restore the four color choices of the original implementors of MorphicMenus"	Parameters at: #menuColor put: (Color r: 0.8 g: 0.8 b: 0.8).	Parameters at: #menuBorderColor put: #raised.	Parameters at: #menuBorderWidth put: 2.	Parameters at: #menuTitleColor put: (Color r: 0.5 g: 1 b: 0.75).	Parameters at: #menuTitleBorderColor put: #inset.	Parameters at: #menuTitleBorderWidth put: 1.	Parameters at: #menuLineUpperColor put: (Color r: 0.667 g: 0.667 b: 0.667).	Parameters at: #menuLineLowerColor put: (Color r: 0.833 g: 0.833 b: 0.833).! !!Preferences class methodsFor: 'hard-coded prefs' stamp: 'jm 10/4/2002 15:02'!browseToolClass	^ Browser! !!Preferences class methodsFor: 'hard-coded prefs' stamp: 'programmatic 7/15/1999 09:55'!cmdGesturesEnabled	"compiled programatically -- return hard-coded preference value"	^ true! !!Preferences class methodsFor: 'hard-coded prefs' stamp: 'programmatic 7/15/1999 09:55'!cmdKeysInText	"compiled programatically -- return hard-coded preference value"	^ true! !!Preferences class methodsFor: 'pref buttons' stamp: 'jm 6/15/2003 11:52'!buttonRepresenting: prefSymbol wording: aString color: aColor	"self currentHand attachMorph: (Preferences buttonRepresenting: #balloonHelpEnabled wording: 'Balloon Help' color: nil)"	"Return a button that controls the setting of prefSymbol.  It will keep up to date even if the preference value is changed in a different place"	| outerButton aButton str aHelp miniWrapper |	(FlagDictionary includesKey: prefSymbol) ifFalse: [self error: 'Unknown preference: ', prefSymbol printString].	outerButton _ AlignmentMorph newRow height: 24.	outerButton color:  (aColor ifNil: [Color r: 0.645 g: 1.0 b: 1.0]).	outerButton hResizing: #spaceFill; vResizing: #shrinkWrap.	outerButton addMorph: (aButton _ ThreePhaseButtonMorph checkBox).	aButton		target: self;		actionSelector: #togglePreference:;		arguments: (Array with: prefSymbol);		target: Preferences;		getSelector: prefSymbol.	outerButton addTransparentSpacerOfSize: (2 @ 0).	str _ StringMorph contents: aString font: (StrikeFont familyName: 'NewYork' size: 12).	miniWrapper _ AlignmentMorph newRow hResizing: #shrinkWrap; vResizing: #shrinkWrap.	miniWrapper color: Color transparent.	miniWrapper addMorphBack: str lock.	outerButton addMorphBack: miniWrapper.	aButton setBalloonText: (aHelp _ Preferences helpMessageForPreference: prefSymbol).	miniWrapper setBalloonText: aHelp; setProperty: #balloonTarget toValue: aButton.	^ outerButton! !!Preferences class methodsFor: 'pref buttons' stamp: 'sw 7/13/1999 18:55'!togglePreference: prefSymbol	| curr |	curr _ (FlagDictionary at: prefSymbol ifAbsent: [^ self error: 'unknown pref: ', prefSymbol printString]).	self setPreference: prefSymbol toValue: (curr == true) not! !!Preferences class methodsFor: 'misc' stamp: 'sw 10/6/1999 15:20'!addModelItemsToWindowMenu: aMenu	aMenu addLine.	aMenu add: 'restore default preference settings' target: self action: #chooseInitialSettings.	aMenu add: 'restore default text highlighting' target: self action: #initializeTextHighlightingParameters! !!Preferences class methodsFor: 'misc' stamp: 'sw 7/13/1999 16:52'!menuColorString	^ (self valueOfFlag: #menuColorFromWorld)		ifFalse:			['start menu-color-from-world']		ifTrue:			['stop menu-color-from-world']! !!Preferences class methodsFor: 'misc' stamp: 'sw 11/30/1999 22:23'!roundedCornersString	^ ((self valueOfFlag: #roundedWindowCorners)		ifFalse:			['start']		ifTrue:			['stop']), ' rounding window corners'! !!Preferences class methodsFor: 'misc' stamp: 'sw 6/11/1999 20:53'!staggerPolicyString	^ (self valueOfFlag: #reverseWindowStagger)		ifTrue: ['switch to tiling']		ifFalse: ['switch to staggering']! !!Preferences class methodsFor: 'misc' stamp: 'sw 7/13/1999 16:51'!toggleMenuColorPolicy	self togglePreference: #menuColorFromWorld! !!Preferences class methodsFor: 'misc' stamp: 'sw 7/13/1999 16:52'!toggleRoundedCorners	self togglePreference: #roundedWindowCorners! !!Preferences class methodsFor: 'misc' stamp: 'sw 6/11/1999 20:49'!toggleWindowPolicy	self togglePreference: #reverseWindowStagger! !!Preferences class methodsFor: 'personalization' stamp: 'sw 7/1/1999 23:07'!compileHardCodedPref: prefName enable: aBoolean	"Compile a method that returns a simple true or false (depending on the value of aBoolean) when Preferences is sent prefName as a message"	self class compileProgrammatically: (prefName asString, '	"compiled programatically -- return hard-coded preference value"	^ ', aBoolean storeString) classified: 'hard-coded prefs'.	"Preferences compileHardCodedPref: #testing enable: false"! !!Preferences class methodsFor: 'personalization' stamp: 'sw 6/29/1999 13:53'!disableProgrammerFacilities	"Warning: do not call this lightly!!  It disables all access to menus, debuggers, halos.  There is no guaranteed return from this, which is to say, you cannot necessarily reenable these things once they are disabled -- you can only use whatever the UI of the current project affords, and you cannot even snapshot -- you can only quit.      You can completely reverse the work of this method by calling the dual Preferences method enableProgrammerFacilities, provided you have left yourself leeway to bring about a call to that method.	To set up a system that will come up in such a state, you have to request the snapshot in the same breath as you disable the programmer facilities.  To do this, put the following line into the 'do' menu and then evaluate it from that 'do' menu:         Preferences disableProgrammerFacilities.You will be prompted for a new image name under which to save the resulting image."	self beep.	(self confirm: 'CAUTION!!!!This is a drastic step!!Do you really want to do this?')		ifFalse:			[self beep.  ^ self inform: 'whew!!'].	self disable: #cmdDotEnabled.       "No user-interrupt-into-debugger"	self compileHardCodedPref: #cmdGesturesEnabled enable: false.  "No halos, etc."	self compileHardCodedPref: #cmdKeysInText enable: false.    "No user commands invokable via cmd-key combos in text editor"	self enable: #noviceMode.           "No control-menu"	self disable: #warnIfNoSourcesFile.	self disable: #warnIfNoChangesFile.	Smalltalk saveAs! !!Preferences class methodsFor: 'personalization' stamp: 'sw 6/29/1999 13:55'!enableProgrammerFacilities	"Meant as a one-touch recovery from a #disableProgrammerFacilities call."	"Preferences enableProgrammerFacilities"	self enable: #cmdDotEnabled.	self compileHardCodedPref: #cmdGesturesEnabled enable: true. 	self compileHardCodedPref: #cmdKeysInText enable: true.	self disable: #noviceMode.	self enable: #warnIfNoSourcesFile.	self enable: #warnIfNoChangesFile.! !!Preferences class methodsFor: 'help' stamp: 'jm 10/16/2002 12:33'!helpMsgsAThroughF	"This, and the other methodds in this category, are automatically called whenever you call:   		Preferences initializeHelpMessages	or		Preferences callHelpMessageInitializers"	^ #( 		(annotationPanes			'If true, a thin horizontal annotation pane is used in browsers.')		(balloonHelpEnabled			'Whether balloon help should be offered when the cursor lingers over certain objects.')		(browseWithPrettyPrint			'If true, browsers will automatically format their contents')		(cautionBeforeClosing 			'If true, Morphic windows seen in an mvc project will put up a warning before allowing themselves to be dismissed')		(caseSensitiveFinds			'If true, then the "find" command in text will always make its searches in a case-sensitive fashion')		(changeSetVersionNumbers			'If true, version-number extensions will be used when constructing names for change-set fileouts.  If false, timestamp extensions are used.')		(checkForSlips 			'If true, then whenever you file out a change set, it is checked for ''slips'' and if any are found, you are so informed and given a chance to open a browser on them')		(clickOnLabelToEdit			'If true, a click on the label of a system window lets you edit it; if false, allow dragging of system windows when clicking on the label')		(cmdDotEnabled			'If true, cmd-dot brings up a debugger;		if false, the cmd-dot interrupt is disabled')		(colorWhenPrettyPrinting			'If true, then when browseWithPrettyPrint is in effect, the pretty-printing will be presented in color')		(confirmFirstUseOfStyle			'If true, the first attempt to submit a method with non-standard style will bring up a confirmation dialog')		(debugHaloHandle 			'If true, a special debugging halo handle is displayed at the right of the halo; if false, no such handle is shown.')		(diffsInChangeList			'If true, changeList browsers and Versions browsers will open up by default showing diffs, i.e. revealing the differences between successive versions or between the in-memory code and the code on disk')		(fastDragWindowForMorphic			'If true, morphic window drag will be done by dragging an outline of the window.')	)  "end of list"! !!Preferences class methodsFor: 'help' stamp: 'sw 2/15/2000 18:39'!helpMsgsAdditionA	"This, and the other methodds in this category, are automatically called whenever you call   	Preferences initializeHelpMessages		or	Preferences callHelpMessageInitializers"	^ #( (simpleMenus	'If true, simpler menus are presented.'))	"Preferences resetCategoryInfo"! !!Preferences class methodsFor: 'help' stamp: 'programmatic 5/10/2000 15:45'!helpMsgsAdditionbrowsingalternativeBrowseIt	^ #((alternativeBrowseIt 'if true, then the "browse it" (cmd-b) feature in the text editor will offer you a list of class names matching the selection, if appropriate' ) )! !!Preferences class methodsFor: 'help'!helpMsgsAdditionscrollinghiddenScrollBars	^ #((hiddenScrollBars 'If true, then scrollbars will only be shown if a pane''s contents are too large to fit inside the pane.' ) )! !!Preferences class methodsFor: 'help' stamp: 'jm 10/16/2002 12:52'!helpMsgsGThroughP		^ #((ignoreStyleIfOnlyBold	'If true, then any method submission in which the only style change is for bolding will be treated as a method with no style specifications')(inboardScrollbars	'If true, then ScrollPane will place scrollbars inside on the right and will not hide them on exit')(logDebuggerStackToFile	'If true, whenever you fall into a debugger a summary of its stack will be written to a file named''SqueakDebug.log''')(menuColorFromWorld	'Governs whether the colors used in morphic menus should be derived from the color of the world background')(mvcProjectsAllowed	'If true, the open... menu will offer you the chance to open an mvc project')(noviceMode 	'If true, certain novice-mode accommodations are made')(optionalButtons	'If true, then optional buttons will be used in certain standard tools, including browsers, message lists, fileLists, changeLists, and debuggers')(printAlternateSyntax	'If true, thenprettyPrint using experimental syntax.Otherwise use normal ST-80 syntax')(projectZoom	'If true, then show a zoom effect when entering or leaving projects. This can be costly of memory (at least an extra screen buffer) so dont use it in low space situations. But it is cool')(promptForUpdateServer	'If false, the prompt for server choice when updating code from the server is suppressed. Set this to false to leave the server choice unchanged from update to update')	)! !!Preferences class methodsFor: 'help' stamp: 'jm 12/9/2003 17:03'!helpMsgsQThroughZ	^ #(		(reverseWindowStagger			'If true, a reverse-stagger strategy  is used for determining where newly launched windows will be placed; if false, a direct- stagger strategy is used.')		(roundedMenuCorners			'Whether morphic menus should have rounded corners')		(roundedWindowCorners			'Governs whether morphic system windows should have rounded corners')		(scrollBarsNarrow			'If true, morphic scrollbars will be narrow.')		(scrollBarsOnRight			'If true, morphic scrollbars in subsequently opened windows will appear on the right side of their pane.')		(scrollBarsWithoutMenuButton			'If true, morphic scrollbars in subsequently opened windows will not include a menu button.')		(smartUpdating			'If true, then morphic tools such as browsers and inspectors will keep their contents up to date automatically, so that if something changes anywhere, the change will be reflected everywhere.')		(soundQuickStart			'If true, attempt to start playing sounds using optional "quick start"')		(soundsEnabled			'If false, all sound playing is disabled')		(systemWindowEmbedOK			'Determines whether, in Morphic, when a SystemWindow is dropped onto a willing receptor it should be deposited into that receptor.')		(timeStampsInMenuTitles			'If true, then the author''s timestamp is displayed as the menu title of any message list; if false, no author''s timestamps are shown')		(thoroughSenders			'If true, then ''senders'' browsers will dive inside structured literals in their search')		(twentyFourHourFileStamps			'If #changeSetVersionNumbers is false, this preference determines whether the date/time suffix used with changeset fileouts is based on a 24-hr clock or a 12-hr clock.')		(uniformWindowColors			'If true, then all standard windows are given the same color rather than their customized window-type-specific colors')		(warnIfNoChangesFile			'If true, then you will be warned, whenever you start up, if no changes filecan be found')		(warnIfNoSourcesFile 			'If true, then you will be warned, whenever you start up, if no sources file can be found')	)! !!Preferences class methodsFor: 'help' stamp: 'sw 5/9/2000 03:12'!moreHelpA	^ #(	(systemWindowEmbedOK	'Determines whether, in Morphic, when a SystemWindow or MenuMorph is dropped onto a willing receptor, it should be deposited into that receptor.')			) ! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 5/10/2000 15:45'!alternativeBrowseIt	^ self valueOfFlag: #alternativeBrowseIt! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 1/13/2000 10:57'!annotationPanes	^ self valueOfFlag: #annotationPanes! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 10/16/2002 13:04'!autoAccessors	^ self valueOfFlag: #autoAccessors! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 16:26'!balloonHelpEnabled	^ self valueOfFlag: #balloonHelpEnabled! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 16:26'!browseWithPrettyPrint	^ self valueOfFlag: #browseWithPrettyPrint! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 10/16/2002 13:04'!browserShowsPackagePane	^ self valueOfFlag: #browserShowsPackagePane! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 10/1/1999 20:55'!caseSensitiveFinds	^ self valueOfFlag: #caseSensitiveFinds! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 1/13/2000 10:57'!cautionBeforeClosing	^ self valueOfFlag: #cautionBeforeClosing! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 11/13/1999 22:52'!changeSetVersionNumbers	^ self valueOfFlag: #changeSetVersionNumbers! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 1/13/2000 12:21'!checkForSlips	^ self valueOfFlag: #checkForSlips! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 1/13/2000 10:57'!clickOnLabelToEdit	^ self valueOfFlag: #clickOnLabelToEdit! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 16:26'!cmdDotEnabled	^ self valueOfFlag: #cmdDotEnabled! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 11/6/1999 22:54'!colorWhenPrettyPrinting	^ self valueOfFlag: #colorWhenPrettyPrinting! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 10/16/2002 13:04'!compressFlashImages	^ self valueOfFlag: #compressFlashImages! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 16:27'!confirmFirstUseOfStyle	^ self valueOfFlag: #confirmFirstUseOfStyle! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 10/16/2002 13:04'!conversionMethodsAtFileOut	^ self valueOfFlag: #conversionMethodsAtFileOut! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 1/13/2000 10:57'!debugHaloHandle	^ self valueOfFlag: #debugHaloHandle! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 1/13/2000 10:57'!diffsInChangeList	^ self valueOfFlag: #diffsInChangeList! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 16:27'!extractFlashInHighQuality	^ self valueOfFlag: #extractFlashInHighQuality! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 16:27'!extractFlashInHighestQuality	^ self valueOfFlag: #extractFlashInHighestQuality! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 16:27'!fastDragWindowForMorphic	^ self valueOfFlag: #fastDragWindowForMorphic! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 6/1/2000 16:56'!hiddenScrollBars	^ self valueOfFlag: #hiddenScrollBars! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 16:28'!ignoreStyleIfOnlyBold	^ self valueOfFlag: #ignoreStyleIfOnlyBold! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 16:28'!inboardScrollbars	^ self valueOfFlag: #inboardScrollbars! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 16:28'!logDebuggerStackToFile	^ self valueOfFlag: #logDebuggerStackToFile! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 7/1/1999 22:32'!menuColorFromWorld	^ self valueOfFlag: #menuColorFromWorld! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 7/1/1999 23:28'!mouseOverHaloseEnabled	^ self valueOfFlag: #mouseOverHaloseEnabled! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 1/13/2000 10:57'!mvcProjectsAllowed	^ self valueOfFlag: #mvcProjectsAllowed! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 16:28'!noviceMode	^ self valueOfFlag: #noviceMode! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 12/13/1999 10:51'!optionalButtons	^ self valueOfFlag: #optionalButtons! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 20:50'!printAlternateSyntax	^ self valueOfFlag: #printAlternateSyntax! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 1/13/2000 10:57'!projectZoom	^ self valueOfFlag: #projectZoom! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 1/13/2000 10:57'!promptForUpdateServer	^ self valueOfFlag: #promptForUpdateServer! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 16:28'!reverseWindowStagger	^ self valueOfFlag: #reverseWindowStagger! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 11/26/1999 11:42'!roundedMenuCorners	^ self valueOfFlag: #roundedMenuCorners! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 7/1/1999 22:32'!roundedWindowCorners	^ self valueOfFlag: #roundedWindowCorners! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 1/13/2000 10:57'!scrollBarsNarrow	^ self valueOfFlag: #scrollBarsNarrow! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 1/13/2000 10:57'!scrollBarsOnRight	^ self valueOfFlag: #scrollBarsOnRight! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 1/13/2000 10:57'!scrollBarsWithoutMenuButton	^ self valueOfFlag: #scrollBarsWithoutMenuButton! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 2/15/2000 18:46'!simpleMenus	^ self valueOfFlag: #simpleMenus! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 10/20/1999 12:22'!smartUpdating	^ self valueOfFlag: #smartUpdating! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 1/13/2000 10:57'!soundQuickStart	^ self valueOfFlag: #soundQuickStart! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 1/12/2000 22:40'!soundsEnabled	^ self valueOfFlag: #soundsEnabled! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 1/13/2000 10:57'!systemWindowEmbedOK	^ self valueOfFlag: #systemWindowEmbedOK! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 16:29'!thoroughSenders	^ self valueOfFlag: #thoroughSenders! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 1/13/2000 12:21'!timeStampsInMenuTitles	^ self valueOfFlag: #timeStampsInMenuTitles! !!Preferences class methodsFor: 'standard preferences' stamp: 'programmatic 11/13/1999 22:52'!twentyFourHourFileStamps	^ self valueOfFlag: #twentyFourHourFileStamps! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 1/12/2000 22:56'!useAnnotationPanes	"Because of so any senders, this wording retained here though we defer to the renamed flag"	^ self valueOfFlag: #annotationPanes! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 16:30'!warnIfNoChangesFile	^ self valueOfFlag: #warnIfNoChangesFile! !!Preferences class methodsFor: 'standard preferences' stamp: 'sw 6/28/1999 16:30'!warnIfNoSourcesFile	^ self valueOfFlag: #warnIfNoSourcesFile! !!Preferences class methodsFor: 'initial values' stamp: 'jm 10/16/2002 12:29'!initialValuesAToM	"CategoryInfo _ nil"	"Preferences openFactoredPanel"	^#(		(annotationPanes					false	(browsing))		(autoAccessors						false	(general))		(balloonHelpEnabled					true	(morphic))		(browserShowsPackagePane			false	(browsing))		(browseWithPrettyPrint				false	(browsing))		(caseSensitiveFinds					false	(general))		(cautionBeforeClosing				false	(windows))		(changeSetVersionNumbers			true	(fileout))		(checkForSlips						true	(fileout))		(clickOnLabelToEdit					true	(windows))		(cmdDotEnabled						true	(debug))		(colorWhenPrettyPrinting			false	(browsing))		(compressFlashImages				false	(media))		(confirmFirstUseOfStyle				true	(browsing))		(conversionMethodsAtFileOut			false	(fileout))		(debugHaloHandle					true	(debug halos))		(diffsInChangeList					true	(browsing))		(extractFlashInHighQuality			true	(media))		(extractFlashInHighestQuality		false	(media))		(fastDragWindowForMorphic			false	(windows))		(ignoreStyleIfOnlyBold				true	(browsing))		(inboardScrollbars					false	(scrolling))		(logDebuggerStackToFile				true	(debug))		(menuColorFromWorld				false	(menus))		(mvcProjectsAllowed					false	(general)))! !!Preferences class methodsFor: 'initial values' stamp: 'sw 2/15/2000 18:37'!initialValuesAdditionA	"Another lot of initial values for prefs.  Simply placing methods of this sort in the 'initial values' category will assure that the initial values provided are ascribed to the preference when prefs are initialized"	^ #(			(simpleMenus						false	(menus)))	"Preferences resetCategoryInfo"! !!Preferences class methodsFor: 'initial values' stamp: 'programmatic 5/10/2000 15:45'!initialValuesAdditionbrowsingalternativeBrowseIt	^ #((alternativeBrowseIt false (browsing ) ) )! !!Preferences class methodsFor: 'initial values'!initialValuesAdditionscrollinghiddenScrollBars	^ #((hiddenScrollBars false (scrolling ) ) )! !!Preferences class methodsFor: 'initial values' stamp: 'jm 12/9/2003 17:08'!initialValuesNToZ	"Another lot of initial values for prefs. Simply placing methods of this sort in the 'initial values' category will assure that the initial values provided are ascribed to the preference when prefs are initialized."	"Preferences resetCategoryInfo"	^ #(			(noviceMode							false	(general))		(optionalButtons						false	(general))		(printAlternateSyntax				false	(browsing))		(projectZoom							false	(general))		(promptForUpdateServer				true	(updates))		(reverseWindowStagger				true	(windows))		(roundedMenuCorners				true	(menus))		(roundedWindowCorners				false	(windows))		(scrollBarsNarrow					false	(scrolling))		(scrollBarsOnRight					false	(scrolling))		(scrollBarsWithoutMenuButton		false	(menus scrolling))		(smartUpdating						true	(browsing))		(soundsEnabled						false	(media))		(soundQuickStart					false	(media))		(systemWindowEmbedOK				false	(windows))		(thoroughSenders					true	(general))		(timeStampsInMenuTitles				false	(menus))		(twentyFourHourFileStamps			true	(fileout)) 		(warnIfNoChangesFile				true	(general))		(warnIfNoSourcesFile				true	(general))	)! !!Preferences class methodsFor: 'window colors' stamp: 'sw 7/12/1999 17:41'!installBrightWindowColors	"Preferences installBrightWindowColors"	| windowColorDict |	(Parameters includesKey: #windowColors) ifFalse:		[Parameters at: #windowColors put: IdentityDictionary new].	windowColorDict _ Parameters at: #windowColors.	#(	(Browser				lightGreen)		(ChangeList				lightBlue)		(ChangeSorter			lightBlue)		(Debugger				lightRed)		(DualChangeSorter		lightBlue)		(FileContentsBrowser		tan)		(FileList					lightMagenta)		(MessageSet				lightBlue)		(Object					white)		(SelectorBrowser			lightCyan)		(StringHolder			lightYellow)		(TranscriptStream		lightOrange))	do:			[:pair |				windowColorDict at: pair first put: (Color perform: pair last)]! !!Preferences class methodsFor: 'window colors' stamp: 'sw 7/12/1999 17:41'!installPastelWindowColors	"Preferences installPastelWindowColors"	| windowColorDict |	(Parameters includesKey: #windowColors) ifFalse:		[Parameters at: #windowColors put: IdentityDictionary new].	windowColorDict _ Parameters at: #windowColors.	#(	(Browser				paleGreen)		(ChangeList				paleBlue)		(ChangeSorter			paleBlue)		(Debugger				veryPaleRed)		(DualChangeSorter		paleBlue)		(FileContentsBrowser		paleTan)		(FileList					paleMagenta)		(MessageSet				paleBlue)		(Object					white)		(SelectorBrowser			palePeach)		(StringHolder			paleYellow)		(TranscriptStream		paleOrange))	do:			[:pair |				windowColorDict at: pair first put: (Color perform: pair last)]! !!Preferences class methodsFor: 'window colors' stamp: 'sw 7/13/1999 15:12'!installUniformWindowColors	"Preferences installUniformWindowColors"	| windowColorDict |	(Parameters includesKey: #windowColors) ifFalse:		[Parameters at: #windowColors put: IdentityDictionary new].	windowColorDict _ Parameters at: #windowColors.	#(	(Browser				white)		(ChangeList				white)		(ChangeSorter			white)		(Debugger				white)		(DualChangeSorter		white)		(FileContentsBrowser		white)		(FileList					white)		(MessageSet				white)		(Object					white)		(SelectorBrowser			white)		(StringHolder			white)		(TranscriptStream		white))	do:			[:pair |				windowColorDict at: pair first put: (Color perform: pair last)]! !!Preferences class methodsFor: 'window colors' stamp: 'sw 10/27/1999 11:34'!setWindowColorFor: modelSymbol to: incomingColor	| aColor |	(Parameters includesKey: #windowColors) ifFalse:		[Parameters at: #windowColors put: IdentityDictionary new.		self installBrightWindowColors].	aColor _ incomingColor asNontranslucentColor.	(aColor = ColorPickerMorph perniciousBorderColor or: [aColor = Color black]) ifTrue: [^ self].	^ (Parameters at: #windowColors) at: modelSymbol put: aColor	! !!Preferences class methodsFor: 'window colors' stamp: 'jm 5/31/2003 16:44'!windowColorClasses	^ #(Browser	 ChangeList ChangeSorter Debugger DualChangeSorter FileContentsBrowser FileList	MessageSet StringHolder TranscriptStream)! !!Preferences class methodsFor: 'window colors' stamp: 'sw 7/13/1999 16:03'!windowColorFor: aModelClassName	| classToCheck windowColors |	(Parameters includesKey: #windowColors) ifFalse:		[Parameters at: #windowColors put: IdentityDictionary new.		self installBrightWindowColors].	classToCheck _ Smalltalk at: aModelClassName.	windowColors _ Parameters at: #windowColors.	[windowColors includesKey: classToCheck name]		whileFalse:			[classToCheck _ classToCheck superclass].	^ windowColors at: classToCheck name ifAbsent: [Color white]	! !!Preferences class methodsFor: 'window colors' stamp: 'sw 7/13/1999 20:10'!windowColorHelp	"The 'Window Colors' panel lets you select colors for the standard Squeak windows.The three buttons entitled 'Bright', 'Pastel', and 'White' let you install three different standard color schemes.The rows of color swatches and tool names indicate what the color for each tool is currently set to be.  You can change the color for any tool by clicking on its swatch, then choosing a new color in the ensuing color-picker.'TranscriptStream' governs the color of Transcripts.'MessageSet' governs the color of message-list browsers.'ChangeList' governs the color of change-list browsers *and* versions browsers.'StringHolder' governs the color of Workspaces.Any time you request a new window (browser, file-list, etc.), the current window-color setting for that kind of window will determine what color is used.But note that if in Morphic, the 'Tools' flap and the 'Standard Parts Bin' both contain pre-allocated window prototypes, and these will not automatically change when you edit the standard window colors.  To get the Tools flap to reflect your latest color choices, hit the 'Update Tools Flap' button.  To get the standard parts bin to reflect your latest color choices, evaluate 'ScriptingSystem resetStandardPartsBin'"	(StringHolder new contents: (self class firstCommentAt: #windowColorHelp))		openLabel: 'About Window Colors'	"Preferences windowColorHelp"! !!Preferences class methodsFor: 'window colors' stamp: 'jm 6/15/2003 12:48'!windowSpecificationPanel	"Preferences windowSpecificationPanel"	| aPanel buttonRow aButton aRow aSwatch aColor aWindow aMiniWorld |	aPanel _ AlignmentMorph newColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap.	aPanel addMorph: (buttonRow _ AlignmentMorph newRow color: (aColor _ Color tan lighter)).		aButton _ SimpleButtonMorph new target: self.	buttonRow addTransparentSpacerOfSize: 2@0.	buttonRow addMorphBack: (SimpleButtonMorph new label: '?'; target: self; actionSelector: #windowColorHelp; setBalloonText: 'Click for an explanation of this panel'; color: Color veryVeryLightGray; yourself).	buttonRow addTransparentSpacerOfSize: 8@0.	#(	('Bright' 	installBrightWindowColors	yellow			'Use standard bright colors for all windows.')		('Pastel'		installPastelWindowColors	paleMagenta			'Use standard pastel colors for all windows.')		('White'	installUniformWindowColors		white			'Use white backgrounds for all standard windows.')	) do: [:quad |			aButton _ aButton fullCopy				label: quad first;				actionSelector: quad second;				color: (Color colorFrom: quad third);				setBalloonText: quad fourth;				yourself.			buttonRow addMorphBack: aButton.			buttonRow addTransparentSpacerOfSize: 10@0].	self windowColorClasses do: [:clName | 			aRow _ AlignmentMorph newRow color: aColor.			aSwatch _ UpdatingRectangleMorph new				target: self;				getSelector: #windowColorFor:;				putSelector: #setWindowColorFor:to:;				argument: clName;				extent: (40 @ 20);				yourself.			aRow addMorphFront: aSwatch.			aRow addTransparentSpacerOfSize: (12 @ 1).			aRow addMorphBack:				(StringMorph contents: clName font: TextStyle defaultFont).			aPanel addMorphBack: aRow].	 Smalltalk isMorphic			ifTrue: [					aWindow _ aPanel wrappedInWindowWithTitle: 'Window Colors'.					self currentHand attachMorph: aWindow.					aWindow world startSteppingSubmorphsOf: aPanel.]			ifFalse: [					(aMiniWorld _ MVCWiWPasteUpMorph newWorldForProject: nil)						addMorph: aPanel.					aMiniWorld startSteppingSubmorphsOf: aPanel.					MorphWorldView openOn: aMiniWorld						label: 'Window Colors'						extent: aMiniWorld fullBounds extent].! !!Preferences class methodsFor: 'text highlighting' stamp: 'sw 9/7/1999 13:00'!chooseInsertionPointColor	ColorPickerMorph new		sourceHand: self currentHand;		target: self;		selector: #insertionPointColor:;		originalColor: self insertionPointColor;		addToWorld: self currentWorld			near: self currentHand cursorBounds! !!Preferences class methodsFor: 'text highlighting' stamp: 'sw 9/7/1999 12:57'!chooseTextHighlightColor	ColorPickerMorph new		sourceHand: self currentHand;		target: self;		selector: #textHighlightColor:;		originalColor: self textHighlightColor;		addToWorld: self currentWorld			near: self currentHand cursorBounds! !!Preferences class methodsFor: 'text highlighting' stamp: 'sw 9/7/1999 13:07'!initializeTextHighlightingParameters	"Preferences initializeTextHighlightingParameters"	Parameters at: #insertionPointColor put: (Color r: 0.4 g: 1.0 b: 0).	Parameters at: #textHighlightColor put: (Color r: 0.4 g: 1.0 b: 0).! !!Preferences class methodsFor: 'text highlighting' stamp: 'sw 9/7/1999 12:53'!insertionPointColor	^ Parameters at: #insertionPointColor! !!Preferences class methodsFor: 'text highlighting' stamp: 'sw 9/7/1999 12:54'!insertionPointColor: aColor	Parameters at: #insertionPointColor put: aColor! !!Preferences class methodsFor: 'text highlighting' stamp: 'sw 9/7/1999 12:53'!textHighlightColor	^ Parameters at: #textHighlightColor! !!Preferences class methodsFor: 'text highlighting' stamp: 'sw 9/7/1999 12:54'!textHighlightColor: aColor	Parameters at: #textHighlightColor put: aColor! !!Preferences class methodsFor: 'pretty-printing' stamp: 'jm 10/16/2002 13:09'!initializeSyntaxColorsAndStyles	"To change the color choices, you can simply edit this method, and then evaluate the following line:		Preferences initializeSyntaxColorsAndStyles	Later, people may wish to produce interactive editors for modifying the choices"	| specs |	SyntaxColorsAndStyles _ IdentityDictionary new.	# (	(temporaryVariable		(magenta		bold))		(methodArgument		(magenta		italic))		(blockArgument			(magenta		italic))		(comment				(red				normal))		(variable				(blue			bold))		(literal					(brown			normal))		(keyword				(black	 		normal)))	do: [:nameAndSpecs |		specs _ nameAndSpecs second.		SyntaxColorsAndStyles at: nameAndSpecs first put:			(SyntaxAttribute color: (Color perform: specs first) emphasis: specs last)].! !!Preferences class methodsFor: 'pretty-printing' stamp: 'jm 10/16/2002 13:10'!syntaxAttributesFor: aPartSymbol	SyntaxColorsAndStyles ifNil: [self initializeSyntaxColorsAndStyles].	^ (SyntaxColorsAndStyles at: aPartSymbol ifAbsent: [^ #()]) attributeList! !!Preferences class methodsFor: 'fonts' stamp: 'jm 6/9/2003 22:11'!chooseFontWithPrompt: aPrompt andSendTo: aReceiver withSelector: aSelector	Smalltalk isMorphic		ifFalse: [self mvcPromptForFont: aPrompt andSendTo: aReceiver withSelector: aSelector]		ifTrue: [self promptForFont: aPrompt andSendTo: aReceiver withSelector: aSelector].! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/8/1999 17:30'!chooseListFont	self chooseFontWithPrompt: 'standard list font' andSendTo: self withSelector: #setListFontTo:! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/8/1999 17:30'!chooseMenuFont	self chooseFontWithPrompt: 'standard menu font' andSendTo: self withSelector: #setMenuFontTo:! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/10/1999 11:34'!chooseSystemFont	self chooseFontWithPrompt: 'Default text font' andSendTo: self withSelector: #setSystemFontTo:! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/8/1999 18:39'!chooseWindowTitleFont	self chooseFontWithPrompt: 'window title font' andSendTo: self withSelector: #setWindowTitleFontTo:! !!Preferences class methodsFor: 'fonts' stamp: 'jm 10/5/2002 07:10'!fontConfigurationMenu	| aMenu |	aMenu _ MenuMorph new defaultTarget: Preferences.	aMenu addTitle: 'Standard System Fonts'.	aMenu add: 'default text font...' action: #chooseSystemFont.	aMenu balloonTextForLastItem: 'Choose the default font to be used for code and  in workspaces, transcripts, etc.'.	aMenu lastItem font: TextStyle defaultFont.	aMenu add: 'list font...' action: #chooseListFont.	aMenu lastItem font: Preferences standardListFont.	aMenu balloonTextForLastItem: 'Choose the font to be used in list panes'.	aMenu balloonTextForLastItem: 'Choose the font to be used on textual flap tabs'.	aMenu add: 'menu font...' action: #chooseMenuFont.	aMenu lastItem font: Preferences standardMenuFont.	aMenu balloonTextForLastItem: 'Choose the font to be used in menus'.	aMenu add: 'window-title font...' action: #chooseWindowTitleFont.	aMenu lastItem font: Preferences windowTitleFont emphasis: 1.	aMenu balloonTextForLastItem: 'Choose the font to be used in window titles.'.	aMenu add: 'balloon-help font...' target: BalloonMorph action: #chooseBalloonFont.	aMenu lastItem font: BalloonMorph balloonFont.	aMenu balloonTextForLastItem: 'choose the font to be used when presenting balloon help.'.	"aMenu add: 'code font...' action: #chooseCodeFont.	aMenu lastItem font: Preferences standardCodeFont.	aMenu balloonTextForLastItem: 'Choose the font to be used in code panes.'."	aMenu addLine.	aMenu add: 'restore default font choices' action: #restoreDefaultFonts.	aMenu balloonTextForLastItem: 'Use the standard system font defaults'.	^ aMenu! !!Preferences class methodsFor: 'fonts' stamp: 'jm 6/9/2003 22:20'!fontMenuForStyle: styleName target: target selector: selector 	| menu |	menu _ MenuMorph entitled: styleName. 	(StrikeFont sizesForFamilyName: styleName) do: [:sz |		menu 			add: (sz asString, ' Point') 			target: target 			selector: selector			argument: ((TextStyle named: styleName) fontOfPointSize: sz).		menu lastItem font: ((TextStyle named: styleName) fontOfPointSize: sz)].	^ menu! !!Preferences class methodsFor: 'fonts' stamp: 'jm 6/9/2003 22:13'!mvcPromptForFont: aPrompt andSendTo: aTarget withSelector: aSelector	"self mvcPromptForFont: 'Choose system font style' andSendTo: nil withSelector: #setSystemFontTo:"	| aMenu aChoice aStyle namesAndSizes aFont |	aMenu _ CustomMenu new.	(StrikeFont familyNames copyWithout: 'DefaultTextStyle')		do: [:fName | aMenu add: fName action: fName].	aChoice _ aMenu startUpWithCaption: aPrompt.	aChoice ifNil: [^ self].	aMenu _ CustomMenu new.	aStyle _ TextStyle named: aChoice.	(namesAndSizes _ aStyle fontNamesWithHeights) do:		[:aString | aMenu add: aString action: aString].	aChoice _ aMenu startUpWithCaption: nil.	aChoice ifNil: [^ self].	aFont _ aStyle fontAt: (namesAndSizes indexOf: aChoice).	aTarget perform: aSelector with: aFont.! !!Preferences class methodsFor: 'fonts' stamp: 'jm 10/5/2002 07:10'!presentMvcFontConfigurationMenu	| aMenu result |	aMenu _ CustomMenu new.	aMenu title: 'Standard System Fonts'.	aMenu add: 'default text font...' action: #chooseSystemFont.	aMenu add: 'list font...' action: #chooseListFont.	aMenu add: 'menu font...' action: #chooseMenuFont.	aMenu add: 'window-title font...' action: #chooseWindowTitleFont.	"aMenu add: 'code font...' action: #chooseCodeFont."	aMenu addLine.	aMenu add: 'restore default font choices' action: #restoreDefaultFonts.	(result _ aMenu startUp) ifNotNil:		[self perform: result]! !!Preferences class methodsFor: 'fonts' stamp: 'jm 6/9/2003 22:23'!promptForFont: aPrompt andSendTo: aTarget withSelector: aSelector	"NOTE: Morphic ONLY!!!!. Derived from a method written by Robin Gibson"	"self promptForFont: 'Choose system font:' andSendTo: nil withSelector: #setSystemFontTo:"	| menu subMenu |	menu _ MenuMorph entitled: aPrompt.	(StrikeFont familyNames copyWithout: 'DefaultTextStyle') do: [:styleName |		subMenu _ self fontMenuForStyle: styleName target: aTarget selector: aSelector.		menu add: styleName subMenu: subMenu.		menu lastItem font: ((TextStyle named: styleName) fontOfSize: 18)].	menu popUpForHand: self currentHand.! !!Preferences class methodsFor: 'fonts' stamp: 'jm 6/9/2003 22:12'!restoreDefaultFonts	"Preferences restoreDefaultFonts"	#(	(setButtonFontTo:		ComicBold		16)		(setListFontTo:			NewYork		12)		(setMenuFontTo:			NewYork		12)		(setWindowTitleFontTo:	NewYork		15)		(setSystemFontTo:		NewYork		12)	) do: [:triplet |			self perform: triplet first with: (StrikeFont familyName: triplet second size: triplet third)].	Smalltalk at: #BalloonMorph ifPresent:		[:thatClass | thatClass setBalloonFontTo: (StrikeFont familyName: #ComicPlain size: 12)].	"Note:  The standard button font is reset by this code but is not otherwise settable by a public UI (too many things can go afoul) "! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/8/1999 22:06'!setButtonFontTo: aFont	Parameters at: #standardButtonFont put: aFont! !!Preferences class methodsFor: 'fonts' stamp: 'jm 10/5/2002 06:58'!setListFontTo: aFont	Parameters at: #standardListFont put: aFont.	ListParagraph initialize.! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/8/1999 18:04'!setMenuFontTo: aFont	Parameters at: #standardMenuFont put: aFont.	PopUpMenu setMenuFontTo: aFont! !!Preferences class methodsFor: 'fonts' stamp: 'jm 10/5/2002 06:58'!setSystemFontTo: aFont	"Establish the default text font and style."	| aStyle newDefaultStyle |	aFont ifNil: [^ self].	aStyle _ aFont textStyle ifNil: [^ self].	newDefaultStyle _ aStyle copy.	newDefaultStyle defaultFontIndex: (aStyle fontIndexOf: aFont).	TextConstants at: #DefaultTextStyle put: newDefaultStyle.! !!Preferences class methodsFor: 'fonts' stamp: 'jm 10/5/2002 06:58'!setWindowTitleFontTo: aFont	Parameters at: #windowTitleFont put: aFont.	StandardSystemView setLabelStyle.! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/8/1999 16:13'!standardButtonFont	"Answer an attractive font to use for buttons"	"Answer the font to be used for textual flap tab labels"	^ Parameters at: #standardButtonFont ifAbsent:		[Parameters at: #standardButtonFont put: (StrikeFont familyName: #ComicBold size: 16)]! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/8/1999 16:09'!standardListFont	"Answer the font to be used in lists"	 ^ Parameters at: #standardListFont ifAbsent:		[Parameters at: #standardListFont put: TextStyle defaultFont]! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/8/1999 16:58'!standardMenuFont	"Answer the font to be used in menus"	 ^ Parameters at: #standardMenuFont ifAbsent:		[Parameters at: #standardMenuFont put: TextStyle defaultFont]! !!Preferences class methodsFor: 'fonts' stamp: 'sw 12/8/1999 16:10'!windowTitleFont	"Answer the standard font to use for window titles"	^  Parameters at: #windowTitleFont ifAbsent:		[Parameters at: #windowTitleFont put: (StrikeFont familyName: #NewYork size: 15)]! !!Preferences class methodsFor: 'halos' stamp: 'jm 6/15/2003 12:13'!classicHaloSpecs	"Non-iconic halos with traditional placements"	"Preferences resetHaloSpecifications"  "  <-  will result in the standard default halos being reinstalled"	"NB: listed below in clockwise order"		^ #(	"  	selector				horiz		vert			color info						icon key		---------				------		-----------		-------------------------------		---------------"	(addMenuHandle:		left			top				(red)							none)	(addDismissHandle:		leftCenter	top				(red		muchLighter)			'Halo-Dismiss')	(addGrabHandle:			center		top				(black)							none)	(addDragHandle:			rightCenter	top				(brown)							none)	(addDupHandle:			right		top				(green)							none)		(addDebugHandle:		right		topCenter		(blue	veryMuchLighter)		none)	(addRepaintHandle:		right		center			(lightGray)						none)	(addGrowHandle:		right		bottom			(yellow)						none)	(addFontEmphHandle:	rightCenter	bottom			(lightBrown darker)				none)	(addFontStyleHandle:		center		bottom			(lightRed)						none)	(addFontSizeHandle:		leftCenter	bottom			(lightGreen)						none)	(addRotateHandle:		left			bottom			(blue)							none))! !!Preferences class methodsFor: 'halos' stamp: 'jm 6/15/2003 12:13'!customHaloSpecs	"Intended for you to modify to suit your personal preference. What is implemented in the default here is just a skeleton; in comment at the bottom of this method are some useful lines you may wish to paste in to the main body here, possibly modifying positions, colors, etc..	Note that in this example, we include:			Dismiss handle, at top-left			Menu handle, at top-right			Resize handle, at bottom-right			Rotate handle, at bottom-left			Drag handle, at top-center			Recolor handle, at left-center. (this one is NOT part of the standard formulary --											it is included here to illustrate how to 											add non-standard halos)			Note that the optional handles for specialized morphs, such as Sketch, Text, PasteUp, are also included"	^ #(	(addDismissHandle:		left			top				(red		muchLighter)			'Halo-Dismiss')	(addMenuHandle:		right		top				(red)							'Halo-Menu')	(addDragHandle:			center		top				(brown)							'Halo-Drag')	(addGrowHandle:		right		bottom			(yellow)						'Halo-Scale')	(addRecolorHandle:		left			center			(green muchLighter lighter)		'Halo-Recolor')	(addRepaintHandle:		right		center			(lightGray)						'Halo-Paint')	(addFontSizeHandle:		leftCenter	bottom			(lightGreen)						'Halo-FontSize')	(addFontStyleHandle:		center		bottom			(lightRed)						'Halo-FontStyle')	(addFontEmphHandle:	rightCenter	bottom			(lightBrown darker)				'Halo-FontEmph')	(addRotateHandle:		left			bottom			(blue)							'Halo-Rot')	(addDebugHandle:		right		topCenter		(blue	veryMuchLighter)		'Halo-Debug')	).	"  Other useful handles...  		selector				horiz		vert			color info						icon key		---------				------		-----------		-------------------------------		---------------	(addGrabHandle:			center		top				(black)							'Halo-Grab')	(addDragHandle:			rightCenter	top				(brown)							'Halo-Drag')	(addDupHandle:			right		top				(green)							'Halo-Dup')		(addHelpHandle:			center		bottom			(lightBlue)						'Halo-Help')	(addRepaintHandle:		right		center			(lightGray)						'Halo-Paint')	"! !!Preferences class methodsFor: 'halos' stamp: 'jm 6/5/2003 21:31'!customHalosInForce	^ (self parameterAt: #HaloTheme) == #customHaloSpecs! !!Preferences class methodsFor: 'halos' stamp: 'jm 6/15/2003 12:19'!haloSpecifications	"Answer a list of HaloSpecs that describe which halos are to be used, what they should look like, and where they should be situated"	^ Parameters at: #HaloSpecs ifAbsent:			[self installHaloTheme: #iconicHaloSpecifications]! !!Preferences class methodsFor: 'halos' stamp: 'jm 6/15/2003 11:52'!haloThemeRadioButtons	| buttonColumn aRow aRadioButton aStringMorph |	buttonColumn _ AlignmentMorph newColumn color: Color transparent.	#((iconicHaloSpecifications		iconic	iconicHalosInForce	'circular halos with icons inside')	  (customHaloSpecs				custom	customHalosInForce	'customizable halos')	) do: [:quad |		aRow _ AlignmentMorph newRow color: Color transparent.		aRow vResizing: #shrinkWrap.		aRow addMorph: (aRadioButton _ ThreePhaseButtonMorph radioButton).		aRadioButton target: Preferences.		aRadioButton setBalloonText: quad fourth.		aRadioButton actionSelector: #installHaloTheme:.		aRadioButton getSelector: quad third.		aRadioButton arguments: (Array with: quad first).		aRow addTransparentSpacerOfSize: (4 @ 0).		aRow addMorphBack: (aStringMorph _ StringMorph contents: quad second asString).		aStringMorph setBalloonText: quad fourth.		buttonColumn addMorphBack: aRow].	^ buttonColumn	"self currentHand attachMorph: Preferences haloThemeRadioButtons"! !!Preferences class methodsFor: 'halos' stamp: 'jm 6/15/2003 12:20'!iconicHaloSpecifications	^ #(	"  	selector				horiz		vert			color info						icon key		---------				------		-----------		-------------------------------		---------------"	(addCollapseHandle:		left			topCenter		(tan)							'Halo-Collapse')	(addDebugHandle:		right		topCenter		(blue	veryMuchLighter)		'Halo-Debug')	(addDismissHandle:		left			top				(red		muchLighter)			'Halo-Dismiss')	(addRotateHandle:		left			bottom			(blue)							'Halo-Rot')	(addMenuHandle:		leftCenter	top				(red)							'Halo-Menu')	(addGrabHandle:			center		top				(black)							'Halo-Grab')	(addDragHandle:			rightCenter	top				(brown)							'Halo-Drag')	(addDupHandle:			right		top				(green)							'Halo-Dup')		(addHelpHandle:			center		bottom			(lightBlue)						'Halo-Help')	(addGrowHandle:		right		bottom			(yellow)						'Halo-Scale')	(addRepaintHandle:		right		center			(lightGray)						'Halo-Paint')	(addFontSizeHandle:		leftCenter	bottom			(lightGreen)						'Halo-FontSize')	(addFontStyleHandle:		center		bottom			(lightRed)						'Halo-FontStyle')	(addFontEmphHandle:	rightCenter	bottom			(lightBrown darker)				'Halo-FontEmph')	)! !!Preferences class methodsFor: 'halos' stamp: 'sw 1/27/2000 23:25'!iconicHalosInForce	^ (self parameterAt: #HaloTheme) == #iconicHaloSpecifications! !!Preferences class methodsFor: 'halos' stamp: 'sw 1/28/2000 10:36'!installCustomHaloSpecs	"Install an alternative set of halos, as customized by the user"	"Preferences installCustomHaloSpecs"	self installHaloTheme: #customHaloSpecs! !!Preferences class methodsFor: 'halos' stamp: 'sw 1/27/2000 16:45'!installHaloSpecsFromArray: anArray	| aColor |	^ Parameters at: #HaloSpecs put: 		(anArray collect:			[:quin |				aColor _ Color.				quin fourth do: [:sel | aColor _ aColor perform: sel].				HaloSpec new 					horizontalPlacement: quin second					verticalPlacement: quin third 					color: aColor					iconSymbol: quin fifth					addHandleSelector: quin first])! !!Preferences class methodsFor: 'halos' stamp: 'sw 1/27/2000 23:15'!installHaloTheme: themeSymbol	self installHaloSpecsFromArray: (self perform: themeSymbol).	self setParameter: #HaloTheme to: themeSymbol	! !!Preferences class methodsFor: 'halos' stamp: 'sw 1/28/2000 10:36'!installIconicHaloSpecs	"Install an alternative set of halos,  rather more based on the old placements, and without icons, , and lacking the scripting-relating handles.."	"Preferences installIconicHaloSpecs"	self installHaloTheme: #iconicHaloSpecifications! !I am a server for a simple telepresence system. This system allows users to discover which other users are online and to get their IP addresses so they can initiate peer-to-peer communications.My 'users' instance variable contains a collection of user records of the form:	<username><password><availableFlag><ip address><timestamp>"Protocol:The first byte of a request message determines the response:	1 -- get available users		format: <1><username><password><availableFlag>		response: <1><count>[<username><4 byte IP address>]	2 -- get all users		format: <2><username><password><availableFlag>		response: <2><count>[<username>]	3 -- register user		format: <3><username><password>		response: <3>'ok'	4 -- unregister user		format: <4><username><password>		response: <4>'ok'	error response: <0><error string>Note that the first byte of each response matches the first byte of the request (i.e., the command byte). The first byte of an error response is zero, followed by a string describing the problem.Usage:The client UI should provide a way for users to enter their name and password, as well as a button to register or unregister that name and password with the server. Once a user is registered, the client polls the server once every minute or so by sending a "get available users" request. This will answer a list of the currently available users along with their ip addresses. If the "availableFlag" is set in the request, the requesting user's presence is advertised. A user who is busy--say, on a phone call--can thus monitor which users are available without making themselves available.Some possible future enhancements:  a. Improve security by not sending passwords in the clear.  b. Provide a remote administrator interface.  c. Provide more detailed user state info, such as "on phone, away from desk, at lunch". Or maybe allow the user to post a virtual textal note on their virtual office door.  d. Allow a user to control which other users can sense their presence. At times you might want to be available to a few people but not everyone.  e. Add a set of commands to support chat rooms, such as "get chat room list", "move user to a given room", "get list of users in a room".!!PresenceServer methodsFor: 'initialization' stamp: 'jm 1/21/2003 17:37'!initialize	super initialize.	users _ OrderedCollection new.! !!PresenceServer methodsFor: 'start/stop' stamp: 'jm 1/22/2003 16:20'!serverStartup	"Sent when the server is starting up. Subclasses can override this message to do their own initialization at startup time."	self readUserFile: UserFileName.! !!PresenceServer methodsFor: 'request handling' stamp: 'jm 1/22/2003 16:50'!doAllUsers: aByteArray requestSocket: aMessageSocket	"Handle an allUsers request. The reply is a list of all users registered with this server. As a side effect, this command also updates the requesting user's availability."	| s username password isAvailable reply |	s _ ReadStream on: aByteArray.	s skip: 1.  "command byte"	username _ s string.	password _ s string.	isAvailable _ s boolean.	(self checkUser: username password: password) ifFalse: [		^ self errorReply: 'bad user name or password'].	self updateUser: username isAvailable: isAvailable ipAddr: aMessageSocket socket remoteAddress.	reply _ WriteStream on: (ByteArray new: 4000).	reply nextPut: 2.	reply uint16: users size.	users do: [:r | reply string: r first].	^ reply contents! !!PresenceServer methodsFor: 'request handling' stamp: 'jm 1/22/2003 16:50'!doAvailableUsers: aByteArray requestSocket: aMessageSocket	"Handle an availableUsers request. The reply is a list of users who have interacted with the server in the past several minutes. As a side effect, this command also updates the requestings user's availability."	| s username password isAvailable cutoffTime availableUsers reply userAvailable timestamp |	s _ ReadStream on: aByteArray.	s skip: 1.  "command byte"	username _ s string.	password _ s string.	isAvailable _ s boolean.	(self checkUser: username password: password) ifFalse: [		^ self errorReply: 'bad user name or password'].	self updateUser: username isAvailable: isAvailable ipAddr: aMessageSocket socket remoteAddress.	availableUsers _ OrderedCollection new.	cutoffTime _ Time totalSeconds - 120.	availableUsers _ users select: [:rec |		userAvailable _ rec at: 3.		timestamp _ rec at: 5.		userAvailable and: [timestamp > cutoffTime]].	reply _ WriteStream on: (ByteArray new: 1000).	reply nextPut: 1.	reply uint16: availableUsers size.	availableUsers do: [:rec |		reply string: (rec at: 1).  "username"		reply nextPutAll: (rec at: 4)].  "ip address, 5 bytes"	^ reply contents! !!PresenceServer methodsFor: 'request handling' stamp: 'jm 1/22/2003 16:26'!doRegisterUser: aByteArray	"Handle user registration. Users are allowed to register their own name and password. However, once a user has been registered, the user's password must be supplied on all other requests, including a request to unregister that user. The reply is the string 'ok' if registration succeeded."	| s username password rec reply |	s _ ReadStream on: aByteArray.	s skip: 1.  "command byte"	username _ s string.	password _ s string.	rec _ users detect: [:r | r first = username] ifNone: [nil].	rec ifNotNil: [^ self errorReply: 'Sorry, user name in use: ', username].	users add:		(Array with: username with: password with: false with: (ByteArray new: 4) with: 0).	self writeUserFile: UserFileName.	reply _ WriteStream on: (ByteArray new: 5000).	reply nextPut: 3.	reply string: 'ok'.	^ reply contents! !!PresenceServer methodsFor: 'request handling' stamp: 'jm 1/22/2003 16:28'!doUnregisterUser: aByteArray	"Handle user unregistration. Users are allowed to unregister their own name and password, making that user name available. One can change one's password by unregistering and then immediately registering that user name with the new password. The reply is the string 'ok' if unregistration succeeded."	| s username password rec reply |	s _ ReadStream on: aByteArray.	s skip: 1.  "command byte"	username _ s string.	password _ s string.	(self checkUser: username password: password) ifFalse: [		^ self errorReply: 'bad user name or password'].	rec _ users detect: [:r | r first = username] ifNone: [nil].	rec ifNotNil: [users remove: rec].	self writeUserFile: UserFileName.	reply _ WriteStream on: (ByteArray new: 3).	reply nextPut: 4.	reply string: 'ok'.	^ reply contents! !!PresenceServer methodsFor: 'request handling' stamp: 'jm 1/18/2003 11:03'!processMessage: aByteArray requestSocket: aSocket	"The first byte of the message defines the operation. Zero-length messages are echoed."	| op |	aByteArray size = 0 ifTrue: [^ ''].  "ping: an empty message generates an empty respose"	op _ aByteArray first.	op = 1 ifTrue: [^ self doAvailableUsers: aByteArray requestSocket: aSocket].	op = 2 ifTrue: [^ self doAllUsers: aByteArray requestSocket: aSocket].	op = 3 ifTrue: [^ self doRegisterUser: aByteArray].	op = 4 ifTrue: [^ self doUnregisterUser: aByteArray].	^ self errorReply: 'unknown command', op printString! !!PresenceServer methodsFor: 'private' stamp: 'jm 1/22/2003 16:27'!checkUser: username password: password	"Answer true if the given username is registered with the given password."	| rec |	rec _ users detect: [:r | r first = username] ifNone: [^ false].	^ password = (rec at: 2)! !!PresenceServer methodsFor: 'private' stamp: 'jm 1/18/2003 11:17'!errorReply: aString	"Create an error reply buffer consisting of the byte 0 followed by the given error string."	| buf s |	buf _ ByteArray new: aString size + 3.	s _ WriteStream on: buf.	s nextPut: 0.  "error reply"	s string: aString.	^ s contents! !!PresenceServer methodsFor: 'private' stamp: 'jm 1/21/2003 17:22'!readUserFile: fileName	"Read the users list from the given file. The file is stored as one user per line with a tab separating the user name and password."	| lines fields noAddr |	(FileDirectory default fileExists: fileName) ifFalse: [^ self].	users _ OrderedCollection new.	noAddr _ ByteArray new: 4.	lines _ (FileStream readOnlyFileNamed: fileName) contentsOfEntireFile findTokens: String crlf.	lines do: [:l |		fields _ l findTokens: String tab.		fields size >= 2 ifTrue: [			users add: (Array with: (fields at: 1) with: (fields at: 2) with: false with: noAddr with: 0)]].! !!PresenceServer methodsFor: 'private' stamp: 'jm 1/22/2003 16:28'!updateUser: username isAvailable: isAvailable ipAddr: ipAddress	"Update the user record for the given user with that user's current IP address and the current time."	| rec |	rec _ users detect: [:r | r first = username] ifNone: [^ self].	isAvailable		ifTrue: [			rec at: 3 put: true.			rec at: 4 put: ipAddress.			rec at: 5 put: Time totalSeconds]		ifFalse: [			rec at: 3 put: false.			rec at: 4 put: nil.			rec at: 5 put: Time totalSeconds].! !!PresenceServer methodsFor: 'private' stamp: 'jm 1/22/2003 16:30'!users	^ users! !!PresenceServer methodsFor: 'private' stamp: 'jm 1/21/2003 17:30'!writeUserFile: fileName	"Write the current users list to the given file. The file is stored as one user per line with a tab separating the user name and password."	| sorted f |	sorted _ users asArray sort: [:a :b | a first < b first].	FileDirectory default deleteFileNamed: fileName ifAbsent: [].	f _ FileDirectory default newFileNamed: fileName.	sorted do: [:userRec | f nextPutAll: (userRec at: 1); tab; nextPutAll: (userRec at: 2); cr].	f close.! !!PresenceServer class methodsFor: 'class initialization' stamp: 'jm 1/22/2003 16:18'!initialize	UserFileName _ 'presence.dat'.! !!PresenceServer class methodsFor: 'port number' stamp: 'jm 9/18/2001 11:56'!portNumber	^ 54325! !I represent an independent path of control in the system. This path of control may be stopped (by sending the message suspend) in such a way that it can later be restarted (by sending the message resume). When any one of several paths of control can be advanced, the single instance of ProcessorScheduler named Processor determines which one will actually be advanced partly using the value of priority.(If anyone ever makes a subclass of Process, be sure to use allSubInstances in anyProcessesAbove:.)!!Process methodsFor: 'changing process state' stamp: 'jm 5/23/2003 11:21'!terminate 	"Stop the process that the receiver represents forever."	| context |	Processor activeProcess == self		ifTrue: 			[thisContext sender == nil ifFalse:				[thisContext sender release].			thisContext removeSelf suspend]		ifFalse: 			[myList == nil				ifFalse: 					[myList remove: self ifAbsent: [].					myList _ nil].			context _ suspendedContext.			suspendedContext _ nil.			(context ~~ nil and: [context sender ~~ nil])				ifTrue: [context sender release]]! !My single instance, named Processor, coordinates the use of the physical processor by all Processes requiring service.!!ProcessorScheduler methodsFor: 'private' stamp: 'tk 6/24/1999 11:27'!anyProcessesAbove: highestPriority 	"Do any instances of Process exist with higher priorities?"	^(Process allInstances "allSubInstances" select: [:aProcess | 		aProcess priority > highestPriority]) isEmpty		"If anyone ever makes a subclass of Process, be sure to use allSubInstances."! !!ProcessorScheduler class methodsFor: 'background process' stamp: 'di 2/4/1999 08:45'!startUp	"Install a background process of the lowest possible priority that is always runnable."	"Details: The virtual machine requires that there is aways some runnable process that can be scheduled; this background process ensures that this is the case."	Smalltalk installLowSpaceWatcher.	BackgroundProcess == nil ifFalse: [BackgroundProcess terminate].	BackgroundProcess _ [self idleProcess] newProcess.	BackgroundProcess priority: SystemRockBottomPriority.	BackgroundProcess resume.! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel	^ channel! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:47'!channel: midiChannel	channel _ midiChannel.! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:49'!program	^ program! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!program: midiProgramChange	program _ midiProgramChange.! !!ProgramChangeEvent methodsFor: 'accessing' stamp: 'jm 9/10/1998 07:48'!program: midiProgramChange channel: midiChannel	program _ midiProgramChange.	channel _ midiChannel.! !!ProgramChangeEvent methodsFor: 'classification' stamp: 'jm 9/10/1998 09:46'!isProgramChange	^ true! !!ProgramChangeEvent methodsFor: 'midi' stamp: 'jm 9/10/1998 18:31'!outputOnMidiPort: aMidiPort	"Output this event to the given MIDI port."	aMidiPort		midiCmd: 16rC0		channel: channel		byte: program.! !!ProgramChangeEvent methodsFor: 'printing' stamp: 'jm 9/10/1998 08:28'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': prog '.	program printOn: aStream.	aStream nextPut: $).! !A Project stores the state of a complete Squeak desktop, including the windows, and the currently active changeSet. A project knows who its parent project is. When you change projects, whether by entering or exiting, the screen state of the project being exited is saved in that project.A project is retained by its view in the parent world. It is effectively named by the name of its changeSet, which can be changed either by renaming in a changeSorter, or by editing the label of its view from the parent project.As the site of major context switch, Projects are the locus of swapping between the old MVC and the new Morphic worlds. The distinction is based on whether the variable 'world' contains a WorldMorph or a ControlManager.Saving and LoadingProjects may be stored on the disk in external format.Projects may be loaded from a server and stored back. Storing on a server never overwrites; it always makes a new version. A project remembers the url of where it lives in urlList. The list is length one, for now. The url may point to a local disk instead of a server. All projects that the user looks at, are cached in the Squeaklet folder. Sorted by server. The cache holds the most recent version only.!!Project methodsFor: 'initialization' stamp: 'jm 6/16/2003 20:58'!defaultBackgroundColor	^ Color r: 1.0 g: 1.0 b: 0.065! !!Project methodsFor: 'initialization' stamp: 'di 3/29/2000 14:16'!initMorphic	"Written so that Morphic can still be removed."	Smalltalk verifyMorphicAvailability ifFalse: [^ nil].	self initialize.	world _ PasteUpMorph newWorldForProject: self.! !!Project methodsFor: 'initialization' stamp: 'di 4/14/1999 13:55'!initialProject	self saveState.	parentProject _ self.	previousProject _ nextProject _ nil! !!Project methodsFor: 'initialization' stamp: 'jm 6/21/2003 11:18'!initialize	changeSet _ ChangeSet new.	transcript _ TranscriptStream new.	displayDepth _ Display depth.	parentProject _ CurrentProject.! !!Project methodsFor: 'initialization' stamp: 'di 7/19/1999 15:00'!installPasteUpAsWorld: pasteUpMorph	"(ProjectViewMorph newMorphicProjectOn: aPasteUpMorph) openInWorld."	world _ pasteUpMorph beWorldForProject: self! !!Project methodsFor: 'initialization' stamp: 'jm 10/7/2002 06:10'!setChangeSet: aChangeSet	changeSet _ aChangeSet! !!Project methodsFor: 'initialization' stamp: 'di 3/29/2000 14:16'!setProjectHolder: aProject	self initialize.	world _ ControlManager new.! !!Project methodsFor: 'initialization' stamp: 'di 6/10/1998 13:54'!windowActiveOnFirstClick	^ true! !!Project methodsFor: 'initialization' stamp: 'di 6/12/1998 15:58'!windowReqNewLabel: newLabel	newLabel isEmpty ifTrue: [^ false].	newLabel = changeSet name ifTrue: [^ true].	(ChangeSorter changeSetNamed: newLabel) == nil		ifFalse: [self inform: 'Sorry that name is already used'.				^ false].	changeSet name: newLabel.	^ true! !!Project methodsFor: 'accessing' stamp: 'tk 4/5/2000 16:29'!changeSet	^ changeSet! !!Project methodsFor: 'accessing' stamp: 'jm 5/16/2003 09:31'!isMorphic	"Answer true if this is a Morphic project."	^ world isMorph! !!Project methodsFor: 'accessing' stamp: 'di 3/29/2000 15:37'!isTopProject	"Return true only if this is the top project (its own parent).	Also include the test here for malformed project hierarchy."	parentProject == self ifTrue: [^ true].	parentProject == nil ifTrue: [self error: 'No project should have a nil parent'].	^ false! !!Project methodsFor: 'accessing' stamp: 'tk 6/26/1998 22:17'!labelString	^ changeSet name! !!Project methodsFor: 'accessing' stamp: 'di 7/19/1999 15:06'!name	changeSet == nil ifTrue: [^ 'no name'].	^ changeSet name! !!Project methodsFor: 'accessing' stamp: 'sw 2/15/1999 12:12'!nextProject	^ nextProject! !!Project methodsFor: 'accessing' stamp: 'di 4/14/1999 13:59'!setParent: newParent	parentProject _ newParent.	nextProject _ previousProject _ nil.! !!Project methodsFor: 'accessing' stamp: 'tk 4/5/2000 13:57'!urlList	^ urlList! !!Project methodsFor: 'menu messages' stamp: 'tk 10/26/1999 14:25'!enter	"Enter the new project"	self enter: (CurrentProject parent == self) revert: false saveForRevert: false.! !!Project methodsFor: 'menu messages' stamp: 'jm 10/30/2002 20:48'!enter: returningFlag revert: revertFlag saveForRevert: saveForRevert	"Install my ChangeSet, Transcript, and scheduled views as current globals. If returningFlag is true, we will return to the project from whence the current project was entered; don't change its previousProject link in this case.	If saveForRevert is true, save the ImageSegment of the project being left.	If revertFlag is true, make stubs for the world of the project being left.	If revertWithoutAsking is true in the project being left, then always revert."	| showZoom forceRevert response seg |	self == CurrentProject ifTrue: [^ self].	forceRevert _ false.	CurrentProject rawParameters 		ifNil: [revertFlag ifTrue: [^ self inform: 'nothing to revert to']]		ifNotNil: [saveForRevert ifFalse: [				forceRevert _ CurrentProject projectParameters 								at: #revertWithoutAsking ifAbsent: [false]]].	forceRevert not & revertFlag ifTrue: [		response _ SelectionMenu confirm: 'Are you sure you want to destroy this Project\ and revert to an older version?\\(From the parent project, click on this project''s thumbnail.)' withCRs			trueChoice: 'Revert to saved version' 			falseChoice: 'Cancel'.		response ifFalse: [^ self]].	revertFlag | forceRevert 		ifTrue: [seg _ CurrentProject projectParameters at: #revertToMe ifAbsent: [					^ self inform: 'nothing to revert to']]		ifFalse: [CurrentProject makeThumbnail].	(revertFlag | saveForRevert | forceRevert) ifFalse: [].	"Update the display depth and make a thumbnail of the current project"	CurrentProject displayDepth: Display depth.	"Show the project transition.	Note: The project zoom is run in the context of the old project,		so that eventual errors can be handled accordingly"	displayDepth == nil ifTrue: [displayDepth _ Display depth].	Display setExtent: Display extent depth: displayDepth.	(showZoom _ self showZoom) ifTrue: [		self displayZoom: CurrentProject parent ~~ self].	(world isMorph and: [world hasProperty: #letTheMusicPlay])		ifTrue: [world removeProperty: #letTheMusicPlay]		ifFalse: [Smalltalk at: #ScorePlayer ifPresent: [:playerClass | 					playerClass allSubInstancesDo: [:player | player pause]]].	returningFlag		ifTrue: [nextProject _ CurrentProject]		ifFalse: [previousProject _ CurrentProject].	CurrentProject saveState.	CurrentProject _ self.	Smalltalk newChanges: changeSet.	TranscriptStream newTranscript: transcript.	Sensor flushKeyboard.	world isMorph		ifTrue:			[World _ world.  "Signifies Morphic"			world install]		ifFalse:			[World _ nil.  "Signifies MVC"			Smalltalk at: #ScheduledControllers put: world].	revertFlag | forceRevert ifTrue: [		seg clone revert].	"non-cloned one is for reverting again later"	"Complete the enter: by launching a new process"	world isMorph		ifTrue:			[self spawnNewProcessAndTerminateOld: true]		ifFalse:			[showZoom ifFalse: [ScheduledControllers restore].			ScheduledControllers searchForActiveController]! !!Project methodsFor: 'menu messages' stamp: 'tk 10/26/1999 14:25'!exit	"Leave the current project and return to the project in which this one was created."	self isTopProject ifTrue: [^ PopUpMenu notify: 'Can''t exit the top project'].	parentProject enter: false revert: false saveForRevert: false.! !!Project methodsFor: 'menu messages' stamp: 'jm 5/29/2003 18:07'!makeThumbnail	"Make a thumbnail image of this project from the Display."	viewSize ifNil: [viewSize _ Display extent // 8].	thumbnail _ Form extent: viewSize depth: Display depth.	(WarpBlt toForm: thumbnail)			sourceForm: Display;			cellSize: 2;  "installs a colormap"			combinationRule: Form over;			copyQuad: (Display boundingBox) innerCorners			toRect: (0@0 extent: viewSize).! !!Project methodsFor: 'menu messages' stamp: 'sma 4/30/2000 10:11'!saveState	"Save the current state in me prior to leaving this project"	changeSet _ Smalltalk changes.	Smalltalk isMorphic		ifTrue:			[world _ World.			world sleep]		ifFalse:			[world _ ScheduledControllers.			ScheduledControllers unCacheWindows].	transcript _ Transcript.	activeProcess _ nil! !!Project methodsFor: 'menu messages' stamp: 'di 9/29/1999 00:09'!viewLocFor: exitedProject	"Look for a view of the exitedProject, and return its center"	| ctlr |	world isMorph		ifTrue: [world submorphsDo:					[:v | ((v isKindOf: SystemWindow) and: [v model == exitedProject])						ifTrue: [^ v center]]]		ifFalse: [ctlr _ world controllerWhoseModelSatisfies:							[:p | p == exitedProject].				ctlr ifNotNil: [^ ctlr view windowBox center]].	^ Sensor cursorPoint.  "default result"! !!Project methodsFor: 'release' stamp: 'di 9/28/1999 23:46'!addDependent: aMorph	"Projects do not keep track of their dependents, lest they point into other projects and thus foul up the tree structure for image segmentation."	^ self  "Ignore this request"! !!Project methodsFor: 'release' stamp: 'sw 7/6/1998 11:16'!canDiscardEdits	"Don't regard a window of mine as one to be discarded as part of a 'closeUnchangedWindows' sweep"	^ false! !!Project methodsFor: 'release' stamp: 'sw 2/15/1999 12:15'!deletingProject: aProject	"Clear my previousProject link if it points at the given Project, which is being deleted."	previousProject == aProject		ifTrue: [previousProject _ nil].	nextProject == aProject		ifTrue:	[nextProject _ nil]! !!Project methodsFor: 'release' stamp: 'jm 10/14/2002 18:34'!okToChange	| ok hasSubProjects itsName |	hasSubProjects _ world isMorph		ifTrue: [(world submorphs select:						[:m | (m isKindOf: SystemWindow)								and: [m model isKindOf: Project]]) size > 0]		ifFalse: [(world controllerWhoseModelSatisfies:						[:m | m isKindOf: Project]) notNil].	hasSubProjects ifTrue:		[PopUpMenu notify: 'The project ', self name printString, 'contains sub-projects.  You must remove theseexplicitly before removing their parent.'.		^ false].	ok _ world isMorph not and: [world scheduledControllers size <= 1].	ok ifFalse: [self isMorphic ifTrue: [		self parent == Project current 			ifFalse: [^true]]].  "view from elsewhere.  just delete it."	ok _ (self confirm:'Really delete the project', self name printString, 'and all its windows?').			ok ifFalse: [^ false].	"about to delete this project; clear previous links to it from other Projects:"	Project allProjects do: [:p | p deletingProject: self].	ProjectViewMorph allSubInstancesDo: [:p | 		p deletingProject: self.		p project == self ifTrue: [p abandon]].	(changeSet isEmpty and: [(changeSet projectsBelongedTo copyWithout: self) isEmpty])		ifTrue:			[itsName _ changeSet name.			ChangeSorter removeChangeSet: changeSet.			Transcript cr; show: 'project change set ', itsName, ' deleted.'].	^ true! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 13:14'!activeProcess	^ activeProcess! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 13:20'!interruptName: labelString	"Create a Notifier on the active scheduling process with the given label."	| suspendingList projectProcess |	Smalltalk isMorphic ifFalse:		[^ ScheduledControllers interruptName: labelString].	projectProcess _ Project current activeProcess.	(suspendingList _ projectProcess suspendingList) == nil		ifTrue: [projectProcess == Processor activeProcess					ifTrue: [projectProcess suspend]]		ifFalse: [suspendingList remove: projectProcess.				projectProcess offList].	Debugger openInterrupt: labelString onProcess: projectProcess! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 14:07'!resumeProcess: aProcess	"Adopt aProcess as the project process -- probably because of proceeding from a debugger"	activeProcess _ aProcess.	activeProcess resume! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 09:21'!spawnNewProcess	exitFlag _ false.	activeProcess _		[[World doOneCycle.  Processor yield.  exitFlag] whileFalse: [].		self exit]			newProcess priority: Processor userSchedulingPriority.	activeProcess resume! !!Project methodsFor: 'active process' stamp: 'di 6/20/1998 09:22'!spawnNewProcessAndTerminateOld: terminate	self spawnNewProcess.	terminate		ifTrue: [Processor terminateActive]		ifFalse: [Processor activeProcess suspend]! !!Project methodsFor: 'active process' stamp: 'di 4/14/2000 12:38'!spawnNewProcessIfThisIsUI: suspendedProcess	world isMorph ifFalse: [^self spawnNewProcess].	"does this ever happen?"	self activeProcess == suspendedProcess		ifTrue: ["Transcript show: 'spawning'; cr."				self spawnNewProcess ] 		ifFalse: ["Transcript show: 'not spawning'; cr" ].! !!Project methodsFor: 'file in/out' stamp: 'tk 10/26/1999 14:23'!revert	| |	"Exit this project and do not save it.  Warn user unless in dangerous projectRevertNoAsk mode.  Exit to the parent project.  Do a revert on a clone of the segment, to allow later reverts."	projectParameters ifNil: [^ self inform: 'nothing to revert to'].	parentProject enter: false revert: true saveForRevert: false.	"does not return!!"! !!Project methodsFor: 'project parameters' stamp: 'jm 10/7/2002 06:21'!initializeProjectParameters	projectParameters _ IdentityDictionary new.	^ projectParameters! !!Project methodsFor: 'project parameters' stamp: 'ar 5/25/2000 23:23'!parameterAt: aSymbol	^self parameterAt: aSymbol ifAbsent:[nil]! !!Project methodsFor: 'project parameters' stamp: 'ar 5/25/2000 23:23'!parameterAt: aSymbol ifAbsent: aBlock	projectParameters ifNil:[^aBlock value].	^projectParameters at: aSymbol ifAbsent: aBlock! !!Project methodsFor: 'project parameters' stamp: 'sw 4/22/1999 15:14'!projectParameters	^ projectParameters ifNil: [self initializeProjectParameters]! !!Project methodsFor: 'project parameters' stamp: 'tk 10/26/1999 13:55'!rawParameters	^ projectParameters! !!Project methodsFor: 'displaying' stamp: 'jm 10/7/2002 06:27'!displayZoom: entering	"Show the project transition when entering a new project"	| newDisplay vanishingPoint |	"show animated zoom to new display"	newDisplay _ self imageForm.	entering		ifTrue: [vanishingPoint _ Sensor cursorPoint]		ifFalse: [vanishingPoint _ self viewLocFor: CurrentProject].	Display zoomIn: entering orOutTo: newDisplay at: 0@0			vanishingPoint: vanishingPoint.! !!Project methodsFor: 'displaying' stamp: 'ar 6/2/1999 01:58'!imageForm	^self imageFormOfSize: Display extent		depth: (displayDepth ifNil:[Display depth])! !!Project methodsFor: 'displaying' stamp: 'ar 5/25/2000 18:01'!imageFormOfSize: extentPoint depth: d	| newDisplay |	newDisplay _ DisplayScreen extent: extentPoint depth: d.	Display replacedBy: newDisplay do:[		world isMorph 			ifTrue:[world fullDrawOn: (Display getCanvas)] "Morphic"			ifFalse:[world restore]. "MVC"	].	^newDisplay! !!Project methodsFor: 'displaying' stamp: 'sw 1/12/2000 18:44'!showZoom	"Decide if user wants a zoom transition, and if there is enough memory to do it."	^ Preferences projectZoom and:		"Only show zoom if there is room for both displays plus a megabyte"		[Smalltalk garbageCollectMost > 						(Display boundingBox area*displayDepth //8+1000000)]! !!Project class methodsFor: 'class initialization' stamp: 'di 4/14/1999 21:34'!initialize	"This is the Top Project."   	CurrentProject ifNil:		[CurrentProject _ super new initialProject.		CurrentProject spawnNewProcessAndTerminateOld: true].	"Project initialize"! !!Project class methodsFor: 'instance creation' stamp: 'di 6/20/1998 13:14'!activeProcess	^ CurrentProject activeProcess! !!Project class methodsFor: 'instance creation' stamp: 'di 7/19/1999 14:55'!newMorphic	"ProjectView open: Project newMorphic"	^ self basicNew initMorphic! !!Project class methodsFor: 'utilities' stamp: 'jm 5/23/2003 13:04'!addItem: item toMenu: menu selection: action project: aProject	| c |	c _ aProject isMorphic 		ifTrue: [Color red darker]		ifFalse: [Color veryVeryDarkGray].	(menu isKindOf: MenuMorph)		ifTrue: [			menu add: item selector: #jumpToSelection: argument: action.			menu items last color: c]		ifFalse: [			menu add: item action: action].! !!Project class methodsFor: 'utilities' stamp: 'di 6/10/1999 11:30'!allNames	^ (self allProjects collect: [:p | p name]) asSortedCollection: [:n1 :n2 | n1 asLowercase < n2 asLowercase]! !!Project class methodsFor: 'utilities' stamp: 'di 6/10/1999 11:30'!allNamesAndProjects	^ (self allProjects asSortedCollection: [:p1 :p2 | p1 name asLowercase < p2 name asLowercase]) collect:		[:aProject | Array with: aProject name with: aProject]! !!Project class methodsFor: 'utilities' stamp: 'di 6/10/1999 11:44'!allProjects	^ self allSubInstances select: [:p | p name notNil]! !!Project class methodsFor: 'utilities' stamp: 'sw 3/6/1999 22:54'!buildJumpToMenu: menu	"Make the supplied menu offer a list of potential projects, consisting of:		*	The previous-project chain		*	The next project, if any		*	The parent project, if any		*	All projects, alphabetically"	| prev listed i next  toAdd |	listed _ OrderedCollection with: CurrentProject.	i _ 0.	prev _ CurrentProject previousProject.	[(prev ~~ nil and: [(listed includes: prev) not])] whileTrue:		[i _ i + 1.		listed add: prev.		self addItem: prev name , ' (back ' , i printString , ')'					toMenu: menu selection: ('%back' , i printString) project: prev.				prev _ prev previousProject].	(((next _ CurrentProject nextProject) ~~ nil) and: [(listed includes: next) not]) ifTrue:		[self addItem: (next name, ' (forward 1)') toMenu: menu selection: next name project: next]. 	(i > 0 or: [next ~~ nil]) ifTrue: [menu addLine].	"Then the parent"	CurrentProject isTopProject ifFalse: 		[self addItem: CurrentProject parent name , ' (parent)' toMenu: menu selection: #parent project: CurrentProject parent.		menu addLine].	"Finally all the projects, in alphabetical order"	Project allNamesAndProjects do:		[:aPair | 			toAdd _ aPair last == CurrentProject				ifTrue:					[aPair first, ' (current)']				ifFalse:					[aPair first].			self addItem: toAdd toMenu: menu selection: aPair first project: aPair last].	^ menu! !!Project class methodsFor: 'utilities' stamp: 'di 6/13/1998 11:24'!jumpToProject		"Project jumpToProject"	"Present a list of potential projects and enter the one selected."	self jumpToSelection: (self buildJumpToMenu: CustomMenu new) startUp! !!Project class methodsFor: 'utilities' stamp: 'tk 3/10/2000 21:09'!jumpToSelection: selection	"Enter the project corresponding to this menu selection."	"Project jumpToProject"	| nBack prev pr |	selection ifNil: [^ self].	(selection beginsWith: '%back') ifTrue:		[nBack _ (selection copyFrom: 6 to: selection size) asNumber.		prev _ CurrentProject previousProject.		1 to: nBack-1 do:			[:i | prev ifNotNil: [prev _ prev previousProject]].		prev ifNotNil: [prev enter: true revert: false saveForRevert: false]].	selection = #parent ifTrue: [		CurrentProject parent enter: false revert: false saveForRevert: false.		^ self].	(pr _ Project named: selection) ifNil: [^ self].	pr enter: false revert: false saveForRevert: false! !!Project class methodsFor: 'utilities' stamp: 'tk 3/10/2000 21:10'!named: projName	"Answer the project with the given name, or nil if there is no project of that given name."	"(Project named: 'New Changes') enter"	^ self allProjects		detect: [:proj | proj name = projName]		ifNone: [nil]! !!Project class methodsFor: 'utilities' stamp: 'jm 5/23/2003 13:03'!ofWorld: aPasteUpMorph	"Find the project of a world."	"Usually it is the current project"	self current world == aPasteUpMorph ifTrue: [^ self current].	"Inefficient enumeration if it is not..."	^ self allSubInstances		detect: [:pr | pr world == aPasteUpMorph]		ifNone: [nil]! !!Project class methodsFor: 'utilities' stamp: 'tk 10/26/1999 14:25'!returnToPreviousProject	"Return to the project from which this project was entered. Do nothing if the current project has no link to its previous project."	| prevProj |	prevProj _ CurrentProject previousProject.	prevProj ifNotNil: [prevProj enter: true revert: false saveForRevert: false].! !!Project class methodsFor: 'constants' stamp: 'jm 5/29/2003 18:31'!current	"Answer the project that is currently being used."	^ CurrentProject! !!ProjectController methodsFor: 'control activity' stamp: 'tk 10/26/1999 14:26'!redButtonActivity	| index |	view isCollapsed ifTrue: [^ super redButtonActivity].	(view insetDisplayBox containsPoint: Sensor cursorPoint)		ifFalse: [^ super redButtonActivity].	index _ (PopUpMenu labelArray: #('enter' 'jump to project...') lines: #()) 		startUpCenteredWithCaption: nil.	index = 0 ifTrue: [^ self].	"save size on enter for thumbnail on exit"	model setViewSize: view insetDisplayBox extent.	index = 1 ifTrue: [^ model enter: false revert: false saveForRevert: false].	index = 2 ifTrue: [Project jumpToProject. ^ self].! !!ProjectView methodsFor: 'initialization' stamp: 'sw 8/4/1998 19:15'!maybeRelabel: newLabel	"If the change set name given by newLabel is already in use, do nothing; else relabel the view"	(newLabel isEmpty or: [newLabel = self label])		ifTrue: [^ self].	(ChangeSorter changeSetNamed: newLabel) == nil		ifFalse: [^ self].	self relabel: newLabel! !!ProjectView methodsFor: 'initialization' stamp: 'sw 1/11/2000 15:30'!uncacheBits	super uncacheBits.	self label ~=  model name ifTrue: [self setLabelTo: model name]! !!ProjectView methodsFor: 'displaying' stamp: 'tk 4/20/2000 21:27'!displayDeEmphasized 	| cmd |	"Display this view with emphasis off.  Check for a command that could not be executed in my subproject.  Once it is done, remove the trigger."	super displayDeEmphasized.	ArmsLengthCmd ifNil: [^ self].	cmd _ ArmsLengthCmd.	ArmsLengthCmd _ nil.	model "project" perform: cmd.	model "project" enter.! !!ProjectView methodsFor: 'displaying' stamp: 'sw 1/11/2000 15:32'!displayView	super displayView.	self label = model name		ifFalse: [self setLabelTo: model name].	self isCollapsed ifTrue: [^ self].	model thumbnail ifNil: [^ self].	self insetDisplayBox extent = model thumbnail extent		ifTrue: [model thumbnail displayAt: self insetDisplayBox topLeft]		ifFalse: [(model thumbnail					magnify: model thumbnail boundingBox					by: self insetDisplayBox extent asFloatPoint / model thumbnail extent) 				displayAt: self insetDisplayBox topLeft]! !!ProjectView methodsFor: 'displaying' stamp: 'sw 9/14/1998 13:01'!release	super release.	Smalltalk garbageCollect! !!ProjectView class methodsFor: 'as yet unclassified' stamp: 'tk 10/26/1999 14:26'!openAndEnter: aProject 	"Answer an instance of me for the argument, aProject. It is created on the	display screen."	| topView |	topView _ self new model: aProject.	topView minimumSize: 50 @ 30.	topView borderWidth: 2.	topView window: (RealEstateAgent initialFrameFor: topView).	ScheduledControllers schedulePassive: topView controller.	aProject enter: false revert: false saveForRevert: false! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'sw 9/22/1999 11:30'!borderColor	^ currentBorderColor ifNil: [currentBorderColor _ Color gray]! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'di 6/29/1999 10:44'!fullDrawOn: aCanvas	(Preferences roundedWindowCorners and: [(owner isKindOf: SystemWindow) not])		ifTrue: [CornerRounder roundCornersOf: self on: aCanvas					displayBlock: [super fullDrawOn: aCanvas]					borderWidth: 1]		ifFalse: [super fullDrawOn: aCanvas]! !!ProjectViewMorph methodsFor: 'drawing' stamp: 'jm 11/13/2002 11:00'!showBorderAs: aColor	form border: form boundingBox width: 1 fillColor: aColor.	currentBorderColor _ aColor.	self changed.! !!ProjectViewMorph methodsFor: 'events' stamp: 'tk 12/9/1999 08:03'!abandon	"Home ViewMorph of project is going away."	project _ nil.	super abandon.! !!ProjectViewMorph methodsFor: 'events' stamp: 'sw 9/22/1999 11:34'!balloonText	^ 'Click here to enter theproject named"', project name, '"'! !!ProjectViewMorph methodsFor: 'events' stamp: 'di 6/22/1998 09:41'!deletingProject: aProject	"My project is being deleted.  Delete me as well."	project == aProject ifTrue: [self delete].! !!ProjectViewMorph methodsFor: 'events' stamp: 'jm 5/29/2003 18:07'!drawOn: aCanvas	project ifNil: [^ super drawOn: aCanvas].	project thumbnail ifNil: [		form fill: (0@0 extent: form extent) rule: Form over 			fillColor: project defaultBackgroundColor.		^ super drawOn: aCanvas].	project thumbnail ~~ lastProjectThumbnail ifTrue:			["scale thumbnail to fit my bounds"			(WarpBlt toForm: form)				sourceForm: project thumbnail;				cellSize: 2;  "installs a colormap"				combinationRule: Form over;				copyQuad: (project thumbnail boundingBox) innerCorners				toRect: (0@0 extent: form extent).			lastProjectThumbnail _ project thumbnail.			form borderWidth: 1].	super drawOn: aCanvas.! !!ProjectViewMorph methodsFor: 'events' stamp: 'jm 10/14/2002 18:41'!enter	"Enter my project."	(owner isKindOf: SystemWindow)		ifTrue: [project setViewSize: self extent].	self showBorderAs: Color gray.	project enter: false revert: false saveForRevert: false.! !!ProjectViewMorph methodsFor: 'events' stamp: 'jm 11/13/2002 11:01'!extent: aPoint	"Set my image Form to the given extent."	| newExtent scaleP scale |	((bounds extent = aPoint) and:	 [form depth = Display depth]) ifFalse: [		lastProjectThumbnail			ifNil: [newExtent _ aPoint]			ifNotNil: [				scaleP _ aPoint / lastProjectThumbnail extent.				scale _ scaleP "scaleP x asFloat max: scaleP y asFloat".				newExtent _ (lastProjectThumbnail extent * scale) rounded].		self form: (Form extent: newExtent depth: Display depth).		lastProjectThumbnail _ nil].! !!ProjectViewMorph methodsFor: 'events' stamp: 'sw 9/22/1999 11:41'!handlesMouseOver: evt	^ true! !!ProjectViewMorph methodsFor: 'events' stamp: 'jm 6/15/2003 17:12'!initialize	super initialize.	color _ Color paleGreen.	currentBorderColor _ Color gray.! !!ProjectViewMorph methodsFor: 'events' stamp: 'sw 9/22/1999 12:48'!mouseDown: evt	self showBorderAs: Color red.	self world displayWorld.	mouseDownTime _ Time millisecondClockValue! !!ProjectViewMorph methodsFor: 'events' stamp: 'sw 9/22/1999 11:25'!mouseEnter: evt	self showBorderAs: Color blue! !!ProjectViewMorph methodsFor: 'events' stamp: 'sw 9/22/1999 11:20'!mouseLeave: evt	self showBorderAs: Color gray! !!ProjectViewMorph methodsFor: 'events' stamp: 'jm 10/2/2002 11:58'!mouseMove: evt	| menu selection |	(self containsPoint: evt cursorPoint)		ifTrue:			[self showBorderAs: Color red.			mouseDownTime				ifNil:					[mouseDownTime _ Time millisecondClockValue]				ifNotNil:					[((Time millisecondClockValue - mouseDownTime) > 1100)						ifTrue:							[menu _ CustomMenu new.							menu add: 'enter this project' action: #enter.							selection _ (menu build preSelect: #enter) startUpCenteredWithCaption: ('Project Named', 								'"', project name, '"').							selection = #enter ifTrue: [^ self enter].							]]]		ifFalse:			[self showBorderAs: Color blue.			mouseDownTime _ nil]! !!ProjectViewMorph methodsFor: 'events' stamp: 'sw 9/22/1999 11:27'!mouseUp: evt	(self containsPoint: evt cursorPoint) ifTrue:		[^ self enter].	self showBorderAs: Color gray! !!ProjectViewMorph methodsFor: 'events' stamp: 'tk 4/1/2000 18:55'!step	| cmd |	"Check for a command that could not be executed in my subproject.  Once it is done, remove the trigger.  If this is too slow, make armsLengthCmd an inst var."	cmd _ self valueOfProperty: #armsLengthCmd.	cmd ifNil: [^ super step].	self removeProperty: #armsLengthCmd.	(self valueOfProperty: #wasStepping) ifFalse: [		self stopStepping].	self removeProperty: #wasStepping.	project perform: cmd.	project enter.! !!ProjectViewMorph methodsFor: 'accessing' stamp: 'tk 8/30/1999 11:48'!project	^project! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'jm 6/15/2003 17:07'!newMVCProject	"Create an instance of me on a new MVC project (in a SystemWindow)."	| proj window |	proj _ Project new.	window _ (SystemWindow labelled: proj name) model: proj.	window		addMorph: (self on: proj)		frame: (0@0 corner: 1.0@1.0).	^ window! !!ProjectViewMorph class methodsFor: 'project window creation' stamp: 'di 7/19/1999 14:55'!newMorphicProjectOn: aPasteUpOrNil	"Return an instance of me on a new Morphic project (in a SystemWindow)."	| proj window |	proj _ Project newMorphic.	aPasteUpOrNil ifNotNil: [proj installPasteUpAsWorld: aPasteUpOrNil].	window _ (SystemWindow labelled: proj name) model: proj.	window		addMorph: (self on: proj)		frame: (0@0 corner: 1.0@1.0).	^ window! !An instance of ProtocolBrowser shows the methods a class understands--inherited or implemented at this level--as a "flattened" list.!!ProtocolBrowser methodsFor: 'private' stamp: 'jm 5/15/2003 23:12'!onSubProtocolOf: aClass 	"Initialize with the entire protocol for the class, aClass, but excluding those inherited from Object."	| sels |	sels _ Set new.	aClass withAllSuperclasses do: [:c | c == Object ifFalse: [sels addAll: c selectors]].	self initListFrom: sels asSortedCollection highlighting: aClass.! !!ProtocolBrowser methodsFor: 'private' stamp: 'di 3/31/1999 14:33'!setClassAndSelectorIn: csBlock	"Decode strings of the form    <selectorName> (<className> [class])  "	| i classAndSelString sel |	sel _ self selection asString.	i _ sel indexOf: $(.	"Rearrange to  <className> [class] <selectorName> , and use MessageSet"	classAndSelString _ (sel copyFrom: i + 1 to: sel size - 1) , ' ' ,					(sel copyFrom: 1 to: i - 1) withoutTrailingBlanks.	MessageSet parse: classAndSelString toClassAndSelector: csBlock! !!PseudoClass methodsFor: 'class'!classComment: aChangeRecord	self organization classComment: aChangeRecord! !!PseudoClass methodsFor: 'class' stamp: 'di 1/13/1999 12:00'!classPool 	self exists ifFalse: [^ nil].	^ self realClass classPool! !!PseudoClass methodsFor: 'class'!comment	| rStr |	rStr := self organization commentRemoteStr.	^rStr isNil		ifTrue:[self name,' has not been commented']		ifFalse:[rStr string]! !!PseudoClass methodsFor: 'class'!comment: aString	self commentString: aString.! !!PseudoClass methodsFor: 'class' stamp: 'wod 4/15/98 17:21'!commentString	^self organization classComment asString! !!PseudoClass methodsFor: 'class'!commentString: aString	self classComment: aString asText. "Just wrap it"! !!PseudoClass methodsFor: 'class'!definition	^definition ifNil:['There is no class definition for this class'].! !!PseudoClass methodsFor: 'class'!definition: aString	definition := aString! !!PseudoClass methodsFor: 'class'!metaClass	^metaClass ifNil:[metaClass := PseudoMetaclass new name: (self name)].! !!PseudoClass methodsFor: 'class'!renameTo: aString	self hasDefinition ifTrue:[		self isMetaClass ifTrue:[			self definition: (self definition				copyReplaceAll: name,' class'				with: aString, ' class').		] ifFalse:[			self definition: (self definition 					copyReplaceAll:'ubclass: #',name					with:'ubclass: #', aString)]].	name := aString.	metaClass ifNotNil:[metaClass renameTo: aString].! !!PseudoClass methodsFor: 'class' stamp: 'di 1/13/1999 12:00'!sharedPools 	self exists ifFalse: [^ nil].	^ self realClass sharedPools! !!PseudoClass methodsFor: 'accessing' stamp: 'sma 6/16/1999 22:59'!allInstVarNames	^#()! !!PseudoClass methodsFor: 'accessing' stamp: 'sma 2/6/2000 12:30'!allSuperclasses	^ self realClass allSuperclasses! !!PseudoClass methodsFor: 'accessing' stamp: 'sma 4/28/2000 17:24'!compilerClass	^ (Smalltalk at: name ifAbsent: [^ Compiler]) compilerClass! !!PseudoClass methodsFor: 'accessing'!fullName	^self name! !!PseudoClass methodsFor: 'accessing'!name	^name! !!PseudoClass methodsFor: 'accessing'!name: anObject	name _ anObject! !!PseudoClass methodsFor: 'accessing'!organization	^organization ifNil:[organization := PseudoClassOrganizer defaultList: SortedCollection new].! !!PseudoClass methodsFor: 'accessing'!realClass	^Smalltalk at: self name asSymbol! !!PseudoClass methodsFor: 'accessing' stamp: 'wod 5/19/1998 17:42'!theNonMetaClass	"Sent to a class or metaclass, always return the class"	^self! !!PseudoClass methodsFor: 'removing'!removeAllUnmodified	| stClass |	self exists ifFalse:[^self].	self removeUnmodifiedMethods: self selectors.	stClass := self realClass.	(self hasDefinition and:[stClass definition = self definition]) ifTrue:[definition := nil].	(self hasComment and:[stClass comment asString = self commentString]) ifTrue:[ self classComment: nil].	metaClass isNil ifFalse:[metaClass removeAllUnmodified].! !!PseudoClass methodsFor: 'removing'!removeUnmodifiedMethods: aCollection	| stClass |	self exists ifFalse:[^self].	stClass := self realClass.	aCollection do:[:sel|		(self sourceCodeAt: sel) = (stClass sourceCodeAt: sel ifAbsent:['']) asString ifTrue:[			self removeMethod: sel.		].	].	self organization removeEmptyCategories.! !!PseudoClass methodsFor: 'private' stamp: 'sma 2/6/2000 12:23'!allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level	^ self realClass allSubclassesWithLevelDo: classAndLevelBlock startingLevel: level! !!PseudoClass methodsFor: 'private'!confirmRemovalOf: aString	^self confirm:'Remove ',aString,' ?'! !!PseudoClass methodsFor: 'private'!evaluate: aString	^Compiler evaluate: aString for: nil logged: true! !!PseudoClass methodsFor: 'private'!makeSureClassExists: aString	| theClass |	theClass := Smalltalk at: (aString asSymbol) ifAbsent:[nil].	theClass ifNotNil:[^true].	^self confirm: aString,' does not exist in the system. Use nil instead?'.! !!PseudoClass methodsFor: 'private'!makeSureSuperClassExists: aString	| theClass |	theClass := Smalltalk at: (aString asSymbol) ifAbsent:[nil].	theClass ifNotNil:[^true].	^self confirm: 'The super class ',aString,' does not exist in the system. Use nil instead?'.! !!PseudoClass methodsFor: 'private'!parserClass	^Parser! !!PseudoClass methodsFor: 'testing'!exists	^(Smalltalk at: self name asSymbol ifAbsent:[^false]) isKindOf: Behavior! !!PseudoClass methodsFor: 'testing'!hasChanges	self sourceCode isEmpty ifFalse:[^true].	self organization hasNoComment ifFalse:[^true].	definition isNil ifFalse:[^true].	metaClass isNil ifFalse:[^metaClass hasChanges].	^false! !!PseudoClass methodsFor: 'testing'!hasComment	^self organization commentRemoteStr notNil! !!PseudoClass methodsFor: 'testing'!hasDefinition	^definition notNil! !!PseudoClass methodsFor: 'testing'!hasMetaclass	^metaClass notNil! !!PseudoClass methodsFor: 'testing'!isMetaClass	^false! !!PseudoClass methodsFor: 'testing'!nameExists	^Smalltalk includesKey: self name asSymbol! !!PseudoClass methodsFor: 'testing'!needsInitialize	^self hasMetaclass and:[		self metaClass selectors includes: #initialize]! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileIn	"FileIn the receiver"	self hasDefinition ifTrue:[self fileInDefinition].	self fileInMethods: self selectors.	metaClass ifNotNil:[metaClass fileIn].	self needsInitialize ifTrue:[		self evaluate: self name,' initialize'.	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInCategory: aCategory	^self fileInMethods: (self organization listAtCategoryNamed: aCategory)! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInDefinition	(self makeSureSuperClassExists: (definition copyUpTo: Character space)) ifFalse:[^self].	self hasDefinition ifTrue:[		Transcript cr; show:'Defining ', self name.		self evaluate: self definition].	self exists ifFalse:[^self].	self hasComment ifTrue:[self realClass classComment: self comment].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInMethod: selector	^self fileInMethods: (Array with: selector)! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInMethods	^self fileInMethods: self selectors! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileInMethods: aCollection	"FileIn all methods with selectors taken from aCollection"	| theClass cat |	self exists ifFalse:[^self classNotDefined].	theClass := self realClass.	aCollection do:[:sel|		cat := self organization categoryOfElement: sel.		cat = self removedCategoryName ifFalse:[			theClass 				compile: (self sourceCodeAt: sel) 				classified: cat				withStamp: (self stampAt: sel)				notifying: nil.		].	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOut	| f |	f := (FileStream newFileNamed: self name,'.st').	self fileOutOn: f.	self needsInitialize ifTrue:[		f cr; nextChunkPut: self name,' initialize'.	].	f close! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutCategory: categoryName	| f |	f := (FileStream newFileNamed: self name,'-',categoryName,'.st').	self fileOutMethods: (self organization listAtCategoryNamed: categoryName)			on: f.	f close! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutDefinitionOn: aStream	self hasDefinition ifFalse:[^self].	aStream nextChunkPut: self definition; cr.	self hasComment ifTrue:[		aStream cr; nextPut: $!!; nextChunkPut: self name,' comment: '; cr.		aStream nextChunkPut: self commentString printString.	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutMethod: selector	| f |	f := (FileStream newFileNamed: self name,'-', selector, '.st').	self fileOutMethods: (Array with: selector)			on: f.	f close! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutMethods: aCollection on: aStream	"FileOut all methods with selectors taken from aCollection"	| cat categories |	categories := Dictionary new.	aCollection do:[:sel|		cat := self organization categoryOfElement: sel.		cat = self removedCategoryName ifFalse:[			(categories includesKey: cat) 				ifFalse:[categories at: cat put: Set new].			(categories at: cat) add: sel].	].	categories associationsDo:[:assoc|		cat := assoc key.		aStream cr; cr; nextPut:$!!; nextChunkPut:(String streamContents:[:s|			s nextPutAll: self fullName; nextPutAll:' methodsFor: '; print: cat asString]).		assoc value do:[:sel|			aStream cr.			aStream nextChunkPut: (self sourceCodeAt: sel).		].		aStream space; nextPut:$!!.	].! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutMethodsOn: aStream	^self fileOutMethods: self selectors on: aStream.! !!PseudoClass methodsFor: 'fileIn/fileOut'!fileOutOn: aStream	"FileOut the receiver"	self fileOutDefinitionOn: aStream.	metaClass ifNotNil:[metaClass fileOutDefinitionOn: aStream].	self fileOutMethods: self selectors on: aStream.	metaClass ifNotNil:[metaClass fileOutMethods: metaClass selectors on: aStream].! !!PseudoClass methodsFor: 'errors'!classNotDefined	^self inform: self name,' is not defined in the system.You have to define this class first.'.! !!PseudoClass methodsFor: 'categories'!removeCategory: selector	(self organization listAtCategoryNamed: selector) do:[:sel|		self organization removeElement: sel.		self sourceCode removeKey: sel.	].	self organization removeCategory: selector.! !!PseudoClass methodsFor: 'categories'!removedCategoryName	^'*** removed methods ***' asSymbol! !!PseudoClass methodsFor: 'categories'!whichCategoryIncludesSelector: aSelector 	"Answer the category of the argument, aSelector, in the organization of 	the receiver, or answer nil if the receiver does not inlcude this selector."	^ self organization categoryOfElement: aSelector! !!PseudoClass methodsFor: 'methods' stamp: 'sma 6/1/2000 14:54'!addMethodChange: aChangeRecord	| selector |	selector _ self parserClass new parseSelector: aChangeRecord string.	self organization classify: selector under: aChangeRecord category.	self sourceCodeAt: selector put: aChangeRecord! !!PseudoClass methodsFor: 'methods'!methodChange: aChangeRecord	aChangeRecord isMetaClassChange ifTrue:[		^self metaClass addMethodChange: aChangeRecord.	] ifFalse:[		^self addMethodChange: aChangeRecord.	].! !!PseudoClass methodsFor: 'methods'!removeMethod: selector	self organization removeElement: selector.	self sourceCode removeKey: selector.! !!PseudoClass methodsFor: 'methods'!removeSelector: aSelector	| catName |	catName := self removedCategoryName.	self organization addCategory: catName before: self organization categories first.	self organization classify: aSelector under: catName.	self sourceCodeAt: aSelector put:'methodWasRemoved' asText.! !!PseudoClass methodsFor: 'methods'!selectors	^self sourceCode keys! !!PseudoClass methodsFor: 'methods'!sourceCode	^source ifNil:[source := Dictionary new]! !!PseudoClass methodsFor: 'methods'!sourceCodeAt: sel	^(self sourceCode at: sel) string! !!PseudoClass methodsFor: 'methods'!sourceCodeAt: sel put: object	self sourceCode at: sel put: object! !!PseudoClass methodsFor: 'methods'!sourceCodeTemplate	^''! !!PseudoClass methodsFor: 'methods'!stampAt: selector	^(self sourceCode at: selector) stamp! !!PseudoClass methodsFor: 'printing' stamp: 'sma 6/17/1999 00:00'!literalScannedAs: scannedLiteral notifying: requestor 	^ scannedLiteral! !!PseudoClass methodsFor: 'testing method dictionary' stamp: 'sma 6/5/2000 10:26'!scopeHas: varName ifTrue: assocBlock	(self exists and: [self realClass scopeHas: varName ifTrue: assocBlock]) ifTrue: [^ true].	assocBlock value: (Smalltalk 		associationAt: varName asSymbol		ifAbsent: [^ false]).	^ true! !!PseudoClassOrganizer methodsFor: 'as yet unclassified' stamp: 'wod 4/15/98 17:08'!classComment	"Answer the comment associated with the object that refers to the receiver."	globalComment == nil ifTrue: [^''].	^globalComment! !!PseudoClassOrganizer methodsFor: 'as yet unclassified'!classComment: aChangeRecord	globalComment := aChangeRecord! !!PseudoClassOrganizer methodsFor: 'as yet unclassified'!setDefaultList: aCollection	super setDefaultList: aCollection.	self classComment: nil.! !!PseudoMetaclass methodsFor: 'accessing'!fullName	^self name,' class'! !!PseudoMetaclass methodsFor: 'accessing'!realClass	^super realClass class! !!PseudoMetaclass methodsFor: 'testing'!isMetaClass	^true! !I represent a particular kind of Rectangle that has a border and inside color.!!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 2/7/2000 15:34'!next: anInteger 	"Answer the next anInteger elements of my collection. Must override to get class right."	| newArray |	newArray _ (isBinary ifTrue: [ByteArray] ifFalse: [String]) new: anInteger.	^ self nextInto: newArray! !!RWBinaryOrTextStream methodsFor: 'as yet unclassified' stamp: 'tk 10/1/1998 11:54'!setFileTypeToObject	"do nothing.  We don't have a file type"! !This Random Number Generator graciously contributed by David N. Smith.  It is an adaptation of the Park-Miller RNG which uses Floats to avoid the need for LargeInteger arithmetic.!!Random methodsFor: 'initialization' stamp: 'di 8/6/1999 15:32'!initialize	" Set a reasonable Park-Miller starting seed "	[seed := (Time millisecondClockValue bitAnd: 16r3FFFFFFF) bitXor: self hash.	seed = 0] whileTrue: ["Try again if ever get a seed = 0"].	a := 16r000041A7 asFloat.    " magic constant =      16807 "	m := 16r7FFFFFFF asFloat.    " magic constant = 2147483647 "	q := (m quo: a) asFloat.	r  := (m \\ a) asFloat.! !!Random methodsFor: 'initialization' stamp: 'sma 5/12/2000 12:29'!seed: anInteger 	seed _ anInteger! !!Random methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:25'!next	"Answer a random Float in the interval [0 to 1)."	^ (seed _ self nextValue) / m! !!Random methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:45'!next: anInteger	^ self next: anInteger into: (Array new: anInteger)! !!Random methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:46'!next: anInteger into: anArray	1 to: anInteger do: [:index | anArray at: index put: self next].	^ anArray! !!Random methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:25'!nextInt: anInteger	"Answer a random integer in the interval [1, anInteger]."	^ (self next * anInteger) truncated + 1! !!Random methodsFor: 'die rolling' stamp: 'sma 5/12/2000 13:42'!check: nDice	"Roll some dice, WoD-style."	^ self check: nDice difficulty: 6! !!Random methodsFor: 'die rolling' stamp: 'sma 5/12/2000 13:47'!check: nAttack against: nDefend	"Roll some dice, WoD-style."	^ self check: nAttack against: nDefend difficulty: 6! !!Random methodsFor: 'die rolling' stamp: 'sma 5/12/2000 13:46'!check: nAttack against: nDefend difficulty: diff	"Roll some dice, WoD-style."	| attacks defends |	attacks _ self check: nAttack difficulty: diff.	attacks < 0 ifTrue: [^ attacks].	defends _ self check: nDefend difficulty: diff.	^ attacks - defends min: 0! !!Random methodsFor: 'die rolling' stamp: 'sma 5/12/2000 13:42'!check: nDice difficulty: diff	"Roll some dice, WoD-style."	| result die |	result _ 0.	nDice timesRepeat: 		[(die _ self nextInt: 10) = 1			ifTrue: [result _ result - 1]			ifFalse: [die >= diff ifTrue: [result _ result + 1]]].	^ result! !!Random methodsFor: 'die rolling' stamp: 'sma 5/12/2000 13:48'!diceToken: stream	"Private. Mini scanner, see #roll:"	stream atEnd ifTrue: [^ nil].	stream peek isDigit ifTrue: [^ Number readFrom: stream].	^ stream next asLowercase! !!Random methodsFor: 'private' stamp: 'sma 5/12/2000 12:28'!nextValue	"This method generates random instances of Integer 	in the interval	0 to 16r7FFFFFFF. This method does NOT update the seed; repeated sends	answer the same value.	The algorithm is described in detail in 'Random Number Generators: 	Good Ones Are Hard to Find' by Stephen K. Park and Keith W. Miller 	(Comm. Asso. Comp. Mach., 31(10):1192--1201, 1988)."	| lo hi aLoRHi answer |	hi _ (seed quo: q) asFloat.	lo _ seed - (hi * q).  " = seed rem: q"  	aLoRHi _ (a * lo) - (r * hi).	answer _ (aLoRHi > 0.0)		ifTrue:  [aLoRHi]		ifFalse: [aLoRHi + m].	^ answer! !!Random methodsFor: 'private' stamp: 'sma 5/12/2000 12:43'!seed	^ seed! !!Random class methodsFor: 'examples' stamp: 'sma 5/12/2000 12:39'!example	"If you just want a quick random integer, use:		10 atRandom	Every integer interval can give a random number:		(6 to: 12) atRandom	SequenceableCollections can give randomly selected elements:		'pick one of these letters randomly' atRandom	SequenceableCollections also respond to shuffled, as in:		($A to: $Z) shuffled	The correct way to use class Random is to store one in 	an instance or class variable:		myGenerator _ Random new.	Then use it every time you need another number between 0.0 and 1.0 (excluding)		myGenerator next	You can also generate a positive integer		myGenerator nextInt: 10"! !!Random class methodsFor: 'instance creation' stamp: 'sma 5/12/2000 12:41'!seed: anInteger	^ self new initialize seed: anInteger! !I represent an accessor for a sequence of objects that can only read objects from the sequence.!!ReadStream methodsFor: 'accessing'!next	"Primitive. Answer the next object in the Stream represented by the	receiver. Fail if the collection of this stream is not an Array or a String.	Fail if the stream is positioned at its end, or if the position is out of	bounds in the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 65>	position >= readLimit		ifTrue: [^nil]		ifFalse: [^collection at: (position _ position + 1)]! !!ReadStream methodsFor: 'accessing' stamp: 'ls 8/16/1998 00:46'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for efficiency"	| ans endPosition |	endPosition _ position + anInteger  min:  readLimit.	ans _ collection copyFrom: position+1 to: endPosition.	position _ endPosition.	^ans! !!ReadStream methodsFor: 'accessing' stamp: 'ar 12/23/1999 15:01'!next: n into: aCollection startingAt: startIndex	"Read n objects into the given collection. 	Return aCollection or a partial copy if less than	n elements have been read."	| max |	max _ (readLimit - position) min: n.	aCollection 		replaceFrom: startIndex 		to: startIndex+max-1		with: collection		startingAt: position+1.	position _ position + max.	max = n		ifTrue:[^aCollection]		ifFalse:[^aCollection copyFrom: 1 to: startIndex+max-1]! !!ReadStream methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:20'!size	"Compatibility with other streams (e.g., FileStream)"	^readLimit! !!ReadStream methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:59'!upTo: anObject	"fast version using indexOf:"	| start end |	start _ position+1.	end _ collection indexOf: anObject startingAt: start ifAbsent: [ 0 ].	"not present--return rest of the collection"		end = 0 ifTrue: [ ^self upToEnd ].	"skip to the end and return the data passed over"	position _ end.	^collection copyFrom: start to: (end-1)! !!ReadStream methodsFor: 'accessing' stamp: 'ls 9/12/1998 00:59'!upToEnd	| start |	start _ position+1.	position _ collection size.	^collection copyFrom: start to: position! !I represent an accessor for a sequence of objects. My instances can both read and store objects.!!ReadWriteStream methodsFor: 'accessing' stamp: 'ls 8/16/1998 00:47'!next: anInteger 	"Answer the next anInteger elements of my collection.  overriden for efficiency"	| ans endPosition |	endPosition _ position + anInteger  min:  readLimit.	ans _ collection copyFrom: position+1 to: endPosition.	position _ endPosition.	^ans! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'di 5/25/1998 15:25'!checkForPreamble: chunk	((chunk beginsWith: '"Change Set:') and: [Smalltalk changes preambleString == nil])		ifTrue: [Smalltalk changes preambleString: chunk].	((chunk beginsWith: '"Postscript:') and: [Smalltalk changes postscriptString == nil])		ifTrue: [Smalltalk changes postscriptString: chunk].							! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'sw 11/19/1998 16:31'!fileIn	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation."	^ self fileInAnnouncing: 'Reading ' , self name! !!ReadWriteStream methodsFor: 'fileIn/Out' stamp: 'sw 11/19/1998 16:29'!fileInAnnouncing: announcement	"This is special for reading expressions from text that has been formatted 	with exclamation delimitors. The expressions are read and passed to the 	Compiler. Answer the result of compilation.  Put up a progress report with     the given announcement as the title."	| val chunk |	announcement displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during:		[:bar |		[self atEnd]			whileFalse: 				[bar value: self position.				self skipSeparators.				val _ (self peekFor: $!!)					ifTrue: [(Compiler evaluate: self nextChunk logged: false)								scanFrom: self]					ifFalse: [chunk _ self nextChunk.							self checkForPreamble: chunk.							Compiler evaluate: chunk logged: true].				self skipStyleChunk].		self close].	^ val! !Responsible for real-estate management on the screen, which is to say, controlling where new windows appear, with what sizes, etc.  5/20/96 sw!!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jm 5/29/2003 19:23'!assignCollapseFrameFor: aSSView 	"Offer up a location along the left edge of the screen for a collapsed SSView. Make sure it doesn't overlap any other collapsed frames."	| grid otherFrames topLeft viewBox collapsedFrame extent newFrame verticalBorderDistance top |	grid _ 8.	verticalBorderDistance _ 8.	Smalltalk isMorphic		ifTrue: 			[otherFrames _ ((SystemWindow windowsIn: World satisfying: [:w | w ~= aSSView])						collect: [:w | w collapsedFrame])							select: [:rect | rect notNil].			viewBox _ World viewBox]		ifFalse: 			[otherFrames _ (ScheduledControllers scheduledWindowControllers						collect: [:aController | aController view ~= aSSView ifTrue: [aController view collapsedFrame]])							select: [:rect | rect notNil].			viewBox _ Display boundingBox].	collapsedFrame _ aSSView collapsedFrame.	extent _ collapsedFrame notNil				ifTrue: [collapsedFrame extent]				ifFalse: [Smalltalk isMorphic					ifTrue: [aSSView getRawLabel width + aSSView labelWidgetAllowance @ (aSSView labelHeight + 2)]					ifFalse: [(aSSView labelText extent x + 70) @ aSSView labelHeight							min: aSSView labelDisplayBox extent					]				].	collapsedFrame notNil		ifTrue: [(otherFrames anySatisfy: [:f | collapsedFrame intersects: f])				ifFalse: ["non overlapping"					^ collapsedFrame]].	top _ viewBox top + verticalBorderDistance.	[topLeft _ viewBox left @ top.	newFrame _ topLeft extent: extent.	newFrame bottom <= (viewBox height - verticalBorderDistance)]		whileTrue: 			[(otherFrames anySatisfy: [:w | newFrame intersects: w])				ifFalse: ["no overlap"					^ newFrame].			top _ top + grid].	"If all else fails... (really to many wins here)"	^ 0 @ 0 extent: extent! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jm 5/29/2003 19:23'!assignCollapsePointFor: aSSView	"Offer up a location along the left edge of the screen for a collapsed SSView.	Make sure it doesn't overlap any other collapsed frames."	| grid otherFrames y free topLeft viewBox |	grid _ 24.  "should be mult of 8, since manual move is gridded by 8"	Smalltalk isMorphic		ifTrue: [otherFrames _ ((SystemWindow windowsIn: World satisfying: [:w | true])					collect: [:w | w collapsedFrame])						select: [:rect | rect notNil].				viewBox _ World viewBox]		ifFalse: [otherFrames _ (ScheduledControllers scheduledWindowControllers					collect: [:aController | aController view collapsedFrame])						select: [:rect | rect notNil].				viewBox _ Display boundingBox].	y _ viewBox top.	[(y _ y + grid) <= (viewBox height - grid)]		whileTrue:		[topLeft _ viewBox left@y.		free _ true.		otherFrames do: [:w | free _ free & (topLeft ~= w topLeft)].		free ifTrue: [^ topLeft]].	"If all else fails..."	^ 0 @ 0! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 8/10/1999 11:57'!initialFrameFor: aView	"Find a plausible initial screen area for the supplied view.  See called method."	^ self initialFrameFor: aView initialExtent: aView initialExtent! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:49'!initialFrameFor: aView initialExtent: initialExtent	"Find a plausible initial screen area for the supplied view, which should be a StandardSystemView, taking into account the 'reverseWindowStagger' Preference, the size needed, and other windows currently on the screen."	| allOrigins screenRight screenBottom putativeOrigin putativeFrame allowedArea staggerOrigin otherFrames |	Preferences reverseWindowStagger ifTrue:		[^ self strictlyStaggeredInitialFrameFor: aView initialExtent: initialExtent].	allowedArea _ self maximumUsableArea.	screenRight _ allowedArea right.	screenBottom _ allowedArea bottom.	otherFrames _ Smalltalk isMorphic		ifTrue: [(SystemWindow windowsIn: World satisfying: [:w | w isCollapsed not])					collect: [:w | w bounds]]		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	allOrigins _ otherFrames collect: [:f | f origin].	self standardPositions do:  "First see if one of the standard positions is free"		[:aPosition | (allOrigins includes: aPosition)			ifFalse:				[^ (aPosition extent: initialExtent) squishedWithin: allowedArea]].	staggerOrigin _ self standardPositions first.  "Fallback: try offsetting from top left"	putativeOrigin _ staggerOrigin.	[putativeOrigin _ putativeOrigin + StaggerOffset.	putativeFrame _ putativeOrigin extent: initialExtent.	(putativeFrame bottom < screenBottom) and:					[putativeFrame right < screenRight]]				whileTrue:					[(allOrigins includes: putativeOrigin)						ifFalse:							[^ (putativeOrigin extent: initialExtent) squishedWithin: allowedArea]].	^ (self scrollBarSetback @ self screenTopSetback extent: initialExtent) squishedWithin: allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'tk 11/26/1998 09:34'!initialize	"Initialize the class variables in the receiver.  5/22/96 sw"	"RealEstateAgent initialize"	StaggerOffset _ 6 @ 20.	ReverseStaggerOffset _ -6 @ 20.	StaggerOrigin _ 200 @ 30.	StandardSize _ 600@400.! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'jm 12/2/2003 18:04'!maximumUsableArea	| allowedArea |	allowedArea _ Display boundingBox deepCopy.	Smalltalk isMorphic ifTrue: [allowedArea _ allowedArea intersect: World viewBox].	^ allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 20:58'!screenTopSetback	Smalltalk isMorphic		ifTrue: [^ 0]		ifFalse: [^ 18]! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'di 9/22/1998 20:58'!scrollBarSetback	Smalltalk isMorphic		ifTrue: [^ 16-3]  "width = 16; inset from border by 3"		ifFalse: [^ 24]! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:49'!standardPositions	"Return a list of standard window positions -- this may have one, two, or four of them, depending on the size and shape of the display screen.  "	| anArea aList  midX midY |	anArea _ self maximumUsableArea.	midX _ self scrollBarSetback +   ((anArea width - self scrollBarSetback)  // 2).	midY _ self screenTopSetback + ((anArea height - self screenTopSetback) // 2).	aList _ OrderedCollection with: (self scrollBarSetback @ self screenTopSetback).	self windowColumnsDesired > 1		ifTrue:			[aList add: (midX @ self screenTopSetback)].	self windowRowsDesired > 1		ifTrue:			[aList add: (self scrollBarSetback @ (midY+self screenTopSetback)).			self windowColumnsDesired > 1 ifTrue:				[aList add: (midX @ (midY+self screenTopSetback))]].	^ aList! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:55'!standardWindowExtent	"Answer the standard default extent for new windows.  "	| effectiveExtent width strips height grid allowedArea maxLevel |	effectiveExtent _ self maximumUsableArea extent					- (self scrollBarSetback @ self screenTopSetback).	Preferences reverseWindowStagger ifTrue:		["NOTE: following copied from strictlyStaggeredInitialFrameFor:"		allowedArea _ self maximumUsableArea insetBy: (			self scrollBarSetback @ self screenTopSetback extent: 0@0		).		"Number to be staggered at each corner (less on small screens)"		maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].		"Amount by which to stagger (less on small screens)"		grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].		^ (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))) min: StandardSize "600@400"].	width _ (strips _ self windowColumnsDesired) > 1		ifTrue:			[effectiveExtent x // strips]		ifFalse:			[(3 * effectiveExtent x) // 4].	height _ (strips _ self windowRowsDesired) > 1		ifTrue:			[effectiveExtent y // strips]		ifFalse:			[(3 * effectiveExtent y) //4].	^ width @ height"RealEstateAgent standardWindowExtent"! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:53'!strictlyStaggeredInitialFrameFor: aStandardSystemView initialExtent: initialExtent	"This method implements a staggered window placement policy that I like.	Basically it provides for up to 4 windows, staggered from each of the 4 corners.	The windows are staggered so that there will always be a corner visible.	"	| allowedArea grid initialFrame otherFrames cornerSel corner delta putativeCorner free maxLevel |	allowedArea _ self maximumUsableArea insetBy: (		self scrollBarSetback @ self screenTopSetback extent: 0@0	).	"Number to be staggered at each corner (less on small screens)"	maxLevel _ allowedArea area > 300000 ifTrue: [3] ifFalse: [2].	"Amount by which to stagger (less on small screens)"	grid _ allowedArea area > 500000 ifTrue: [40] ifFalse: [20].	initialFrame _ 0@0 extent: ((initialExtent							"min: (allowedArea extent - (grid*(maxLevel+1*2) + (grid//2))))							min: 600@400")).	otherFrames _ Smalltalk isMorphic		ifTrue: [(SystemWindow windowsIn: World satisfying: [:w | w isCollapsed not])					collect: [:w | w bounds]]		ifFalse: [ScheduledControllers scheduledWindowControllers				select: [:aController | aController view ~~ nil]				thenCollect: [:aController | aController view isCollapsed								ifTrue: [aController view expandedFrame]								ifFalse: [aController view displayBox]]].	0 to: maxLevel do:		[:level | 		1 to: 4 do:			[:ci | cornerSel _ #(topLeft topRight bottomRight bottomLeft) at: ci.			corner _ allowedArea perform: cornerSel.			"The extra grid//2 in delta helps to keep title tabs distinct"			delta _ (maxLevel-level*grid+(grid//2)) @ (level*grid).			1 to: ci-1 do: [:i | delta _ delta rotateBy: #right centerAt: 0@0]. "slow way"			putativeCorner _ corner + delta.			free _ true.			otherFrames do:				[:w |				free _ free & ((w perform: cornerSel) ~= putativeCorner)].			free ifTrue:				[^ (initialFrame align: (initialFrame perform: cornerSel)								with: putativeCorner)						 squishedWithin: allowedArea]]].	"If all else fails..."	^ (self scrollBarSetback @ self screenTopSetback extent: initialFrame extent)		squishedWithin: allowedArea! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:54'!windowColumnsDesired	"Answer how many separate vertical columns of windows are wanted.  5/22/96 sw"	^ Preferences reverseWindowStagger		ifTrue:			[1]		ifFalse:			[(self maximumUsableArea width > 640)				ifTrue:					[2]				ifFalse:					[1]]! !!RealEstateAgent class methodsFor: 'as yet unclassified' stamp: 'RAA 11/21/1999 22:54'!windowRowsDesired	"Answer how many separate horizontal rows of windows are wanted.  5/22/96 sw"	^ Preferences reverseWindowStagger		ifTrue:			[1]		ifFalse:			[(self maximumUsableArea height > 480)				ifTrue:					[2]				ifFalse:					[1]]! !I am a simple interface for recording sounds.!!RecordingControlsMorph methodsFor: 'initialization' stamp: 'jm 6/15/2003 20:23'!addButtonRows	| r |	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Record' action: #record).	r addMorphBack: (Morph new extent: 4@1; color: color).	r addMorphBack: (self buttonName: 'Stop' action: #stop).	r addMorphBack: (Morph new extent: 4@1; color: color).	r addMorphBack: self makeStatusLight.	self addMorphBack: r.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Play' action: #playback).	r addMorphBack: (Morph new extent: 4@1; color: color).	r addMorphBack: (self buttonName: 'Trim' action: #trim).	r addMorphBack: (Morph new extent: 4@1; color: color).	r addMorphBack: (self buttonName: 'Edit' action: #showSamples).	self addMorphBack: r.! !!RecordingControlsMorph methodsFor: 'initialization' stamp: 'jm 7/4/1998 14:43'!initialize	| r |	super initialize.	borderWidth _ 2.	orientation _ #vertical.	recorder _ SoundRecorder new.	self addButtonRows.	self addRecordLevelSlider.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: self makeRecordMeter.	self addMorphBack: r.	self extent: 10@10.  "make minimum size"! !!RecordingControlsMorph methodsFor: 'button commands' stamp: 'jm 6/15/2003 19:48'!showSamples	"Show my samples in a SimpleWaveEditor."	| ed w |	recorder pause.	ed _ SimpleWaveEditor new.	ed data: recorder condensedSamples.	ed samplingRate: recorder samplingRate.	w _ self world.	w activeHand		ifNil: [w addMorph: ed]		ifNotNil: [w activeHand attachMorph: ed].! !!RecordingControlsMorph methodsFor: 'stepping' stamp: 'tk 6/24/1999 11:41'!startStepping	"Make the level meter active when dropped into the world. Do nothing if already recording. Note that this will cause other recorders to stop recording..."	super startStepping.	recorder isPaused ifTrue: [		SoundRecorder allSubInstancesDo: [:r | r stopRecording].  "stop all other sound recorders"		recorder pause].  "meter is updated while paused"! !!RecordingControlsMorph methodsFor: 'other' stamp: 'jm 7/4/1998 14:49'!addRecordLevelSlider	| levelSlider r |	levelSlider _ SimpleSliderMorph new		color: color;		extent: 100@2;		target: recorder;		actionSelector: #recordLevel:;		adjustToValue: recorder recordLevel.	r _ AlignmentMorph newRow		color: color;		inset: 0;		centering: #center;		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: '0 ').	r addMorphBack: levelSlider.	r addMorphBack: (StringMorph contents: ' 10').	self addMorphBack: r.! !!RecordingControlsMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:03'!includeInNewMorphMenu	^ true! !I represent a rectangular area of the screen. Arithmetic functions take points as arguments and carry out scaling and translating operations to create new instances of me. Rectangle functions create new instances by determining intersections of rectangles with rectangles.!!Rectangle methodsFor: 'accessing' stamp: 'acg 2/23/2000 00:52'!aboveCenter	"Answer the point slightly above the center of the receiver."	^self topLeft + self bottomRight // (2@3)! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/22/1998 16:11'!adjustTo: newRect along: side 	"Return a copy adjusted to fit a neighbor that has changed size."	side = #left ifTrue: [^ self withRight: newRect left].	side = #right ifTrue: [^ self withLeft: newRect right].	side = #top ifTrue: [^ self withBottom: newRect top].	side = #bottom ifTrue: [^ self withTop: newRect bottom].! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 16:00'!bordersOn: her along: herSide 	(herSide = #right and: [self left = her right])	| (herSide = #left and: [self right = her left])		ifTrue:		[^ (self top max: her top) < (self bottom min: her bottom)].	(herSide = #bottom and: [self top = her bottom])	| (herSide = #top and: [self bottom = her top])		ifTrue:		[^ (self left max: her left) < (self right min: her right)].	^ false! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 16:11'!forPoint: aPoint closestSideDistLen: sideDistLenBlock	"Evaluate the block with my side (symbol) closest to aPoint,		the approx distance of aPoint from that side, and		the length of the side (or 0 if aPoint is beyond the side)"	| side |	side _ self sideNearestTo: aPoint.	side == #right ifTrue:		[^ sideDistLenBlock value: side value: (self right - aPoint x) abs			value: ((aPoint y between: self top and: self bottom)						ifTrue: [self height] ifFalse: [0])].	side == #left ifTrue:		[^ sideDistLenBlock value: side value: (self left - aPoint x) abs			value: ((aPoint y between: self top and: self bottom)						ifTrue: [self height] ifFalse: [0])].	side == #bottom ifTrue:		[^ sideDistLenBlock value: side value: (self bottom - aPoint y) abs			value: ((aPoint x between: self left and: self right)						ifTrue: [self width] ifFalse: [0])].	side == #top ifTrue:		[^ sideDistLenBlock value: side value: (self top - aPoint y) abs			value: ((aPoint x between: self left and: self right)						ifTrue: [self width] ifFalse: [0])].! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 10/21/1998 15:09'!sideNearestTo: aPoint	| distToLeft distToRight distToTop distToBottom closest side |	distToLeft _ aPoint x - self left.	distToRight _ self right - aPoint x.	distToTop _ aPoint y - self top.	distToBottom _ self bottom - aPoint y.	closest _ distToLeft. side _ #left.	distToRight < closest ifTrue: [closest _ distToRight. side _ #right].	distToTop < closest ifTrue: [closest _ distToTop. side _ #top].	distToBottom < closest ifTrue: [closest _ distToBottom. side _ #bottom].	^ side" | r | r _ Rectangle fromUser.Display border: r width: 1.[Sensor anyButtonPressed] whileFalse:	[(r sideNearestTo: Sensor cursorPoint) , '      ' displayAt: 0@0]"! !!Rectangle methodsFor: 'rectangle functions' stamp: 'di 9/8/1999 21:25'!withSideOrCorner: side setToPoint: newPoint	"Return a copy with side set to newPoint"	^ self withSideOrCorner: side setToPoint: newPoint minExtent: 0@0! !!Rectangle methodsFor: 'rectangle functions' stamp: 'bf 9/10/1999 16:16'!withSideOrCorner: side setToPoint: newPoint minExtent: minExtent	"Return a copy with side set to newPoint"	^self withSideOrCorner: side setToPoint: newPoint minExtent: minExtent		limit: ((#(left top) includes: side) ifTrue: [SmallInteger minVal] ifFalse: [SmallInteger maxVal])! !!Rectangle methodsFor: 'rectangle functions' stamp: 'bf 9/10/1999 16:07'!withSideOrCorner: side setToPoint: newPoint minExtent: minExtent limit: limit	"Return a copy with side set to newPoint"	side = #top ifTrue: [^ self withTop: (newPoint y min: corner y - minExtent y max: limit + minExtent y)].	side = #bottom ifTrue: [^ self withBottom: (newPoint y min: limit - minExtent y max: origin y + minExtent y)].	side = #left ifTrue: [^ self withLeft: (newPoint x min: corner x - minExtent x max: limit + minExtent x)].	side = #right ifTrue: [^ self withRight: (newPoint x min: limit - minExtent x max: origin x + minExtent x)].	side = #topLeft ifTrue: [^ (newPoint min: corner - minExtent) corner: self bottomRight].	side = #bottomRight ifTrue: [^ self topLeft corner: (newPoint max: origin + minExtent)].	side = #bottomLeft ifTrue: [^ self topRight rect: ((newPoint x min: corner x - minExtent x) @ (newPoint y max: origin y + minExtent y))].	side = #topRight ifTrue: [^ self bottomLeft rect: ((newPoint x max: origin x + minExtent x) @ (newPoint y min: corner y - minExtent y))].! !!Rectangle methodsFor: 'testing' stamp: 'jm 6/17/1999 19:40'!intersects: aRectangle 	"Answer whether aRectangle intersects the receiver anywhere."	"Optimized; old code answered:		(origin max: aRectangle origin) < (corner min: aRectangle corner)"	| rOrigin rCorner |	rOrigin _ aRectangle origin.	rCorner _ aRectangle corner.	rCorner x < origin x		ifTrue: [^ false].	rCorner y < origin y		ifTrue: [^ false].	rOrigin x > corner x		ifTrue: [^ false].	rOrigin y > corner y	ifTrue: [^ false].	^ true! !!Rectangle methodsFor: 'truncation and round off' stamp: 'jm 5/29/1998 15:53'!truncated	"Answer a Rectangle whose origin and corner have any fractional parts removed. Answer the receiver if its coordinates are already integral."	(origin x isInteger and:	[origin y isInteger and:	[corner x isInteger and:	[corner y isInteger]]])		ifTrue: [^ self].	^ Rectangle origin: origin truncated corner: corner truncated! !I am a simple rectangle with a border.!!RectangleMorph methodsFor: 'initialization' stamp: 'jm 10/9/2002 06:06'!initialize	super initialize.	color _ Color gray.! !!RectangleMorph class methodsFor: 'as yet unclassified' stamp: 'jm 5/31/2003 20:02'!includeInNewMorphMenu	^ true! !!RemoteString methodsFor: 'accessing' stamp: 'hmm 4/26/2000 21:28'!setSourcePointer: aSourcePointer	sourceFileNumber _ SourceFiles fileIndexFromSourcePointer: aSourcePointer.	filePositionHi _ SourceFiles filePositionFromSourcePointer: aSourcePointer! !!RemoteString methodsFor: 'accessing' stamp: 'hmm 4/26/2000 20:47'!sourcePointer	sourceFileNumber ifNil: [^ 0].	^SourceFiles sourcePointerFromFileIndex: sourceFileNumber andPosition: filePositionHi! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 6/30/1998 18:28'!reset	super reset.	sound reset.	samplesPerIteration _ sound samplesRemaining.	iterationCount == #forever		ifTrue: [iteration _ 1]		ifFalse: [iteration _ iterationCount].! !!RepeatingSound methodsFor: 'sound generation' stamp: 'jm 1/18/1999 10:31'!samplesRemaining	iterationCount == #forever ifTrue: [^ 1000000].	iteration > 0		ifTrue: [^ sound samplesRemaining + ((iteration - 1) * samplesPerIteration)]		ifFalse: [^ 0].! !!RepeatingSound class methodsFor: 'car motor example' stamp: 'jm 1/29/1999 10:01'!carMotorSound	"Return a repeating sound for the sound of a car engine."	"RepeatingSound carMotorSound play"	^ self carMotorSound: 10.0! !!RepeatingSound class methodsFor: 'car motor example' stamp: 'jm 1/29/1999 09:32'!carMotorSound: speed	"Return a repeating sound for the sound of a car engine running at the given speed."	"(RepeatingSound carMotorSound: 2.0) play"	CarMotorSamples ifNil: [self initializeCarMotor].	^ RepeatingSound repeatForever:		((LoopedSampledSound			unloopedSamples: CarMotorSamples			pitch: 20.0			samplingRate: 22050)				setPitch: speed dur: 100.0 loudness: 1.0)! !!RestSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:07'!duration	"Answer the duration of this sound in seconds."	^ initialCount asFloat / self samplingRate! !!RestSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:42'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!RestSound methodsFor: 'accessing' stamp: 'jm 4/20/2003 20:13'!gain	^ 1.0! !!RestSound methodsFor: 'accessing' stamp: 'di 2/17/1999 21:09'!samples	^ SoundBuffer newMonoSampleCount: initialCount! !!RestSound class methodsFor: 'instance creation' stamp: 'jm 3/31/1999 21:05'!dur: d	"Return a rest of the given duration."	^ self new setDur: d! !I represent an expression of the form ^expr.!I'm a translucent rectangle that displays its current width and height. I'm useful as a way to measure the size of objects on the screen.!!RulerMorph methodsFor: 'drawing' stamp: 'jm 6/15/2003 12:03'!initialize	super initialize.	self color: ((Color r: 0.8 g: 1.0 b: 1.0) alpha: 0.3).	self borderWidth: 1.! !!RulerMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:07'!includeInNewMorphMenu	^ true! !!RunArray methodsFor: 'accessing' stamp: 'di 1/15/1999 00:04'!= otherArray 	"Test if all my elements are equal to those of otherArray"	(otherArray isMemberOf: RunArray) ifFalse: [^ self hasEqualElements: otherArray].	"Faster test between two RunArrays" 	^ (runs hasEqualElements: otherArray runs)		and: [values hasEqualElements: otherArray values]! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:16'!addFirst: value	"Add value as the first element of the receiver."	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values first ~= value])	  ifTrue:		[runs addFirst: 1.		values addFirst: value]	  ifFalse:		[runs at: 1 put: runs first+1]! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:18'!addLast: value	"Add value as the last element of the receiver."	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values last ~= value])	  ifTrue:		[runs addLast: 1.		values addLast: value]	  ifFalse:		[runs at: runs size put: runs last+1]! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:18'!addLast: value  times: times	"Add value as the last element of the receiver, the given number of times"	times = 0 ifTrue: [ ^self ].	lastIndex _ nil.  "flush access cache"	(runs size=0 or: [values last ~= value])	  ifTrue:		[runs add: times.		values add: value]	  ifFalse:		[runs at: runs size put: runs last+times]! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:18'!repeatLast: times  ifEmpty: defaultBlock	"add the last value back again, the given number of times.  If we are empty, add (defaultBlock value)"	times = 0 ifTrue: [^self ].	lastIndex _ nil.  "flush access cache"	(runs size=0)	  ifTrue:		[runs addLast: times.		values addLast: defaultBlock value]	  ifFalse:		[runs at: runs size put: runs last+times] ! !!RunArray methodsFor: 'adding' stamp: 'ls 8/20/1998 10:18'!repeatLastIfEmpty: defaultBlock	"add the last value back again.  If we are empty, add (defaultBlock value)"	lastIndex _ nil.  "flush access cache"	(runs size=0)	  ifTrue:[		 runs addLast: 1.		values addLast: defaultBlock value]	  ifFalse:		[runs at: runs size put: runs last+1]! !!RunArray methodsFor: 'copying' stamp: 'ls 10/10/1999 13:15'!copyFrom: start to: stop	| newRuns run1 run2 offset1 offset2 | 	stop < start ifTrue: [^RunArray new].	self at: start setRunOffsetAndValue: [:r :o :value1 | run1 _ r. offset1_ o.  value1].	self at: stop setRunOffsetAndValue: [:r :o :value2 | run2 _ r. offset2_ o. value2].	run1 = run2		ifTrue: 			[newRuns _ Array with: offset2 - offset1 + 1]		ifFalse: 			[newRuns _ runs copyFrom: run1 to: run2.			newRuns at: 1 put: (newRuns at: 1) - offset1.			newRuns at: newRuns size put: offset2 + 1].	^RunArray runs: newRuns values: (values copyFrom: run1 to: run2)! !!RunArray methodsFor: 'printing' stamp: 'sma 6/1/2000 09:47'!printOn: aStream	self printNameOn: aStream.	aStream		nextPutAll: ' runs: ';		print: runs;		nextPutAll: ' values: ';		print: values! !!RunArray methodsFor: 'printing' stamp: 'jm 1/1/2004 18:59'!writeOn: aStream	aStream uint16: runs size.	1 to: runs size do: [:x |		aStream uint16: (runs at: x).		aStream uint16: (values at: x)].! !!RunArray methodsFor: 'enumerating' stamp: 'ar 12/27/1999 13:43'!runsAndValuesDo: aBlock	"Evaluate aBlock with run lengths and values from the receiver"	^runs with: values do: aBlock.! !!RunArray class methodsFor: 'instance creation' stamp: 'ls 8/20/1998 10:12'!new	^self runs: OrderedCollection new values: OrderedCollection new! !!RunArray class methodsFor: 'instance creation' stamp: 'ls 8/20/1998 10:12'!new: size withAll: value 	"Answer a new instance of me, whose every element is equal to the	argument, value."	size = 0 ifTrue: [^self new].	^self runs: (OrderedCollection with: size) values: (OrderedCollection with: value)! !!RunArray class methodsFor: 'instance creation' stamp: 'jm 1/1/2004 19:00'!readFrom: aStream	"Answer an instance of me as described on the stream, aStream."	| size runs values |	size _ aStream uint16.	runs _ Array new: size.	values _ Array new: size.	1 to: size do: [:x |		runs at: x put: aStream uint16.		values at: x put: aStream uint16].	^ self runs: runs values: values! !!RunArray class methodsFor: 'instance creation' stamp: 'tk 1/13/1999 08:28'!scanFrom: strm	"Read the style section of a fileOut or sources file.  nextChunk has already been done.  We need to return a RunArray of TextAttributes of various kinds."	| rr vv aa this |	(strm peekFor: $( ) ifFalse: [^ nil].	rr _ OrderedCollection new.	[strm skipSeparators.	 strm peekFor: $)] whileFalse: 		[rr add: (Number readFrom: strm)].	vv _ OrderedCollection new.	"Value array"	aa _ OrderedCollection new.	"Attributes list"	[(this _ strm next) == nil] whileFalse: [		this == $, ifTrue: [vv add: aa asArray.  aa _ OrderedCollection new].		this == $f ifTrue: [aa add: 			(TextFontChange new fontNumber: (Number readFrom: strm))].		this == $b ifTrue: [aa add: (TextEmphasis bold)].		this == $i ifTrue: [aa add: (TextEmphasis italic)].		this == $u ifTrue: [aa add: (TextEmphasis underlined)].		this == $= ifTrue: [aa add: (TextEmphasis struckOut)].		this == $n ifTrue: [aa add: (TextEmphasis normal)].		this == $- ifTrue: [aa add: (TextKern kern: -1)].		this == $+ ifTrue: [aa add: (TextKern kern: 1)].		this == $c ifTrue: [aa add: (TextColor scanFrom: strm)]. "color"		this == $L ifTrue: [aa add: (TextLink scanFrom: strm)].	"L not look like 1"		this == $R ifTrue: [aa add: (TextURL scanFrom: strm)].				"R capitalized so it can follow a number"		this == $q ifTrue: [aa add: (TextSqkPageLink scanFrom: strm)].		this == $d ifTrue: [aa add: (TextDoIt scanFrom: strm)].		"space, cr do nothing"		].	aa size > 0 ifTrue: [vv add: aa asArray].	^ self runs: rr asArray values: vv asArray"RunArray scanFrom: (ReadStream on: '(14 50 312)f1,f1b,f1LInteger +;i')"! !This class implements the SMTP (mail sending) protocol specified in RFC 821.Note that it does not look up DNS MX records when sending to the specified host, so it will not work correctly to send directly to large structured domain names like "intel.com" or "microsoft.com", but it will work fine for talking with your local mail server which will then pass along the mail to the real destination.Note also that the error reporting is done with error: and so an exception handler must be wrapped around the sending call in case it fails.!!SMTPSocket methodsFor: 'low-level protocol' stamp: 'jm 10/14/1998 12:52'!connectToSMTPServer: serverName	"connect to the given server on the SMTP port"	| addr |	Socket initializeNetwork.	addr _ NetNameResolver addressForName: serverName.	addr ifNil: [self error: 'Could not find host address'].	Transcript show: 'connecting to ', serverName, '...'.	self connectTo: addr  port: 25.	self waitForConnectionUntil: Socket standardDeadline.	self isConnected ifFalse: [		^false ].	self checkSMTPResponse.	self sendCommand: 'HELO aSqueakSystem'.	self checkSMTPResponse.	^true! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'jm 5/24/2003 13:36'!data: messageData	"send the data of a message"	| cookedLine |	"inform the server we are sending the message data"	self sendCommand: 'DATA'.	self checkSMTPResponse.	"process the data one line at a time"	messageData lines do:  [ :messageLine |		cookedLine _ messageLine.		(cookedLine beginsWith: '.') ifTrue: [ 			"lines beginning with a dot must have the dot doubled"			cookedLine _ '.', cookedLine ].		self sendCommand: cookedLine ].	"inform the server the entire message text has arrived"	self sendCommand: '.'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:13'!getSMTPResponse	"wait for an SMTP response, and return the number of the response"	| line |	[ line _ self getResponse.	Transcript show: line.	(line at: 4) = $- ] whileTrue.	^(line copyFrom: 1 to: 3) asNumber! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:21'!mailFrom: fromAddress	self sendCommand: 'MAIL FROM: <', fromAddress, '>'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:31'!quit	"send a QUIT command.  This is polite to do, and indeed some servers might drop messages that don't have an associated QUIT"	self sendCommand: 'QUIT'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'low-level protocol' stamp: 'ls 9/10/1998 22:20'!recipient: aRecipient	"specify a recipient for the message.  aRecipient should be a bare email address"	self sendCommand: 'RCPT TO: <', aRecipient, '>'.	self checkSMTPResponse.! !!SMTPSocket methodsFor: 'private' stamp: 'ls 9/10/1998 22:37'!checkSMTPResponse	"get an SMTP response, and check that it's in the 200's or 300's.  If it's not, close the socket and issue an error:"	(#(2 3) includes: self getSMTPResponse // 100) ifFalse: [		self close.		self error: 'server responded with an error' ].! !!SMTPSocket methodsFor: 'public protocol' stamp: 'mdr 10/12/1998 14:41'!mailFrom: sender to: recipientList text: messageText	"deliver this mail to a list of users.  NOTE: the recipient list should be a collection of simple internet style addresses -- no '<>' or '()' stuff"	self mailFrom: sender.	recipientList do: [ :recipient |		self recipient: recipient ].	self data: messageText.! !!SMTPSocket class methodsFor: 'sending mail' stamp: 'mdr 1/28/1999 16:42'!deliverMailFrom: fromAddress to: recipientList text: messageText usingServer: serverName	"Deliver a single email to a list of users and then close the connection.  For delivering multiple messages, it is best to create a single connection and send all mail over it.  NOTE: the recipient list should be a collection of simple internet style addresses -- no '<>' or '()' stuff"	| sock |	sock _ self usingServer: serverName.	sock mailFrom: fromAddress to: recipientList text: messageText.	sock quit.	sock close.	^true! !!SMTPSocket class methodsFor: 'examples' stamp: 'ls 9/10/1998 22:40'!example	"SMTPSocket example"	"send a message over SMTP"	self deliverMailFrom: 'lex@cc.gatech.edu' to: #(root src) text:'From: testTo: "not listed"Subject: this is a testHello from Squeak!!'	usingServer: 'localhost'.! !!SMTPSocket class methodsFor: 'examples' stamp: 'ls 9/10/1998 22:36'!example2	"SMTPSocket example2"	"send a message using the low-level protocol methods.  Normally one would just use the high-level class message"	| sock |	sock _ self new.	sock connectToSMTPServer: 'localhost'.	sock mailFrom: 'lex@cc.gatech.edu'.	sock recipient: 'lex@localhost'.	sock recipient: 'root'.	sock data:'From: testTo: "not listed"Subject: this is a testHi, this is a test message.'.	sock quit.	sock close.! !!SMTPSocket class methodsFor: 'instance creation' stamp: 'mdr 1/29/1999 18:59'!usingServer: serverName	"Create a SMTP socket to the specified server for sending one or more mail messages"	| sock |	Socket initializeNetwork.	sock _ self new.	sock connectToSMTPServer: serverName.	^sock! !I represent a collection of individual notes at different pitches, volumes, and articulations. On request, I can select the best note to use for a given pitch, duration, and volume. I currently only support two volumes, loud and soft, and two articulations, normal and staccato, but I can easily be extended to include more. The main barrier to keeping more variations is simply the memory space (assuming my component notes are sampled sounds).!!SampledInstrument methodsFor: 'accessing' stamp: 'jm 4/20/2003 19:53'!allKeyMaps: keyMap	sustainedSoft _ keyMap.	sustainedLoud _ keyMap.	staccatoSoft _ keyMap.	staccatoLoud _ keyMap.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/3/1998 17:30'!allSampleSets: sortedNotes	| keyMap |	keyMap _ self midiKeyMapFor: sortedNotes.	sustainedSoft _ keyMap.	sustainedLoud _ keyMap.	staccatoSoft _ keyMap.	staccatoLoud _ keyMap.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/3/1998 19:04'!initialize	sustainedThreshold _ 0.15.	loudThreshold _ 0.5.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:21'!loudThreshold	^ loudThreshold! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:22'!loudThreshold: aNumber	loudThreshold _ aNumber asFloat.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 10:02'!staccatoLoudAndSoftSampleSet: sortedNotes	staccatoLoud _ self midiKeyMapFor: sortedNotes.	staccatoSoft _ staccatoLoud.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!staccatoLoudSampleSet: sortedNotes	staccatoLoud _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!staccatoSoftSampleSet: sortedNotes	staccatoSoft _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!sustainedLoudSampleSet: sortedNotes	sustainedLoud _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/2/1998 09:54'!sustainedSoftSampleSet: sortedNotes	sustainedSoft _ self midiKeyMapFor: sortedNotes.! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:21'!sustainedThreshold	^ sustainedThreshold! !!SampledInstrument methodsFor: 'accessing' stamp: 'jm 8/4/1998 23:22'!sustainedThreshold: aNumber	sustainedThreshold _ aNumber asFloat.! !!SampledInstrument methodsFor: 'playing' stamp: 'jm 8/3/1998 18:53'!soundForMidiKey: midiKey dur: d loudness: l	"Answer an initialized sound object that generates a note for the given MIDI key (in the range 0..127), duration (in seconds), and loudness (in the range 0.0 to 1.0)."	| keymap note |	l >= loudThreshold		ifTrue: [			d >= sustainedThreshold				ifTrue: [keymap _ sustainedLoud]				ifFalse: [keymap _ staccatoLoud]]		ifFalse: [			d >= sustainedThreshold				ifTrue: [keymap _ sustainedSoft]				ifFalse: [keymap _ staccatoSoft]].	keymap ifNil: [keymap _ sustainedLoud].	note _ (keymap at: midiKey) copy.	^ note		setPitch: (AbstractSound pitchForMIDIKey: midiKey)		dur: d		loudness: (l * note gain)! !!SampledInstrument methodsFor: 'playing' stamp: 'jm 8/3/1998 16:53'!soundForPitch: pitchNameOrNumber dur: d loudness: l	"Answer an initialized sound object that generates a note of the given pitch, duration, and loudness. Pitch may be a numeric pitch or a string pitch name such as 'c4'. Duration is in seconds and loudness is in the range 0.0 to 1.0."	"Note:  Generally, SampledInstruments are expected to be played via MIDI key numbers rather than by pitches, since finding the MIDI key for a given pitch is expensive."	^ self soundForMidiKey: (AbstractSound midiKeyForPitch: pitchNameOrNumber)		dur: d		loudness: l! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 12:39'!allNotes	"Answer a collection containing of all the unique sampled sounds used by this instrument."	| r |	r _ IdentitySet new.	r addAll: sustainedLoud.	sustainedSoft ~~ sustainedLoud ifTrue: [r addAll: sustainedSoft].	staccatoLoud ~~ sustainedLoud ifTrue: [r addAll: staccatoLoud].	staccatoSoft ~~ staccatoLoud ifTrue: [r addAll: staccatoSoft].	^ (r asSortedCollection: [:n1 :n2 | n1 pitch < n2 pitch]) asArray! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/2/1998 12:55'!chooseSamplesForPitch: pitchInHz from: sortedNotes	"From the given collection of LoopedSampledSounds, choose the best one to be pitch-shifted to produce the given pitch."	"Assume: the given collection is sorted in ascending pitch order."	| i lower higher |	i _ 1.	[(i < sortedNotes size) and: [(sortedNotes at: i) pitch < pitchInHz]]		whileTrue: [i _ i + 1].	i = 1 ifTrue: [^ sortedNotes at: 1].	lower _ sortedNotes at: i - 1.	higher _ sortedNotes at: i.	"note: give slight preference for down-shifting a higher-pitched sample set"	(pitchInHz / lower pitch) < ((0.95 * higher pitch) / pitchInHz)		ifTrue: [^ lower]		ifFalse: [^ higher].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 9/8/1998 16:24'!memorySpace	"Answer the number of bytes required to store the samples for this instrument."	| total |	total _ 0.	self allNotes do: [:n |		total _ total + (n leftSamples monoSampleCount * 2).		n isStereo ifTrue: [total _ total + (n leftSamples monoSampleCount * 2)]].	^ total! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/3/1998 16:42'!midiKeyMapFor: sortedNotes	"Return a 128 element array that maps each MIDI key number to the sampled note from the given set with the closests pitch. A precise match isn't necessary because the selected note will be pitch shifted to play at the correct pitch."	^ (0 to: 127) collect: [:k |		self			chooseSamplesForPitch: (AbstractSound pitchForMIDIKey: k)			from: sortedNotes].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/18/1998 10:57'!playChromaticRunFrom: startPitch to: endPitch	(AbstractSound chromaticRunFrom: startPitch to: endPitch on: self) play.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 15:52'!pruneNoteList: aNoteList notesPerOctave: notesPerOctave	"Return a pruned version of the given note list with only the given number of notes per octave. Assume the given notelist is in sorted order."	| r interval lastPitch |	r _ OrderedCollection new: aNoteList size.	interval _ (2.0 raisedTo: (1.0 / notesPerOctave)) * 0.995.	lastPitch _ 0.0.	aNoteList do: [:n |		n pitch > (lastPitch * interval) ifTrue: [			r addLast: n.			lastPitch _ n pitch]].	^ r! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/6/1998 00:39'!pruneToNotesPerOctave: notesPerOctave	"Prune all my keymaps to the given number of notes per octave."	sustainedLoud _ self midiKeyMapFor:		(self pruneNoteList: sustainedLoud notesPerOctave: notesPerOctave).	sustainedSoft _ self midiKeyMapFor:		(self pruneNoteList: sustainedSoft notesPerOctave: notesPerOctave).	staccatoLoud _ self midiKeyMapFor:		(self pruneNoteList: staccatoLoud notesPerOctave: notesPerOctave).	staccatoSoft _ self midiKeyMapFor:		(self pruneNoteList: staccatoSoft notesPerOctave: notesPerOctave).! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/11/1998 14:44'!pruneToSingleNote: aNote	"Fill all my keymaps with the given note."	| oneNoteMap |	oneNoteMap _ Array new: 128 withAll: aNote.	sustainedLoud _ oneNoteMap.	sustainedSoft _ oneNoteMap.	staccatoLoud _ oneNoteMap.	staccatoSoft _ oneNoteMap.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/4/1998 18:22'!readSampleSetFrom: dirName	"Answer a collection of sounds read from AIFF files in the given directory and sorted in ascending pitch order."	| all dir fullName snd |	all _ SortedCollection sortBlock: [:s1 :s2 | s1 pitch < s2 pitch].	dir _ FileDirectory default on: dirName.	dir fileNames do: [:n |		fullName _ dir fullNameFor: n.		Utilities			informUser: 'Reading AIFF file ', n			during:				[snd _ LoopedSampledSound new					fromAIFFFileNamed: fullName					mergeIfStereo: true].		all add: snd].	^ all asArray! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/2/1998 20:32'!readSampleSetInfoFrom: dirName	"MessageTally spyOn: [SampledInstrument new readSampleSetFrom: 'Tosh:Desktop Folder:AAA Squeak2.0 Beta:Organ Samples:Flute8'] timeToRun"	| all dir fullName info |	all _ OrderedCollection new.	dir _ FileDirectory default on: dirName.	dir fileNames do: [:n |		fullName _ dir fullNameFor: n.		info _ AIFFFileReader new readFromFile: fullName			mergeIfStereo: false			skipDataChunk: true.		all add: n -> info].	^ all! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/4/1998 23:13'!testAtPitch: aPitch	"SampledInstrument testAtPitch: 'c4'"	| pattern |	pattern _ (#(		(c4 0.64 100) 		(c4 0.64 200) 		(c4 0.64 400) 		(c4 0.64 600) 		(c4 0.64 800) 		(c4 1.28 1000) 		(c4 1.28 400) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.32 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.16 500) 		(c4 0.08 500) 		(c4 0.08 500) 		(c4 0.16 500) 		(c4 0.08 500) 		(c4 0.08 500) 		(c4 0.64 500))			collect: [:triple | triple copy at: 1 put: aPitch; yourself]).	(AbstractSound noteSequenceOn: self from: pattern) play.! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/5/1998 15:16'!trimAttackOf: sampleBuffer threshold: threshold	"Trim 'silence' off the initial attacks of the given sound buffer."	(sustainedSoft, sustainedLoud, staccatoSoft, staccatoLoud) do: [:snd |		snd leftSamples: (self trimAttackOf: snd leftSamples threshold: threshold).		snd isStereo ifTrue: [			snd rightSamples:				(self trimAttackOf: snd rightSamples threshold: threshold)]].! !!SampledInstrument methodsFor: 'other' stamp: 'jm 8/5/1998 11:07'!trimAttacks: threshold	"Trim 'silence' off the initial attacks all my samples."	(sustainedSoft, sustainedLoud, staccatoSoft, staccatoLoud) do: [:snd |		snd leftSamples: (self trimAttackOf: snd leftSamples threshold: threshold).		snd isStereo ifTrue: [			snd rightSamples:				(self trimAttackOf: snd rightSamples threshold: threshold)]].! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 6/7/1999 11:26'!buildSmallOrchestra	"Example of how to build a skeleton orchestra that uses less memory (about 14 MBytes)."	"SampledInstrument buildSmallOrchestra"	| dir |	AbstractSound unloadSampledTimbres.	dir _ 'Tosh:Not Backed Up:Sample Library:Orchestra'.	#(clarinet oboe bassoon trombone tympani) do: [:instName |		SampledInstrument			readSimpleInstrument: instName			fromDirectory: dir.		(AbstractSound soundNamed: instName, '-f') pruneToNotesPerOctave: 1].	#(flute bass) do: [:instName |		SampledInstrument			readSimpleInstrument: instName			fromDirectory: dir.		(AbstractSound soundNamed: instName, '-f') pruneToNotesPerOctave: 2].	(AbstractSound soundNamed: 'bass-f') allNotes do: [:n |		n firstSample: (n findStartPointForThreshold: 2500)].	(AbstractSound soundNamed: 'bassoon-f') allNotes do: [:n |		n beUnlooped.		n firstSample: (n findStartPointForThreshold: 0)].	(AbstractSound soundNamed: 'trombone-f') allNotes do: [:n |		n firstSample: (n findStartPointForThreshold: 1800)].	AbstractSound soundNamed: 'trumpet-f' put: (AbstractSound soundNamed: 'trombone-f').	AbstractSound soundNamed: 'horn-f' put: (AbstractSound soundNamed: 'trombone-f').	AbstractSound soundNamed: 'violin-f' put: (AbstractSound soundNamed: 'bass-f').	AbstractSound soundNamed: 'viola-f' put: (AbstractSound soundNamed: 'bass-f').	AbstractSound soundNamed: 'cello-f' put: (AbstractSound soundNamed: 'bass-f').	(AbstractSound soundNamed: 'bassoon-f') allNotes do: [:n | n beUnlooped].! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/19/1998 09:29'!readLoudAndStaccatoInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readLoudAndStaccatoInstrument: 'oboe'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter loud short snd |	sampleSetDir _ orchestraDir, ':', instName.	memBefore _ Smalltalk garbageCollect.	loud _ SampledInstrument new readSampleSetFrom: sampleSetDir, ' f'.	short _ SampledInstrument new readSampleSetFrom: sampleSetDir, ' stacc'.	memAfter _ Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-f&stacc' put:		(snd _ SampledInstrument new			allSampleSets: loud;			staccatoLoudAndSoftSampleSet: short).	"fix slow attacks"	snd allNotes do: [:n | n firstSample: (n findStartPointForThreshold: 500)].	AbstractSound soundNamed: instName, '-f' put:		(snd _ SampledInstrument new			allSampleSets: loud).	"fix slow attacks"	snd allNotes do: [:n | n firstSample: (n findStartPointForThreshold: 1000)].! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/19/1998 09:29'!readPizzInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readPizzInstrument: 'violin'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter sampleSet snd |	sampleSetDir _ orchestraDir, ':', instName, ' pizz'.	memBefore _ Smalltalk garbageCollect.	sampleSet _ SampledInstrument new readSampleSetFrom: sampleSetDir.	memAfter _ Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-pizz' put:		(snd _ SampledInstrument new allSampleSets: sampleSet).	"fix slow attacks"	snd allNotes do: [:n |		n firstSample: (n findStartPointForThreshold: 1000)].	^ snd! !!SampledInstrument class methodsFor: 'instance creation' stamp: 'jm 8/17/1998 18:06'!readSimpleInstrument: instName fromDirectory: orchestraDir	"SampledInstrument		readSimpleInstrument: 'oboe'		fromDirectory: 'Tosh:Sample Library:Orchestra'"	| sampleSetDir memBefore memAfter sampleSet snd |	sampleSetDir _ orchestraDir, ':', instName, ' f'.	memBefore _ Smalltalk garbageCollect.	sampleSet _ SampledInstrument new readSampleSetFrom: sampleSetDir.	memAfter _ Smalltalk garbageCollect.	Transcript show:		instName, ': ', (memBefore - memAfter) printString,		' bytes; ', memAfter printString, ' bytes left'; cr.	AbstractSound soundNamed: instName, '-f' put:		(snd _ SampledInstrument new allSampleSets: sampleSet).	"fix slow attacks"	snd allNotes do: [:n |		n firstSample: (n findStartPointForThreshold: 1000)].	^ snd! !!SampledSound methodsFor: 'initialization' stamp: 'jm 1/18/1999 06:42'!pitch: pitchNameOrNumber	| p |	p _ self nameOrNumberToPitch: pitchNameOrNumber.	originalSamplingRate _		((self samplingRate asFloat * p asFloat) / NominalSamplePitch asFloat) asInteger.	self reset.! !!SampledSound methodsFor: 'initialization' stamp: 'jm 9/27/2003 12:23'!setPitch: pitchNameOrNumber dur: d loudness: vol	"Used to play scores using the default sample table."	"(SampledSound pitch: 880.0 dur: 1.5 loudness: 0.6) play"	| p |	super setPitch: pitchNameOrNumber dur: d loudness: vol.	p _ self nameOrNumberToPitch: pitchNameOrNumber.	"samples _ DefaultSampleTable."	samplesSize _ samples size.	initialCount _ (d * self samplingRate asFloat) rounded.	originalSamplingRate _		((self samplingRate asFloat * p asFloat) / NominalSamplePitch asFloat) asInteger.	self loudness: vol.	self reset.! !!SampledSound methodsFor: 'initialization' stamp: 'jm 7/20/2003 22:26'!setSamples: anArray from: startIndex to: endIndex samplingRate: rate loudness: loudness	"Initialize me to play the given range of the given array at the given sampling rate."	| buf |	anArray class isWords ifFalse: [		"convert the subarray into a SoundBuffer"		buf _ SoundBuffer fromArray: (anArray copyFrom: startIndex to: endIndex).		^ self setSamples: buf samplingRate: rate].	anArray class isWords		ifTrue: [samples _ anArray]		ifFalse: [samples _ SoundBuffer fromArray: anArray].	samplesSize _ samples size.	originalSamplingRate _ rate.	self loudness: loudness.	initialCount _ ((endIndex - (startIndex - 1)) * SoundPlayer samplingRate) // rate.	scaledInitialIndex _ startIndex * IncrementScaleFactor.  "scaled index of the first sample to play"	self reset.! !!SampledSound methodsFor: 'initialization' stamp: 'jm 7/9/1999 19:23'!setSamples: anArray samplingRate: rate	"Set my samples array to the given array with the given nominal sampling rate. Altering the rate parameter allows the sampled sound to be played back at different pitches."	"Note: There are two ways to use sampled sound: (a) you can play them through once (supported by this method) or (b) you can make them the default waveform with which to play a musical score (supported by the class method defaultSampleTable:)."	"Assume: anArray is either a SoundBuffer or a collection of signed 16-bit sample values."	"(SampledSound		samples: SampledSound coffeeCupClink		samplingRate: 5000) play"	"copy the array into a SoundBuffer if necessary"	anArray class isWords		ifTrue: [samples _ anArray]		ifFalse: [samples _ SoundBuffer fromArray: anArray].	samplesSize _ samples size.	samplesSize >= SmallInteger maxVal ifTrue: [  "this is unlikely..."		self error: 'sample count must be under ',  SmallInteger maxVal printString].	originalSamplingRate _ rate.	initialCount _ (samplesSize * self samplingRate) // originalSamplingRate.	self loudness: 1.0.	self reset.! !!SampledSound methodsFor: 'accessing' stamp: 'jm 8/23/2003 18:51'!currentPosition	"Answer the current position of the playback head in seconds since the start of this sound (at the original sampling)."	| sampleIndex |	sampleIndex _ indexHighBits + (scaledIndex >> IncrementFractionBits).	^ sampleIndex asFloat / originalSamplingRate! !!SampledSound methodsFor: 'accessing' stamp: 'jm 9/11/1998 15:39'!duration: seconds	super duration: seconds.	count _ initialCount _ (seconds * self samplingRate) rounded.! !!SampledSound methodsFor: 'accessing' stamp: 'jm 8/23/2003 18:12'!playbackRate	"Answer the playback rate."	^ (scaledIncrement * self samplingRate) asFloat /		(originalSamplingRate * IncrementScaleFactor)! !!SampledSound methodsFor: 'accessing' stamp: 'jm 8/23/2003 18:15'!playbackRate: aNumber	"Set the playback rate."	| rate |	rate _ aNumber asFloat max: 0.01.	scaledIncrement _		((rate * originalSamplingRate * IncrementScaleFactor) / self samplingRate) rounded.! !!SampledSound methodsFor: 'playing' stamp: 'jm 7/9/1999 22:33'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Mix the given number of samples with the samples already in the given buffer starting at the given index. Assume that the buffer size is at least (index + count) - 1."	| lastIndex outIndex sampleIndex sample i s overflow |	<primitive: 185>	self var: #aSoundBuffer declareC: 'short int *aSoundBuffer'.	self var: #samples declareC: 'short int *samples'.	lastIndex _ (startIndex + n) - 1.	outIndex _ startIndex.    "index of next stereo output sample pair"	sampleIndex _ indexHighBits + (scaledIndex >> IncrementFractionBits).	[(sampleIndex <= samplesSize) and: [outIndex <= lastIndex]] whileTrue: [		sample _ ((samples at: sampleIndex) * scaledVol) // ScaleFactor.		leftVol > 0 ifTrue: [			i _ (2 * outIndex) - 1.			s _ (aSoundBuffer at: i) + ((sample * leftVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		rightVol > 0 ifTrue: [			i _ 2 * outIndex.			s _ (aSoundBuffer at: i) + ((sample * rightVol) // ScaleFactor).			s >  32767 ifTrue: [s _  32767].  "clipping!!"			s < -32767 ifTrue: [s _ -32767].  "clipping!!"			aSoundBuffer at: i put: s].		scaledVolIncr ~= 0 ifTrue: [			scaledVol _ scaledVol + scaledVolIncr.			((scaledVolIncr > 0 and: [scaledVol >= scaledVolLimit]) or:			 [scaledVolIncr < 0 and: [scaledVol <= scaledVolLimit]])				ifTrue: [  "reached the limit; stop incrementing"					scaledVol _ scaledVolLimit.					scaledVolIncr _ 0]].		scaledIndex _ scaledIndex + scaledIncrement.		scaledIndex >= ScaledIndexOverflow ifTrue: [			overflow _ scaledIndex >> IncrementFractionBits.			indexHighBits _ indexHighBits + overflow.			scaledIndex _ scaledIndex - (overflow << IncrementFractionBits)].		sampleIndex _ indexHighBits + (scaledIndex >> IncrementFractionBits).		outIndex _ outIndex + 1].	count _ count - n.! !!SampledSound methodsFor: 'playing' stamp: 'jm 7/15/2003 12:29'!reset	"Details: The sample index and increment are scaled to allow fractional increments without having to do floating point arithmetic in the inner loop."	super reset.	scaledIncrement _		((originalSamplingRate asFloat / self samplingRate) * IncrementScaleFactor) rounded.	count _ initialCount.	scaledIndex _ IncrementScaleFactor.  "index of the first sample, scaled"	scaledInitialIndex ifNotNil: [scaledIndex _ scaledInitialIndex].	indexHighBits _ 0.! !!SampledSound methodsFor: 'playing' stamp: 'jm 9/9/1998 21:58'!stopAfterMSecs: mSecs	"Terminate this sound this note after the given number of milliseconds."	count _ (mSecs * self samplingRate) // 1000.! !!SampledSound methodsFor: 'file i/o' stamp: 'jm 12/3/2003 17:28'!storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream	"Store my samples on the given stream at the current SoundPlayer sampling rate. If bigFlag is true, then each 16-bit sample is stored most-significant byte first (AIFF files), otherwise it is stored least-significant byte first (WAV files)."	self samplingRate ~= originalSamplingRate ifTrue: [		^ super storeSampleCount: samplesToStore bigEndian: bigEndianFlag on: aBinaryStream].	"optimization: if sampling rates match, just store my buffer"	samples storeOn: aBinaryStream bigEndian: bigEndianFlag stereo: false.! !!SampledSound methodsFor: 'object i/o' stamp: 'jm 9/25/2003 10:32'!fieldsVersion	^ 1! !!SampledSound methodsFor: 'object i/o' stamp: 'jm 9/28/2003 18:44'!initFieldsFrom: anObjStream version: classVersion	self initFieldsNamed: #(		envelopes		scaledVol		initialCount		samples		originalSamplingRate		samplesSize		scaledIncrement		scaledInitialIndex 	) from: anObjStream.! !!SampledSound methodsFor: 'object i/o' stamp: 'jm 9/28/2003 18:44'!storeFieldsOn: anObjStream	self storeFieldsNamed: #(		envelopes		scaledVol		initialCount		samples		originalSamplingRate		samplesSize		scaledIncrement		scaledInitialIndex 	) on: anObjStream.! !!SampledSound class methodsFor: 'class initialization' stamp: 'jm 12/4/2003 20:06'!initialize	"SampledSound initialize"	IncrementFractionBits _ 16.	IncrementScaleFactor _ 2 raisedTo: IncrementFractionBits.	ScaledIndexOverflow _ 2 raisedTo: 29.  "handle overflow before needing LargePositiveIntegers"	NominalSamplePitch _ 400.	SoundLibrary ifNil: [SoundLibrary _ Dictionary new].! !!SampledSound class methodsFor: 'instance creation' stamp: 'jm 12/4/2003 20:49'!fromFileNamed: fileName	"Read a sound from the file of the given name. The resulting sound may be a SampledSound (mono) or a MixedSound (stereo)."	"(SampledSound fromFileNamed: 'test.aif') play"	| f id snd |	f _ (FileStream readOnlyFileNamed: fileName) binary.	id _ (f next: 4) asString.	f position: 0.	id = 'RIFF' ifTrue: [snd _ self readWAVFrom: f].	id = 'FORM' ifTrue: [snd _ self readAIFFrom: f].	id = '.snd' ifTrue: [snd _ self readSNDFrom: f].	f close.	snd ifNil: [self error: 'Unrecognized audio file format'].	^ snd! !!SampledSound class methodsFor: 'coffee cup clink' stamp: 'jm 12/4/2003 19:58'!coffeeCupClink	"Return the samples array for the sound of a spoon being tapped against a coffee cup."	CoffeeCupClink ifNil: [CoffeeCupClink _ SoundBuffer fromArray: self coffeeCupSamples].	^ CoffeeCupClink! !!SampledSound class methodsFor: 'coffee cup clink' stamp: 'jm 12/4/2003 20:03'!coffeeCupSamples	"Answer an array of 16-bit samples for the sound of a spoon being tapped against a coffee cup."	^ #(768 1024 -256 2304 -13312 26624 32512 19200 6400 -256 5888 32512 28928 32512 -32768 32512 -32768 18688 26368 -26112 32512 32512 2304 32512 5632 2816 10240 -4608 -1792 32512 32512 -5376 10752 32512 32512 32512 8192 15872 32512 -3584 -32768 -23296 -24832 -32768 -32768 -32768 -2304 32512 32512 -32768 32512 -15360 6400 8448 -18176 -32768 -256 -32768 -29440 9472 20992 17920 32512 32512 -256 32512 -32768 -32768 -23040 -32768 -25088 -32768 -27648 -1536 24320 -32768 32512 20480 27904 22016 16384 -32768 32512 -27648 -32768 -7168 28160 -6400 5376 32512 -256 32512 -7168 -11776 -19456 -27392 -24576 -32768 -24064 -19456 12800 32512 27136 2048 25344 15616 8192 -4608 -28672 -32768 -30464 -2560 17664 256 -8192 8448 32512 27648 -6144 -512 -7424 -18688 7936 -256 -22272 -14080 2048 27648 15616 -12288 -768 5376 3328 5632 3072 -6656 -20480 10240 27136 -10752 -11008 -768 -2048 6144 -7168 -3584 -1024 -7680 19712 26112 1024 -11008 3072 16384 -8960 -14848 -4864 -23808 -11264 12288 8192 7168 4864 23040 32512 512 -11776 -5632 -16896 -21504 -12800 -6144 -16896 -4352 32512 32512 23296 21760 5632 2816 -9472 -20992 -11264 -29440 -32768 -3584 7680 8448 15360 32512 32512 15616 15104 -2048 -27904 -27904 -25600 -12288 -12032 -13568 17152 22272 15360 30208 28160 7680 -5632 -8192 -16384 -31744 -25856 -10752 -3840 6656 13056 24320 26368 12800 20736 12288 -19200 -20992 -16640 -21504 -17920 -6912 8448 11264 14080 23040 18176 8192 -1024 0 256 -20992 -19712 -4608 -11264 -2048 14080 12032 8192 6912 13056 9216 -5632 -5376 -3840 -6656 -9984 -5632 4864 -3584 -1280 17408 7680 -1280 4096 2816 -1024 -4864 3328 8448 -768 -5888 -2048 5120 0 3072 11008 -7680 -15360 2560 6656 -3840 0 11776 7680 2816 1536 -1280 -3840 -8704 -1536 3584 -9728 -9728 11776 18688 7680 6656 6400 -4864 -3840 -256 -6912 -13312 -11264 2304 9728 1792 3328 18944 18432 6912 6144 -1536 -17664 -14336 -2304 -10496 -15616 -4096 9728 17152 14848 13312 11520 2304 -1024 2560 -8704 -26624 -18688 -256 -256 2816 14080 13824 12544 14080 9728 -512 -12032 -8960 -3328 -9984 -15872 -5120 8192 3584 10496 20224 7936 4608 6144 1280 -8704 -12800 -7424 -8448 -8960 -3840 7424 13056 8704 13312 13056 -2304 -4864 -768 -7168 -10496 -4608 -1536 -3072 -1280 6144 13312 11008 4864 4864 1536 -8960 -7680 1792 -4864 -7680 2816 5632 3328 2560 5376 7936 3584 -512 512 -4608 -9728 0 9216 768 -4096 7680 7168 256 4608 -768 -8704 -6400 2048 6144 -3072 -3328 6400 9472 3840 -768 1792 -3840 -5120 6144 768 -9984 -4352 5120 9472 6912 2816 1792 1280 768 512 -2816 -9728 -6912 6912 6912 -3328 -768 8448 11776 10752 3328 -6912 -10752 -8704 -1536 0 -6912 -3328 9984 13568 7424 6144 6656 256 0 256 -12032 -17920 -8192 3584 8960 4096 5632 12032 8704 6912 5632 -3584 -10496 -7936 -2048 -9216 -11776 2304 9472 15104 14848 5888 512 -2816 1024 2560 -9984 -13312 -5120 768 1792 768 8448 12032 11264 12800 -256 -11264 -9728 -2304 3072 -4352 -6912 256 2304 5376 9984 8192 2816 1280 3584 -2048 -11008 -8448 -2048 3072 4864 2304 3072 3072 3072 7168 3328 -5376 -4864 512 512 -1792 -1792 1792 5376 5888 5888 512 -5888 -3584 4096 3584 -6400 -4864 4608 3072 3840 5376 1024 768 2816 5888 -768 -12288 -7936 2304 5888 3328 2048 6144 3072 3072 6400 -3328 -7168 256 4096 -512 -9472 -6656 3328 6912 9216 8704 3840 -2560 -256 6656 -2560 -11264 -4608 -768 -1280 1536 3072 4096 5120 9984 11264 1024 -8192 -6144 -1024 -3840 -5632 -512 1024 2304 9728 9728 1280 512 4096 2816 -3584 -9984 -6912 -2304 512 5632 7680 3584 1024 5632 5888 -1280 -3584 -2304 -2560 -1536 -1024 -1792 -512 1536 7680 9984 2048 -2048 2048 3328 -1280 -4096 -3328 -4608 -1280 4352 3328 1280 1792 5120 6912 1024 -2560 0 -768 -1024 1280 -256 -4608 -1280 6400 5120 768 1792 2560 2048 0 -1536 -1280 -2304 1024 5376 2560 -2560 -512 4096 2048 512 768 -1280 -256 2560 2560 -256 -1024 768 3584 1280 -3328 -1536 1792 2816 3328 2304 -256 256 2816 2304 -1280 -3328 -1536 2304 2304 -256 -256 1024 1536 3840 5120 1024 -2048 0 1536 -768 -2560 -1792 256 2304 2048 1536 256 768 5888 6656 256 -3840 -2304 -1280 -1536 256 0 -512 2304 4352 3840 768 0 2304 3072 256 -3072 -2560 -2560 256 4608 2560 256 1536 3072 3072 1792 256 256 512 -256 -768 -1280 -1536 768 4352 2816 -512 768 2560 2560 2304 -256 -1792 -768 768 1792 256 -2304 -256 3328 3840 2304 2304 1536 256 2048 1024 -1536 -1792 -1024 512 256 -512 0 2304 4864 5120 4352 1024 -1280 0 -768 -2816 -2304 -512 1024 2048 2304 2048 3072 3840 2816 2048 -512 -3072 -1792 -1536 -1280 768 1280 1536 2304 2816 2048 1536 2048 1536 1536 -768 -3840 -2048 0 1280 2816 1792 1536 2560 3584 2816 1024 256 -768 -768 -1280 -2816 -768 1792 3328 5120 3072 1280 1536 1792 768 -1024 -1280 -1536 -768 512 256 1536 2560 2560 3328 1280 0 768 1536 768 -256 -512 -1536 -1280 768 1280 2304 2560 2560 2560 1024 -256 -512 0 1280 1536 768 -1280 -512 2048 1536 2048 1280 -256 256 512 768 768 1280 2304 1792 512 -1280 -1024 768 1536 1536 256 -768 1536 3584 3072 1792 -256 -1536 -512 256 -512 -512 768 2048 2048 1792 1280 1280 3072 2816 768 -1024 -2304 -1024 256 256 1280 1792 2304 2816 2304 1280 512 1024 768 -768 -1280 -1280 -512 1536 2560 2816 2048 512 1024 1792 1280 768 0 -768 -768 0 256 256 1280 2560 2304 2304 1536 512 512 1024 1280 0 -1792 -1536 -512 1280 3072 2816 1792 512 1024 1536 256 -256 768 768 256 256 -256 512 1280 1280 1536 768 1024 1792 1536 1024 0 256 -512 -256 1024 512 256 768 1792 2304 1280 256 768 1024 1280 1792 768 -768 -768 768 512 256 1024 1792 1536 1280 1536 1792 1280 768 512 -512 -1792 -512 512 768 2304 2816 1792 768 1536 2304 1536 0 -256 -256 -768 -768 256 1536 1536 2304 2048 256 768 2048 2304 1280 0 -256 -1024 -1024 0 1024 1792 2304 2304 1280 512 1280 2048 1280 256 -512 -1792 -1536 256 1536 1792 2048 2048 2048 1536 512 512 768 256 -256 0 -512 -1024 768 2048 2304 2304 1280 1280 1024 1024 1024 0 -512 256 768 0 -256 1536 2304 1792 2304 1280 -512 -256 768 1536 1024 256 512 512 1024 1792 1792 1536 1024 1280 0 -1280 256 2048 2560 2048 1024 -256 -256 1024 1280 1536 1024 0 0 256 768 1792 2304 2048 1280 1024 0 -512 -256 256 1024 1024 512 768 768 1280 2048 1792 1024 768 768 -256 -1024 0 256 1024 1536 1024 1280 1536 1792 1792 1024 512 512 0 -512 -256 512 768 1280 1280 1024 1280 1792 1792 1280 512 -256 -256 256 512 1280 1024 1280 1280 1024 1024 768 1024 1024 1024 1280 256 256 768 768 1024 512 256 768 1280 2560 2560 1280 512 -256 -512 -256 1024 1536 768 1024 1280 768 1024 1536 1536 1024 256 0 0 0 768 768 512 1280 1536 1280 1280 1280 1280 768 768 256 -256 768 768 256 768 1280 1792 1536 1536 1536 256 512 1024 0 -768 -256 768 512 1024 2048 1536 1024 1536 1536 768 0 0 -256)! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 10:41'!addLibrarySoundNamed: aString samples: sampleData samplingRate: samplesPerSecond	"Add the given sound to the sound library. The sample data may be either a ByteArray or a SoundBuffer. If the former, it is take to be 8-bit unsigned samples. If the latter, it is taken to be 16 bit signed samples."	SoundLibrary		at: aString		put: (Array with: sampleData with: samplesPerSecond).! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 11:04'!playSoundNamed: aString	"Play the sound with given name. Do nothing if there is no sound of that name in the library."	"SampledSound playSoundNamed: 'croak'"	| snd |	snd _ self soundNamed: aString.	snd ifNotNil: [snd play].	^ snd! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 10:40'!putCoffeeCupClinkInSoundLibrary	"SampledSound putCoffeeCupClinkInSoundLibrary"	self addLibrarySoundNamed: 'clink'		samples: self coffeeCupClink		samplingRate: 11025! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 11:06'!soundLibrary	"Answer the sound library dictionary."	^ SoundLibrary! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 11:07'!soundNamed: aString	"Answer the sound of the given name, or nil if there is no sound of that name."	"(SampledSound soundNamed: 'shutterClick') play"	| entry samples |	entry _ SoundLibrary		at: aString		ifAbsent:			[self inform: aString, ' not found in the Sound Library'.			^ nil].	entry ifNil: [^ nil].	samples _ entry at: 1.	samples class isBytes ifTrue: [samples _ self convert8bitSignedTo16Bit: samples].	^ self samples: samples samplingRate: (entry at: 2)! !!SampledSound class methodsFor: 'sound library' stamp: 'jm 1/14/1999 11:08'!soundNames	"Answer a list of sound names for the sounds stored in the sound library."	"| s |	 SampledSound soundNames asSortedCollection do: [:n |		n asParagraph display.		s _ SampledSound soundNamed: n.		s ifNotNil: [s playAndWaitUntilDone]]"	^ SoundLibrary keys asArray! !!SampledSound class methodsFor: 'conversions' stamp: 'jm 12/4/2003 19:30'!convert8bitUnsignedTo16Bit: anArray	"Convert the given array of samples--assumed to be 8-bit unsigned, linear data--into 16-bit signed samples. Return an array containing the resulting samples."	| n samples s |	n _ anArray size.	samples _ SoundBuffer newMonoSampleCount: n.	1 to: n do: [:i |		s _ anArray at: i.		samples at: i put: (s - 128) * 256].	^ samples! !!SampledSound class methodsFor: 'mulaw encode/decode' stamp: 'jm 12/4/2003 19:25'!uLawEncode: anArray	"Convert the given array of 16-bit signed samples into a ByteArray of uLaw-encoded 8-bit samples."	| n out s |	n _ anArray size.	out _ ByteArray new: n.	1 to: n do: [:i |		s _ anArray at: i.		s _ s bitShift: -3.  "drop 3 least significant bits"		s < 0			ifTrue: [s _ (self uLawEncodeSample: s negated) bitOr: 16r80]			ifFalse: [s _ (self uLawEncodeSample: s)].		out at: i put: s].	^ out! !!SampledSound class methodsFor: 'file reading support' stamp: 'jm 12/4/2003 09:54'!findWAVEChunk: chunkID in: aBinaryStream ifAbsent: notFoundBlock	"Search the given stream from its beginning for a chunk with the given four-letter id and answer the size of the chunk. The stream is left positioned at the start of the chunk data. If  no chunk of the given type is found, answer the result of evaluating notFoundBlock."	| id count |	aBinaryStream position: 0.	id _ (aBinaryStream next: 4) asString.	id = 'RIFF' ifFalse: [^ self error: 'Not a RIFF file'].	aBinaryStream skip: 4.  "skip total length"	id _ (aBinaryStream next: 4) asString.	id = 'WAVE' ifFalse: [^ self error: 'Not a WAVE file'].	[aBinaryStream atEnd] whileFalse: [		id _ (aBinaryStream next: 4) asString.		count _ aBinaryStream littleEndianUint32.		id = chunkID ifTrue: [^ count].		aBinaryStream skip: (count roundUpTo: 2)].  "skip this chunk. round size up to next even number"	^ notFoundBlock value! !!SampledSound class methodsFor: 'file reading support' stamp: 'jm 12/4/2003 18:05'!infoForWAVFileNamed: fileName asString: stringFlag	"Answer the encoding information for the WAV file of the given name."	| f count header s type channels samplingRate bitsPerSample |	f _ (FileStream readOnlyFileNamed: fileName) binary.	count _ self findWAVEChunk: 'fmt ' in: f ifAbsent: [^ self error: 'Bad WAV file'].	header _ f next: count.	"process format chunk"	s _ ReadStream on: header.	type _ s littleEndianUint16.	channels _ s littleEndianUint16.	samplingRate _ s littleEndianUint32.	s littleEndianUint32.  "average bytes per second"	s littleEndianUint16.  "block alignment"	bitsPerSample _ s littleEndianUint16.	f close.	stringFlag		ifTrue: [			^ fileName, ': ', samplingRate printString, ', ',				(channels > 2					ifTrue: [channels printString, ' channels, ']					ifFalse: [channels = 1 ifTrue: ['mono, '] ifFalse: ['stereo, ']]),				bitsPerSample printString, '-bit',				(type = 1 ifTrue: [''] ifFalse: [' format=', type printString])]		ifFalse: [			^ Array with: samplingRate with: channels with: bitsPerSample with: type].! !!SampledSound class methodsFor: 'file reading support' stamp: 'jm 12/4/2003 18:33'!readAIFFrom: aBinaryStream	"Read a sound in AIFF format from the given stream."	| aiff channels samplingRate |	aiff _ AIFFFileReader new.	aiff readFromStream: aBinaryStream mergeIfStereo: true skipDataChunk: false.	channels _ aiff channelData size.	samplingRate _ aiff samplingRate.	"build sound object"	channels = 1 ifTrue: [^ self samples: (aiff channelData at: 1) samplingRate: samplingRate].	channels = 2 ifTrue: [		^ MixedSound new			add: (self samples: (aiff channelData at: 1) samplingRate: samplingRate) pan: 0.0;			add: (self samples: (aiff channelData at: 2) samplingRate: samplingRate) pan: 1.0;			yourself].	 self error: 'Unsupported number of channels: ', channels printString.! !!SampledSound class methodsFor: 'file reading support' stamp: 'jm 12/9/2003 17:36'!readMP3FromFileNamed: fileNamed	"Read a sound in MP3 format from the file with the given name. Answer true if successful."	| aiff channels samplingRate |self halt.	aiff _ AIFFFileReader new.	aiff readFromStream: fileNamed mergeIfStereo: true skipDataChunk: false.	channels _ aiff channelData size.	samplingRate _ aiff samplingRate.	"build sound object"	channels = 1 ifTrue: [^ self samples: (aiff channelData at: 1) samplingRate: samplingRate].	channels = 2 ifTrue: [		^ MixedSound new			add: (self samples: (aiff channelData at: 1) samplingRate: samplingRate) pan: 0.0;			add: (self samples: (aiff channelData at: 2) samplingRate: samplingRate) pan: 1.0;			yourself].	 self error: 'Unsupported number of channels: ', channels printString.! !!SampledSound class methodsFor: 'file reading support' stamp: 'jm 12/5/2003 18:02'!readSNDFrom: aBinaryStream	"Read a sound in Sun Audio format from the given stream."	"A few formats in use:		1	muLaw		2	8-bit linear		3	16-bit linear"	| id hdrSize count encoding samplingRate channels data leftAndRight |	"read the header"	id _ (aBinaryStream next: 4) asString.	id = '.snd' ifFalse: [^ self error: 'Not a Sun Audio (.au) file'].	hdrSize _ aBinaryStream uint32. 	count _ aBinaryStream uint32.	encoding _ aBinaryStream uint32.	samplingRate _ aBinaryStream uint32.	channels _ aBinaryStream uint32.	aBinaryStream skip: (hdrSize - 24).	"check the format"	((encoding >= 1) & (encoding <= 3)) ifFalse: [		^ self error: 'Unsupported Sun Audio (.au) format: ', encoding printString].	encoding = 1 ifTrue: [data _ self uLawDecode: (aBinaryStream next: count)].	encoding = 2 ifTrue: [data _ self convert8bitSignedTo16Bit: (aBinaryStream next: count)].	encoding = 3 ifTrue: [		data _ SoundBuffer newMonoSampleCount: count // 2.		aBinaryStream next: (count // 4) into: data startingAt: 1.  "size is in 32-bit words"		Smalltalk isBigEndian ifFalse: [data reverseEndiannessStereo: (channels = 2)]].	"build sound object"	channels = 1 ifTrue: [^ self samples: data samplingRate: samplingRate].	channels = 2 ifTrue: [		leftAndRight _ data splitStereo.		^ MixedSound new			add: (self samples: leftAndRight first samplingRate: samplingRate) pan: 0.0;			add: (self samples: leftAndRight last samplingRate: samplingRate) pan: 1.0;			yourself].	 self error: 'Unsupported number of channels: ', channels printString.! !!SampledSound class methodsFor: 'file reading support' stamp: 'jm 12/4/2003 20:52'!readWAVFrom: aBinaryStream	"Answer a new instance of me from the windows WAV file with the given name. Currently, only formats 1 (uncompressed 8-bit or 16-bit) and 7 (muLaw) WAV files can be read."	"A few formats in use:		 1	PCM audio in integer format		 2	Microsoft adaptive PCM		 7	muLaw		17	Intel DVI_ADPCM		85	ISO/MPEG Layer 3"	| count header s encoding channels samplingRate bitsPerSample data leftAndRight |	count _ self findWAVEChunk: 'fmt ' in: aBinaryStream ifAbsent: [^ self error: 'Bad WAV file'].	header _ aBinaryStream next: count.	"process format chunk"	s _ ReadStream on: header.	encoding _ s littleEndianUint16.	channels _ s littleEndianUint16.	samplingRate _ s littleEndianUint32.	s littleEndianUint32.  "average bytes per second"	s littleEndianUint16.  "block alignment"	bitsPerSample _ s littleEndianUint16.	"check the format"	((encoding = 1) | (encoding = 7)) ifFalse: [		^ self error: 'Unsupported wave format: ', encoding printString].	((bitsPerSample = 8) | (bitsPerSample = 16)) ifFalse: [		^ self error: 'Unsupported wave bits/sample: ', bitsPerSample printString].	"read samples"	count _ self findWAVEChunk: 'data' in: aBinaryStream ifAbsent: [^ self error: 'Bad WAV file'].	bitsPerSample = 8		ifTrue: [			data _ aBinaryStream next: count.			encoding = 1 ifTrue: [data _ self convert8bitUnsignedTo16Bit: data].			encoding = 7 ifTrue: [data _ self uLawDecode: data]]		ifFalse: [			data _ SoundBuffer newMonoSampleCount: count // 2.			aBinaryStream next: (count // 4) into: data startingAt: 1.  "size is in 32-bit words"			Smalltalk isBigEndian ifTrue: [data reverseEndiannessStereo: (channels = 2)]].	"build sound object"	channels = 1 ifTrue: [^ self samples: data samplingRate: samplingRate].	channels = 2 ifTrue: [		leftAndRight _ data splitStereo.		^ MixedSound new			add: (self samples: leftAndRight first samplingRate: samplingRate) pan: 0.0;			add: (self samples: leftAndRight last samplingRate: samplingRate) pan: 1.0;			yourself].	 self error: 'Unsupported number of channels: ', channels printString.! !I scan a string or text, picking out Smalltalk syntactic tokens. I look one character ahead. I put each token found into the instance variable, token, and its type (a Symbol) into the variable, tokenType. At the end of the input stream, I pretend to see an endless sequence of special characters called doits.!!Scanner methodsFor: 'multi-character scans' stamp: 'di 5/29/1998 12:25'!xBinary	tokenType _ #binary.	token _ Symbol internCharacter: self step.	[(typeTable at: hereChar asciiValue) = #xBinary and: [hereChar ~= $-]]		whileTrue: [token _ (token , (String with: self step)) asSymbol]! !!Scanner methodsFor: 'multi-character scans' stamp: 'di 10/10/1999 23:43'!xLitQuote	"Symbols and vectors: #(1 (4 5) 2 3) #ifTrue:ifFalse: #'abc'."	| start |	self step. "litQuote"	self scanToken.	tokenType = #leftParenthesis		ifTrue: 			[start _ mark.			self scanToken; scanLitVec.			tokenType == #doIt				ifTrue: [mark _ start.						self offEnd: 'Unmatched parenthesis']]		ifFalse: 			[(#(word keyword colon ) includes: tokenType) 				ifTrue:					[self scanLitWord]				ifFalse:					[(tokenType==#literal)						ifTrue:							[(token isMemberOf: Symbol)								ifTrue: "##word"									[token _ token "May want to move toward ANSI here"]]						ifFalse:							[tokenType==#string ifTrue: [token _ token asSymbol]]]].	tokenType _ #literal"	#(Pen)	#Pen	#'Pen'	##Pen	###Pen"! !!Scanner class methodsFor: 'instance creation' stamp: 'jm 5/30/2003 10:21'!new	^ self basicNew initScanner! !!Scanner class methodsFor: 'testing' stamp: 'bf 4/27/2000 12:56'!isLiteralSymbol: aSymbol 	"Test whether a symbol can be stored as # followed by its characters.  	Symbols created internally with asSymbol may not have this property, 	e.g. '3' asSymbol."	| i ascii type |	i _ aSymbol size.	i = 0 ifTrue: [^ false].	i = 1 ifTrue: [('$''"()#0123456789' includes: (aSymbol at: 1))		ifTrue: [^ false] ifFalse: [^ true]].	ascii _ (aSymbol at: 1) asciiValue.	"TypeTable should have been origined at 0 rather than 1 ..."	ascii = 0 ifTrue: [^ false].	type _ TypeTable at: ascii.	(type == #xColon or: [type == #verticalBar]) ifTrue: [^ i = 1].	type == #xBinary ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^ false].					(TypeTable at: ascii) == #xBinary ifFalse: [^ false].					i _ i - 1].			^ true].	type == #xLetter ifTrue: 			[[i > 1]				whileTrue: 					[ascii _ (aSymbol at: i) asciiValue.					ascii = 0 ifTrue: [^ false].					type _ TypeTable at: ascii.					(type == #xLetter or: [type == #xDigit or: [type == #xColon]])						ifFalse: [^ false].					i _ i - 1].			^ true].	^ false! !This is a real-time player for MIDI scores (i.e., scores read from MIDI files). Score can be played using either the internal sound synthesis or an external MIDI synthesizer on platforms that support MIDI output.!!ScorePlayer methodsFor: 'initialization' stamp: 'di 6/15/1999 11:17'!initialize	super initialize.	score _ MIDIScore new initialize.	instruments _ Array new.	overallVolume _ 0.5.	leftVols _ Array new.	rightVols _ Array new.	muted _ Array new.	rate _ 1.0.	repeat _ false.	durationInTicks _ 100.! !!ScorePlayer methodsFor: 'initialization' stamp: 'di 6/15/1999 11:18'!onScore: aMIDIScore	| trackCount totalVol incr curr pan |	score _ aMIDIScore.	trackCount _ score tracks size.	durationInTicks _ score durationInTicks.	instruments _ (1 to: trackCount) collect: [:i | FMSound oboe1].	leftVols _ Array new: trackCount.	rightVols _ Array new: trackCount.	muted  _ Array new: trackCount withAll: false.	rate _ 1.0.	repeat _ false.	tempo _ 120.0.	trackCount = 0 ifTrue: [^ self].	1 to: trackCount do: [:i |		leftVols at: i put: ScaleFactor // 4.		rightVols at: i put: ScaleFactor // 4].	"distribute inital panning of tracks left-to-right"	totalVol _ 1.0.	incr _ totalVol / (((trackCount // 2) + 1) * 2).	curr _ 0.	1 to: trackCount do: [:t |		t even			ifTrue: [pan _ curr]			ifFalse: [				curr _ curr + incr.				pan _ totalVol - curr].		self panForTrack: t put: pan].! !!ScorePlayer methodsFor: 'initialization' stamp: 'di 6/20/1999 00:46'!updateDuration	durationInTicks _ score durationInTicks.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 19:07'!doControl	super doControl.	1 to: activeSounds size do: [:i | (activeSounds at: i) first doControl].	ticksSinceStart _ ticksSinceStart + ticksClockIncr.	self processAllAtTick: ticksSinceStart asInteger.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 16:58'!isDone	| track |	activeSounds size > 0 ifTrue: [^ false].	activeMIDINotes size > 0 ifTrue: [^ false].	1 to: score tracks size do: [:i |		track _ score tracks at: i.		(trackEventIndex at: i) <= track size ifTrue: [^ false]].	^ true! !!ScorePlayer methodsFor: 'sound generation' stamp: 'di 8/5/1998 23:07'!isPlaying	^ SoundPlayer isPlaying: self! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 6/16/1999 20:28'!jumpToTick: startTick	| |	self reset.	self processTempoMapAtTick: startTick.	self skipNoteEventsThruTick: startTick.	ticksSinceStart _ startTick.! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 7/4/1998 08:21'!mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: leftVol rightVol: rightVol	"Play a number of sounds concurrently. The level of each sound can be set independently for the left and right channels."	| myLeftVol myRightVol someSoundIsDone pair snd trk left right |	myLeftVol _ (leftVol * overallVolume) asInteger.	myRightVol _ (rightVol * overallVolume) asInteger.	someSoundIsDone _ false.	1 to: activeSounds size do: [:i |		pair _ activeSounds at: i.		snd _ pair at: 1.		trk _ pair at: 2.		left _ (myLeftVol * (leftVols at: trk)) // ScaleFactor.		right _ (myRightVol * (rightVols at: trk)) // ScaleFactor.		snd samplesRemaining > 0			ifTrue: [				snd mixSampleCount: n into: aSoundBuffer startingAt: startIndex leftVol: left rightVol: right]			ifFalse: [someSoundIsDone _ true]].	someSoundIsDone ifTrue: [		activeSounds _ activeSounds select: [:p | p first samplesRemaining > 0]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 10/30/2002 18:30'!processAllAtTick: scoreTick	self processTempoMapAtTick: scoreTick.	midiPort		ifNil: [self processNoteEventsAtTick: scoreTick]		ifNotNil: [self processMIDIEventsAtTick: scoreTick].	self isDone ifTrue: [		repeat			ifTrue: [self reset]			ifFalse: [done _ true]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 9/10/1998 17:49'!processNoteEventsAtTick: scoreTick	"Process note events through the given score tick using internal Squeak sound synthesis."	| instr j evt snd |	1 to: score tracks size do: [:i |		instr _ instruments at: i.		j _ trackEventIndex at: i.		[evt _ score eventForTrack: i after: j ticks: scoreTick.		 evt ~~ nil] whileTrue: [			(evt isNoteEvent and: [(muted at: i) not]) ifTrue: [				snd _ instr					soundForMidiKey: evt midiKey					dur: secsPerTick * evt duration					loudness: evt velocity asFloat / 127.0.				activeSounds add: (Array with: snd with: i)].			j _ j + 1.			trackEventIndex at: i put: j]].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 6/16/1999 21:04'!processTempoMapAtTick: scoreTick	"Process tempo changes through the given score tick."	| map tempoChanged |	map _ score tempoMap.	map ifNil: [^ self].	tempoChanged _ false.	[(tempoMapIndex <= map size) and:	 [(map at: tempoMapIndex) time <= scoreTick]] whileTrue: [		tempoChanged _ true.		tempoMapIndex _ tempoMapIndex + 1].	tempoChanged ifTrue: [		tempo _ (120.0 * (500000.0 / (map at: tempoMapIndex - 1) tempo)) roundTo: 0.01.		self tempoOrRateChanged].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 10/30/2002 18:29'!reset	super reset.	tempo _ 120.0.	self tempoOrRateChanged.	done _ false.	ticksSinceStart _ 0.	"one index for each sound track, plus one for the ambient track..."	trackEventIndex _ Array new: score tracks size+1 withAll: 1.	tempoMapIndex _ 1.	activeSounds _ OrderedCollection new.	activeMIDINotes _ OrderedCollection new.	overallVolume ifNil: [overallVolume _ 0.5].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 6/16/1999 20:56'!skipNoteEventsThruTick: startTick	"Skip note events through the given score tick using internal Squeak sound synthesis."	| j evt |	1 to: score tracks size do: [:i |		j _ trackEventIndex at: i.		[evt _ score eventForTrack: i after: j ticks: startTick.		 evt == nil] whileFalse: [			evt isNoteEvent				ifTrue: [					(((evt time + evt duration) > startTick) and: [(muted at: i) not]) ifTrue: [						self startNote: evt forStartTick: startTick trackIndex: i]]				ifFalse: [					midiPort == nil ifFalse: [evt outputOnMidiPort: midiPort]].			j _ j + 1].		trackEventIndex at: i put: j].! !!ScorePlayer methodsFor: 'sound generation' stamp: 'jm 6/16/1999 20:30'!startNote: noteEvent forStartTick: startTick trackIndex: trackIndex	"Prepare a note to begin playing at the given tick. Used to start playing at an arbitrary point in the score. Handle both MIDI and built-in synthesis cases."	| snd |	midiPort		ifNil: [			snd _ (instruments at: trackIndex)				soundForMidiKey: noteEvent midiKey				dur: secsPerTick * (noteEvent endTime - startTick)				loudness: noteEvent velocity asFloat / 127.0.			activeSounds add: (Array with: snd with: trackIndex)]		ifNotNil: [			noteEvent startNoteOnMidiPort: midiPort.			activeMIDINotes add: (Array with: noteEvent with: trackIndex)].! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 10/12/1998 17:13'!closeMIDIPort	"Stop using MIDI for output. Music will be played using the built-in sound synthesis."	self pause.	midiPort _ nil.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/24/1998 22:33'!midiPlayLoop	| mSecsPerStep tStart mSecs |	mSecsPerStep _ 5.	[done] whileFalse: [		tStart _ Time millisecondClockValue.		self processAllAtTick: ticksSinceStart asInteger.		(Delay forMilliseconds: mSecsPerStep) wait.		mSecs _ Time millisecondClockValue - tStart.		mSecs < 0 ifTrue: [mSecs _ mSecsPerStep].  "clock wrap"		ticksSinceStart _ ticksSinceStart + (mSecs asFloat / (1000.0 * secsPerTick))].! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 10/12/1998 15:56'!openMIDIPort: portNum	"Open the given MIDI port. Music will be played as MIDI commands to the given MIDI port."	midiPort _ SimpleMIDIPort openOnPortNumber: portNum.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 18:31'!processMIDIEventsAtTick: scoreTick	"Process note events through the given score tick using MIDI."	| j evt |	1 to: score tracks size do: [:i |		j _ trackEventIndex at: i.		[evt _ score eventForTrack: i after: j ticks: scoreTick.		 evt ~~ nil] whileTrue: [			evt isNoteEvent				ifTrue: [					(muted at: i) ifFalse: [						evt startNoteOnMidiPort: midiPort.						activeMIDINotes add: (Array with: evt with: i)]]				ifFalse: [evt outputOnMidiPort: midiPort].			j _ j + 1.			trackEventIndex at: i put: j]].	self turnOffActiveMIDINotesAt: scoreTick.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 20:45'!startMIDIPlaying	"Start up a process to play this score via MIDI."	midiPort ensureOpen.	midiPlayerProcess ifNotNil: [midiPlayerProcess terminate].	midiPlayerProcess _ [self midiPlayLoop] newProcess.	midiPlayerProcess		priority: Processor userInterruptPriority;		resume.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 20:44'!stopMIDIPlaying	"Terminate the MIDI player process and turn off any active notes."	midiPlayerProcess ifNotNil: [midiPlayerProcess terminate].	midiPlayerProcess _ nil.	activeMIDINotes do: [:pair | pair first endNoteOnMidiPort: midiPort].	activeMIDINotes _ activeMIDINotes species new.! !!ScorePlayer methodsFor: 'midi output' stamp: 'jm 9/10/1998 17:48'!turnOffActiveMIDINotesAt: scoreTick	"Turn off any active MIDI notes that should be turned off at the given score tick."	| evt someNoteEnded |	midiPort ifNil: [^ self].	someNoteEnded _ false. 	activeMIDINotes do: [:pair |		evt _ pair first.		evt endTime <= scoreTick ifTrue: [			evt endNoteOnMidiPort: midiPort.			someNoteEnded _ true]].	someNoteEnded ifTrue: [		activeMIDINotes _ activeMIDINotes select: [:p | p first endTime > scoreTick]].! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 12/16/2001 11:59'!duration	"Answer the duration in seconds of my MIDI score when played at the current rate. Take tempo changes into account."	| totalSecs currentTempo lastTempoChangeTick |	totalSecs _ 0.0.	currentTempo _ 120.0.  "quarter notes per minute"	lastTempoChangeTick _ 0.	score tempoMap ifNotNil: [		score tempoMap do: [:tempoEvt |			"accumulate time up to this tempo change event"			secsPerTick _ 60.0 / (currentTempo * rate * score ticksPerQuarterNote).			totalSecs _ totalSecs + (secsPerTick * (tempoEvt time - lastTempoChangeTick)).			"set the new tempo"			currentTempo _ (120.0 * (500000.0 / tempoEvt tempo)) roundTo: 0.01.			lastTempoChangeTick _ tempoEvt time]].	"add remaining time through end of score"	secsPerTick _ 60.0 / (currentTempo * rate * score ticksPerQuarterNote).	totalSecs _ totalSecs + (secsPerTick * (score durationInTicks - lastTempoChangeTick)).	^ totalSecs! !!ScorePlayer methodsFor: 'accessing' stamp: 'di 6/15/1999 11:37'!durationInTicks	durationInTicks == nil ifTrue: [^ 1000].	^ durationInTicks! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 12/16/2001 20:20'!isStereo	^ true! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/28/1998 22:58'!midiPort	^ midiPort! !!ScorePlayer methodsFor: 'accessing' stamp: 'di 5/30/1999 12:46'!millisecondsSinceStart	"Answer the approximate number of milliseconds of real time since the beginning of the score. Since this calculation uses the current tempo, which can change throughout the piece, it is safer to use ticksSinceStart for synchronization."	^ (secsPerTick * ticksSinceStart * 1000) asInteger! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/10/1998 17:25'!mutedForTrack: trackIndex put: aBoolean	muted at: trackIndex put: aBoolean.	aBoolean ifFalse: [^ self].	"silence any currently sounding notes for this track"	activeSounds do: [:pair |		pair last = trackIndex ifTrue: [activeSounds remove: pair ifAbsent: []]].	midiPort ifNotNil: [		activeMIDINotes do: [:pair |			pair last = trackIndex ifTrue: [				pair first endNoteOnMidiPort: midiPort.				activeMIDINotes remove: pair ifAbsent: []]]].! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 5/30/1999 17:16'!mutedState	^ muted! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 08:17'!overallVolume	^ overallVolume! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 08:18'!overallVolume: aNumber	"Set the overally playback volume to a value between 0.0 (off) and 1.0 (full blast)."	overallVolume _ (aNumber asFloat min: 1.0) max: 0.0.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:32'!panForTrack: i	| left right fullVol pan |	left _ leftVols at: i.	right _ rightVols at: i.	left = right ifTrue: [^ 0.5].  "centered"	fullVol _ left max: right.	left < fullVol		ifTrue: [pan _ left asFloat / (2.0 * fullVol)]		ifFalse: [pan _ 1.0 - (right asFloat / (2.0 * fullVol))].	^ pan roundTo: 0.001! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:58'!panForTrack: i put: aNumber	"Set the left-right pan for this track to a value in the range [0.0..1.0], where 0.0 means full-left."	| fullVol pan left right |	fullVol _ (leftVols at: i) max: (rightVols at: i).	pan _ (aNumber asFloat min: 1.0) max: 0.0.	pan <= 0.5		ifTrue: [  "attenuate right channel"			left _ fullVol.			right _ 2.0 * pan * fullVol]		ifFalse: [  "attenuate left channel"			left _ 2.0 * (1.0 - pan) * fullVol.			right _ fullVol].	rightVols at: i put: right asInteger.	leftVols at: i put: left asInteger.! !!ScorePlayer methodsFor: 'accessing' stamp: 'di 6/20/1999 00:42'!positionInScore	^ self ticksSinceStart asFloat / (self durationInTicks max: 1)! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 6/16/1999 22:50'!positionInScore: pos	self isPlaying ifTrue: [^ self "ignore rude intrusion"].	ticksSinceStart _ pos * durationInTicks.	done _ false.! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/22/1998 09:32'!ticksForMSecs: mSecs	^ (mSecs asFloat / (1000.0 * secsPerTick)) rounded! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 9/10/1998 20:48'!ticksSinceStart	"Answer the number of score ticks that have elapsed since this piece started playing. The duration of a tick is determined by the MIDI score."	^ ticksSinceStart! !!ScorePlayer methodsFor: 'accessing' stamp: 'di 6/19/1999 10:45'!ticksSinceStart: newTicks	"Adjust ticks to folow, eg, piano roll autoscrolling"	self isPlaying ifFalse: [ticksSinceStart _ newTicks]! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 7/4/1998 09:16'!volumeForTrack: i	| vol |	vol _ (leftVols at: i) max: (rightVols at: i).	^ (vol asFloat / ScaleFactor) roundTo: 0.0001! !!ScorePlayer methodsFor: 'accessing' stamp: 'jm 6/30/1998 20:22'!volumeForTrack: i put: aNumber	| newVol oldLeft oldRight oldFullVol left right |	newVol _ ((aNumber asFloat max: 0.0) min: 1.0) * ScaleFactor.	oldLeft _ leftVols at: i.	oldRight _ rightVols at: i.	oldFullVol _ oldLeft max: oldRight.	oldFullVol = 0 ifTrue: [oldFullVol _ 1.0].	oldLeft < oldFullVol		ifTrue: [			left _ newVol * oldLeft / oldFullVol.			right _ newVol]		ifFalse: [			left _ newVol.			right _ newVol * oldRight / oldFullVol].	leftVols at: i put: left asInteger.	rightVols at: i put: right asInteger.! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 10/30/2002 18:29'!pause	"Pause this sound. It can be resumed from this point, or reset and resumed to start from the beginning."	super pause.	activeSounds _ activeSounds species new.	midiPort ifNotNil: [self stopMIDIPlaying].! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 10/30/2002 18:28'!resumePlaying	"Resume playing. Start over if done."	done ifTrue: [self reset].	self jumpToTick: ticksSinceStart.  "Play up to here in case we got scrolled to new position."	midiPort		ifNil: [super resumePlaying]  "let the sound player drive sound generation" 		ifNotNil: [self startMIDIPlaying].  "start a process to drive MIDI output"! !!ScorePlayer methodsFor: 'operating' stamp: 'jm 9/10/1998 20:56'!tempoOrRateChanged	"This method should be called after changing the tempo or rate."	secsPerTick _ 60.0 / (tempo * rate * score ticksPerQuarterNote).	ticksClockIncr _ (1.0 / self controlRate) / secsPerTick.! !A ScorePlayerMorph mediates between a score such as a MIDIScore, a PianoRollScoreMorph, and the actual SoundPlayer synthesizer.It provides control over volume, tempo, instrumentation, and location in the score.!!ScorePlayerMorph methodsFor: 'initialization' stamp: 'jm 10/12/1998 17:14'!closeMIDIPort	scorePlayer closeMIDIPort.	LastMIDIPort _ nil.! !!ScorePlayerMorph methodsFor: 'initialization' stamp: 'di 6/15/1999 10:31'!onScorePlayer: aScorePlayer title: scoreName	| divider col r |	scorePlayer _ aScorePlayer.	scorePlayer ifNotNil:		[scorePlayer  reset.		instrumentSelector _ Array new: scorePlayer score tracks size].	divider _ AlignmentMorph new		extent: 10@1;		borderWidth: 1;		inset: 0;		borderColor: #raised;		color: color;		hResizing: #spaceFill;		vResizing: #rigid.	self removeAllMorphs.	self addMorphBack: self makeControls.	scorePlayer ifNil: [^ self].	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	r addMorphBack: self rateControl;		addMorphBack: (Morph newBounds: (0@0 extent: 20@0) color: Color transparent);		addMorphBack: self volumeControl.	self addMorphBack: r.	self addMorphBack: self scrollControl.	col _ AlignmentMorph newColumn color: color; inset: 0.	self addMorphBack: col.	1 to: scorePlayer trackCount do: [:trackIndex |		col addMorphBack: divider fullCopy.		col addMorphBack: (self trackControlsFor: trackIndex)].	LastMIDIPort ifNotNil: [		"use the most recently set MIDI port"		scorePlayer openMIDIPort: LastMIDIPort].! !!ScorePlayerMorph methodsFor: 'initialization' stamp: 'di 10/14/1998 15:46'!openMIDIFile	"Open a MIDI score and re-init controls..."	| score fileName f player |	fileName _ Utilities chooseFileWithSuffixFromList: #('.mid' '.midi')					withCaption: 'Choose a MIDI file to open'.	fileName ifNil: [^ self].	f _ FileStream readOnlyFileNamed: fileName.	score _ (MIDIFileReader new readMIDIFrom: f binary) asScore.	f close.	player _ ScorePlayer onScore: score.	self onScorePlayer: player title: fileName! !!ScorePlayerMorph methodsFor: 'initialization' stamp: 'jm 10/12/1998 18:00'!openMIDIPort	| portNum |	portNum _ SimpleMIDIPort outputPortNumFromUser.	portNum ifNil: [^ self].	scorePlayer openMIDIPort: portNum.	LastMIDIPort _ portNum.! !!ScorePlayerMorph methodsFor: 'accessing' stamp: 'jm 6/1/1998 09:10'!scorePlayer	^ scorePlayer! !!ScorePlayerMorph methodsFor: 'layout' stamp: 'di 10/14/1998 15:30'!makeControls	| b r reverbSwitch repeatSwitch |	b _ SimpleButtonMorph new		target: self;		borderColor: #raised;		borderWidth: 2;		color: color.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r addMorphBack: (b fullCopy label: '<>'; actWhen: #buttonDown;														actionSelector: #invokeMenu).	r addMorphBack: (b fullCopy label: 'Piano Roll';		actionSelector: #makePianoRoll).	r addMorphBack: (b fullCopy label: 'Rewind';		actionSelector: #rewind).	b target: scorePlayer.	r addMorphBack: (b fullCopy label: 'Play';			actionSelector: #resumePlaying).	r addMorphBack: (b fullCopy label: 'Pause';			actionSelector: #pause).	reverbSwitch _ SimpleSwitchMorph new		offColor: color;		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		borderWidth: 2;		label: 'Reverb Disable';		actionSelector: #disableReverb:;		target: scorePlayer;		setSwitchState: SoundPlayer isReverbOn not.	r addMorphBack: reverbSwitch.	scorePlayer ifNotNil:		[repeatSwitch _ SimpleSwitchMorph new			offColor: color;			onColor: (Color r: 1.0 g: 0.6 b: 0.6);			borderWidth: 2;			label: 'Repeat';			actionSelector: #repeat:;			target: scorePlayer;			setSwitchState: scorePlayer repeat.		r addMorphBack: repeatSwitch].	b target: self.	^ r! !!ScorePlayerMorph methodsFor: 'layout' stamp: 'jm 9/28/1998 23:05'!makeMIDIController: evt	self world activeHand attachMorph:		(MIDIControllerMorph new midiPort: scorePlayer midiPort).! !!ScorePlayerMorph methodsFor: 'layout' stamp: 'jm 10/11/2002 08:55'!makePianoRoll	"Create a piano roll viewer for this score player."	| pianoRoll hand |	pianoRoll _ PianoRollScoreMorph new on: scorePlayer.	hand _ self world activeHand.	hand		ifNil: [self world addMorph: pianoRoll]		ifNotNil: [hand attachMorph: pianoRoll].	pianoRoll startStepping.! !!ScorePlayerMorph methodsFor: 'layout' stamp: 'di 11/9/1999 13:30'!panAndVolControlsFor: trackIndex	| volSlider panSlider c r middleLine pianoRollColor |	pianoRollColor _ (Color wheel: scorePlayer score tracks size) at: trackIndex.	volSlider _ SimpleSliderMorph new		color: color;		sliderColor: pianoRollColor;		extent: 101@2;		target: scorePlayer;		arguments: (Array with: trackIndex);		actionSelector: #volumeForTrack:put:;		minVal: 0.0;		maxVal: 1.0;		adjustToValue: (scorePlayer volumeForTrack: trackIndex).	panSlider _ volSlider fullCopy		actionSelector: #panForTrack:put:;		minVal: 0.0;		maxVal: 1.0;				adjustToValue: (scorePlayer panForTrack: trackIndex).	c _ AlignmentMorph newColumn		color: color;		inset: 0;		centering: #center;		hResizing: #spaceFill;		vResizing: #shrinkWrap.	middleLine _ Morph new  "center indicator for pan slider"		color: (Color r: 0.4 g: 0.4 b: 0.4);		extent: 1@(panSlider height - 4);		position: panSlider center x@(panSlider top + 2).	panSlider addMorphBack: middleLine.	r _ self makeRow.	r addMorphBack: (StringMorph contents: '0').	r addMorphBack: volSlider.	r addMorphBack: (StringMorph contents: '10').	c addMorphBack: r.	r _ self makeRow.	r addMorphBack: (StringMorph contents: 'L').	r addMorphBack: panSlider.	r addMorphBack: (StringMorph contents: 'R').	c addMorphBack: r.	^ c! !!ScorePlayerMorph methodsFor: 'layout' stamp: 'di 11/9/1999 13:30'!rateControl	| rateSlider middleLine r |	rateSlider _ SimpleSliderMorph new		color: color;		sliderColor: Color gray;		extent: 180@2;		target: self;		actionSelector: #setLogRate:;		minVal: -1.0;		maxVal: 1.0;		adjustToValue: 0.0.	middleLine _ Morph new  "center indicator for pan slider"		color: (Color r: 0.4 g: 0.4 b: 0.4);		extent: 1@(rateSlider height - 4);		position: rateSlider center x@(rateSlider top + 2).	rateSlider addMorphBack: middleLine.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'slow ').	r addMorphBack: rateSlider.	r addMorphBack: (StringMorph contents: ' fast').	^ r! !!ScorePlayerMorph methodsFor: 'layout' stamp: 'di 11/9/1999 13:30'!scrollControl	| r |	scrollSlider _ SimpleSliderMorph new		color: color;		sliderColor: Color gray;		extent: 360@2;		target: scorePlayer;		actionSelector: #positionInScore:;		adjustToValue: scorePlayer positionInScore.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'start ').	r addMorphBack: scrollSlider.	r addMorphBack: (StringMorph contents: ' end').	^ r! !!ScorePlayerMorph methodsFor: 'layout' stamp: 'jm 4/20/1999 10:59'!trackNumAndMuteButtonFor: trackIndex	| muteButton instSelector pianoRollColor r |	muteButton _ SimpleSwitchMorph new		onColor: (Color r: 1.0 g: 0.6 b: 0.6);		offColor: color;		color: color;		label: 'Mute';		target: scorePlayer;		actionSelector: #mutedForTrack:put:;		arguments: (Array with: trackIndex).	instSelector _ PopUpChoiceMorph new		extent: 95@14;		contentsClipped: 'oboe1';		target: self;		actionSelector: #atTrack:from:selectInstrument:;		getItemsSelector: #instrumentChoicesForTrack:;		getItemsArgs: (Array with: trackIndex).	instSelector arguments:		(Array with: trackIndex with: instSelector).	instrumentSelector at: trackIndex put: instSelector.	"select track color using same color list as PianoRollScoreMorph"	pianoRollColor _ (Color wheel: scorePlayer score tracks size) at: trackIndex.	r _ self makeRow		hResizing: #rigid;		vResizing: #spaceFill;		extent: 70@10.	r addMorphBack:		((StringMorph			contents: trackIndex printString			font: (TextStyle default fontOfSize: 24)) color: pianoRollColor).	trackIndex < 10		ifTrue: [r addMorphBack: (Morph new color: color; extent: 19@8)]  "spacer"		ifFalse: [r addMorphBack: (Morph new color: color; extent: 8@8)].  "spacer"	r addMorphBack:		(StringMorph new			extent: 140@14;			contentsClipped: (scorePlayer infoForTrack: trackIndex)).	r addMorphBack: (Morph new color: color; extent: 8@8).  "spacer"	r addMorphBack: instSelector.	r addMorphBack: (AlignmentMorph newRow color: color).  "spacer"	r addMorphBack: muteButton.	^ r! !!ScorePlayerMorph methodsFor: 'layout' stamp: 'di 11/9/1999 13:30'!volumeControl	| volumeSlider r |	volumeSlider _ SimpleSliderMorph new		color: color;		sliderColor: Color gray;		extent: 80@2;		target: scorePlayer;		actionSelector: #overallVolume:;		adjustToValue: scorePlayer overallVolume.	r _ self makeRow		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: 'soft  ').	r addMorphBack: volumeSlider.	r addMorphBack: (StringMorph contents: ' loud').	^ r! !!ScorePlayerMorph methodsFor: 'controls' stamp: 'jm 10/9/2002 08:05'!atTrack: trackIndex from: aPopUpChoice selectInstrument: selection	| snd |	(selection beginsWith: 'edit ') ifTrue: [^ self].	snd _ nil.	1 to: instrumentSelector size do: [:i |		((trackIndex ~= i) and:		 [selection = (instrumentSelector at: i) contents])			ifTrue: [snd _ scorePlayer instrumentForTrack: i]].  "use existing instrument prototype"	snd ifNil: [		selection = 'clink'			ifTrue: [				snd _ (SampledSound					samples: SampledSound coffeeCupClink					samplingRate: 11025) copy]			ifFalse: [snd _ (AbstractSound soundNamed: selection) copy]].	scorePlayer instrumentForTrack: trackIndex put: snd.	(instrumentSelector at: trackIndex) contentsClipped: selection.! !!ScorePlayerMorph methodsFor: 'controls' stamp: 'jm 10/12/1998 17:18'!rewind	scorePlayer pause; reset.! !!ScorePlayerMorph methodsFor: 'menu' stamp: 'jm 10/9/2002 08:07'!instrumentChoicesForTrack: trackIndex	| names inst |	names _ AbstractSound soundNames asOrderedCollection.	names _ names collect: [:n |		inst _ AbstractSound soundNamed: n.		(inst isKindOf: UnloadedSound)			ifTrue: [n, '(out)']			ifFalse: [n]].	names add: 'clink'.	^ names asArray! !!ScorePlayerMorph methodsFor: 'menu' stamp: 'jm 10/31/2002 11:06'!invokeMenu	"Invoke a menu of additonal functions for this ScorePlayer."	| aMenu |	aMenu _ CustomMenu new.	aMenu add: 'open a MIDI file' action: #openMIDIFile.	aMenu addList: #(		-		('save as AIFF file'		saveAsAIFF)		('save as WAV file'		saveAsWAV)		('save as Sun AU file'	saveAsSunAudio)		-).	aMenu addLine.	scorePlayer midiPort		ifNil: [			aMenu add: 'play via MIDI' action: #openMIDIPort]		ifNotNil: [			aMenu add: 'play via built in synth' action: #closeMIDIPort.			aMenu add: 'new MIDI controller' action: #makeMIDIController:].	aMenu invokeOn: self defaultSelection: nil.! !!ScorePlayerMorph methodsFor: 'menu' stamp: 'jm 12/17/2001 08:14'!saveAsAIFF	"Create a stereo AIFF audio file with the result of performing my score."	| fileName |	fileName _ FillInTheBlank request: 'New file name?'.	fileName size = 0 ifTrue: [^ self].	(fileName asLowercase endsWith: '.aif') ifFalse: [		fileName _ fileName, '.aif'].	scorePlayer storeAIFFOnFileNamed: fileName.! !!ScorePlayerMorph methodsFor: 'menu' stamp: 'jm 12/17/2001 08:16'!saveAsSunAudio	"Create a stereo Sun audio file with the result of performing my score."	| fileName |	fileName _ FillInTheBlank request: 'New file name?'.	fileName size = 0 ifTrue: [^ self].	(fileName asLowercase endsWith: '.au') ifFalse: [		fileName _ fileName, '.au'].	scorePlayer storeSunAudioOnFileNamed: fileName.! !!ScorePlayerMorph methodsFor: 'menu' stamp: 'jm 12/17/2001 08:14'!saveAsWAV	"Create a stereo WAV audio file with the result of performing my score."	| fileName |	fileName _ FillInTheBlank request: 'New file name?'.	fileName size = 0 ifTrue: [^ self].	(fileName asLowercase endsWith: '.wav') ifFalse: [		fileName _ fileName, '.wav'].	scorePlayer storeWAVOnFileNamed: fileName.! !!ScorePlayerMorph methodsFor: 'menu' stamp: 'jm 9/12/1998 22:14'!updateInstrumentsFromLibrary	"The instrument library has been modified. Update my instruments with the new versions from the library. Use a single instrument prototype for all parts with the same name; this allows the envelope editor to edit all the parts by changing a single sound prototype."	| unloadPostfix myInstruments name displaysAsUnloaded isUnloaded |	unloadPostfix _ '(out)'.	myInstruments _ Dictionary new.	1 to: instrumentSelector size do: [:i |		name _ (instrumentSelector at: i) contents.		displaysAsUnloaded _ name endsWith: unloadPostfix.		displaysAsUnloaded ifTrue: [			name _ name copyFrom: 1 to: name size - unloadPostfix size].		(myInstruments includesKey: name) ifFalse: [			myInstruments at: name put:				(name = 'clink'					ifTrue: [						(SampledSound							samples: SampledSound coffeeCupClink							samplingRate: 11025) copy]					ifFalse: [						(AbstractSound							soundNamed: name							ifAbsent: [								(instrumentSelector at: i) contentsClipped: 'default'.								FMSound default]) copy])].		scorePlayer instrumentForTrack: i put: (myInstruments at: name).		"update loaded/unloaded status in instrumentSelector if necessary"		isUnloaded _ (myInstruments at: name) isKindOf: UnloadedSound.		(displaysAsUnloaded and: [isUnloaded not])			ifTrue: [(instrumentSelector at: i) contentsClipped: name].		(displaysAsUnloaded not and: [isUnloaded])			ifTrue: [(instrumentSelector at: i) contentsClipped: name, unloadPostfix]].! !!ScorePlayerMorph methodsFor: 'stepping' stamp: 'di 6/15/1999 11:48'!step	scrollSlider adjustToValue: scorePlayer positionInScore.! !!ScorePlayerMorph class methodsFor: 'as yet unclassified' stamp: 'jm 10/12/1998 16:29'!openOn: aScore title: aString	| player |	player _ ScorePlayer onScore: aScore.	(self new onScorePlayer: player title: aString) openInWorld.! !I am a button that is associated with a HatBlockMorph. I keep my label updated with the current script name and change the label color to reflect the state of the process associated with the HatBlockMorph. I delete myself if the HatBlockMorph is deleted.!!ScratchButtonMorph methodsFor: 'initialization' stamp: 'jm 8/24/2003 10:31'!initialize	super initialize.	self color: (Color r: 0.6 g: 0.0 b: 0.8).	self extent: 29@23.	nameMorph _ (StringMorph contents: 'button')		font: LabelFont;		color: Color white;		position: (self left + 5) @ self top.	self addMorph: nameMorph.! !!ScratchButtonMorph methodsFor: 'accessing' stamp: 'jm 9/28/2003 16:48'!target: aHatBlock	target _ aHatBlock.	self step.! !!ScratchButtonMorph methodsFor: 'dropping/grabbing' stamp: 'TIS 8/8/2003 10:23'!justDroppedInto: aMorph event: anEvent	"I can be dropped into script editor pane or work pane."	(owner isKindOf: ScratchViewerMorph) 		ifTrue: [^ self rejectDropEvent: anEvent]		ifFalse: [^ self].! !!ScratchButtonMorph methodsFor: 'event handling' stamp: 'jm 9/28/2003 17:05'!click: evt	target ifNil: [^ self].	target toggleProcess.	self step.  "update run indicator immediately"! !!ScratchButtonMorph methodsFor: 'stepping' stamp: 'jm 9/30/2003 21:34'!step	| c |	target ifNil: [^ self].	target owner ifNil: [  "my target has been deleted; delete myself"		self delete.		target _ nil.		^ self].	"update runIndicator"	target step.  "in case target is not in world"	c _ target indicatorColor.	c saturation < 0.1 ifTrue: [c _ Color white].	nameMorph color: c.	"update name"	nameMorph contents = target scriptName ifFalse: [		nameMorph contents: target scriptName.		self width: nameMorph width + 10].! !!ScratchButtonMorph methodsFor: 'stepping' stamp: 'jm 9/28/2003 17:04'!stepTime	^ 100! !!ScratchButtonMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:13'!fieldsVersion	^ 1! !!ScratchButtonMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:14'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		nameMorph		target	) from: anObjStream.! !!ScratchButtonMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:14'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		nameMorph		target	) on: anObjStream.! !!ScratchFileChooserDialog methodsFor: 'initialization' stamp: 'MD 12/18/2003 13:37'!initialize	"Add one more morph for the user's response."	|dirDisplay col model |	super initialize.	model _ ScratchFileChooserModel new.	extensions _ '*.*'.		list _ PluggableListMorphDoubleClick on: model			list: #itemList			selected: #selectedItem			changeSelected: #selectedItem:			menu: #itemListMenu:			keystroke: #itemListKeystroke:.	dirList _ PluggableListMorphDoubleClick on: model			list: #directoryList			selected: #selectedDir			changeSelected: #selectedDir:			menu: nil			keystroke: nil.	dirDisplay _ UpdatingStringMorph on: model selector: #dirName.	dirDisplay useStringFormat.	dirDisplay font: (TextStyle default fontAt: 2) emphasis: 1.	fileSelection _ UpdatingStringMorph on: model selector: #selectedItemName.	fileSelection useStringFormat.	fileSelection font: (TextStyle default fontAt: 2) emphasis: 1.	"make list scroll bar stay up"	list retractable: false.	list extent: 250@300.		dirList retractable: false.	dirList extent: 250@80.		extensionsField _ UpdatingStringMorph new 		contents: extensions asString;		target: self;		getSelector: #getExtensions;		putSelector: #propagateExtensions:;		useStringFormat.	newFileName _ UpdatingStringMorph new		contents: ' <type new file name> ';		target: self;		getSelector: #getFilenameString;		putSelector: #propagateFilenameString:;		useStringFormat.	self type: 1 withButtonsForYes: false no: false okay: true cancel: true;		message: ' '.	col _ self submorphs at: 1.	col removeAllMorphs.	col inset: 5; extent: 5@5.	col		addMorphBack: (Morph new color: col color; extent: 5);  		addMorphBack: fileSelection;		addMorphBack: (Morph new color: col color; extent: 5);  "spacer"		addMorphBack: dirDisplay;		addMorphBack: (Morph new color: col color; extent: 5);  "spacer"		addMorphBack: dirList;		addMorphBack: (Morph new color: col color; extent: 5);  "spacer"		addMorphBack: list;		addMorphBack: (Morph new color: col color; extent: 5);  "spacer"		addMorphBack: extensionsField;		addMorphBack: (Morph new color: col color; extent: 5);  "spacer"		addMorphBack: (AlignmentMorph new color: col color; 			addMorphBack: (SimpleButtonMorph new label: 'Create new file: '; target: self; actionSelector: #createNewFile; color: Color lightGray; borderColor: Color black); 			addMorphBack: (Morph new color: col color; extent: 5); 			addMorphBack: newFileName);		addMorphBack: buttonRow.! !!ScratchFileChooserDialog methodsFor: 'interaction' stamp: 'MD 12/16/2003 16:45'!getUserResponse	"Wait for the user to respond, then report their response. The symbol #cancelled is returned if the user wishes to cancel the operation. True/false is returned if they respond yes/no, and a string with the full path name is returned if this is a file chooser dialog and they don't cancel. To get the file from the response use the method: FileDirectory on: <reponse>"	"Details: This is invoked synchronously from the caller. In order to keep processing inputs and updating the screen while waiting for the user to respond, this method has its own version of the World's event loop."	| w |	self openInWorld.	w _ self world.	self position: w center - (self extent // 2).  "center on screen"	self extent: self extent.  "force layout"	response _ #cancelled.  "default response"	done _ false.	[done or: [(list getModel) isFinalSelection]] whileFalse: [w doOneCycle].  "wait for user to press a button"	self delete.	w doOneCycle.  "erase myself from the screen""self halt."	((response = #cancelled) and: [(list getModel isFinalSelection) not])		ifTrue: [^ #cancelled]		"ifFalse: [^ fileSelection contents ]"		ifFalse: [^ list getModel selectedItemName]! !!ScratchFileChooserDialog methodsFor: 'geometry' stamp: 'MD 12/18/2003 12:36'!extent: aPoint	"Resize my submorphs correctly whenever I get resized."	| minExtent col |	submorphs size = 0 ifTrue: [^ super extent: aPoint].  "no submorphs to resize; happens during initialization"	minExtent _ 100@100.	buttonRow ifNotNil: [minExtent _ (buttonRow minWidth @ buttonRow minHeight) + (10@60)].	super extent: (aPoint max: minExtent).	col _ self firstSubmorph.	col extent: self extent - (10@28).  "resize the column"		list ifNotNil: [list extent: self extent - (20@280)]. "20@230"	list ifNotNil: [list width: (self width - 20). list height: (self height + list height) / 4].	dirList ifNotNil: [dirList width: (self width - 20). dirList height: (self height + dirList height) / 6]. "20@350"	col submorphs do: [:m |		(m isKindOf: UpdatingStringMorph) ifTrue: [ 			m extent: (col width - (2 * col inset))@15 ].	"	(m isKindOf: PluggableListMorph) ifTrue: [			m extent: self extent - (20@150)]" "This works with just the file list but we don't want the same for the directory list."	]! !!ScratchFileChooserDialog methodsFor: 'as yet unclassified' stamp: 'jm 1/4/2004 10:49'!createNewFile	| filename newFile aFileName directory |	aFileName _ newFileName contents.	(aFileName = '' or: [aFileName = ' <type new file name> ']) 		ifTrue: [filename _ InputDialogBoxMorph askWithCancel: 'File name?' defaultResponse: ' ']		ifFalse: [filename _ aFileName].	filename		ifNil: [			Transcript show: 'nil in new file: ', filename; cr.			^ nil]		ifNotNil: [			directory _ FileDirectory default directoryNamed: (list getModel dirName).			Transcript show: directory.			newFile _ directory newFileNamed: (directory fullNameFor: filename).			^ newFile].! !!ScratchFileChooserDialog methodsFor: 'as yet unclassified' stamp: 'MD 12/18/2003 13:34'!createNewFile: aFilename	|filename newFile |	(aFilename = '' or: [aFilename = ' <type new file name> ']) 		ifTrue: [filename _ InputDialogBoxMorph askWithCancel: 'File name?' defaultResponse: ' ']		ifFalse: [filename _ aFilename].	filename ifNil: [^ nil]		ifNotNil: [			newFile _ (FileDirectory directoryNamed: (self dirName)) newFileNamed: filename.			^ newFile].! !!ScratchFileChooserDialog methodsFor: 'as yet unclassified' stamp: 'MD 12/17/2003 16:48'!getExtensions	^ extensions! !!ScratchFileChooserDialog methodsFor: 'as yet unclassified' stamp: 'MD 12/18/2003 13:10'!getFilenameString	^ newFileName contents.! !!ScratchFileChooserDialog methodsFor: 'as yet unclassified' stamp: 'MD 12/18/2003 11:08'!propagateExtensions: anObject	| tempExtensions |	(anObject size = 0) ifTrue: [extensions _ nil. list getModel extensions: nil.]		ifFalse: [			tempExtensions _ anObject substrings.			extensions _ anObject.			list getModel extensions: tempExtensions.]	! !!ScratchFileChooserDialog methodsFor: 'as yet unclassified' stamp: 'MD 12/18/2003 13:12'!propagateFilenameString: anObject	| |	(anObject size = 0 or: [anObject isNil]) ifTrue: [^ nil].		! !!ScratchFileChooserDialog class methodsFor: 'as yet unclassified' stamp: 'MD 12/11/2003 14:28'!example	| morph |	morph _ self new.	morph extent: 400@420.		^ morph openInWorld getUserResponse.! !!ScratchFileChooserModel methodsFor: 'initialization' stamp: 'MD 12/16/2003 15:47'!initialize	currentDir _ FileDirectory default.	selectedIndex _ 0.	selectedDir _ 0.	doubleClicked _ false.	finalSelection _ false.		! !!ScratchFileChooserModel methodsFor: 'accessing' stamp: 'MD 12/12/2003 18:24'!dirName	"Answer the current directory name."	(currentDir pathParts isEmpty) ifFalse: [ ^ 'Folder: ', currentDir pathParts last].	^ 'Folder: <root> '! !!ScratchFileChooserModel methodsFor: 'accessing' stamp: 'MD 12/15/2003 15:10'!directoryList	"Answer a collection of the folder names within the file system. Prefix directories with a tab to indicate the hierarchy."		^ ((Array with: '[]'), currentDir pathParts withIndexCollect: [:each :i | ( String new: i-1 withAll: $ ), each])! !!ScratchFileChooserModel methodsFor: 'accessing' stamp: 'MD 12/16/2003 18:38'!doubleClicked: aBoolean	aBoolean = nil ifFalse: [doubleClicked _ aBoolean].! !!ScratchFileChooserModel methodsFor: 'accessing' stamp: 'MD 12/17/2003 14:43'!extensions	^ fileExtensions! !!ScratchFileChooserModel methodsFor: 'accessing' stamp: 'MD 12/18/2003 11:43'!extensions: anArrayTranscript show: 'called model extensions ',(anArray isNil) asString;cr.	"tempArray _ Array with: anArray substrings."	fileExtensions _ anArray.	self changed: #itemList."	self changed: #selectedItem."! !!ScratchFileChooserModel methodsFor: 'accessing' stamp: 'MD 12/16/2003 14:45'!isDoubleClicked		^ doubleClicked.! !!ScratchFileChooserModel methodsFor: 'accessing' stamp: 'MD 12/16/2003 15:57'!isFinalSelection		^ finalSelection.! !!ScratchFileChooserModel methodsFor: 'accessing' stamp: 'MD 12/18/2003 11:44'!itemList	| ext filesAndDirectoriesList |	"Answer a collection of the file and folder names within the current directory. Prefix directories with a string to indicate what they are.""	^ currentDir entries collect: [:e |		e isDirectory ifTrue: [e name] ifFalse: [e name, ' <dir>']]."	filesAndDirectoriesList _ 		(currentDir directoryNames collect: [:e | ' <dir> ', e name]) ,		(currentDir fileNames select: [:d | 			(fileExtensions isNil not and: [fileExtensions includes: '*']) 				ifTrue: [fileExtensions _ nil]. 			fileExtensions				ifNil: [true]				ifNotNil: [					ext _ (FileDirectory extensionFor: d) asLowercase.					fileExtensions includes: ext. ]		]).		^ filesAndDirectoriesList.	! !!ScratchFileChooserModel methodsFor: 'accessing' stamp: 'jm 12/2/2003 13:01'!itemListKeystroke: aCharacter	self beep.! !!ScratchFileChooserModel methodsFor: 'accessing' stamp: 'MD 12/11/2003 15:30'!selectedDir	"Answer the index of the selected file or directory. Answer zero if there is no selection."		^ selectedDir! !!ScratchFileChooserModel methodsFor: 'accessing' stamp: 'MD 12/15/2003 15:56'!selectedDir: anIndex	| tempArray tempDir |	"Select the folder with the given index."	anIndex = 0 ifFalse: [selectedDir _ anIndex].	tempDir _ String new.		tempArray _ self directoryList withIndexCollect: [:i :p | (p <= selectedDir) ifTrue: [i withBlanksTrimmed].]. "select up to the index and not all the parts"	tempArray allButFirst do: [:i | i ifNotNil: [tempDir _ tempDir , i withBlanksTrimmed asString, FileDirectory pathNameDelimiter asString]]. "compose gradually the tempDir string with the full path that will become the new currentDir"		selectedIndex _ 0.	currentDir _ FileDirectory on: tempDir.	self changed: #selectedDir.	self changed: #directoryList.	self changed: #itemList.	! !!ScratchFileChooserModel methodsFor: 'accessing' stamp: 'MD 12/10/2003 15:19'!selectedItem	"Answer the index of the selected file or directory. Answer zero if there is no selection."		^ selectedIndex! !!ScratchFileChooserModel methodsFor: 'accessing' stamp: 'MD 12/16/2003 18:06'!selectedItem: anIndex	"Select the file or folder with the given index."	anIndex > currentDir entries size ifTrue: [Transcript show: 'turned to 0'. selectedIndex _ 0].	anIndex = 0 ifFalse: [selectedIndex _ anIndex]. "anIndex = 0 means that the user selected the curent selection. In order to select what appears highlighted on the list, we need the selectedIndex" doubleClicked ifTrue: [		(selectedIndex <= currentDir directoryNames size) ifTrue: [		currentDir _ currentDir directoryNamed: (currentDir directoryNames at: selectedIndex).		self changed: #selectedItem.		self changed: #itemList.		self changed: #directoryList. 		selectedDir _ selectedDir + 1. self changed: #selectedDir. "we are selecting directory from the 'items' list so we need to update the directory index manually. The new directory will be a subdirectory of the currentDir." doubleClicked _ false. finalSelection _ false. 		] ifFalse: [self changed: #selectedItem. finalSelection _ true.]]ifFalse:[	self changed: #selectedItem.	]	! !!ScratchFileChooserModel methodsFor: 'accessing' stamp: 'MD 12/18/2003 11:45'!selectedItemName	"Answer the index of the selected file or directory. Answer zero if there is no selection."	| entries |	entries _ self itemList.	((1 <= selectedIndex and: [selectedIndex > currentDir directoryNames size]) and: [selectedIndex <= entries size]) ifFalse: [^ 'no file selected'].	^ currentDir fullPathFor: (entries at: (selectedIndex - currentDir directoryNames size))	! !!ScratchFileChooserModel methodsFor: 'menu' stamp: 'jm 12/2/2003 13:20'!goToParentDir	| parentPath |	parentPath _ FileDirectory dirPathFor: currentDir pathName.	parentPath size = 0 ifTrue: [^ self].	currentDir _ FileDirectory on: parentPath.	selectedIndex _ 0.	self changed: #selectedItem.	self changed: #itemList.! !!ScratchFileChooserModel methodsFor: 'menu' stamp: 'jm 12/2/2003 13:11'!itemListMenu: aMenu	^ aMenu addList: #((up goToParentDir))! !!ScratchFileChooserModel methodsFor: 'menu' stamp: 'jm 12/2/2003 13:11'!perform: sel orSendTo: otherObject	"Handle the given action myself, if I can, or let otherObject handle it."	(self respondsTo: sel)		ifTrue: [self perform: sel]		ifFalse: [otherObject perform: sel].! !!ScratchFileChooserModel class methodsFor: 'example' stamp: 'jm 12/2/2003 13:35'!example	"self example"	| model dirDisplay selectionDisplay col list |	model _ self new.	list _ PluggableListMorph on: model			list: #itemList			selected: #selectedItem			changeSelected: #selectedItem:			menu: #itemListMenu:			keystroke: #itemListKeystroke:.	dirDisplay _ UpdatingStringMorph on: model selector: #dirName.	dirDisplay useStringFormat.	selectionDisplay _ UpdatingStringMorph on: model selector: #selectedItemName.	selectionDisplay useStringFormat.	"make list scroll bar stay up"	list retractable: false.	list extent: 250@300.	col _ AlignmentMorph newColumn.	col borderWidth: 2; inset: 5; extent: 5@5.	col		addMorphBack: (Morph new color: col color; extent: 5);  "spacer"		addMorphBack: dirDisplay;		addMorphBack: (Morph new color: col color; extent: 5);  "spacer"		addMorphBack: list;		addMorphBack: (Morph new color: col color; extent: 5);  "spacer"		addMorphBack: selectionDisplay.	col openInWorld.! !I am the top level user interface for Scratch. I tile the screen with a toolbar, a work pane (for content), a viewer pane, and a script editor pane. I can resize myself to fill the entire Squeak window.I keep a list of Scratch processes (threads) and run each one to the its next stopping point when I am stepped each screen update cycle.!!ScratchFrameMorph methodsFor: 'intialization' stamp: 'ee 8/6/2003 11:33'!barForms: formList	"Set the forms used for my joints and dividing bars, create my toolbar, then position everything."	| topJointForm leftJointForm rightJointForm bottomJointForm vBarForm hBarForm |	topJointForm _ formList at: 1.	topJointFormHeight _ topJointForm height.	leftJointForm _ formList at: 2.	rightJointForm _ formList at: 3.	bottomJointForm _ formList at: 4.	vBarForm _ formList at: 5.	hBarForm _ formList at: 6.	vBar _ ScratchPaneDivider new scratchFrame: self.	vBar startForm: topJointForm edgeForm: vBarForm endForm: bottomJointForm; edgeOffset: 1.	hBar _ ScratchPaneDivider new scratchFrame: self.	hBar startForm: leftJointForm edgeForm: hBarForm endForm: rightJointForm.	self createPanes.	self createToolBar.	self createButtons.	self addMorphFront: vBar.	self addMorphFront: hBar.	self positionBars.! !!ScratchFrameMorph methodsFor: 'intialization' stamp: 'jm 10/20/2003 11:18'!createButtons	| buttonSpecs bName bSelector button |	"buttonSpecs defines the toolbar buttons; first is icon name, second is selector"	buttonSpecs _ #(		"name			selector"		(folder			fileMenu)"xxx		(viewFull		noOp) xxx"		(sound			addSoundMorph)		(sprite			addSpriteMorph)		(imagebox		addImageBoxMorph)		(sensorboard	addSensorBoardMorph)		(stop			stopAll)"xxx		(help			noOp) xxx"	).	buttonSpecs do: [:spec |		bName _ spec at: 1.		bSelector _ spec at: 2.		button _ ToggleButton 			onForm: (DefaultSkin at: (bName, 'ButtonPressed') asSymbol)			offForm: (DefaultSkin at: (bName, 'Button') asSymbol)			overForm: (DefaultSkin at: (bName, 'ButtonOver') asSymbol).		button target: self; actionSelector: bSelector; isMomentary: true.		bName = #folder ifTrue: [button actWhen: #buttonDown].		buttonPane addMorphBack: button.		((bName = #folder) or: [bName = #sensorboard])			ifTrue: [				buttonPane addMorphBack: 					(AlignmentMorph new hResizing: #spaceFill; color: Color transparent)]			ifFalse: [				(bName = #help) ifFalse: [  "add a spacer except for the final button"					buttonPane addMorphBack: 						(AlignmentMorph new 							hResizing: #rigid; 							width: 6; 							color: Color transparent)]]].! !!ScratchFrameMorph methodsFor: 'intialization' stamp: 'jm 9/13/2003 20:01'!createPanes	"Create and add my work, viewer, and scripts panes."	workPane _ ScratchWorkPaneMorph new.	viewerPane _ ScratchViewerMorph new.		scriptsPane _ ScratchScriptEditorMorph new.	viewerPane thumbnail workPane: workPane.	scriptsPane thumbnail workPane: workPane.	"make panes sticky so clicking on them doesn't pick up entire frame"	self addMorph: (workPane isSticky: true);		addMorph: (viewerPane isSticky: true);		addMorph: (scriptsPane isSticky: true).! !!ScratchFrameMorph methodsFor: 'intialization' stamp: 'ee 8/6/2003 15:54'!createToolBar	"Create and add a toolBar and a buttonPane and then create my buttons."	toolBar _ ScratchToolBar newFromSkin: DefaultSkin.	toolBar position: (self topLeft + ((topLeftForm width - 7)@0)).	self addMorph: toolBar.	buttonPane _ AlignmentMorph new		color: Color transparent;		position: toolBar topLeft + (10@0).	toolBar addMorph: buttonPane.! !!ScratchFrameMorph methodsFor: 'intialization' stamp: 'jm 9/13/2003 20:07'!initialize	super initialize.	vBarX _ (self width - 200).	hBarY _ (self height // 2).	fillScreenFlag _ false.	processes _ OrderedCollection new.	inProcessStep _ false.! !!ScratchFrameMorph methodsFor: 'accessing' stamp: 'jm 7/20/2003 12:05'!extent: aPoint	"Position all my submorphs whenever I get resized."	super extent: aPoint.	self positionBars.! !!ScratchFrameMorph methodsFor: 'accessing' stamp: 'jm 7/20/2003 12:05'!fillScreenFlag: aBoolean	"If true, fill the entire window."	fillScreenFlag _ aBoolean.! !!ScratchFrameMorph methodsFor: 'accessing' stamp: 'jm 7/20/2003 12:06'!hBarY: aNumber	"Fix my layout whenever my horizontal bar is moved."	hBarY _ aNumber.	self positionBars.! !!ScratchFrameMorph methodsFor: 'accessing' stamp: 'jm 11/13/2003 20:42'!projectDirectory	projectDirectory ifNil: [^ FileDirectory default].	^ projectDirectory! !!ScratchFrameMorph methodsFor: 'accessing' stamp: 'jm 7/20/2003 12:13'!scriptsPane	^ scriptsPane! !!ScratchFrameMorph methodsFor: 'accessing' stamp: 'jm 7/20/2003 12:06'!vBarX: aNumber	"Fix my layout whenever my vertical bar is moved."	vBarX _ aNumber.	self positionBars.! !!ScratchFrameMorph methodsFor: 'accessing' stamp: 'jm 7/20/2003 12:08'!viewerPane	^ viewerPane! !!ScratchFrameMorph methodsFor: 'accessing' stamp: 'jm 7/20/2003 12:08'!workPane	^ workPane! !!ScratchFrameMorph methodsFor: 'buttonActions' stamp: 'jm 9/29/2003 19:57'!addImageBoxMorph	self paintingInProgress ifTrue: [^ self beep].	self activeHand attachMorph: ImageBoxMorph new.! !!ScratchFrameMorph methodsFor: 'buttonActions' stamp: 'jm 9/29/2003 19:57'!addSensorBoardMorph	self paintingInProgress ifTrue: [^ self beep].	self activeHand attachMorph: SensorBoardMorph new.! !!ScratchFrameMorph methodsFor: 'buttonActions' stamp: 'jm 9/29/2003 19:58'!addSoundMorph	| soundMorphToAdd |	self paintingInProgress ifTrue: [^ self beep].	soundMorphToAdd _ SoundMorph new.	self activeHand grabMorph: soundMorphToAdd.	soundMorphToAdd position: self activeHand position.! !!ScratchFrameMorph methodsFor: 'buttonActions' stamp: 'jm 9/29/2003 19:58'!addSpriteMorph	self paintingInProgress ifTrue: [^ self beep].	self activeHand attachMorph: SpriteMorph new.! !!ScratchFrameMorph methodsFor: 'buttonActions' stamp: 'jm 7/20/2003 12:31'!noOp	"Do nothing."! !!ScratchFrameMorph methodsFor: 'buttonActions' stamp: 'jm 9/29/2003 19:58'!stopAll	"Stop all processes and make sure I am stepping."	processes do: [:p | p stop].	processes _ OrderedCollection new.	inProcessStep _ false.	SoundPlayer shutDown.	workPane allMorphsDo: [:m |		(m isKindOf: ImageBoxMorph) ifTrue: [m stopPlaying].		(m isKindOf: SoundMorph) ifTrue: [m pausePlaying]].	scriptsPane allMorphsDo: [:m |		(m respondsTo: #litUp:) ifTrue: [m litUp: false]].	self world ifNotNil: [self world startSteppingSubmorphsOf: self].! !!ScratchFrameMorph methodsFor: 'file menu' stamp: 'jm 7/21/2003 09:24'!allPensUp	"Lift the pens of all my sprites."	workPane allMorphsDo: [:m |		(m respondsTo: #penDown:) ifTrue: [m penDown: false]].! !!ScratchFrameMorph methodsFor: 'file menu' stamp: 'jm 7/21/2003 09:22'!clearPenTrails	"Clear the pen trails from my work pane."	workPane clearTurtleTrails.! !!ScratchFrameMorph methodsFor: 'file menu' stamp: 'jm 8/3/2003 14:24'!exitProject	"Exit the current project. This is hack for demos where you want to have a bunch of Scratch worlds set up in different projects."	Project current exit.! !!ScratchFrameMorph methodsFor: 'file menu' stamp: 'jm 11/13/2003 11:42'!fileMenu	"Present the Scratch file menu. Right now, this menu contains all the Scratch menu commands."	| menu |	menu _ CustomMenu new.	menu add: 'new' action: #newScratchProject.	menu add: 'open...' action: #openScratchProject.	menu add: 'save...' action: #saveScratchProject.	menu addLine.	menu add: 'presentation size...' action: #setPresentationSize.	menu add: 'clear pen trails' action: #clearPenTrails.	menu addLine.	menu add: 'single stepping...' action: #setSingleStepping.	Sensor shiftPressed ifTrue: [		menu addLine.		fillScreenFlag			ifTrue: [menu add: 'turn fill screen off' action: #fillScreenOff]			ifFalse: [menu add: 'turn fill screen on' action: #fillScreenOn].		UseErrorCatcher			ifTrue: [menu add: 'turn error catching off' action: #toggleErrorCatcher]			ifFalse: [menu add: 'turn error catching on' action: #toggleErrorCatcher].		menu addLine.		menu add: 'exit project' action: #exitProject].	menu invokeOn: self.! !!ScratchFrameMorph methodsFor: 'file menu' stamp: 'jm 9/30/2003 00:27'!fillScreenOff	"Stop filling the entire screen. Useful during development."	fillScreenFlag _ false.	self isSticky: false.	self extent: self extent - 30.	Preferences disable: #noviceMode.! !!ScratchFrameMorph methodsFor: 'file menu' stamp: 'jm 9/30/2003 00:34'!fillScreenOn	"Start filling the entire screen and being sticky. Also configure a few other things for the end user such as turning off halos and the control menu (noviceMode) and making sure that error catching is enabled."	fillScreenFlag _ true.	self position: 0@0.	self isSticky: true.	self comeToFront.	UseErrorCatcher _ true.	Preferences enable: #noviceMode.! !!ScratchFrameMorph methodsFor: 'file menu' stamp: 'jm 12/1/2003 18:50'!installPageMorphs: morphList	| offset |	offset _ workPane position.	morphList do: [:m | m position: m position + offset].	viewerPane target: nil.	scriptsPane target: nil.	workPane removeAllMorphs.	workPane addAllMorphs: morphList.	morphList do: [:m | (m respondsTo: #openAfterLoad) ifTrue: [m openAfterLoad]].	self world ifNotNil: [self world startSteppingSubmorphsOf: workPane].! !!ScratchFrameMorph methodsFor: 'file menu' stamp: 'jm 11/13/2003 11:32'!newScratchProject	"Make a new, blank Scratch project."	workPane submorphs size > 0 ifTrue: [		(self confirm: 'Discard changes to the current project?') ifFalse: [^ self]].	self stopAll.	self installPageMorphs: #().	projectDirectory _ FileDirectory default.	projectName _ ''.! !!ScratchFrameMorph methodsFor: 'file menu' stamp: 'jm 12/1/2003 18:05'!openScratchProject	| result fName in pages |	result _ StandardFileMenu oldFileExtensions: #(scratch).	result ifNil: [^ self].	fName _ result directory pathName, FileDirectory slash, result name.	in _ (FileStream readOnlyFileNamed: fName) binary.	pages _ ObjStream new readObjFrom: in.	in close.	projectDirectory _ result directory.	projectName _ result name.	self stopAll.	processes _ processes species new.	inProcessStep _ false.	self installPageMorphs: pages first second.! !!ScratchFrameMorph methodsFor: 'file menu' stamp: 'jm 11/12/2003 07:57'!saveScratchProject	| fName |	self paintingInProgress ifTrue: [		^ self inform: 'Please close the image editor before saving.'].	self soundRecordingOrEditingInProgress ifTrue: [		^ self inform: 'Please close all sound recorders and editors before saving.'].	projectName ifNil: [projectName _ ''].	(projectName asLowercase endsWith: '.scratch')		ifTrue: [fName _ projectName copyFrom: 1 to: projectName size - 8]		ifFalse: [fName _ projectName].	fName _ FillInTheBlank request: 'File name?' initialAnswer: fName.	fName size = 0 ifTrue: [^ self].	(fName endsWith: '.scratch') ifFalse: [fName _ fName, '.scratch'].	projectName _ FileDirectory localNameFor: fName.  "ignore path, if any; save in the original project directory"	projectDirectory ifNil: [projectDirectory _ FileDirectory default].	self writeScratchProject.! !!ScratchFrameMorph methodsFor: 'file menu' stamp: 'jm 11/13/2003 12:53'!setPresentationSize	"Set the presentation size. This merely displays some gray boundary line to help the user design their presentation."	| menu extent |	menu _ CustomMenu new title: 'Presentation size?'.	menu add: '240 x 320' action: 240@320.	menu add: '320 x 240' action: 320@240.	menu add: '320 x 320' action: 320@320.	menu add: '640 x 480' action: 640@480.	menu add: '720 x 540' action: 720@540.	menu add: '800 x 600' action: 800@600.	menu add: '960 x 720' action: 960@720.	menu add: '1024 x 768' action: 1024@768.	menu add: 'unlimited' action: 10000@10000.	extent _ menu startUp.	extent ifNil: [^ self].	workPane presentationExtent: extent.! !!ScratchFrameMorph methodsFor: 'file menu' stamp: 'jm 8/7/2003 12:12'!setSingleStepping	"Ask whether script should be single-stepped."	| menu mSecs |	menu _ CustomMenu new title: 'Single-step speed?'.	menu add: 'full speed' action: 0.	menu add: 'fast' action: 10.	menu add: 'medium' action: 50.	menu add: 'slow' action: 200.	mSecs _ menu startUp.	mSecs ifNil: [^ self].	ScratchProcess blockHighlightMSecs: mSecs.! !!ScratchFrameMorph methodsFor: 'file menu' stamp: 'jm 9/29/2003 23:19'!toggleErrorCatcher	UseErrorCatcher _ UseErrorCatcher not.! !!ScratchFrameMorph methodsFor: 'file menu' stamp: 'jm 12/3/2003 08:03'!writeScratchProject	"Write this Scratch project to the file named projectFile in the project directory. Called by saveScratchProject."	| oldScriptsTarget mList mOffset pages saveError out |	self world ifNotNil: [self world firstHand newKeyboardFocus: nil].  "terminates active editor"	oldScriptsTarget _ scriptsPane target.	scriptsPane target: nil.	mList _ workPane submorphs.	mOffset _ workPane position.	workPane removeAllMorphs.	mList do: [:m | m position: m position - mOffset].	pages _ Array with: (Array with: 'page1' with: mList).	saveError _ nil.	[	out _ (FileStream newFileNamed: (projectDirectory unusedNameStartingWith: 'tmp')) binary.		ObjStream new storeObj: pages on: out showProgress: true.		out close.	] ifError: [:err :rcvr | saveError _ err].	mList do: [:m | m position: m position + mOffset].	workPane changed.	workPane addAllMorphs: mList.	scriptsPane target: oldScriptsTarget.	saveError		ifNil: [			projectDirectory deleteFileNamed: projectName.			projectDirectory rename: out localName toBe: projectName.			projectDirectory setMacFileNamed: projectName type: 'ScPr' creator: 'FaST']		ifNotNil: [			out close.			projectDirectory deleteFileNamed: out localName.			self inform: 'Save failed: ', saveError].! !!ScratchFrameMorph methodsFor: 'drawing' stamp: 'jm 7/20/2003 14:03'!drawOn: aCanvas	"Optimization: Don't draw the frame if the area to be redrawn is entirely within one of my panes."	| r |	workPane ifNotNil: [		r _ aCanvas clipRect.		(workPane bounds containsRect: r) ifTrue: [^ self].		(viewerPane bounds containsRect: r) ifTrue: [^ self].		(scriptsPane bounds containsRect: r) ifTrue: [^ self]].	super drawOn: aCanvas.! !!ScratchFrameMorph methodsFor: 'stepping' stamp: 'jm 11/13/2003 12:35'!step	"Run each process until it gives up control, then filter out any processes that have terminated."	| screenExtent |	fillScreenFlag ifTrue: [		screenExtent _ (Display width max: MinWidth)@(Display height max: MinHeight).		((self position = (0@0)) and: [self extent = screenExtent]) ifFalse: [			self position: 0@0.			^ self extent: screenExtent]].	ScriptableScratchMorph origin: workPane position.	self stepProcesses.! !!ScratchFrameMorph methodsFor: 'stepping' stamp: 'jm 7/9/2003 12:02'!stepTime	"Every screen update cycle."	^ 0! !!ScratchFrameMorph methodsFor: 'processes' stamp: 'jm 8/11/2003 10:24'!startProcessForStatements: blockList	"Start a process to run the given list of blocks (script). Answer the new process."	| proc |	proc _ ScratchProcess new expression: blockList.	processes addLast: proc.	^ proc! !!ScratchFrameMorph methodsFor: 'processes' stamp: 'jm 9/29/2003 23:30'!stepProcesses	"Run each Scratch process until it gives up control, then filter out any processes that have terminated."	"Details: Iterate over a copy of processes to allow processes to stop themselves. During development, the error catcher makes it difficult to track down errors, so it can be disabled."	| proc |	inProcessStep ifTrue: [^ self].	inProcessStep _ true.	UseErrorCatcher		ifTrue: [			[processes copy do: [:p | (proc _ p) runStep]] ifError: [proc errorFlag: true]]		ifFalse: [			processes copy do: [:p | p runStep]].	processes _ processes select: [:p | p isTerminated not and: [p errorFlag not]].	inProcessStep _ false.! !!ScratchFrameMorph methodsFor: 'private' stamp: 'jm 9/29/2003 19:56'!paintingInProgress	"Answer true if the paint editor is in use."	^ workPane submorphs anySatisfy: [:m | m isKindOf: MyPaintFrame]! !!ScratchFrameMorph methodsFor: 'private' stamp: 'ee 8/6/2003 14:30'!positionBars	"Upon resizing, do the following:		- constrain my size		- constrain the movement of my vertical and horizontal bars		- position my vertical and horizontal bars		- position my workPane, viewerPane and blocks Pane		- layout my buttonPane"	| constrainedY constrainedX minHBarY maxHBarY minVBarX maxVBarX |	topEdgeForm ifNil: [^ self].	(self height < MinHeight) ifTrue: [self height: MinHeight].	(self width < MinWidth) ifTrue: [self width: MinWidth].	minHBarY _ topEdgeForm height + 90.	maxHBarY _ self height - (bottomEdgeForm height + 122).	constrainedY _ (hBarY max: minHBarY) min: maxHBarY.	minVBarX _ leftEdgeForm width + 160.	maxVBarX _ self width - (rightEdgeForm width + 170).	constrainedX _ (vBarX max: minVBarX) min: maxVBarX.	vBar position: self topLeft + (constrainedX @ (topEdgeForm height - topJointFormHeight + 4)).	vBar height: self height - topEdgeForm height + topJointFormHeight - 4.	hBar position: self topLeft + ((constrainedX + vBar edgeOffset) @ constrainedY).												hBar width: self width - (constrainedX + vBar edgeOffset).	workPane position: self topLeft + ((leftEdgeForm width - 3)@topEdgeForm height).	workPane height: self height - (bottomEdgeForm height + topEdgeForm height - 3).	workPane width: constrainedX.	viewerPane position: self topLeft + ((constrainedX + 10)@(topEdgeForm height - 4)); comeToFront.	viewerPane height: constrainedY - (topEdgeForm height - 9).	viewerPane width: self width - (constrainedX + rightEdgeForm width + 8).	scriptsPane position: self topLeft + ((constrainedX + 10)@(constrainedY + hBar height - 7)); comeToFront.	scriptsPane height: self height - constrainedY - (bottomEdgeForm height * 2) + 5.	scriptsPane width: self width - (constrainedX + rightEdgeForm width + 8).	toolBar width: (self width - (topLeftForm width + topRightForm width - 14)).	buttonPane width: (toolBar width - 22).! !!ScratchFrameMorph methodsFor: 'private' stamp: 'jm 9/29/2003 20:20'!soundRecordingOrEditingInProgress	"Answer true if a sound recorder or editor is in use."	^ workPane submorphs anySatisfy: [:m |		(m isKindOf: ScratchSoundEditor) | (m isKindOf: ScratchRecordingMorph)]! !!ScratchFrameMorph class methodsFor: 'class initialization' stamp: 'jm 9/29/2003 23:14'!initialize	MinWidth _ 470.	MinHeight _ 300.	UseErrorCatcher _ true.! !!ScratchFrameMorph class methodsFor: 'instance creation' stamp: 'jm 8/4/2003 14:48'!includeInNewMorphMenu	^ true! !!ScratchFrameMorph class methodsFor: 'instance creation' stamp: 'jm 7/3/2003 09:44'!new	"Answer a new instance of me using the default skin."	| corners edges bars |	DefaultSkin ifNil: [^ super new].  "no default skin"	corners _ Array		with: (DefaultSkin at: #topLeft)		with: (DefaultSkin at: #topRight)		with: (DefaultSkin at: #bottomLeft)		with: (DefaultSkin at: #bottomRight).	edges _ Array		with: (DefaultSkin at: #topEdge)		with: (DefaultSkin at: #leftEdge)		with: (DefaultSkin at: #rightEdge)		with: (DefaultSkin at: #bottomEdge).	bars _ Array		with: (DefaultSkin at: #topJoint)		with: (DefaultSkin at: #leftJoint)		with: (DefaultSkin at: #rightJoint)		with: (DefaultSkin at: #bottomJoint)		with: (DefaultSkin at: #vBar)		with: (DefaultSkin at: #hBar).	^ super new		cornerForms: corners;		edgeTileForms: edges;		barForms: bars! !!ScratchFrameMorph class methodsFor: 'instance creation' stamp: 'jm 7/20/2003 14:04'!newNoUI	"Answer a new instance of me with no UI."	^ super new extent: 20@15! !!ScratchFrameMorph class methodsFor: 'instance creation' stamp: 'jm 7/20/2003 22:32'!withFormsFrom: aDirectory	"Answer an image of me using the forms from the given directory."	"ScratchFrameMorph withFormsFrom: (FileDirectory default directoryNamed: 'ScratchSkin')" 	| bars m |	m _ super withFormsFrom: aDirectory.	bars _ Array		with: (Utilities form: 'topJoint' from: aDirectory)		with: (Utilities form: 'leftJoint' from: aDirectory)		with: (Utilities form: 'rightJoint' from: aDirectory)		with: (Utilities form: 'bottomJoint' from: aDirectory)		with: (Utilities form: 'vBar' from: aDirectory)		with: (Utilities form: 'hBar' from: aDirectory).	^ m barForms: bars! !!ScratchFrameMorph class methodsFor: 'default skin' stamp: 'ee 11/30/2003 18:46'!defaultSkin	^ DefaultSkin! !!ScratchFrameMorph class methodsFor: 'default skin' stamp: 'MD 12/4/2003 14:21'!readDefaultSkinFrom: aDirectory	"Read the Forms for my default skin from the given directory and store them in my DefaultSkin dictionary."	"self readDefaultSkinFrom: (FileDirectory default directoryNamed: 'ScratchSkin')."	| normal pressed over |	DefaultSkin _ Dictionary new.	"read frame forms"	#(topLeft topRight bottomLeft bottomRight	  topEdge leftEdge rightEdge bottomEdge	  topJoint leftJoint rightJoint bottomJoint	  vBar hBar) do: [:n |		DefaultSkin at: n asSymbol put: (Utilities form: n from: aDirectory)].	"read toobard forms"	#(toolBarLeft toolBarMiddle toolBarRight) do: [:n |		DefaultSkin at: n asSymbol put: (Utilities form: n from: aDirectory)].	"read button forms"	#(folder viewFull sound sprite imagebox sensorboard stop help) do: [:n |		normal _ n, 'Button'.		pressed _ n, 'ButtonPressed'.		over _ n, 'ButtonOver'.		DefaultSkin at: normal asSymbol put: (Utilities form: normal from: aDirectory).		DefaultSkin at: pressed asSymbol put: (Utilities form: pressed from: aDirectory).		DefaultSkin at: over asSymbol put: (Utilities form: pressed from: aDirectory)].		"read dialogs forms"	#(dialogTopLeft dialogTopLeftAttention dialogTopLeftInfo 	  dialogTopRight dialogBottomLeft dialogBottomRight	  dialogTopEdge dialogLeftEdge dialogRightEdge dialogBottomEdge	  dialogButton dialogButtonPressed dialogButtonOver) do: [:n |		DefaultSkin at: n asSymbol put: (Utilities form: n from: aDirectory)].! !I display a graph of numbers, normalized so the full range of values just fits my height. I support a movable cursor that can be dragged with the mouse.Implementation notes: Some operations on me may be done at sound sampling rates (e.g. 11-44 thousand times/second). To allow such high bandwidth application, certain operations that change my appearance do not immediately report a damage rectangle. Instead, a flag is set indicating that my display needs to refreshed and a step method reports the damage rectangle if that flag is set. Also, I cache a bitmap of my graph to allow the cursor to be moved without redrawing the graph.All indices, like startIndex, cursor, etc are in terms of the graph data.IMPORTANT!!  The current implementation cannot stand alone, it needs to be a submorph of SoundEditor.!!ScratchGraphMorph methodsFor: 'initialization' stamp: 'LY 7/31/2003 11:55'!addRuler	ruler _ ScratchRulerMorph graphMorph: self.	self addMorphBack: ruler.	ruler position: self bottomLeft.! !!ScratchGraphMorph methodsFor: 'initialization'!initialize	super initialize.	self color: (Color r: 0.8 g: 0.8 b: 0.6).	self extent: 365@80.	self borderWidth: 2.	dataColor _ Color darkGray.	cursorColor _ Color red.	playCursorColor _ Color blue.	cursorColorAtZeroCrossings _ Color red.	startIndex _ 1.	viewer _ false.	selection _ {nil. nil}.	scale _ 1.0.	hasChanged _ false.	posVals _ negVals _ nil.	self data:		((0 to: 360 - 1) collect:			[:x | (100.0 * (x degreesToRadians sin)) asInteger]).		! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'jm 7/12/2003 17:23'!color: aColor	super color: aColor.	self flushCachedForm.! !!ScratchGraphMorph methodsFor: 'accessing'!cursor	^ editor cursor! !!ScratchGraphMorph methodsFor: 'accessing'!cursor: aNumber	editor cursor: aNumber.! !!ScratchGraphMorph methodsFor: 'accessing'!cursorAtEnd	^editor cursor truncated >= data size! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'jm 7/12/2003 17:23'!cursorColor	^ cursorColor! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'jm 7/12/2003 17:23'!cursorColor: aColor	cursorColor _ aColor.	self flushCachedForm.! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'jm 7/12/2003 17:23'!cursorColorAtZeroCrossing	^ cursorColorAtZeroCrossings! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'jm 7/12/2003 17:23'!cursorColorAtZeroCrossings: aColor	cursorColorAtZeroCrossings _ aColor.	self flushCachedForm.! !!ScratchGraphMorph methodsFor: 'accessing'!cursorWrapped: aNumber	| sz |	editor cursor ~= aNumber ifTrue: [		editor cursor: aNumber.		sz _ data size.		sz = 0			ifTrue: [editor cursor: 1]			ifFalse: [				((editor cursor >= (sz + 1)) or: [editor cursor < 0]) ifTrue: [					 editor cursor: editor cursor - ((editor cursor // sz) * sz)].				editor cursor < 1 ifTrue: [editor cursor: sz + editor cursor]].		"assert: 1 <= cursor < data size + 1"		hasChanged _ true].! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'LY 7/30/2003 14:45'!customScale	| answer |	"called when the user wants to input a scale value"	answer _ (FillInTheBlankMorph request: 'Please type desired scale:' initialAnswer: '2x' centerAt: self bounds topLeft + (150@30) inWorld: World onCancelReturn:  '1x' acceptOnCR: true).	self zoom: (answer truncateTo: answer size -1) asNumber.		! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'jm 7/12/2003 17:23'!data	^ data! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'jm 7/12/2003 17:23'!data: aCollection	data _ aCollection.	maxVal _ minVal _ 0.	data do: [:x |		x < minVal ifTrue: [minVal _ x].		x > maxVal ifTrue: [maxVal _ x]].	self flushCachedForm.! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'jm 7/12/2003 17:23'!dataColor	^ dataColor! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'jm 7/12/2003 17:23'!dataColor: aColor	dataColor _ aColor.	self flushCachedForm.! !!ScratchGraphMorph methodsFor: 'accessing'!editor	^editor! !!ScratchGraphMorph methodsFor: 'accessing'!editor: aSoundEditor	editor _ aSoundEditor.! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'jm 7/28/2003 10:11'!interpolatedValueAtCursor	| sz prev frac next |	data isEmpty ifTrue: [^ 0].	sz _ data size.	owner cursor < 0 ifTrue: [^ data at: 1].  "just to be safe, though cursor shouldn't be negative"	prev _ owner cursor truncated.	frac _ owner cursor - prev.	prev < 1 ifTrue: [prev _ sz].	prev > sz ifTrue: [prev _ 1].	"assert: 1 <= prev <= sz"	frac = 0 ifTrue: [^ data at: prev].  "no interpolation needed"	"interpolate"	next _ prev = sz ifTrue: [1] ifFalse: [prev + 1].	^ ((1.0 - frac) * (data at: prev)) + (frac * (data at: next))! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'jm 7/12/2003 17:23'!lastValue	data size = 0 ifTrue: [^ 0].	^ data last! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'jm 7/12/2003 17:23'!lastValue: aNumber	self appendValue: aNumber.! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'LY 7/31/2003 12:09'!ruler	^ruler.! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'LY 7/30/2003 10:54'!scale		^scale.! !!ScratchGraphMorph methodsFor: 'accessing'!scale: aNumber	"setting the absolute scale of how the graph is display.  It is relative to MinScale, the minimum scale possible, which is the scale value of the viewer."	aNumber < 1 ifTrue: [^self].	scale _ (aNumber*MinScale) asFloat min: 1.		self calculateDataArray.	self flushCachedForm; changed.	editor viewer flushCachedForm; changed.	editor updateSlider.! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'jm 7/12/2003 17:23'!selection	^ selection! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'LY 7/26/2003 16:48'!selection: anArrayOrNil	"Set the selection to the given (startIndex, stopIndex) pair to to nil."	anArrayOrNil		ifNil: [	selection at: 1 put: nil. selection at: 2 put: nil]		ifNotNil: [ selection _ anArrayOrNil.].! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'jm 7/12/2003 17:23'!startIndex	^ startIndex! !!ScratchGraphMorph methodsFor: 'accessing' stamp: 'jm 7/12/2003 17:23'!startIndex: aNumber	startIndex ~= aNumber ifTrue:  [		startIndex _ aNumber asInteger.		self flushCachedForm].! !!ScratchGraphMorph methodsFor: 'accessing'!valueAtCursor	data isEmpty ifTrue: [^ 0].	^ data at: ((editor cursor truncated max: 1) min: data size).! !!ScratchGraphMorph methodsFor: 'accessing'!valueAtCursor: aPointOrNumber	data isEmpty ifTrue: [^ 0].	data		at: ((editor cursor truncated max: 1) min: data size)		put: (self asNumber: aPointOrNumber).	self flushCachedForm.! !!ScratchGraphMorph methodsFor: 'accessing'!viewer: aBoolean	viewer _ aBoolean. "whether or not this graphMorph is the viewer graph Morph"		viewer ifFalse: [self color: Color white.].! !!ScratchGraphMorph methodsFor: 'drawing'!drawOn: aCanvas	| c |	cachedForm = nil ifTrue:  [		c _ FormCanvas extent: bounds extent.		c translateBy: bounds origin negated			during:[:tempCanvas| self drawDataOn: tempCanvas].		cachedForm _ c form].	aCanvas paintImage: cachedForm at: bounds origin.	self drawCursorOn: aCanvas.	self drawPlayCursorOn: aCanvas.	! !!ScratchGraphMorph methodsFor: 'drawing' stamp: 'LY 7/25/2003 17:31'!hasChanged: aBoolean		hasChanged _ aBoolean.! !!ScratchGraphMorph methodsFor: 'change reporting' stamp: 'jm 7/12/2003 17:23'!layoutChanged	super layoutChanged.	cachedForm _ nil.! !!ScratchGraphMorph methodsFor: 'events' stamp: 'jm 7/12/2003 17:23'!handlesMouseDown: evt	^ true! !!ScratchGraphMorph methodsFor: 'events'!mouseDown: evt	"Handles mouse down and drag events.  Updates the cursor's position and sets the selection to an array containing two copies of the current cursor value."	| x s |	 x _ evt cursorPoint x - (bounds left + borderWidth).	s _ editor startSelection.	editor startSelection: editor cursor.  	editor cursor: startIndex + (x/scale).			evt shiftPressed		ifTrue: [  editor selectionNil 					ifFalse: [						editor startSelection: s.				  		self adjustSelection.].]		ifFalse: [				 ((editor selectionNil not) and: [(selection at: 2) - (selection at: 1) > 3])						ifTrue: [ editor selection: nil.			  				      self flushCachedForm.				 				 self changed.].			  	 editor startSelection: editor cursor.				 editor selection: {editor cursor. editor cursor}.].	 		! !!ScratchGraphMorph methodsFor: 'events'!mouseMove: evt	"Updates the cursor position as the mouse moves.  Adjusts the selection only if the mouse is currently being pressed"	| x w |	x _ evt cursorPoint x - (bounds left + borderWidth).	w _ self width - (2 * borderWidth).	(viewer not and: [x < 0]) ifTrue: [		editor cursor: startIndex + (x /scale).		self adjustSelection.		editor slider setValue: (startIndex/data size).		^ self startIndex: self editor cursor].	(viewer not and: [x > w]) ifTrue: [		editor cursor: startIndex + (x /scale).		self adjustSelection.		editor slider setValue: (startIndex/data size).		^ self startIndex: editor cursor - (w/scale) truncated.		"^ editor cursor = data size			ifTrue: [ self startIndex: editor cursor - (w/(scale*2)) truncated.]			ifFalse: [ self startIndex: editor cursor - (w/scale) truncated.]."].	evt anyButtonPressed 		ifTrue: [editor cursor: (startIndex + (x/scale) truncated).				self adjustSelection.]! !!ScratchGraphMorph methodsFor: 'events'!mouseUp: evt	((editor selectionNil not) and: [(selection at: 2) - (selection at: 1) <=3])		ifTrue: [editor selection: nil.				editor startSelection: nil.].! !!ScratchGraphMorph methodsFor: 'stepping'!step	"Make a deferred damage rectangle if I've changed. This allows applications to call methods that invalidate my display at high-bandwidth without paying the cost of doing the damage reporting on ever call; they can merely set hasChanged to true."	super step.		hasChanged == nil ifTrue: [hasChanged _ false].	hasChanged ifTrue: [		self changed.		hasChanged _ false].! !!ScratchGraphMorph methodsFor: 'stepping' stamp: 'LY 7/26/2003 15:51'!stepTime	^150! !!ScratchGraphMorph methodsFor: 'menu' stamp: 'jm 7/12/2003 17:23'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'open wave editor' action: #openWaveEditor.	aCustomMenu add: 'read file' action: #readDataFromFile.! !!ScratchGraphMorph methodsFor: 'menu'!adjustSelection	"Adjust the selection, if any, to the current cursor position. Do nothing if there is no selection."	editor selectionNil ifTrue: [^ self].	editor selection: editor cursor scd: editor startSelection.! !!ScratchGraphMorph methodsFor: 'menu' stamp: 'jm 7/12/2003 17:45'!openWaveEditor	| scaleFactor scaledData editor |	self data: data.  "make sure maxVal and minVal are current"	scaleFactor _ 32767 // ((minVal abs max: maxVal abs) max: 1).	scaledData _ SoundBuffer newMonoSampleCount: data size.	1 to: data size do: [:i | scaledData at: i put: (scaleFactor * (data at: i)) truncated].	editor _ SimpleWaveEditor new		data: scaledData;		samplingRate: 11025.	editor openInWorld.! !!ScratchGraphMorph methodsFor: 'menu' stamp: 'jm 12/4/2003 20:21'!readDataFromFile	| result fName |	result _ StandardFileMenu oldFileExtensions: #(aif aiff au wav).	result ifNil: [^ self].	fName _  result directory pathName, FileDirectory slash, result name.	self data: (SampledSound fromFileNamed: fName) samples.! !!ScratchGraphMorph methodsFor: 'viewing'!computeSlider		editor slider sliderThickness: ((bounds width//scale)/data size)*(editor slider extent x).	editor slider changed.! !!ScratchGraphMorph methodsFor: 'viewing'!setScale	| menu choice |	menu _ CustomMenu new.	menu add: '1x' action: '1';		   add: '2x' action: '2';		   add: '3x' action: '3';		   add: '4x' action: '4';		   add: '5x' action: '5';		   add: 'other' action: #customScale.	choice _ menu startUp.	choice ifNil: [^self].	choice = #customScale 		ifFalse: [self scale: choice asNumber.]			ifTrue: [ self customScale].! !!ScratchGraphMorph methodsFor: 'viewing'!viewSelection	| diff |	selection ifNil: [^self].	scale _ (MinScale*(data size/(selection second - selection first)) asFloat min: 1).	self calculateDataArray.	diff _ (selection second - selection first) - bounds width.	diff < 0		ifTrue: [ self startIndex: selection first asInteger + (diff//2)]		ifFalse: [self startIndex: selection first asInteger.].			editor updateSlider.	! !!ScratchGraphMorph methodsFor: 'viewing'!zoom: aNumber	scale _ ((scale*aNumber asFloat) max: MinScale asFloat) min: 1.		self calculateDataArray.	self flushCachedForm; changed.	editor viewer flushCachedForm; changed.	editor updateSlider.! !!ScratchGraphMorph methodsFor: 'viewing' stamp: 'LY 7/30/2003 15:19'!zoomIn	self zoom: 2.! !!ScratchGraphMorph methodsFor: 'viewing' stamp: 'LY 7/30/2003 15:21'!zoomOut	self zoom: 0.5.! !!ScratchGraphMorph methodsFor: 'commands' stamp: 'jm 7/12/2003 17:23'!appendValue: aPointOrNumber	| newVal |	(data isKindOf: OrderedCollection) ifFalse: [data _ data asOrderedCollection].	newVal _ self asNumber: aPointOrNumber.	data addLast: newVal.	newVal < minVal ifTrue: [minVal _ newVal].	newVal > maxVal ifTrue: [maxVal _ newVal].	self cursor: data size.	self flushCachedForm.! !!ScratchGraphMorph methodsFor: 'commands'!centerCursor	"Scroll so that the cursor is as close as possible to the center of my window."	| w |	w _ self width - (2 * borderWidth).	self startIndex: ((editor cursor - (w // (scale*2))) max: 1).! !!ScratchGraphMorph methodsFor: 'commands' stamp: 'jm 7/12/2003 17:23'!clear	self startIndex: 1.	self cursor: 1.	self data: OrderedCollection new.! !!ScratchGraphMorph methodsFor: 'commands' stamp: 'jm 7/12/2003 17:23'!loadSineWave	self loadSoundData: FMSound sineTable.! !!ScratchGraphMorph methodsFor: 'commands' stamp: 'jm 7/12/2003 17:23'!loadSound: aSound	self loadSoundData: aSound samples.! !!ScratchGraphMorph methodsFor: 'commands' stamp: 'jm 7/12/2003 17:23'!loadSoundData: aCollection	| scale absV newData |	scale _ 0.	aCollection do: [:v | (absV _ v abs) > scale ifTrue: [scale _ absV]].	scale _ 100.0 / scale.	newData _ OrderedCollection new: aCollection size.	1 to: aCollection size do: [:i | newData addLast: (scale * (aCollection at: i))].	self data: newData.	self startIndex: 1.	self cursor: 1.! !!ScratchGraphMorph methodsFor: 'commands' stamp: 'jm 7/12/2003 17:23'!playOnce	| scale absV scaledData |	data isEmpty ifTrue: [^ self].  "nothing to play"	scale _ 1.	data do: [:v | (absV _ v abs) > scale ifTrue: [scale _ absV]].	scale _ 32767.0 / scale.	scaledData _ SoundBuffer newMonoSampleCount: data size.	1 to: data size do: [:i | scaledData at: i put: (scale * (data at: i)) truncated].	(SampledSound samples: scaledData samplingRate: 11025) play.! !!ScratchGraphMorph methodsFor: 'commands' stamp: 'jm 7/12/2003 17:23'!reverse	data _ data reversed.	self flushCachedForm.! !!ScratchGraphMorph methodsFor: 'private'!calculateDataArray	| currIndex neg pos |	negVals _ OrderedCollection new.	posVals _ OrderedCollection new.	data isEmpty ifTrue: [^ self].	currIndex_ neg_pos _ 0.	(1 to: data size) do: [ :i |		((i * scale) truncated > currIndex)			ifTrue: [								currIndex _ (i*scale) truncated.							neg _ neg min: (data at: i).					pos _ pos max: (data at: i).								posVals add: pos.					negVals	add: neg.							pos _ neg _ 0.]			ifFalse: [						neg _ neg min: (data at: i).						pos _ pos max: (data at: i).].].! !!ScratchGraphMorph methodsFor: 'private'!drawCursorOn: aCanvas	| ptr x r c |	ptr _ (editor cursor asInteger max: 1) min: data size.	c _ cursorColor.	((ptr > 1) and: [ptr < data size]) ifTrue: [		(data at: ptr) sign ~= (data at: ptr + 1) sign			ifTrue: [c _ cursorColorAtZeroCrossings]].	r _ self innerBounds.	x _ r left + ((ptr - startIndex)*scale).	((x >= r left) and: [x <= r right]) ifTrue: [		aCanvas fillRectangle: (x@r top corner: x + 1@r bottom) color: c].! !!ScratchGraphMorph methodsFor: 'private'!drawDataOn: aCanvas	| x start end left right yScale baseLine top bottom |	super drawOn: aCanvas.	viewer ifTrue: [self drawViewOn: aCanvas.].	self drawSelectionOn: aCanvas.	(posVals isNil) ifTrue: [^ self].	maxVal = minVal ifTrue: [yScale _ 1.] 					ifFalse: [yScale _ (bounds height - (2 * borderWidth)) asFloat / (maxVal - minVal)].	baseLine _ bounds bottom - borderWidth + (minVal * yScale) truncated.	left _ 0. right _ 10.	x _ bounds left + borderWidth.	start _ (startIndex*scale) truncated min: data size max: 1.	end _ start + bounds width min: data size.	start to: end do: [:i |		i > posVals size ifTrue: [^self].							left _ x truncated. right _ x + 1.		right > (bounds right - borderWidth) ifTrue: [^ self].		top _ baseLine min: (baseLine - (yScale*(posVals at: i))) truncated.		bottom _ (baseLine max: baseLine - (yScale*(negVals at: i))) truncated.													aCanvas fillRectangle: (left@top corner: right@bottom) color: dataColor.		x _ x + 1].! !!ScratchGraphMorph methodsFor: 'private'!drawPlayCursorOn: aCanvas	| ptr x r c |	editor playCursor ifNil: [^self].	(editor endPlaying ~= data size) & (editor playCursor >= (editor endPlaying)) ifTrue: [^self].	ptr _ (editor playCursor asInteger max: 1) min: data size.	c _ cursorColor.	r _ self innerBounds.	x _ r left + ((ptr - startIndex)*scale).	((x >= r left) and: [x <= r right]) ifTrue: [		aCanvas fillRectangle: (x@r top corner: x + 1@r bottom) color: c].! !!ScratchGraphMorph methodsFor: 'private'!drawSelectionOn: aCanvas	| x y lightColor darkColor v1 v2 offsetX s1 s2 bottom |	editor selectionNil ifTrue: [^ self].	lightColor _ Color lightBlue. "(Color r: 0.2 g: 1.0 b: 0.907)."	darkColor _ lightColor darker darker darker.	v1 _ (editor graph startIndex asInteger max: 1) min: data size.	v2 _ v1 + (bounds width/(editor graph scale)) min: data size.		offsetX _ bounds left + borderWidth.	x _ (offsetX + ((selection first - startIndex)*scale)).	y _ bounds top + borderWidth.	viewer 		ifFalse: [			selection first > v2 ifTrue: [^ self].  "selection is not visible"			selection last < v1 ifTrue: [^ self].  "selection is not visible"			aCanvas				fillRectangle: (x@y extent: ((selection last - selection first)*scale)@(self height - (2 * borderWidth)))				color: lightColor. "lightYellow"]		ifTrue: [			s1 _ selection first.			s2 _ selection second.			bottom _ self height - (2 * borderWidth).			((s1 max: s2) <= v1) | ((s1 min: s2) >= v2)				ifTrue: [^aCanvas 											fillRectangle: ((offsetX + (s1*scale))@y extent: ((s2-s1)*scale)@bottom)							color: darkColor.].						(s1 <= v1) & (s2 >= v2)				ifTrue: [^aCanvas fillRectangle: ((offsetX + (s1*scale))@y extent: ((v1-s1)*scale)@bottom)								color: darkColor;								fillRectangle: ((offsetX + (v1*scale))@y extent: ((v2-v1)*scale)@bottom)								color: lightColor;								fillRectangle: (( offsetX + (v2*scale))@y extent: ((s2-v2)*scale)@bottom)								color: darkColor.].						(s1 >= v1) & (s2 <= v2)				ifTrue: [^aCanvas							fillRectangle: ((offsetX + (s1*scale))@y extent: ((s2-s1)*scale)@bottom)							color: lightColor.].				(s1 < v1) & (s2 > v1) & (s2 < v2)				ifTrue: [^aCanvas							fillRectangle: ((offsetX + (s1*scale))@y extent: ((v1-s1)*scale)@bottom)							color: darkColor;							fillRectangle: ((offsetX + (v1*scale))@y extent: ((s2- v1)*scale)@bottom)							color: lightColor.].					(s1 >= v1) & (s2 >= v2) 				ifTrue: [^aCanvas							fillRectangle: ((offsetX + (s1*scale))@y extent: ((v2-s1)*scale)@bottom)							color: lightColor;							fillRectangle: ((offsetX + (v2*scale))@y extent: ((s2 - v2)*scale)@bottom)							color: darkColor.].			"Transcript show: 'no category :(';cr."			].! !!ScratchGraphMorph methodsFor: 'private'!drawViewOn: aCanvas	"highlights the part of the graph morph we're viewing."	| y ex start x |	viewer ifFalse: [^self].			start _ ((editor graph startIndex*bounds width)/data size) truncated min: data size.	ex_ ((editor slider sliderThickness/editor slider extent x)*(bounds width)) min: data size.	x _ (bounds left + borderWidth + start).	y _ bounds top + borderWidth.	aCanvas		fillRectangle: (x@y extent: ex@(self height - (2 * borderWidth)))		color: Color white. "lightYellow".! !!ScratchGraphMorph methodsFor: 'private' stamp: 'LY 7/25/2003 17:31'!flushCachedForm	cachedForm _ nil.	hasChanged _ true. ! !!ScratchGraphMorph methodsFor: 'private' stamp: 'LY 8/1/2003 13:18'!keepIndexInView: index	| w newStart |	w _ bounds width - (2 * borderWidth).	index < startIndex ifTrue: [		newStart _ index - w//scale + 1.		^ self startIndex: (newStart max: 1)].	index > (startIndex + w//scale) ifTrue: [		^ self startIndex: (index min: data size)].! !!ScratchGraphMorph class methodsFor: 'instance creation' stamp: 'LY 7/30/2003 11:52'!MinScale	^MinScale! !!ScratchGraphMorph class methodsFor: 'instance creation' stamp: 'LY 8/1/2003 18:01'!MinScale: aNumber	"aNumber should be equal to: viewer extent x/ graph data size"	MinScale _ aNumber.! !!ScratchGraphMorph class methodsFor: 'instance creation' stamp: 'jm 7/12/2003 17:23'!openOn: dataCollection	"Open a new GraphMorph on the given sequencable collection of data."	^ (self new data: dataCollection) openInWorld! !I am a draggable border. I inform my frame, if I have one, when I am dragged.!!ScratchPaneDivider methodsFor: 'initialization' stamp: 'ee 7/1/2003 14:33'!initialize	super initialize.	self color: Color white.	scratchFrame _ nil.	edgeOffset _ 0.	self extent: 3@Display height.! !!ScratchPaneDivider methodsFor: 'event handling' stamp: 'jm 6/16/2003 22:16'!handlesMouseDown: evt	^ true! !!ScratchPaneDivider methodsFor: 'event handling' stamp: 'jm 6/17/2003 11:23'!handlesMouseOver: evt	^ true! !!ScratchPaneDivider methodsFor: 'event handling' stamp: 'jm 6/17/2003 11:34'!mouseEnter: evt	| c |	c _ self bounds isWide		ifTrue: [StandardSystemController hBorderCursor]		ifFalse: [StandardSystemController vBorderCursor].	evt hand showTemporaryCursor: c.! !!ScratchPaneDivider methodsFor: 'event handling' stamp: 'jm 6/17/2003 11:25'!mouseLeave: evt	evt hand showTemporaryCursor: nil.! !!ScratchPaneDivider methodsFor: 'event handling' stamp: 'ee 7/1/2003 14:39'!mouseMove: evt	"Inform my frame that the position of my vertical or horizontal bar is changing."	scratchFrame ifNil: [^ self].	self bounds isWide		ifTrue: [scratchFrame hBarY: evt cursorPoint y - scratchFrame top]		ifFalse: [scratchFrame vBarX: evt cursorPoint x - scratchFrame left].	 ! !!ScratchPaneDivider methodsFor: 'drawing' stamp: 'ee 7/1/2003 14:34'!drawHEdge: aForm at: startPoint on: aCanvas	"Use the given form starting at the given point to draw a horizontal edge the width of my bounds. Do nothing if aForm is nil."	| p clipC lastX |	aForm ifNil: [^ self].	p _ startPoint.	clipC _ aCanvas copyClipRect: self bounds.	lastX _ self bounds right.	[p x <= lastX] whileTrue: [		clipC paintImage: aForm at: p.		p _ (p x + aForm width) @ p y].			! !!ScratchPaneDivider methodsFor: 'drawing' stamp: 'ee 7/1/2003 14:35'!drawOn: aCanvas	"Draw the appropriate edge according to the geometry of my bounds. Do nothing if I have no forms to draw."	endForm ifNil: [^ self].	self bounds isWide		ifTrue: [			self drawHEdge: edgeForm at: self topLeft on: aCanvas.			aCanvas paintImage: startForm at: self topLeft.			aCanvas paintImage: endForm at: self topRight - (endForm width@0)]			ifFalse: [			self drawVEdge: edgeForm at: (self topLeft + (edgeOffset@(startForm height))) on: aCanvas.			aCanvas paintImage: startForm at: self topLeft.			aCanvas paintImage: endForm at: self bottomLeft - (0@endForm height)].			! !!ScratchPaneDivider methodsFor: 'drawing' stamp: 'ee 6/27/2003 11:38'!drawVEdge: aForm at: startPoint on: aCanvas	"Use the given form starting at the given point to draw a vertical edge the height of my bounds. Do nothing if aForm is nil."	| p clipC lastY |	aForm ifNil: [^ self].	p _ startPoint.	clipC _ aCanvas copyClipRect: self bounds.	lastY _ self bounds bottom.	[p y <= lastY] whileTrue: [		clipC paintImage: aForm at: p.		p _ p x @ (p y + aForm height)].			! !!ScratchPaneDivider methodsFor: 'accessing' stamp: 'ee 6/27/2003 14:47'!edgeOffset	^edgeOffset.! !!ScratchPaneDivider methodsFor: 'accessing' stamp: 'ee 7/1/2003 14:37'!edgeOffset: aNumber	"Set the appropriate pixel offset to compensate for forms of different sizes."	edgeOffset _ aNumber.! !!ScratchPaneDivider methodsFor: 'accessing' stamp: 'ee 6/27/2003 11:07'!scratchFrame: aMorph		scratchFrame _ aMorph.! !!ScratchPaneDivider methodsFor: 'accessing' stamp: 'ee 7/1/2003 14:37'!startForm: aForm edgeForm: aForm2 endForm: aForm3	"Set my end forms, my edge form and my bounds."		startForm _ aForm.	edgeForm _ aForm2.	endForm _ aForm3.	self width: (aForm width max: aForm3 width).	self height: (aForm height max: aForm3 height).! !A ScratchProcess is what brings a script/method/program to life. It keeps track of where it is in executing a script, evaluates expressions, passes arguments, initiates actions, etc.A ScratchFrameMorph object acts as a scheduler, telling each process when to run by calling its runStep method. The runStep method will execute some number of instructions, then volunarily yield control so that the ScratchRunner may run another process. The etiquette is that a process should yield control whenever it's about to execute something that could take a long time. This means that it will yield at the end of any loop iteration, in the middle of a timed command, and before any method call.Example of running one step on a new process for some existing script:	"(ScratchProcess new expression: (HatBlockMorph allInstances last blockSequence)) runStep"Structure:  stackFrame		the ScratchStackFrame describing the current state of this process  readyToYield		a boolean indicating whether to yield control to another process  errorFlag			a boolean indicating whether an error was encountered  readyToTerminate	a boolean indicating whether the stop method has been called!!ScratchProcess methodsFor: 'initialization' stamp: 'DaveF 7/11/2003 21:24'!initialize	stackFrame _ nil.	readyToYield _ false.	errorFlag _ false.	readyToTerminate _ false.! !!ScratchProcess methodsFor: 'accessing' stamp: 'jm 11/20/2003 11:12'!errorFlag	"Answer true if this process has stopped due to an error."	^ errorFlag! !!ScratchProcess methodsFor: 'accessing' stamp: 'jm 11/20/2003 11:12'!errorFlag: aBoolean	"Set the error flag for this process."	errorFlag _ aBoolean.! !!ScratchProcess methodsFor: 'accessing' stamp: 'jm 11/20/2003 11:12'!expression: expression	"Sets the expression to evaluate. This can be a single block or a collection of blocks. It should only be called before running the process."	stackFrame ifNotNil: [self error: 'Cannot modify expression'].	stackFrame _ ScratchStackFrame new expression: expression.! !!ScratchProcess methodsFor: 'accessing' stamp: 'jm 11/20/2003 11:13'!isTerminated	^ stackFrame isNil! !!ScratchProcess methodsFor: 'accessing' stamp: 'jm 9/29/2003 20:14'!readyToTerminate	^ readyToTerminate! !!ScratchProcess methodsFor: 'evaluation' stamp: 'DaveF 7/25/2003 14:28'!applyMethodCall	"Applies the current method call expression to the already-evaluated arguments."	| frame env script params args |	script _ stackFrame expression script.	params _ script parameters.	args _ stackFrame arguments.	"Create the new environment."	env _ Dictionary new.	"Bind formal parameters to arguments."	1 to: params size do: [:index |		env at: (params at: index) put: (args at: index)].		"Create a new stack frame for evaluating the body of the method."	frame _ ScratchStackFrame new		environment: env;		expression: script blockSequence allButFirst.	"Remove the current frame"	self popStackFrame.	"Add a return marker, to indicate that this is where to return to from the method."	self pushStackFrame: (ScratchStackFrame new isReturnMarker: true).	"Add the new stack frame."	self pushStackFrame: frame.	"Indicate that we should yield before proceeding with the call."	readyToYield _ true.! !!ScratchProcess methodsFor: 'evaluation' stamp: 'jm 8/13/2003 17:20'!applyPrimitive	"Apply the current expression (which must be a block) to the current arguments (which must all have been evaluated)."	| command args value selector |	command _ stackFrame expression.	selector _ command selector.	args _ stackFrame arguments.	"special cases for math and boolean operators"	selector isInfix		ifTrue:	[value _ args first perform: selector with: args second]		ifFalse:	[(#(not atRandom) includes: selector)					ifTrue:	[value _ args first perform: selector]					ifFalse:	[value _ command receiver										perform: selector										withArguments: args asArray]].	"set the return value in the parent frame before popStackFrame because popFrame adds a frame while single-stepping"	self returnValueToParentFrame: value.	self popStackFrame.! !!ScratchProcess methodsFor: 'evaluation' stamp: 'jm 8/22/2003 19:23'!applyTimedCommand	"Applies the current command to the already evaluated list of arguments over a particular time interval."	| block arguments currentTime startTime args totalMSecs elapsedMSecs |	block _ stackFrame expression.	arguments _ stackFrame arguments.	"Do we still need to evaluate more arguments?"	arguments size < block argumentCount ifTrue: [^ self evaluateNextArgument].	"Record or get the time when command was first invoked."	currentTime _ Time millisecondClockValue.	startTime _ stackFrame startTime.	startTime ifNil: [  "first call; just set starting time and value"		args _ arguments asArray, (Array with: 0 with: nil).		stackFrame startValue: (block receiver perform: block selector withArguments: args).		stackFrame startTime: currentTime.		readyToYield _ true.		^ self].	"Call primitive time command with its arguments and the elapsed time in seconds"	totalMSecs _ arguments last * 1000.	elapsedMSecs _ currentTime - startTime.	currentTime < startTime ifTrue: [elapsedMSecs _ totalMSecs].  "clock wrap"	args _ arguments asArray, (Array with: elapsedMSecs with: stackFrame startValue).	block receiver perform: block selector withArguments: args.	"If not done, then we leave stack as is and yield."	elapsedMSecs < totalMSecs ifTrue: [		readyToYield _ true.		^ self].	"Pop this command off the stack and return."	self popStackFrame.! !!ScratchProcess methodsFor: 'evaluation' stamp: 'DaveF 8/4/2003 19:20'!evaluate	"Evaluates the current expression in the current environment."	| expression |	"Are we supposed to give up control, instead of evaluating an expression?"	stackFrame shouldYield ifTrue: [^self yield].	"Is this a return marker?"	stackFrame isReturnMarker ifTrue: [^self popStackFrame].	"Dispatch on type."	expression _ stackFrame expression.	"Should we just unlight up a block?"	stackFrame shouldUnlight ifTrue: [expression litUp: false.  ^self popStackFrame].	"Is it a reference to a formal parameter?"	(expression isKindOf: ParameterReferenceMorph)		ifTrue: [^self evaluateParameter].	"Is it self-evaluating?"	((expression isKindOf: ArgMorph) or: [expression isKindOf: WatcherMorph])		ifTrue: [^self evaluateSelfEvaluating].	"Is it a command?"	(expression isKindOf: BlockMorph)		ifTrue: [^self evaluateCommand].	"Is it a sequence of blocks?"	(expression isKindOf: Collection)		ifTrue: [^self evaluateSequence].		self error: 'Unknown expression type:  ', expression printString.! !!ScratchProcess methodsFor: 'evaluation' stamp: 'jm 12/10/2003 20:57'!evaluateCommand	"Evaluates the current command/block."	| expression action |	expression _ stackFrame expression.	expression isHatBlock ifTrue: [^ self popStackFrame].	BlockHighlightMSecs > 0 ifTrue: [expression litUp: true].	"Check if we've got a special form."	expression isSpecialForm		ifTrue: [^self evaluateSpecialForm].	"Do we still need to evaluate more arguments?"	stackFrame arguments size < expression argumentCount		ifTrue: [^self evaluateNextArgument].	"Is this a timed command?"	expression isTimed		ifTrue: [^self applyTimedCommand].	"Is this a user-defined method?"	(expression isKindOf: MethodCallBlockMorph) ifTrue: [		action _ expression action.		action = #call ifTrue:	[^self applyMethodCall].		action = #start ifTrue:	[^self startProcess].		action = #stop ifTrue:	[^self stopProcess].		action = #test ifTrue:	[^self testProcess].		self error: 'Invalid action ', action].	"We've got a primitive command."	self applyPrimitive.! !!ScratchProcess methodsFor: 'evaluation' stamp: 'DaveF 7/9/2003 18:58'!evaluateNextArgument	"Evaluates the next argument of the command in expression.  Requires that expression be a block that takes more args than are already evaluated in the current stack frame."	| argumentExpression |	argumentExpression _ stackFrame expression argumentAt: stackFrame arguments size + 1.	self pushStackFrame: (ScratchStackFrame new expression: argumentExpression).! !!ScratchProcess methodsFor: 'evaluation' stamp: 'jm 8/13/2003 17:22'!evaluateParameter	"Finds the value of the current ParameterMorph expression by looking up the value in the current environment. Makes the value available to the super expression."	| value |	value _ stackFrame environment at: stackFrame expression parameter.	self returnValueToParentFrame: value.	self popStackFrame.! !!ScratchProcess methodsFor: 'evaluation' stamp: 'jm 8/13/2003 17:22'!evaluateSelfEvaluating	"The easiest case. Evaluate a number, color, or any self-evaluating expression."	| value |	value _ stackFrame expression evaluate.	self returnValueToParentFrame: value.	self popStackFrame.! !!ScratchProcess methodsFor: 'evaluation' stamp: 'DaveF 7/9/2003 10:45'!evaluateSequence	"Requires that the current expression be a collection of blocks.  Evaluates the block in the current expression (which is a list of blocks) at the given pc."	| blocks pc |	blocks _ stackFrame expression.	pc _ stackFrame pc.	pc > blocks size		ifTrue:	[self popStackFrame]		ifFalse:	[stackFrame pc: pc + 1.				self pushStackFrame: (ScratchStackFrame new expression: (blocks at: pc))].! !!ScratchProcess methodsFor: 'evaluation' stamp: 'DaveF 7/9/2003 11:20'!evaluateSpecialForm	"Evaluates the current special form expression.  Requires that no arguments have been evaluated, and that the current expression be a special form."	self perform: stackFrame expression selector.! !!ScratchProcess methodsFor: 'evaluation' stamp: 'DaveF 7/23/2003 16:37'!startProcess	"Starts the process referenced by the current expression, which must be a MethodCallBlockMorph."	stackFrame expression script start.	self popStackFrame.! !!ScratchProcess methodsFor: 'evaluation' stamp: 'DaveF 7/23/2003 17:34'!stopProcess	"Stops the process referenced by the current expression, which must be a MethodCallBlockMorph."	stackFrame expression script stop.	self popStackFrame.! !!ScratchProcess methodsFor: 'evaluation' stamp: 'jm 8/13/2003 17:23'!testProcess	"Starts the process referenced by the current expression, which must be a MethodCallBlockMorph."	| value |	value _ stackFrame expression script isRunning.	self returnValueToParentFrame: value.	self popStackFrame.! !!ScratchProcess methodsFor: 'evaluation' stamp: 'DaveF 7/9/2003 18:37'!yield	"Sets a flag indicating that we're ready to yield to another process."	readyToYield _ true.	self popStackFrame.! !!ScratchProcess methodsFor: 'special forms' stamp: 'jm 12/10/2003 22:26'!doAsk	"Evaluate the current expression (which must be an ask)."	| args askBlock argExp target commands |	askBlock _ stackFrame expression.	args _ stackFrame arguments.	"Evaluate the first arg if we haven't already."	args size = 0		ifTrue:	[argExp _ askBlock argumentAt: 1.				^self pushStackFrame: (ScratchStackFrame new expression: argExp)].	"We can pop this expression off the stack now."	self popStackFrame.	"Replace the targets of the these blocks to be the sprite we've found."	target _ args first.	commands _ askBlock firstBlockList.	commands do: [:command | command isHatBlock ifFalse: [command receiver: target]].	"Add this list of commands to the stack."	self pushStackFrame: (ScratchStackFrame new expression: commands).! !!ScratchProcess methodsFor: 'special forms' stamp: 'jm 8/24/2003 12:12'!doForever	"Executes one iteration of a forever loop."	"Right now, the forever special form is at the top of the stack.  We're going to add two more things on top of this:  (1) a frame for evaluating the blocks in the forever block, and (2) a frame that just results in yielding control.  That way we'll evaluate the contents of the block, give up control, and do it all again."	| blocks |	"Remember blocks to evaluate before we clobber the stack."	blocks _ stackFrame expression firstBlockList.		"When we're all done with these blocks, we want to yield."	self pushStackFrame: (ScratchStackFrame new shouldYield: true).	"First, we want to evaluate the blocks inside the loop."	self pushStackFrame: (ScratchStackFrame new expression: blocks).! !!ScratchProcess methodsFor: 'special forms' stamp: 'jm 8/24/2003 12:12'!doIf	"Evaluate the current expression (which must be an if)."	| block arguments argExp |	block _ stackFrame expression.	arguments _ stackFrame arguments.	"Evaluate the arg if we haven't already."	arguments size = 0		ifTrue:	[argExp _ block argumentAt: 1.				^self pushStackFrame: (ScratchStackFrame new expression: argExp)].	"We can pop this expression off the stack either way."	self popStackFrame.	"If the predicate was false, just return."	arguments first		ifFalse: [^self].	"Since the predicate was true, evaluate the body of the if."	self pushStackFrame: (ScratchStackFrame new expression: block firstBlockList).! !!ScratchProcess methodsFor: 'special forms' stamp: 'jm 8/23/2003 19:00'!doMonitor	"Evaluates the first argument, and sets the text of the second argument to be the first value.  Then returns this value."	| args value |		args _ stackFrame arguments.	args size = 0		ifTrue: [^self evaluateNextArgument].	value _ args first.	value isNumber ifTrue: [		value isInteger ifFalse: [value _ value asFloat roundTo: 0.001]].	stackFrame expression submorphs last expression: value asString.	self returnValueToParentFrame: value.	self popStackFrame.! !!ScratchProcess methodsFor: 'special forms' stamp: 'jm 8/24/2003 12:12'!doRepeat	"Handles one iteration of a repeat block."	| arguments argExp block counter frame |	block _ stackFrame expression.	arguments _ stackFrame arguments.	"If we haven't done so yet, evaluate the argument to repeat."	arguments size < 1		ifTrue:	[argExp _ block argumentAt: 1.				^self pushStackFrame: (ScratchStackFrame new expression: argExp)].	"If the number of times to repeat is 0, then we're done."	counter _ arguments first.	counter = 0		ifTrue:	[^self popStackFrame].	"Pop this instruction from the stack."	self popStackFrame.	"At top of stack should now be:		1.  evaluate body of repeat block.		2.  yield.		3.  evaluate repeat block with decremented counter value.	Need to add these to the stack in reverse order."	"3.  evaluate repeat block with decremented counter value."	frame _ ScratchStackFrame new				expression:		block;				addArgument:	counter - 1.	self pushStackFrame: frame.	"2.  yield."	self pushStackFrame: (ScratchStackFrame new shouldYield: true).	"1.  evaluate body of repeat block."	self pushStackFrame: (ScratchStackFrame new expression: block firstBlockList).! !!ScratchProcess methodsFor: 'special forms' stamp: 'jm 8/13/2003 17:18'!doReturn	"Evaluates its argument, and returns the value to the frame from which the current method was called."	| value args |	args _ stackFrame arguments.	"Evaluate the argument, if necessary."	args size < stackFrame expression argumentCount		ifTrue: [^self evaluateNextArgument].	"Remember the return value."	args size > 0		ifTrue:	[value _ args first]		ifFalse:	[value _ nil].	"Pop until we're out of frames to pop, or we hit a return marker."	[stackFrame isNil or: [stackFrame isReturnMarker]] whileFalse:		[self popStackFrame].	stackFrame ifNotNil:	[		self returnValueToParentFrame: value.		self popStackFrame].! !!ScratchProcess methodsFor: 'special forms' stamp: 'DaveF 7/25/2003 11:15'!doUntil	"Evaluates the current until-loop expression."	^self doUntil: true.! !!ScratchProcess methodsFor: 'special forms' stamp: 'jm 8/24/2003 12:12'!doUntil: terminatingBoolean	"Evaluates the current while or until loop expression until the loop condition evaluates to the boolean terminating value."	| args block |	block _ stackFrame expression.	args _ stackFrame arguments.	"Evaluate the condition if we haven't yet."	args size < 1		ifTrue: [^self evaluateNextArgument].	"If the condition matches the terminatingBoolean, pop this frame and we're done."	args first = terminatingBoolean ifTrue: [^self popStackFrame].	"Set up for an iteration of the while loop.  We need to:		1.  evaluate the body		2.  yield to another process		3.  evaluate the while/until block again	Push these onto stack in reverse order."	"3.  evaluate the while/until block again"	"(We remove the current frame and replace it with one that will force the argument to be re-evaluated.)"	self popStackFrame.	self pushStackFrame: (ScratchStackFrame new expression: block).	"2.  yield to another process"	self pushStackFrame: (ScratchStackFrame new shouldYield: true).		"1.  evaluate the body"	self pushStackFrame: (ScratchStackFrame new expression: block firstBlockList).! !!ScratchProcess methodsFor: 'special forms' stamp: 'jm 11/20/2003 11:17'!doWaitUntil	"Evaluates the the wait condition until it evaluates to true."	| block args |	block _ stackFrame expression.	args _ stackFrame arguments.	"evaluate the termination expression if we haven't yet."	args size < 1 ifTrue: [^ self evaluateNextArgument].	"if the termination condition is met, pop this frame and we're done."	args first ifTrue: [^ self popStackFrame].	"Set up for waitUntil loop. We need to:		1.  yield to another process		2.  evaluate the termination expression again	Push these onto stack in reverse order."	"2.  evaluate this block again"	"(Remove the current frame and replace it with one that will force the termination expression to be re-evaluated.)"	self popStackFrame.	self pushStackFrame: (ScratchStackFrame new expression: block).	"1.  yield to another process"	self pushStackFrame: (ScratchStackFrame new shouldYield: true).! !!ScratchProcess methodsFor: 'special forms' stamp: 'DaveF 7/25/2003 11:14'!doWhile	"Evaluates the current while-loop expression."	^self doUntil: false.! !!ScratchProcess methodsFor: 'stack' stamp: 'jm 8/7/2003 11:36'!popStackFrame	"Pops the current stack frame off the top of the stack, so that the next one becomes the current frame."	| command frame unlightFrame |	frame _ stackFrame.	stackFrame _ stackFrame parentFrame.	command _ frame expression.	BlockHighlightMSecs > 0 ifTrue: [		(frame shouldUnlight not and: [command isKindOf: BlockMorph]) ifTrue: [			"We push a new frame for unlighting this command."			unlightFrame _ ScratchStackFrame new				expression: command;				shouldUnlight: true.			self pushStackFrame: unlightFrame]].! !!ScratchProcess methodsFor: 'stack' stamp: 'DaveF 7/18/2003 15:16'!pushStackFrame: aScratchStackFrame	"Pushes the given new stack frame onto the top of the stack, so that it becomes the current stack frame."	| env |	"If the new frame's environment is nil, make it be the same as the old one."	aScratchStackFrame environment ifNil: [		stackFrame			ifNil:		[env _ Dictionary new]			ifNotNil:	[env _ stackFrame environment].		aScratchStackFrame environment: env].	aScratchStackFrame parentFrame: stackFrame.	stackFrame _ aScratchStackFrame.! !!ScratchProcess methodsFor: 'stack' stamp: 'jm 8/13/2003 17:40'!returnValueToParentFrame: anObject	"Append the given object to the argument list of my parent frame."	| f |	stackFrame ifNil: [^ self].	f _ stackFrame parentFrame.	[f notNil and: [f shouldUnlight]] whileTrue: [		f _ f parentFrame].	f ifNotNil: [f addArgument: anObject].! !!ScratchProcess methodsFor: 'stack' stamp: 'DaveF 7/9/2003 18:26'!stackAsArray	"Returns an array describing the contents of the stack.  Useful for debugging."	| frame collection |	frame _ stackFrame.	collection _ OrderedCollection new.		[frame isNil] whileFalse:		[collection add: frame expression.		frame _ frame parentFrame].	^collection asArray! !!ScratchProcess methodsFor: 'entry points' stamp: 'DaveF 8/4/2003 19:19'!runStep	| command |	"Evaluates the current expression, then the next, etc., until the next yield."	"Reset this flag so that we perform at least one operation."	readyToYield _ false.	[readyToYield or: [stackFrame isNil]] whileFalse:		[self evaluate].	"We have to pop all the stack frames, unlighting up commands if we're terminating."	readyToTerminate ifTrue: [		[stackFrame isNil] whileFalse: [			command _ stackFrame expression.			(command isKindOf: BlockMorph) ifTrue: [				command litUp: false].			self popStackFrame]].! !!ScratchProcess methodsFor: 'entry points' stamp: 'jm 8/24/2003 19:56'!stop	"Permanently terminates this process."	readyToYield _ true.	readyToTerminate _ true.! !!ScratchProcess class methodsFor: 'class initialization' stamp: 'jm 8/7/2003 11:36'!initialize	BlockHighlightMSecs _ 50.! !!ScratchProcess class methodsFor: 'class variables' stamp: 'jm 8/7/2003 11:34'!blockHighlightMSecs	^ BlockHighlightMSecs! !!ScratchProcess class methodsFor: 'class variables' stamp: 'jm 8/8/2003 14:02'!blockHighlightMSecs: aNumber	BlockHighlightMSecs _ aNumber.! !!ScratchRecordingMorph methodsFor: 'initialization' stamp: 'jm 9/30/2003 09:13'!addButtonRows	| spacer r |	spacer _ Morph new extent: 5@5; color: color.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Record' action: #record).	r addMorphBack: (spacer copy width: 4).	r addMorphBack: (self buttonName: 'Stop' action: #stop).	r addMorphBack: (spacer copy width: 4).	r addMorphBack: (self buttonName: 'Play' action: #playback).	r addMorphBack: (spacer copy width: 12).	r addMorphBack: (self buttonName: 'Okay' action: #save).	r addMorphBack: (spacer copy width: 4).	r addMorphBack: (self buttonName: 'Cancel' action: #cancel).	self addMorphBack: r.! !!ScratchRecordingMorph methodsFor: 'initialization' stamp: 'jm 9/12/2003 12:37'!initialize	| r |	super initialize.	borderWidth _ 2.	orientation _ #vertical.	recorder _ SoundRecorder new.	recorder recordLevel: 0.5.	self addButtonRows.	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: self makeRecordMeter.	r addMorphBack: (Morph new color: color; extent: 7@5).	r addMorphBack: self makeStatusLight.	self addMorphBack: r.	self extent: 10@10.  "make minimum size"! !!ScratchRecordingMorph methodsFor: 'accessing' stamp: 'jm 9/12/2003 12:18'!soundMorph: aSoundMorph	soundMorph _ aSoundMorph.! !!ScratchRecordingMorph methodsFor: 'button commands' stamp: 'jm 9/12/2003 12:23'!cancel	recorder pause.	self delete.! !!ScratchRecordingMorph methodsFor: 'button commands' stamp: 'LY 7/24/2003 09:49'!playback	recorder pause.	recorder playback.! !!ScratchRecordingMorph methodsFor: 'button commands' stamp: 'LY 7/24/2003 09:49'!record	recorder clearRecordedSound.	recorder resumeRecording.! !!ScratchRecordingMorph methodsFor: 'button commands' stamp: 'jm 9/12/2003 12:17'!save	recorder pause.	(soundMorph notNil and: [recorder recordedSound notNil]) ifTrue: [		soundMorph sound:			(SampledSound				samples: recorder condensedSamples				samplingRate: recorder samplingRate)].	self delete.! !!ScratchRecordingMorph methodsFor: 'button commands' stamp: 'LY 7/24/2003 09:49'!stop	recorder pause.! !!ScratchRecordingMorph methodsFor: 'stepping' stamp: 'LY 7/24/2003 09:49'!startStepping	"Make the level meter active when dropped into the world. Do nothing if already recording. Note that this will cause other recorders to stop recording..."	super startStepping.	recorder isPaused ifTrue: [		SoundRecorder allSubInstancesDo: [:r | r stopRecording].  "stop all other sound recorders"		recorder pause].  "meter is updated while paused"! !!ScratchRecordingMorph methodsFor: 'stepping' stamp: 'LY 7/24/2003 16:32'!step	recorder isPaused		ifTrue: [recordingStatusLight color: Color transparent]		ifFalse: [recordingStatusLight color: Color red].	recordMeter extent: ((recorder meterLevel*1.7) + 1) @ recordMeter height.! !!ScratchRecordingMorph methodsFor: 'stepping' stamp: 'LY 7/24/2003 09:49'!stepTime	^ 50! !!ScratchRecordingMorph methodsFor: 'stepping' stamp: 'LY 7/24/2003 09:49'!stopStepping	"Turn off recording."	super stopStepping.	recorder stopRecording.! !!ScratchRecordingMorph methodsFor: 'other' stamp: 'LY 7/24/2003 09:49'!buttonName: aString action: aSymbol	^ SimpleButtonMorph new		target: self;		label: aString;		actionSelector: aSymbol! !!ScratchRecordingMorph methodsFor: 'other' stamp: 'LY 7/24/2003 16:32'!makeRecordMeter	| outerBox |	outerBox _ Morph new extent: 170@18; color: Color gray.	recordMeter _ Morph new extent: 1@16; color: Color yellow.	recordMeter position: outerBox topLeft + (1@1).	outerBox addMorph: recordMeter.	^ outerBox! !!ScratchRecordingMorph methodsFor: 'other' stamp: 'jm 9/12/2003 12:37'!makeStatusLight	recordingStatusLight _ Morph new extent: 30@18.	recordingStatusLight color: Color transparent.	recordingStatusLight addMorph: ((StringMorph contents: 'Rec') position: 6@3; color: color).	^ recordingStatusLight! !!ScratchRecordingMorph methodsFor: 'other' stamp: 'LY 7/24/2003 09:49'!updateReferencesUsing: aDictionary	"Copy my recorder."	super updateReferencesUsing: aDictionary.	recorder _ SoundRecorder new.! !!ScratchRulerMorph methodsFor: 'initialize' stamp: 'LY 7/23/2003 10:30'!initialize		super initialize.	min _ 0.0.	max _ 100.	marks _ 20.0.	sigDigs _ 1. 	graph _ nil. "used specifically to coord with ScratchGraphMorph"	self borderWidth: 1.	self extent: 200@20.	self color: Color white.! !!ScratchRulerMorph methodsFor: 'accessing' stamp: 'LY 7/23/2003 10:31'!graph: aScratchGraphMorph	graph _ aScratchGraphMorph.! !!ScratchRulerMorph methodsFor: 'accessing' stamp: 'LY 7/23/2003 10:21'!marks: aNumber	marks _ aNumber.	self changed.! !!ScratchRulerMorph methodsFor: 'accessing' stamp: 'LY 7/23/2003 10:19'!min: aMin max: aMax	min _ aMin.	max _ aMax.	self changed.! !!ScratchRulerMorph methodsFor: 'accessing' stamp: 'LY 7/23/2003 10:21'!sigDigs: aNumber	sigDigs _ aNumber truncated.	self changed.! !!ScratchRulerMorph methodsFor: 'drawing'!drawOn: aCanvas	| space bigSpace currVal s ss |		"the amt of space btw each bar.  big Space = the amt of space btw each big bar"	space _ (self extent x/marks) truncated max: 1.	bigSpace _ 5* space asFloat.	graph ifNotNil: [ss _ graph editor origSamplingRate]		   ifNil: [ss _ 1].	currVal _ (min/ss) asFloat roundTo: 0.01.  "the value of where we are in teh rule"	aCanvas fillRectangle: (Rectangle origin: (self left)@(self top) corner: (self right)@(self bottom)) color: Color lightGray.	self removeAllMorphs.	(self left) to: (self right) by: space do: 		[:pos |			(pos - (self left)) \\ bigSpace = 0				ifTrue: [aCanvas line: (pos truncated)@((self top) truncated) to: (pos truncated)@((self top + 5) truncated) color: Color black.				s _ StringMorph contents: (currVal asString).				s center: (pos truncated)@(self top + 12).				self addMorph: s.]				ifFalse: [aCanvas line: (pos truncated)@(self top truncated) to: (pos truncated)@((self top + 1) truncated) color: Color black.]. 			currVal _ currVal + ((max-min)/(marks*ss)) roundTo: 0.01. ].! !!ScratchRulerMorph methodsFor: 'stepping' stamp: 'LY 7/31/2003 11:48'!step		| graphStart graphEnd |	graph ifNil: [^self].	self extent x = graph extent x		ifFalse: [self extent: (graph extent x)@(self extent y).].	graphStart _ graph startIndex min: graph data size.	graphEnd _ graphStart + (graph bounds width/graph scale) min: graph data size.		(min = graphStart and:[ max = graphEnd])		ifFalse: [ min _ graphStart.				  max _ graphEnd truncated.				  self changed.].! !!ScratchRulerMorph class methodsFor: 'instance creation' stamp: 'LY 7/23/2003 10:46'!graphMorph: aScratchGraphMorph	^ self new graph: aScratchGraphMorph; extent: (aScratchGraphMorph extent x)@20.	! !I am a viewer for Scratch blocks and variables. I have a heading row containing the object name (editable) and a drop-down menu icon. Below that is a scrollable area containing the blocks and/or variables for the current category.!!ScratchScriptEditorMorph methodsFor: 'initialization' stamp: 'ee 8/19/2003 12:53'!initialize	super initialize.	self orientation: #vertical.	self color: (Color gray: 0.8).	self borderWidth: 2; borderColor: (Color gray: 0.5).	self inset: 0.	self useRoundedCorners.	self addHeadingRow.	pageViewer _ ScrollFrameMorph new		color: (Color gray: 0.9);		borderWidth: 0.	self addMorphBack: pageViewer.	self target: nil.! !!ScratchScriptEditorMorph methodsFor: 'accessing' stamp: 'TIS 8/7/2003 11:29'!pageViewer	^ pageViewer! !!ScratchScriptEditorMorph methodsFor: 'accessing' stamp: 'jm 11/5/2003 09:53'!suppressBlockReceivers	"Answer true if block receivers should not be display for blocks in me."	^ false! !!ScratchScriptEditorMorph methodsFor: 'accessing' stamp: 'ee 7/1/2003 12:58'!target	^ nameMorph target! !!ScratchScriptEditorMorph methodsFor: 'accessing' stamp: 'jm 12/10/2003 14:28'!target: aScratchObjectOrNil	"Start viewing the given object or no object."	(aScratchObjectOrNil isNil or:	 [aScratchObjectOrNil isScriptable not]) ifTrue: [		nameMorph target: nil; contents: 'no object '.		bin ifNotNil: [bin delete. bin _ nil].		thumbnail target: nil.		topRow color: self color.		^ self].	nameMorph		target: aScratchObjectOrNil;		getSelector: #objName;		putSelector: #objName:.	bin ifNotNil: [bin delete].	bin _ aScratchObjectOrNil blocksBin.	pageViewer contents: bin.	self world ifNotNil: [self world startSteppingSubmorphsOf: bin].	thumbnail target: aScratchObjectOrNil.! !!ScratchScriptEditorMorph methodsFor: 'accessing' stamp: 'TIS 7/14/2003 14:07'!thumbnail	^ thumbnail! !!ScratchScriptEditorMorph methodsFor: 'event handling' stamp: 'jm 8/14/2003 14:54'!handlesMouseDown: evt	^ evt yellowButtonPressed! !!ScratchScriptEditorMorph methodsFor: 'event handling' stamp: 'jm 8/14/2003 14:56'!mouseDown: evt	self scratchMenu.! !!ScratchScriptEditorMorph methodsFor: 'menu' stamp: 'jm 8/14/2003 14:57'!cleanUp	| orderedScripts x y scriptsMorph |	"Align all scripts horizontally in alphabetical order"	x _ y _ 10.	scriptsMorph _ (pageViewer submorphs select: [:c | c isKindOf: ScratchScriptsMorph]) first.	orderedScripts _ (scriptsMorph submorphs select: [:s | s isKindOf: HatBlockMorph]) asArray 		sortBy: [:s1 :s2 | s1 scriptName < s2 scriptName].	orderedScripts do: [:s |		s position: scriptsMorph position + (x@10).		x _ x + 5 + s fullBounds width.		y _ s fullBounds height max: y].	"Line up leftover blocks vertically below the scripts in alphabetical order referring to block type."	x _ 10.	orderedScripts size = 0 ifFalse: [y _ y + 50]. 	(scriptsMorph submorphs sort: [:a :b | a fullPrintString <= b fullPrintString]) do: [:s | 		((s isKindOf: HatBlockMorph) not and: [s owner = scriptsMorph]) ifTrue: [			s position: scriptsMorph position + (x@y).			y _ y + s fullBounds height + 5]].	scriptsMorph layoutChanged.! !!ScratchScriptEditorMorph methodsFor: 'menu' stamp: 'jm 9/25/2003 12:31'!newScriptHat	"Create a new HatBlockMorph for this object."	| m |	m _ HatBlockMorph new scriptOwner: self target.	self world currentHand attachMorph: m.	(self owner notNil and: [self owner respondsTo: #viewerPane]) ifTrue: [		self owner viewerPane categoryChanged: 'scripts'].! !!ScratchScriptEditorMorph methodsFor: 'menu' stamp: 'TIS 8/7/2003 11:18'!scratchMenu	"Present a menu of Scratch object operations."	| menu choice |	self target ifNil: [^ self beep].	menu _ CustomMenu new.	menu add: 'new script hat' action: #newScriptHat.	menu add: 'clean up' action: #cleanUp.	choice _ menu startUp.	choice ifNil: [^ self].	self perform: choice.! !!ScratchScriptEditorMorph methodsFor: 'private' stamp: 'jm 7/20/2003 20:12'!addHeadingRow	"Add a morph that allows editing of my object's name."	topRow _ AlignmentMorph newRow		color: self color;		inset: 3;		centering: #center;		vResizing: #shrinkWrap.	topRow addMorphBack: (thumbnail _ ScratchThumbnailMorph new).	topRow addMorphBack: (AlignmentMorph newSpacer: Color transparent).	topRow addMorphBack: (nameMorph _ UpdatingStringMorph new useStringFormat).	nameMorph font: TextStyle defaultFont emphasis: 1.	topRow addMorphBack: (AlignmentMorph newSpacer: Color transparent).	topRow addMorphBack: (IconicButton new		borderWidth: 0;		labelGraphic: ScratchViewerMorph menuIcon;		color: Color transparent; 		actWhen: #buttonDown;		actionSelector: #scratchMenu;		target: self;		setBalloonText: 'Scratch object menu').	self addMorph: topRow.	thumbnail viewer: self.! !!ScratchScriptEditorMorph methodsFor: 'private' stamp: 'jm 7/20/2003 20:13'!updateColor: aColor	topRow color: aColor.! !I hold the scripts and partially assembled scripts for a ScriptableScratchMorph.!!ScratchScriptsMorph methodsFor: 'initialization' stamp: 'jm 8/3/2003 09:17'!initialize	super initialize.	color _ Color gray: 0.9.	borderWidth _ 0.	self enableDragNDrop: true.! !!ScratchScriptsMorph methodsFor: 'object i/o' stamp: 'jm 9/30/2003 21:29'!fieldsVersion	"I depend on my superclass for object i/o. Currently, thos methods are inherited from Morph."	^ 1! !!ScratchSliderMorph methodsFor: 'initialization' stamp: 'jm 9/25/2003 11:35'!initialize	super initialize.	slider _ SimpleSliderMorph new		minVal: 0; maxVal: 500;		setValue: 0.5;		extent: 200@10.	self orientation: #horizontal; centering: #center; hResizing: #shrinkWrap;		borderWidth: 1; borderColor: (Color r: 0.0 g: 0.65 b: 0.0);		addMorphBack: (sliderMin _ ExpressionArgMorph new expression: '0');		addMorphBack: (AlignmentMorph new width: 5; color: Color transparent; hResizing: #rigid);		addMorphBack: slider;		addMorphBack: (AlignmentMorph new width: 5; color: Color transparent; hResizing: #rigid);		addMorphBack: (sliderMax _ ExpressionArgMorph new expression: '500').	sliderMin labelMorph		putSelector: #minVal:;		getSelector: #minVal;		target: slider;		floatPrecision: 0.01;		useDefaultFormat.	sliderMax labelMorph		putSelector: #maxVal:;		getSelector: #maxVal;		target: slider;		floatPrecision: 0.01;		useDefaultFormat.! !!ScratchSliderMorph methodsFor: 'accessing' stamp: 'TIS 7/10/2003 14:08'!slider	^ slider! !!ScratchSliderMorph methodsFor: 'accessing' stamp: 'jm 9/25/2003 11:20'!target	^ slider target! !!ScratchSliderMorph methodsFor: 'accessing' stamp: 'jm 9/25/2003 11:20'!target: anObject	sliderMin labelMorph		putSelector: #minVal:;		getSelector: #minVal;		target: slider;		useDefaultFormat.	sliderMax labelMorph		putSelector: #maxVal:;		getSelector: #maxVal;		target: slider;		useDefaultFormat.	slider target: anObject.! !!ScratchSliderMorph methodsFor: 'accessing' stamp: 'jm 9/25/2003 11:23'!variable	^ variable! !!ScratchSliderMorph methodsFor: 'accessing' stamp: 'jm 9/25/2003 11:23'!variable: aVariable	variable _ aVariable.! !!ScratchSliderMorph methodsFor: 'stepping' stamp: 'jm 9/25/2003 11:37'!step	self updateSliderPosition.	sliderMin fixArgLayout.	sliderMax fixArgLayout.! !!ScratchSliderMorph methodsFor: 'stepping' stamp: 'tis 7/7/2003 12:57'!stepTime	^ 100! !!ScratchSliderMorph methodsFor: 'private' stamp: 'jm 9/25/2003 11:24'!updateActionSelector	| sel args |	(self target builtinVars includes: variable)		ifTrue: [			sel _ (variable, ':') asSymbol.			args _ #()]		ifFalse: [			sel _ #setUserVar:to:.			args _ Array with: variable].	slider actionSelector: sel; arguments: args.! !!ScratchSliderMorph methodsFor: 'private' stamp: 'jm 9/25/2003 11:31'!updateSliderPosition	"Set my slider position to the variable's current value"	| selector value |	self target ifNil: [^ self].	(self target builtinVars includes: variable)		ifTrue: [			selector _ variable asSymbol.			value _ self target perform: selector]		ifFalse: [			selector _ #getUserVar:.			value _ self target perform: selector with: variable].	value ifNil: [^ self].  "can happen when variable has been deleted"	slider adjustToValue: value.! !!ScratchSliderMorph methodsFor: 'object i/o' stamp: 'jm 9/25/2003 11:16'!fieldsVersion	^ 1! !!ScratchSliderMorph methodsFor: 'object i/o' stamp: 'jm 9/25/2003 11:27'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		slider		sliderMin		sliderMax		variable	) from: anObjStream.! !!ScratchSliderMorph methodsFor: 'object i/o' stamp: 'jm 9/25/2003 11:28'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		slider		sliderMin		sliderMax		variable	) on: anObjStream.! !A sound editor, based on the wave editor.  It can be brought up by the SoundMorph.  When the soundEditor is brought up, it is created with a copy of the sound in the sound morph. It contains the sound of the soundmorph and is capable of editing that sound.  That sound is set in the method "sound:""viewing"graph 					GraphMorph			viewer					GraphMorphselection 				    Array				an array of 2 #s that are the start and end of the selection.  This and the next 2 												variables are in terms of indices of the graph datastartSelection 			   Number				a number indicating the constant pt in a selection (mouse down loc)cursor					   Number				a number indicating the location of the cursor"Scrolling in view"scrollDelta			        Number				a number telling us how much to scroll by, used in stepping to allow scrolling by 												buttonsslider					   slider morph			a slider for the graphtime					   a number			where we are in the graph in terms os msecsdeltaVal 					number				how much the cursor scrolls by, scrolldelta is set to +- this valuefwdButton 					button				scollingbackButton     				button				scrolling"Playing variables" origSamplingRate 		  big number			indicates the sampling rate of the song @ loading												so u can reset to that sampling rate.samplingRate 	         another big number		indicates current sampling rate.	(2 above aren't currently used)volume					   slider morph			indicates volume, (0 to 1.0)		preview						boolean 			whether we're in play all mode or play 	from 												cursor mode, where the cursor moves along with 												the music"Sound manipulation"snd 						SampledSound		Current sound used for playing from cursor + selectioncompleteSnd 				SampledSound		The entire song after editing (doesn't change with playing)soundMorphSound   			SampledSound		a ref to the sound of the SoundMorph that created this, 												so that u can change the sound within that sound editor"Editing tools"copy						SoundBuffer		the portion of the graph data that has been copiedundoSound 					SampledSound		the sound before any cuts/pastes cropsundoSel 					Array				a copy of the selection bf any cut/paste/croprateSlider 					currently not implementedkeyboard!!ScratchSoundEditor methodsFor: 'initialization' stamp: 'jm 9/30/2003 09:14'!addControls	| b r spacer |	b _ SimpleButtonMorph new target: self; borderColor: Color black; useSquareCorners.	b borderColor: #raised; borderWidth: 3.	r _ AlignmentMorph newRow.	r color: Color transparent; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #shrinkWrap; extent: 5@5.	r centering: #center.	spacer _ Morph new color: r color; extent: 40@5.  "spacer"	r addMorphBack: (spacer fullCopy width: 5).	r addMorphBack: (b fullCopy label: 'undo';		actionSelector: #undo).	r addMorphBack: (spacer fullCopy width: 5).	r addMorphBack: (b fullCopy label: 'copy';		actionSelector: #copy).	r addMorphBack: (spacer fullCopy width: 5).	r addMorphBack: (b fullCopy label: 'paste';		actionSelector: #paste).	r addMorphBack: (spacer fullCopy width: 5).	r addMorphBack: (b fullCopy label: 'cut';		actionSelector: #cut).	r addMorphBack: (spacer fullCopy width: 5).	r addMorphBack: (b fullCopy label: 'crop';		actionSelector: #crop).		r addMorphBack: (spacer fullCopy width: 25).	r addMorphBack: (b copy target: graph;							label: 'zoom selection';	actionSelector: #viewSelection).	r addMorphBack: (spacer fullCopy width: 25).	r addMorphBack: (b fullCopy label: 'okay';			actionSelector: #save).	r addMorphBack: (spacer fullCopy width: 5).	r addMorphBack: (b fullCopy label: 'cancel';		actionSelector: #cancel).	self addMorphBack: r.! !!ScratchSoundEditor methodsFor: 'initialization' stamp: 'jm 9/29/2003 20:44'!addGraph	| r |	r _ AlignmentMorph newRow.	r color: Color transparent; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #center.	r addMorphBack: (AlignmentMorph newSpacer: r color).	r addMorphBack: graph.	r addMorphBack: (AlignmentMorph newSpacer: r color).	self addMorphBack: r.! !!ScratchSoundEditor methodsFor: 'initialization' stamp: 'jm 8/12/2003 10:32'!addPlayButtons	| b r m space n scaleSelector |	b _ SimpleButtonMorph new target: self; borderColor: Color black; useSquareCorners.	b borderColor: #raised; borderWidth: 3.	r _ AlignmentMorph newColumn.	r color: Color transparent; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #shrinkWrap; extent: 5@5.	r centering: #center.	m _ AlignmentMorph newRow.	m color: Color transparent; borderWidth: 0; inset: 0.	m hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	m centering: #center.	space _ Morph new color: r color; extent: 3@5.	n _ StringMorph new contents: 'Zoom to: '.	m addMorphBack: n.	scaleSelector _  (IconicButton new		labelGraphic: (SoundMorph soundSkin at: #downArrow);		extent: 15@15;		color: Color transparent;		borderWidth: 0;		target: graph;		actWhen: #buttonDown;		actionSelector: #setScale).	m addMorphBack: scaleSelector.	m addMorphBack: (Morph new color: r color; extent: 5@5).	m addMorphBack: (b copy target: graph; label: '+';			actionSelector: #zoomIn).	m addMorphBack: (Morph new color: r color; extent: 5@5).	m addMorphBack: (b copy target: graph; label: '-';			actionSelector: #zoomOut).	"n _ UpdatingStringMorph new	target: graph;	getSelector: #scale; 	growable: false; width: 25; step.	m addMorphBack: n."	m addMorphBack: (Morph new color: r color; extent: 50@5).			m addMorphBack: (b fullCopy label: 'Play All';			actionSelector: #playAll).	m addMorphBack: space copy.	m addMorphBack: (b fullCopy label: 'Play';				actionSelector: #playAfterCursor).	m addMorphBack: space copy.	m addMorphBack: (b fullCopy label: 'Stop';				actionSelector: #stop).	m addMorphBack: (Morph new color: r color; extent: 50@5).	m addMorphBack: (StringMorph new contents: 'Volume').	m addMorphBack: space copy.		volume _ SimpleSliderMorph new	color: Color veryVeryLightGray;	extent: 60@2;	target: self;	actionSelector: #setVolume:.	m addMorphBack: volume.	m addMorphBack: (Morph new color: r color; extent: 50@5).	r addMorphBack: (Morph new color: r color; extent: 5@5).	r addMorphBack: m.		self addMorphBack: r.! !!ScratchSoundEditor methodsFor: 'initialization'!addSlider	| r m spacer |	r _ AlignmentMorph newRow.	r color: Color transparent; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #shrinkWrap; extent: 5@5.	r centering: #center.			spacer _ Morph new color: r color; extent: (graph left -10)@5.	backButton _ self makeSliderButton: 10@13.	backButton addMorphCentered: (ImageMorph new form: (self class UpArrow rotateBy: #left centerAt: 0@0)).	fwdButton _ self makeSliderButton: 10@13.	fwdButton addMorphCentered: (ImageMorph new form: (self class UpArrow rotateBy: #right centerAt: 0@0)).		slider _ SimpleSliderMorph new		color: Color veryVeryLightGray;		extent: (graph width)@2;		target: self;		setMaxVal: (graph bounds width/(graph scale*graph data size));		actionSelector: #scrollTime:.		r addMorph: spacer.	r addMorph: fwdButton.	r addMorph: slider.	r addMorph: backButton.		m _ Morph new color: r color; extent: 15@5.  "spacer"	r addMorphBack: m.	time _ UpdatingStringMorph new		target: self;		getSelector: #startTime; 		width: 40; step.	time useStringFormat.	r addMorphBack: time.	self addMorphBack: r.! !!ScratchSoundEditor methodsFor: 'initialization' stamp: 'LY 7/11/2003 14:05'!addValueSelectors	| r m b |	b _ SimpleButtonMorph new target: self; borderColor: Color black; useSquareCorners.	b borderColor: #raised; borderWidth: 3.	r _ AlignmentMorph newRow.	r color: Color transparent; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #shrinkWrap; extent: 5@5.	r centering: #center.	r addMorphBack: (Morph new color: r color; extent: 5@5).	"r addMorphBack: (b fullCopy label: '<<';					actionSelector: #slower)."	r addMorphBack: (b fullCopy label: 'Reset Play Rate';	actionSelector: #resetSamplingRate).	"r addMorphBack: (b fullCopy label: '>>';					actionSelector: #faster)."	r addMorphBack: (Morph new color: r color; extent: 25@5).	m _ StringMorph new contents: 'Sampling Rate'.	r addMorphBack: m.	m_ Morph new color: r color; extent: 5@5. "spacer"	r addMorphBack: m.	rateSlider _ SimpleSliderMorph new	color: Color veryVeryLightGray;	extent: 60@2;	target: self;	minVal: 0.2;	maxVal: 2.5;	actionSelector: #samplingRate:.	r addMorphBack: rateSlider.	r addMorphBack: (Morph new color: r color; extent: 30@5).	m _ StringMorph new contents: 'Index: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #cursor; putSelector: #cursor:;		growable: false; width: 30; step.	r addMorphBack: m.		m_ Morph new color: r color; extent: 20@5. "spacer"	r addMorphBack: m.	m _ StringMorph new contents: 'Value: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #valueAtCursor; putSelector: #valueAtCursor:;		growable: false; width: 40; step.	r addMorphBack: m.	m_ Morph new color: r color; extent: 20@5. "spacer"	r addMorphBack: m.	"r addMorphBack: ( b fullCopy label: 'zoom to selection';		actionSelector: #zoomToSelection).	m _ Morph new color: r color; extent: 5@5.	r addMorphBack: m."	self addMorphBack: r.! !!ScratchSoundEditor methodsFor: 'initialization'!addViewer	| r |	r _ AlignmentMorph newRow.	r color: Color transparent; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #center.	r addMorphBack: (AlignmentMorph newSpacer: r color).	r addMorphBack: viewer.	r addMorphBack: (AlignmentMorph newSpacer: r color).	self addMorphBack: r.	! !!ScratchSoundEditor methodsFor: 'initialization'!initialize	super initialize.	copy _ nil.	selection _ {nil. nil}.	scrollDelta _ 0.	deltaVal _ 10.	cursor _ 200.	playCursor _ nil.	samplingRate _ SoundPlayer samplingRate.	self extent: 5@5;		orientation: #vertical;		centering: #centered;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		inset: 3;		color: Color lightGray;		borderWidth: 2.	graph _ ScratchGraphMorph new extent: 450@150.	graph editor: self.	graph selection: selection.	graph addRuler.	graph viewer: false.		viewer _ ScratchGraphMorph new extent: 450@30.	viewer editor: self.	viewer cursorColorAtZeroCrossings: Color red.	viewer viewer: true.	viewer selection: selection.		self addControls.	self addPlayButtons.	self addMorphBack: (Morph new color: self color; extent: 10@5).		self addGraph.	self addMorphBack: (Morph newBounds: (0@0 extent: 0@3) color: Color transparent).	self addSlider.	self addViewer.	viewer left: backButton right.	! !!ScratchSoundEditor methodsFor: 'initialization' stamp: 'LY 7/7/2003 16:20'!makeSliderButton: buttonExtent	| backButton |	backButton _ BorderedMorph		newBounds: (self innerBounds bottomRight - buttonExtent extent: buttonExtent)		color: Color lightGray.	backButton setBorderWidth: 1 borderColor: #raised.	^backButton.	! !!ScratchSoundEditor methodsFor: 'initialization'!playAfterCursor	| sel currSel |	graph data size < 2 ifTrue: [^ self].		sel _ ((selection at: 1) notNil and: [(selection at: 2) - (selection at: 1) > 3]).	sel ifTrue: [currSel _ graph data copyFrom: (selection at: 1) asInteger to: (selection at: 2) asInteger. playCursor _ selection at: 1.			    endPlaying _ selection at: 2.]	    ifFalse: [currSel _ graph data copyFrom: (cursor max: 1) asInteger to: graph data size.				playCursor _ cursor.				endPlaying _ graph data size].			self changed.	snd isNil		ifTrue: [				 snd _ (SampledSound samples: currSel samplingRate: origSamplingRate).				 snd play.]		ifFalse: [			currSel = snd samples				ifTrue: [snd samplesRemaining = 0 ifTrue: [snd reset].						 snd resumePlaying.]				ifFalse: [ snd setSamples: currSel samplingRate: origSamplingRate.						 snd play]].! !!ScratchSoundEditor methodsFor: 'menu' stamp: 'LY 7/10/2003 16:34'!faster	| rate |	rate _ rateSlider getScaledValue*1.1.	rateSlider setScaledValue: rate.	self samplingRate: rate.	! !!ScratchSoundEditor methodsFor: 'menu' stamp: 'jm 7/12/2003 17:39'!invokeMenu	"Invoke a menu of additonal functions."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('save to file'		saveToFile)		('read from file'	readFromFile)).	aMenu invokeOn: self defaultSelection: nil.! !!ScratchSoundEditor methodsFor: 'menu' stamp: 'LY 7/10/2003 14:02'!origSamplingRate	^origSamplingRate.! !!ScratchSoundEditor methodsFor: 'menu' stamp: 'LY 7/21/2003 13:45'!pause	(snd notNil and: [snd isPlaying])		ifTrue: [snd pause.].! !!ScratchSoundEditor methodsFor: 'menu' stamp: 'ee 8/13/2003 15:25'!playAll	"Resumes playing the selection if there is one, otherwise resumes playing the entire soundtrack."	graph data size < 2 ifTrue: [^ self].	playCursor _ 1.	endPlaying _ graph data size.	snd isNil		ifTrue: [				 snd _ (SampledSound samples: graph data samplingRate: origSamplingRate).				 snd play.]		ifFalse: [			snd reset.			(graph data = snd samples)				ifTrue: [snd samplesRemaining = 0 ifTrue: [snd reset].						 snd resumePlaying.]				ifFalse: [snd setSamples: graph data samplingRate: origSamplingRate.						 snd play]]! !!ScratchSoundEditor methodsFor: 'menu' stamp: 'LY 7/18/2003 14:00'!playFrom: start to: end	| sz i1 i2 snd2 |	sz _ graph data size.	i1 _ ((start + 1) min: sz) max: 1.	i2 _ ((end + 1) min: sz) max: i1.	(i1 + 2) >= i2 ifTrue: [^ self].	snd2 _ SampledSound		samples: (graph data copyFrom: i1 to: i2)		samplingRate: samplingRate.	snd2 play.! !!ScratchSoundEditor methodsFor: 'menu' stamp: 'jm 12/4/2003 20:19'!readFromFile	"Read my samples from a file selected by the user."	| result |	result _ StandardFileMenu oldFileExtensions: #(aif aiff au wav).	result ifNil: [^ self].	self readFromFile: result directory pathName, FileDirectory slash, result name.! !!ScratchSoundEditor methodsFor: 'menu' stamp: 'jm 12/4/2003 19:45'!readFromFile: fName	"Read my samples from the file with the given name."	(FileDirectory default fileExists: fName)		ifFalse: [^ self inform: 'File not found: ', fName].	snd _ SampledSound fromFileNamed: fName.	completeSnd _ snd copy.	graph cursor: 200.	samplingRate _ snd originalSamplingRate.	origSamplingRate _ snd originalSamplingRate.	graph data: snd samples.	graph scale: 2.0.	self setVolume: 0.5.	volume setScaledValue: 0.5.		graph data size > 5000		ifTrue: [deltaVal _ 50]		ifFalse: [deltaVal _ graph data size // 10].! !!ScratchSoundEditor methodsFor: 'menu' stamp: 'LY 7/18/2003 14:20'!resetSamplingRate	snd ifNil: [^self].	snd setSamples: snd samples samplingRate: origSamplingRate.	rateSlider setScaledValue: 1.0.! !!ScratchSoundEditor methodsFor: 'menu' stamp: 'LY 7/18/2003 14:17'!samplingRate: sampleRate"Sets the samplingRate to somewhere btw 0.1 and 2.5 the original samplingRate, given a number btw 0.2 and 2.5 (sampleRate)"	snd ifNil: [^self.].	origSamplingRate = 0 		ifFalse: [snd setSamples: snd samples samplingRate: (sampleRate*origSamplingRate)]		ifTrue: [ snd setSamples: snd samples samplingRate: (sampleRate*10000)].	! !!ScratchSoundEditor methodsFor: 'menu' stamp: 'jm 8/23/2003 16:25'!saveToFile	"Read my samples from an image file."	| fileName samples f |	fileName _ FillInTheBlank request: 'File name?'.	fileName ifNil: [^ self].	(fileName asLowercase endsWith: '.aif') ifFalse: [fileName _ fileName, '.aif'].	(graph data isKindOf: SoundBuffer)		ifTrue: [samples _ graph data]		ifFalse: [samples _ SoundBuffer fromArray: graph data].	f _ (FileStream newFileNamed: fileName) binary.	(SampledSound samples: samples samplingRate: samplingRate) storeAIFFSamplesOn: f.	f close.! !!ScratchSoundEditor methodsFor: 'menu' stamp: 'LY 7/10/2003 17:16'!setVolume: aFloat	"aFloat is a value btw 0 and 1.0"		snd ifNil: [^self].	snd adjustVolumeTo: aFloat overMSecs: 50.! !!ScratchSoundEditor methodsFor: 'menu' stamp: 'LY 7/10/2003 16:34'!slower	| rate |	rate _ rateSlider getScaledValue/1.1.	rateSlider setScaledValue: rate.	self samplingRate: rate.	! !!ScratchSoundEditor methodsFor: 'menu' stamp: 'ee 8/13/2003 15:24'!stop	snd pause.	playCursor _ nil.	! !!ScratchSoundEditor methodsFor: 'accessing' stamp: 'LY 7/25/2003 10:41'!cursor	^cursor.! !!ScratchSoundEditor methodsFor: 'accessing'!cursor: aNumber	graph data ifNil: [^self].	cursor ~= aNumber ifTrue:  [	cursor _ ((aNumber truncated max: 1) min: graph data size) truncated.	"graph keepIndexInView: cursor."	].! !!ScratchSoundEditor methodsFor: 'accessing' stamp: 'LY 7/1/2003 14:14'!data: newData	graph data: newData.! !!ScratchSoundEditor methodsFor: 'accessing'!endPlaying	^endPlaying.! !!ScratchSoundEditor methodsFor: 'accessing' stamp: 'LY 7/1/2003 14:14'!graph	^ graph! !!ScratchSoundEditor methodsFor: 'accessing'!playCursor		^playCursor.! !!ScratchSoundEditor methodsFor: 'accessing'!playCursor: aNumber	graph data ifNil: [^self].	"allows the graph to set where the playing cursor is"	cursor ~= aNumber ifTrue:  [	cursor _ ((aNumber truncated max: 1) min: graph data size) truncated.	].! !!ScratchSoundEditor methodsFor: 'accessing' stamp: 'LY 7/1/2003 14:14'!samplingRate	^ samplingRate! !!ScratchSoundEditor methodsFor: 'accessing'!scrollTime: relativeValue	graph startIndex: relativeValue*(graph data size).	viewer flushCachedForm; changed.! !!ScratchSoundEditor methodsFor: 'accessing' stamp: 'LY 7/25/2003 17:54'!selection	^selection.! !!ScratchSoundEditor methodsFor: 'accessing' stamp: 'LY 7/25/2003 21:25'!selection: anArrayorNil	anArrayorNil ifNil: [selection _ {nil. nil}.]			 ifNotNil: [selection _ anArrayorNil.].	graph selection: selection.	viewer selection: selection! !!ScratchSoundEditor methodsFor: 'accessing' stamp: 'LY 7/25/2003 23:19'!selection: aNumber scd: anotherNumber	selection _ { aNumber min: anotherNumber. aNumber max: anotherNumber}.	graph selection: selection.	viewer selection: selection.	graph flushCachedForm; changed.	viewer flushCachedForm; changed.! !!ScratchSoundEditor methodsFor: 'accessing' stamp: 'LY 7/25/2003 17:53'!selectionNil		(selection at: 1) ifNil: [^ true].		^false.! !!ScratchSoundEditor methodsFor: 'accessing' stamp: 'LY 7/30/2003 17:03'!slider 	^slider.! !!ScratchSoundEditor methodsFor: 'accessing' stamp: 'LY 7/18/2003 12:42'!sound	^snd.! !!ScratchSoundEditor methodsFor: 'accessing' stamp: 'LY 7/25/2003 10:16'!startSelection			^ startSelection.! !!ScratchSoundEditor methodsFor: 'accessing' stamp: 'LY 7/25/2003 10:16'!startSelection: aNumber	startSelection _ aNumber.! !!ScratchSoundEditor methodsFor: 'accessing'!updateSliderValue	slider setScaledValue: ((graph startIndex/graph data size min: slider maxVal) max: 0).! !!ScratchSoundEditor methodsFor: 'accessing'!viewer	^viewer.! !!ScratchSoundEditor methodsFor: 'event handling' stamp: 'LY 7/7/2003 21:39'!handlesMouseDown: evt	| p |	p _ evt cursorPoint.	^ (Rectangle origin: backButton topLeft corner: fwdButton bottomRight) containsPoint: p.! !!ScratchSoundEditor methodsFor: 'event handling' stamp: 'LY 7/9/2003 12:38'!handlesMouseOver: evt	^true.! !!ScratchSoundEditor methodsFor: 'event handling' stamp: 'LY 7/25/2003 11:27'!keyStroke: evt	| keyVal |	keyVal _ evt keyCharacter asciiValue.	keyVal = 28 ifTrue: [ cursor _ cursor + (( -10) / graph scale)].	keyVal = 29 ifTrue: [ cursor _ cursor + (10/graph scale)].! !!ScratchSoundEditor methodsFor: 'event handling' stamp: 'LY 7/8/2003 11:55'!mouseDown: evt	| p |	"do stuff"	p _ evt cursorPoint.		(slider containsPoint: p) ifTrue: [ 		slider descending ifTrue: [scrollDelta _ deltaVal negated.]						  ifFalse: [scrollDelta _ deltaVal.].].	(backButton containsPoint: p) ifTrue: [ backButton borderInset. scrollDelta _ deltaVal negated ].	(fwdButton containsPoint: p) ifTrue: [ fwdButton borderInset. scrollDelta _ deltaVal].! !!ScratchSoundEditor methodsFor: 'event handling' stamp: 'LY 7/9/2003 12:40'!mouseEnter: evt	evt hand newKeyboardFocus: self.! !!ScratchSoundEditor methodsFor: 'event handling' stamp: 'LY 7/8/2003 13:16'!mouseUp: evt	"do stuff"	scrollDelta _ 0.	fwdButton borderRaised.	backButton borderRaised.! !!ScratchSoundEditor methodsFor: 'graph ops' stamp: 'LY 8/2/2003 17:13'!back	"Moves the cursor back in the music score."	scrollDelta _ -5.  	self cursor: cursor + scrollDelta.! !!ScratchSoundEditor methodsFor: 'graph ops' stamp: 'jm 8/23/2003 14:40'!cancel	self delete.! !!ScratchSoundEditor methodsFor: 'graph ops' stamp: 'LY 7/24/2003 15:34'!copy	"copies the current selection if there is one."	(selection at: 1) ifNotNil:		[copy _ graph data copyFrom: (graph selection at: 1) to: (graph selection at: 2).]! !!ScratchSoundEditor methodsFor: 'graph ops'!crop		| sel |	"Crops the sound in the sound editor to be only the selected region"	sel _ ((selection at: 1) notNil and: [(selection at: 2) - (selection at: 1) > 3]).	sel ifFalse: [^self].	undoSel _ graph selection copy.	undoSound _ SampledSound samples: graph data samplingRate: samplingRate.	undoCursor _ cursor.	undoScale _ graph scale/ScratchGraphMorph MinScale.	sel _ graph data copyFrom: (selection at: 1) to: (selection at: 2).	graph data: sel.	viewer data: graph data.	cursor _ ((cursor - (selection at: 1)) truncated max: 1) min: graph data size truncated.	"scales the botton viewer so that the data fits on the entire screen." 	(selection second - selection first)/graph data size >= 0.05		ifTrue: [ScratchGraphMorph MinScale: (viewer extent x/ graph data size min: 1). "the mult factor in all scales, the minimum scale allowed...to get this just do self scale: 1, since this multiplied by input"				viewer scale: 1.				graph scale: 1.				viewer startIndex: 1.				graph computeSlider.				self fixSliderRange.].	graph calculateDataArray.	viewer calculateDataArray.	snd setSamples: sel samplingRate: samplingRate.	completeSnd setSamples: sel samplingRate: samplingRate.	selection at: 1 put: 1.	selection at: 2 put: graph data size.! !!ScratchSoundEditor methodsFor: 'graph ops'!cut 	| data1 data2 |	(selection at: 1) ifNil: [^ self.].	undoSound _ SampledSound samples: graph data samplingRate: samplingRate.	undoSel _ graph selection copy.	undoCursor _ cursor.	undoScale _ graph scale/ScratchGraphMorph MinScale.	self copy.	data1 _ graph data copyFrom: 1 to: (selection at: 1).	data2 _ graph data copyFrom: (selection at: 2) to: graph data size.		graph data: (data1, data2).	viewer data: graph data.			"scales the botton viewer so that the data fits on the entire screen." 	((selection second - selection first)/graph data size asFloat) >= 0.05		ifTrue: [ScratchGraphMorph MinScale: (viewer extent x/ graph data size min: 1).				viewer scale: 1.				graph scale: undoScale.				viewer startIndex: 1.				graph computeSlider.				self fixSliderRange.].	graph calculateDataArray.	viewer calculateDataArray.	snd setSamples: graph data samplingRate: samplingRate.	completeSnd setSamples: graph data samplingRate: samplingRate.	cursor _ (selection at: 1).		selection at: 1 put: nil. 	selection at: 2 put: nil.! !!ScratchSoundEditor methodsFor: 'graph ops'!fixSliderRange	slider maxVal: (1 -(slider sliderThickness/slider extent x)).	^slider! !!ScratchSoundEditor methodsFor: 'graph ops' stamp: 'LY 7/26/2003 15:32'!fwd		"moves the cursor forward in the music."	scrollDelta _ 5.	self cursor: cursor + 5.! !!ScratchSoundEditor methodsFor: 'graph ops'!paste	| data1 data2 |	"inserts the copied data into the dataset where the cursor is."		copy ifNil: [^self ].		"self selectionNil ifTrue: [undoSel _ nil.] ifFalse: [undoSel _ selection copy.]."	undoSel _ selection copy.	undoSound _ SampledSound samples: graph data samplingRate: samplingRate.	undoCursor _ cursor.	undoScale _ graph scale/ScratchGraphMorph MinScale.	((self selectionNil not) and: [(selection at: 2) - (selection at: 1) > 3])		ifTrue: [data1 _ graph data copyFrom: 1 to: (graph selection at: 1).			     data2 _ graph data copyFrom: (graph selection at: 2) to: graph data size.]		ifFalse: [data1 _ graph data copyFrom: 1 to: graph cursor truncated.				 data2 _ graph data copyFrom: graph cursor truncated + 1 to: graph data size.].		graph data: (data1, copy, data2).	viewer data: graph data.	"scales the botton viewer so that the data fits on the entire screen." 	(copy size)/graph data size >= 0.05		ifTrue: [ScratchGraphMorph MinScale: (viewer extent x/ graph data size min: 1).				viewer scale: 1.				graph scale: undoScale.				self fixSliderRange.				viewer startIndex: 1.				graph computeSlider.].		graph calculateDataArray.	viewer calculateDataArray.	snd setSamples: graph data samplingRate: samplingRate.	completeSnd setSamples: graph data samplingRate: samplingRate.	self selection: {data1 size. (data1 size) + (copy size).}.	cursor _ selection at: 2.	graph startIndex: (slider getScaledValue)*(graph data size).	viewer flushCachedForm.		! !!ScratchSoundEditor methodsFor: 'graph ops'!save	soundMorphSound setSamples: completeSnd samples samplingRate: samplingRate.	self delete.! !!ScratchSoundEditor methodsFor: 'graph ops'!sound: aSampledSound	"completeSnd is a version of the sound that is unaffected by the play mechanism.  This method is called when a SoundMorph brings up a SoundEditor. soundMorphSound is a copy of the initial sampledSound, used for saving and cancelling edits purposes.  It serves as a reference to the original sound so that we can actually change the sound in the soundMorph"	soundMorphSound _ aSampledSound.	snd _ aSampledSound copy.	completeSnd _ snd copy.	graph cursor: 200.	samplingRate _ snd originalSamplingRate.	origSamplingRate _ snd originalSamplingRate.	ScratchGraphMorph MinScale: (graph extent x/completeSnd samples size).	graph data: completeSnd samples.  "SHOULD IT BE COPY?/"	graph scale: 2.	graph calculateDataArray.	"self fixSliderRange.	graph computeSlider."		viewer data: completeSnd samples.	viewer scale: 1.	viewer calculateDataArray.	self setVolume: snd loudness.	volume setScaledValue: snd loudness.		(graph data size > 5000)		ifTrue: [deltaVal _ 200]		ifFalse: [deltaVal _ (graph data size) // 10].	self updateSlider! !!ScratchSoundEditor methodsFor: 'graph ops' stamp: 'LY 8/2/2003 17:25'!startTime		| ss |	"secs _ cursor / samplingRate.	hrs _ secs // 3600.	mins _ (secs \\ 3600) // 60.	secs _ secs \\ 60 asFloat.	ms _ ((secs \\ 1) * 100) asFloat truncated.	secs _ secs // 1."	" hrs asString,':',mins asString, ':', secs asString, '.', ms asString."		origSamplingRate isNil		ifTrue: [ss _ 20000]		ifFalse: [ss _ origSamplingRate].	^ ((cursor asFloat/ss) roundTo: 0.01) asString.! !!ScratchSoundEditor methodsFor: 'graph ops' stamp: 'LY 7/1/2003 16:12'!startTime: hrMinSecs		| secs hrs mins time |	time _ hrMinSecs findTokens: ' :.'.	hrs _ time at: 1.	mins _ time at: 2.	secs _ time at: 3.		self startIndex: ((hrs asNumber*3600) + (mins asNumber*60)+ secs asNumber )* samplingRate.	! !!ScratchSoundEditor methodsFor: 'graph ops'!undo	| tmpSound tmpSel tmpCursor tmpScale |	undoSound ifNil: [^self].	tmpSound _ SampledSound samples: graph data samplingRate: samplingRate.	tmpSel _ graph selection copy.	tmpCursor _ cursor.	tmpScale _ graph scale/ScratchGraphMorph MinScale.	graph data: undoSound samples copy.	viewer data: graph data.		"scales the botton viewer so that the data fits on the entire screen." 	(tmpSound samples size - graph data size) abs > 3		ifTrue: [ScratchGraphMorph MinScale: ((viewer extent x/ graph data size) min: 1).				viewer scale: 1.				graph scale: undoScale.				viewer startIndex: 1.				graph computeSlider.				self fixSliderRange.].	graph calculateDataArray.	viewer calculateDataArray.	snd setSamples: graph data samplingRate: samplingRate.	completeSnd setSamples: graph data samplingRate: samplingRate.	self selection: undoSel copy.	cursor _ undoCursor.	undoSound _ tmpSound.	undoSel _ tmpSel.	undoCursor _ tmpCursor.	undoScale _ tmpScale.! !!ScratchSoundEditor methodsFor: 'stepping' stamp: 'jm 9/29/2003 20:28'!step	| played prev |	(SoundPlayer isPlaying: snd) ifTrue: [		played _ ((snd millisecondsSinceStart) * snd samples size) / (1000.0 * snd duration).		prev _ (completeSnd samples size - snd samples size).		playCursor _ (played + prev truncated min: graph data size).		self changed].	time contents: self startTime.	scrollDelta = 0 ifFalse: [		graph startIndex: graph startIndex + (scrollDelta/graph scale).		self updateSliderValue.].	graph computeSlider.	self fixSliderRange.! !!ScratchSoundEditor methodsFor: 'stepping' stamp: 'jm 9/29/2003 20:27'!stepTime	^ 150! !!ScratchSoundEditor methodsFor: 'other' stamp: 'LY 7/1/2003 14:14'!normalize: sampleArray	"Return a copy of the given sample array scaled to use the maximum 16-bit sample range. Remove any D.C. offset."	| max abs scale out |	max _ 0.	sampleArray do: [:s |		s > 0 ifTrue: [abs _ s] ifFalse: [abs _ 0 - s].		abs > max ifTrue: [max _ abs]].	scale _ ((1 << 15) - 1) asFloat / max.	out _ sampleArray species new: sampleArray size.	1 to: sampleArray size do: [:i |		out at: i put: (scale * (sampleArray at: i)) truncated].	^ out! !!ScratchSoundEditor methodsFor: 'other' stamp: 'LY 7/1/2003 14:14'!stretch: sampleArray by: stretchFactor	"Return an array consisting of the given samples \stretched in time by the given factor."	| out end incr i frac index |	out _ OrderedCollection new: (stretchFactor * sampleArray size) asInteger + 1.	end _ (sampleArray size - 1) asFloat.	incr _ 1.0 / stretchFactor.	i _ 1.0.	[i < end] whileTrue: [		frac _ i fractionPart.		index _ i truncated.		i _ i + incr.		out addLast:			(((1.0 - frac) * (sampleArray at: index)) + (frac * (sampleArray at: index + 1))) rounded].	^ out asArray! !!ScratchSoundEditor methodsFor: 'other'!updateSlider	"this is the order that these methods have to be called in order to update slider!!!!!!"	graph computeSlider.  	self fixSliderRange.	self updateSliderValue.! !!ScratchSoundEditor class methodsFor: 'instance creation' stamp: 'LY 7/29/2003 09:59'!MenuIcon"a template for the uparrow used in a slider." 	^Form		extent: 12@6		fromArray: #(2r11e28 2r1111e27 2r111111e26)		offset: 0@0.! !!ScratchSoundEditor class methodsFor: 'instance creation' stamp: 'LY 7/7/2003 16:21'!UpArrow"a template for the uparrow used in a slider." 	^Form		extent: 6@3		fromArray: #(2r11e28 2r1111e27 2r111111e26)		offset: 0@0.! !!ScratchSoundEditor class methodsFor: 'instance creation' stamp: 'LY 7/1/2003 14:14'!openOn: dataCollection	"Open a new WaveEditor on the given sequencable collection of data."	^ (self new data: dataCollection) openInWorld! !A ScratchStackFrame describes the complete state of a ScratchProcess. It is simply a container for state information.Each ScratchProcess has a pointer to a ScratchStackFrame containing its state. Whenever the ScratchProcess yields control to another one, its ScratchStackFrame tells it exactly where it left off.Structure:  expression		the ArgMorph, BlockMorph, or a collection of blocks to evaluate,					or #shouldYield or #returnMarker  pc				the index of the next block to evaluate (if expression is a Collection)  parentFrame	the ScratchStackFrame to return to when this one has been evaluated.  arguments		the OrderedCollection of arg values computed so far (if expression is a BlockMorph)  startTime		the time at which evaluation began (if expression is a timed CommandBlockMorph)  startValue		the starting value for interpolation (if expression is a timed CommandBlockMorph)  environment	a Dictionary mapping formal parameter IDs to values passed in a method call  shouldUnlight	a Boolean that indicates if we should unlight the current expression (a block)!!ScratchStackFrame methodsFor: 'initialization' stamp: 'DaveF 8/4/2003 17:23'!initialize	expression _ nil.	pc _ 1.	parentFrame _ nil.	arguments _ OrderedCollection new. 	environment _ nil.	shouldUnlight _ false.	"If environment is nil when added to stack frame, will be modified to point to parent frame's environment."! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'DaveF 7/9/2003 19:46'!addArgument: aValue	"Adds this value to the list of evaluated arguments available in this stack frame."	arguments add: aValue.! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'DaveF 7/8/2003 16:25'!arguments	"Returns the values of the arguments to be sent to the current command."	^arguments.! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'DaveF 7/18/2003 14:01'!environment	^environment.! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'DaveF 7/18/2003 15:28'!environment: aDictionary		environment _ aDictionary.! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'DaveF 7/4/2003 11:50'!expression	^expression.! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'DaveF 7/4/2003 11:33'!expression: anExpression	expression _ anExpression.! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'DaveF 7/15/2003 14:55'!isReturnMarker	^expression = #returnMarker.! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'DaveF 7/15/2003 14:55'!isReturnMarker: aBoolean	expression _ #returnMarker.! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'DaveF 7/8/2003 00:11'!parentFrame	^parentFrame.! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'DaveF 7/8/2003 00:10'!parentFrame: aScratchStackFrame	"Sets this frame's parent frame."	parentFrame _ aScratchStackFrame.! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'DaveF 7/8/2003 00:06'!pc	"Returns the current program counter."	^pc.! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'DaveF 7/8/2003 00:07'!pc: anIndex	"Updates the pc to have the current numeric index, indicating the next block to evaluate."	pc _ anIndex.! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'DaveF 8/4/2003 17:23'!shouldUnlight	^shouldUnlight! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'DaveF 8/4/2003 17:23'!shouldUnlight: aBoolean	shouldUnlight _ aBoolean.! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'DaveF 7/9/2003 18:35'!shouldYield	"Returns true iff this is a dummy frame simply indicating that the process should yield control."	^expression = #shouldYield.! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'DaveF 7/9/2003 18:05'!shouldYield: aBoolean	"Makes this into a special stack frame that tells the evaluator to yield control to another process.  When this flag is set, the rest of the stack frame is ignored."	aBoolean		ifTrue: [expression _ #shouldYield]		ifFalse: [self error: 'Should not call shouldYield: with false.'].! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'jm 8/22/2003 18:56'!startTime	^ startTime! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'jm 8/22/2003 18:56'!startTime: mSecs	"Record the starting time for an interpolating command."		startTime _ mSecs.! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'jm 8/22/2003 18:55'!startValue	^ startValue! !!ScratchStackFrame methodsFor: 'accessing' stamp: 'jm 8/22/2003 18:55'!startValue: aTime	"Record the starting value for an interpolating command."		startValue _ aTime.! !I show an updating thumbnail picture of my target morph. I also allow the user to select a new target morph by clicking on it. I inform my viewer or scriptor when my target morph has changed.!!ScratchThumbnailMorph methodsFor: 'initialization' stamp: 'ee 7/2/2003 12:07'!initialize	super initialize.	self form: (Form extent: 38@38 depth: 16).	form fillColor: Color white.	form border: form boundingBox width: 1.! !!ScratchThumbnailMorph methodsFor: 'accessing' stamp: 'TIS 7/14/2003 14:08'!target	^ target! !!ScratchThumbnailMorph methodsFor: 'accessing' stamp: 'jm 6/22/2003 22:57'!target: aMorph	target _ aMorph.	self updateThumbnail.! !!ScratchThumbnailMorph methodsFor: 'accessing' stamp: 'jm 6/22/2003 22:59'!viewer: aScratchViewerMorph	viewer _ aScratchViewerMorph.! !!ScratchThumbnailMorph methodsFor: 'accessing' stamp: 'jm 9/13/2003 20:02'!workPane: aScratchWorkPaneMorph	workPane _ aScratchWorkPaneMorph.! !!ScratchThumbnailMorph methodsFor: 'event handling' stamp: 'jm 6/22/2003 22:54'!handlesMouseDown: evt	^ true! !!ScratchThumbnailMorph methodsFor: 'event handling' stamp: 'jm 12/1/2003 15:31'!mouseDown: evt	self selectObjectMenu.! !!ScratchThumbnailMorph methodsFor: 'event handling' stamp: 'jm 12/1/2003 15:34'!objectMenuNameFor: aMorph	| scriptCount plural |	scriptCount _ aMorph scripts size.	scriptCount = 0 ifTrue: [^ aMorph objName].	plural _ scriptCount = 1 ifTrue: [''] ifFalse: ['s'].	^ aMorph objName, ' (', scriptCount printString, ' script', plural, ')'! !!ScratchThumbnailMorph methodsFor: 'event handling' stamp: 'jm 12/1/2003 15:34'!selectObjectMenu	"Let the user select which object to view from a menu."	| isInEditor menu selectedMorph |	workPane ifNil: [^ self].	isInEditor _ (self ownerThatIsA: ScratchScriptEditorMorph) notNil.	menu _ CustomMenu new.	workPane submorphsDo: [:m |		((m isKindOf: ScriptableScratchMorph) and:		 [isInEditor not or: [m isScriptable]]) ifTrue: [			menu add: (self objectMenuNameFor: m) action: m]].	selectedMorph _ menu startUp.	selectedMorph ifNil: [^ self].	viewer ifNotNil: [viewer target: selectedMorph].	self target: selectedMorph.! !!ScratchThumbnailMorph methodsFor: 'dropping/grabbing' stamp: 'jm 7/8/2003 01:19'!acceptDroppingMorph: aMorph event: evt	"View the given morph and send it back from whence it came."	viewer target: aMorph.	aMorph slideBackToFormerSituation: evt.! !!ScratchThumbnailMorph methodsFor: 'dropping/grabbing' stamp: 'jm 8/3/2003 13:42'!wantsDroppedMorph: aMorph event: evt	"Answer true if the givne morph is a ScriptableScratchMorph."	^ aMorph isKindOf: ScriptableScratchMorph! !!ScratchThumbnailMorph methodsFor: 'stepping' stamp: 'jm 8/3/2003 21:01'!step	target ifNotNil: [		target world isNil ifTrue: [			viewer target: nil.			self changed]].	self updateThumbnail.! !!ScratchThumbnailMorph methodsFor: 'stepping' stamp: 'jm 12/1/2003 15:39'!updateThumbnail	| f e r |	form fillColor: Color white.	form border: form boundingBox width: 1.	form boundingBox innerCorners do: [:p |		form fill: (p extent: 1) fillColor: Color transparent].	target ifNil: [^ self].	f _ target imageForm.	f width > f height 		ifTrue: [e _ form width @ ((f height * form width) // f width)]		ifFalse: [e _ ((f width * form height) // f height) @ form height].	e _ e max: (8@8).	r _ Rectangle center: (form extent // 2) extent: e.	(WarpBlt toForm: form)		sourceForm: f;		cellSize: 2;  "do smoothing; this also installs a colormap"		combinationRule: Form paint;		copyQuad: f boundingBox innerCorners toRect: (r insetBy: 2).	viewer updateColor: target colorCode.	self changed.! !I am a toolbar for Scratch.!!ScratchToolBar methodsFor: 'initialization' stamp: 'jm 7/20/2003 11:32'!forms: formList	"Set the Forms used to draw my ends and middle and set my height."	leftEndForm _ formList at: 1.	middleForm _ formList at: 2.	rightEndForm _ formList at: 3.	self height: ((leftEndForm height max: middleForm height) max: rightEndForm height).! !!ScratchToolBar methodsFor: 'initialization' stamp: 'jm 7/20/2003 11:32'!initialize	super initialize.	self color: (Color gray: 0.6).! !!ScratchToolBar methodsFor: 'drawing' stamp: 'jm 7/20/2003 11:29'!drawMiddleOn: aCanvas	"Draw a horizontal bar the width of my bounds using my middleForm. Do nothing if middleForm is nil."	| p clipC lastX |	middleForm ifNil: [^ self].	p _ self topLeft.	clipC _ aCanvas copyClipRect: self bounds.	lastX _ self bounds right.	[p x <= lastX] whileTrue: [		clipC paintImage: middleForm at: p.		p _ (p x + middleForm width) @ p y].! !!ScratchToolBar methodsFor: 'drawing' stamp: 'jm 7/20/2003 11:30'!drawOn: aCanvas	"Draw the appropriate edge according to the geometry of my bounds. Use my superclass drawOn: method if my leftEndForm is nil."	leftEndForm ifNil: [^ super drawOn: aCanvas].	self drawMiddleOn: aCanvas.	aCanvas paintImage: leftEndForm at: self topLeft.	aCanvas paintImage: rightEndForm at: self topRight - (rightEndForm width@0).! !!ScratchToolBar class methodsFor: 'instance creation' stamp: 'jm 7/3/2003 10:20'!newFromSkin: aDictionary	"Answer an instance of me using the forms from the given dictionary." 	^ self new forms: (Array		with: (aDictionary at: #toolBarLeft)		with: (aDictionary at: #toolBarMiddle)		with: (aDictionary at: #toolBarRight))! !!ScratchToolBar class methodsFor: 'instance creation' stamp: 'jm 7/20/2003 22:32'!withFormsFrom: aDirectory	"Answer an image of me using the forms from the given directory."	"ScratchToolBar withFormsFrom: (FileDirectory default directoryNamed: 'ScratchSkin')" 	| segments |	segments _ Array		with: (Utilities form: 'toolBarLeft' from: aDirectory)		with: (Utilities form: 'toolBarMiddle' from: aDirectory)		with: (Utilities form: 'toolBarRight' from: aDirectory).	^ self new forms: segments! !!ScratchViewerButtonsMorph methodsFor: 'initialization' stamp: 'jm 12/17/2003 14:28'!addButtonsFor: catList	"ScratchViewerButtonsMorph open"	| bezelW bezelF hues hueIndex nextX b extraSpace |	bezelW _ 2.	bezelF _ ImageMorph bezelDiameter: 17 width: 2 baseColor: self color inset: true.	hues _ #(60 180 120).	hueIndex _ 1.	buttonToCategory _ Dictionary new.	self removeAllMorphs.	self addMorph: labelMorph.	nextX _ 8.	extraSpace _ self width - (2 * nextX) - (20 * (catList size - 2)).	catList do: [:cat |		'-' = cat			ifTrue: [				hueIndex _ hueIndex + 1.				nextX _ nextX + (extraSpace // 2)]			ifFalse: [				b _ self buttonHue: (hues at: hueIndex) bezelForm: bezelF inset: bezelW.				b position: self position + (nextX @ 25).				buttonToCategory at: b put: cat.				self addMorph: b.				nextX _ nextX + 20]].! !!ScratchViewerButtonsMorph methodsFor: 'initialization' stamp: 'jm 12/17/2003 17:05'!allButtonsDo: aBlock	submorphs do: [:m |		(m isKindOf: ToggleButton) ifTrue: [aBlock value: m]].! !!ScratchViewerButtonsMorph methodsFor: 'initialization' stamp: 'jm 12/17/2003 14:13'!buttonHue: hue bezelForm: aForm inset: w	"Answer a new ToggleButton that looks like an LED indicator light of the given hue."	| d onF offF |	d _ aForm width - (2 * w).	onF _ aForm deepCopy.	(ImageMorph glowDiameter: d color: (Color h: hue s: 1 v: 1) on: true)		displayOn: onF at: w@w rule: Form paint.	offF _ aForm deepCopy.	(ImageMorph glowDiameter: d color: (Color h: hue s: 1 v: 1) on: false)		displayOn: offF at: w@w rule: Form paint.	^ ToggleButton onForm: onF offForm: offF! !!ScratchViewerButtonsMorph methodsFor: 'initialization' stamp: 'jm 12/17/2003 17:13'!currentCategory: aString	| newButton |	newButton _ buttonToCategory keyAtValue: aString ifAbsent: [^ self].	self allButtonsDo: [:b | b off].	newButton on.	self label: aString color: Color black.	currentCategory _ aString.! !!ScratchViewerButtonsMorph methodsFor: 'initialization' stamp: 'jm 12/17/2003 17:05'!initialize	super initialize.	self extent: 230@45.	self color: (Color gray: 0.8).	labelMorph _ StringMorph contents: 'Category'.	labelMorph position: (self left + ((self width - labelMorph width) // 2)) @ 5.	self addMorph: labelMorph.	self addButtonsFor: #(control math math2 'mouse/keyboard' other - motion sensing - scripts variables).	self currentCategory: 'motion'.! !!ScratchViewerButtonsMorph methodsFor: 'event handling' stamp: 'jm 12/17/2003 17:24'!handlesMouseDown: evt	^ true! !!ScratchViewerButtonsMorph methodsFor: 'event handling' stamp: 'jm 12/17/2003 17:24'!mouseDown: evt	self allButtonsDo: [:m |		(m containsPoint: evt cursorPoint) ifTrue: [			self currentCategory: (buttonToCategory at: m ifAbsent: [^ self])]].! !!ScratchViewerButtonsMorph methodsFor: 'event handling' stamp: 'jm 12/17/2003 17:24'!preemptsMouseDown: evt	^ true! !!ScratchViewerButtonsMorph methodsFor: 'event handling' stamp: 'jm 12/17/2003 17:24'!zzhandlesMouseDown: evt	^ true! !!ScratchViewerButtonsMorph methodsFor: 'stepping' stamp: 'jm 12/17/2003 17:38'!highlight: aButton	| newCat |	aButton ifNil: [^ self].  "ignore nil"	newCat _ buttonToCategory at: aButton.	newCat = currentCategory ifFalse: [		self label: (buttonToCategory at: aButton) color: Color red.		labelMorph position: (self left + ((self width - labelMorph width) // 2)) @ labelMorph top].	self allButtonsDo: [:b | b off].	aButton on.	litUpButton _ aButton.! !!ScratchViewerButtonsMorph methodsFor: 'stepping' stamp: 'jm 12/16/2003 14:43'!label: aString color: aColor	labelMorph color: aColor.	labelMorph contents: aString.	labelMorph left: self left + ((self width - labelMorph width) // 2).! !!ScratchViewerButtonsMorph methodsFor: 'stepping' stamp: 'jm 12/16/2003 14:36'!step	| p overB |	p _ Sensor cursorPoint.	(self containsPoint: p) ifFalse: [^ self unhighlight].	overB _ submorphs		detect: [:m | (m containsPoint: p) and: [m ~~ labelMorph]]		ifNone: [nil]."	litUpButton = overB ifTrue: [^ self]."	self unhighlight.	self highlight: overB.! !!ScratchViewerButtonsMorph methodsFor: 'stepping' stamp: 'jm 12/16/2003 14:37'!stepTime	^ 50! !!ScratchViewerButtonsMorph methodsFor: 'stepping' stamp: 'jm 12/17/2003 17:10'!unhighlight	litUpButton ifNil: [^ self].  "nothing lit up"	self label: currentCategory color: Color black.	(buttonToCategory at: litUpButton) = currentCategory		ifFalse: [litUpButton off].	litUpButton _ nil.! !I am a Scratch blocks viewer. I have a heading row containing the object name (editable), a thumbnail, and a drop-down menu icon. Below that is a bin for myt blocks, variables, and scripts.!!ScratchViewerMorph methodsFor: 'initialization' stamp: 'jm 8/3/2003 09:39'!initialize	super initialize.	self orientation: #vertical.	self color: (Color gray: 0.8).	self borderWidth: 2; borderColor: (Color gray: 0.5).	self inset: 0.	self useRoundedCorners.	self addHeadingRow.	pageViewer _ ScrollFrameMorph new 		borderWidth: 0;		showHorizontalScrollbar: false.	self addMorphBack: pageViewer.	self target: nil.	currentCategory _ 'none'.! !!ScratchViewerMorph methodsFor: 'accessing' stamp: 'jm 11/18/2003 17:15'!categoryChanged: aString	"The given category has changed (e.g., due to a variable or script add/remove). If that is the current category, update my contents. Otherwise, do nothing."	| p |	self target ifNil: [^ self].	currentCategory = aString ifTrue: [		p _ self target viewerPageForCategory: aString.		pageViewer contents: p.		self isInWorld ifTrue: [self world startSteppingSubmorphsOf: p]].! !!ScratchViewerMorph methodsFor: 'accessing' stamp: 'jm 9/13/2003 20:26'!currentCategory: aString		currentCategory _ aString.	chooser contents: currentCategory.	self updateContents.! !!ScratchViewerMorph methodsFor: 'accessing' stamp: 'jm 6/22/2003 23:14'!target	^ nameMorph target! !!ScratchViewerMorph methodsFor: 'accessing' stamp: 'jm 11/18/2003 15:59'!target: aScratchObject	"Start viewing the given object, if not object, return an empty viewer."	| categories |	aScratchObject ifNil: [		nameMorph target: nil; contents: 'no object '.		thumbnail target: nil.		topRow color: self color.		^ self currentCategory: 'none'].		nameMorph		target: aScratchObject;		getSelector: #objName;		putSelector: #objName:.	thumbnail target: aScratchObject.	categories _ self target blockCategoriesFor: #type.	(categories includes: currentCategory)		ifTrue: [self currentCategory: currentCategory]		ifFalse: [			categories size > 0				ifTrue: [self currentCategory: categories first]				ifFalse: [self currentCategory: 'control']].	self isInWorld ifTrue: [self world startSteppingSubmorphsOf: self].! !!ScratchViewerMorph methodsFor: 'accessing' stamp: 'jm 9/13/2003 20:00'!thumbnail	^ thumbnail! !!ScratchViewerMorph methodsFor: 'menu' stamp: 'jm 8/3/2003 10:38'!addVariable	| varName |	varName _ FillInTheBlank request: 'Variable name?'.	varName size = 0 ifTrue: [^ self].	self target addVariable: varName.	self categoryChanged: 'variables'.		"scroll down to added variable - this works, but the added variables are organized alphabetically - so they are not always on the bottom..."	pageViewer vScrollRelative: 1.0.! !!ScratchViewerMorph methodsFor: 'menu' stamp: 'jm 7/8/2003 00:32'!deleteVariable	| varNames menu varToDelete |	varNames _ self target userVars.	varNames isEmpty ifTrue: [^ self inform: 'No variables.'].	menu _ CustomMenu new.	varNames do: [:s | menu add: s action: s].	varToDelete _ menu startUp.	varToDelete ifNotNil: [		self target deleteVariable: varToDelete.		self categoryChanged: 'variables'].! !!ScratchViewerMorph methodsFor: 'menu' stamp: 'TIS 7/11/2003 08:50'!makeSlider	ScratchSliderMorph new target: self target; openInWorld.! !!ScratchViewerMorph methodsFor: 'menu' stamp: 'jm 11/18/2003 17:15'!updateContents	| p addButton deleteButton |	self target ifNil: [		chooser contents: currentCategory.		pageViewer contents: (Morph new color: (Color gray: 0.9)).		^ self].	buttonPane removeAllMorphs.	currentCategory = 'variables' ifTrue: [		addButton _ (IconicButton new			labelGraphic: AddVarIcon;			extent: 16@16;			color: Color transparent;			borderWidth: 0;			target: self;			actWhen: #buttonDown;			actionSelector: #addVariable).		deleteButton _ (IconicButton new			labelGraphic: DeleteVarIcon;			extent: 16@16;			color: Color transparent;			borderWidth: 0;			target: self;			actWhen: #buttonDown;			actionSelector: #deleteVariable).		buttonPane			addMorphBack: addButton;			addMorphBack: deleteButton].	p _ self target viewerPageForCategory: currentCategory.	chooser contents: currentCategory.	pageViewer contents: p.	self isInWorld ifTrue: [self world startSteppingSubmorphsOf: p].! !!ScratchViewerMorph methodsFor: 'private' stamp: 'jm 7/20/2003 20:25'!addHeadingRow	"Add a morph that allows editing of my object's name."	| secondColumn secondColumnTop secondColumnBottom menuIconPopUp |	secondColumn _ AlignmentMorph newColumn		color: Color transparent;		inset: 0;		vResizing: #shrinkWrap.	secondColumnTop _ AlignmentMorph newColumn		color: Color transparent;		centering: #center;		vResizing: #shrinkWrap.	secondColumnTop addMorphBack: (nameMorph _ UpdatingStringMorph new useStringFormat).	nameMorph font: TextStyle defaultFont emphasis: 1.	secondColumnBottom _ AlignmentMorph newRow.	secondColumnBottom		inset: 3;		color: (Color gray: 0.6);		vResizing: #shrinkWrap.		menuIconPopUp _  (IconicButton new		labelGraphic: MenuIcon;		extent: 16@16;		color: Color transparent;		borderWidth: 0;		target: self;		actWhen: #buttonDown;		actionSelector: #setCategory).	chooser _ StringMorph new.	chooser contents: 'no category'.	buttonPane _ (AlignmentMorph newSpacer: Color transparent).	secondColumnBottom addMorphBack: buttonPane."xxx commented out to save space:	secondColumnBottom addMorphBack: (StringMorph		contents: 'Category: ' font: TextStyle default defaultFont emphasis: 1).xxx"	secondColumnBottom addMorphBack: chooser; addMorphBack: menuIconPopUp.	secondColumnBottom addMorphBack: (AlignmentMorph newSpacer: Color transparent).	secondColumn		addMorphBack: secondColumnTop;		addMorphBack: secondColumnBottom.	topRow _ AlignmentMorph newRow		color: self color;		inset: 3;		centering: #center;		vResizing: #shrinkWrap.	topRow addMorphBack: (thumbnail _ ScratchThumbnailMorph new viewer: self).	topRow addMorphBack: (Morph new color: Color transparent; extent: 3).	topRow addMorphBack: secondColumn.	self addMorph: topRow.! !!ScratchViewerMorph methodsFor: 'private' stamp: 'jm 11/18/2003 15:59'!setCategory	| menu choice |	self target ifNil: [^ self beep].	menu _ CustomMenu new.	(self target blockCategoriesFor: #generic) do: [:c | menu add: c action: c].	menu addLine.	(self target blockCategoriesFor: #type) do: [:c | menu add: c action: c].	menu addLine.	(self target blockCategoriesFor: #object) do: [:c | menu add: c action: c].	choice _ menu startUp.	choice ifNotNil: [self currentCategory: choice].! !!ScratchViewerMorph methodsFor: 'private' stamp: 'ee 7/3/2003 12:20'!updateColor: aColor	topRow color: aColor.! !!ScratchViewerMorph methodsFor: 'private' stamp: 'ee 7/3/2003 15:46'!width: aNumber	super width: aNumber.	self owner ifNotNil: [ ].! !!ScratchViewerMorph class methodsFor: 'class initialization' stamp: 'jm 7/20/2003 20:08'!menuIcon	^ MenuIcon! !!ScratchViewerMorph class methodsFor: 'class initialization' stamp: 'jm 7/7/2003 23:04'!readFormsFrom: aDirectory	"Read my Form from the given directory and save them in class variables."	"self readFormsFrom: (FileDirectory default directoryNamed: 'ScratchSkin')"	AddSliderIcon _ Form fromFileNamed: (aDirectory fullNameFor: 'sliderVariable.gif').	AddVarIcon _ Form fromFileNamed: (aDirectory fullNameFor: 'addVariable.gif').	DeleteVarIcon _ Form fromFileNamed: (aDirectory fullNameFor: 'deleteVariable.gif').	MenuIcon _ Form fromFileNamed: (aDirectory fullNameFor: 'arrowDOWN.gif').! !I am the work (content) pane of the Scratch UI.!!ScratchWorkPaneMorph methodsFor: 'initialization' stamp: 'jm 11/13/2003 11:36'!initialize	super initialize.	self color: (Color r: 0.8784313 g: 0.8784313 b: 0.8784313).	self borderWidth: 0.	presentationExtent _ 10000@10000.  "virtually unlimited"! !!ScratchWorkPaneMorph methodsFor: 'accessing' stamp: 'jm 11/13/2003 11:40'!presentationExtent	^ presentationExtent! !!ScratchWorkPaneMorph methodsFor: 'accessing' stamp: 'jm 11/13/2003 11:51'!presentationExtent: aPoint	presentationExtent _ aPoint.	self changed.! !!ScratchWorkPaneMorph methodsFor: 'drawing' stamp: 'jm 11/13/2003 11:39'!drawOn: aCanvas	"Draw my presentation boundary lines as a guideline for the user. Only draw a boundary line if it is visible."	| w h |	super drawOn: aCanvas.	w _ presentationExtent x.	h _ presentationExtent y.	self width > w ifTrue: [		aCanvas			fillRectangle: (((self left + w)@self top) extent: 1@(self height min: h))			color: Color gray].	self height > h ifTrue: [		aCanvas			fillRectangle: ((self left@(self top + h)) extent: ((self width min: w)@1))			color: Color gray].! !I am the controller for the parts of the display screen that have no view on them. I only provide a standard yellow button menu. I view (a FormView of) an infinite gray form.  (ScheduledControllers screenController) is the way to find me.!!ScreenController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 12:21'!controlActivity	"Any button opens the screen's menu.	If the shift key is down, do find window."	sensor leftShiftDown ifTrue: [^ self findWindow].	(self projectScreenMenu invokeOn: self) ifNil: [super controlActivity]! !!ScreenController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 12:06'!isControlActive	^ self isControlWanted! !!ScreenController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 12:05'!isControlWanted	^ self viewHasCursor and: [sensor anyButtonPressed]! !!ScreenController methodsFor: 'menu messages' stamp: 'jm 5/31/2003 17:08'!aboutThisSystem	Smalltalk aboutThisSystem.! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 6/11/1999 20:25'!bitCachingString	^ StandardSystemView cachingBits		ifTrue: ['don''t save bits (compact)']		ifFalse: ['save bits (fast)']! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 6/11/1999 20:50'!changeWindowPolicy	Preferences toggleWindowPolicy! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 12/10/1999 11:29'!configureFonts	Preferences presentMvcFontConfigurationMenu! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 10/27/1998 14:27'!lookForSlips	Smalltalk changes lookForSlips! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 9/4/1998 10:17'!newChangeSet	ChangeSorter newChangeSet! !!ScreenController methodsFor: 'menu messages' stamp: 'di 7/19/1999 14:56'!openMorphicProject	Smalltalk verifyMorphicAvailability ifFalse: [^ self].	ProjectView open: Project newMorphic.! !!ScreenController methodsFor: 'menu messages' stamp: 'jm 10/7/2002 06:22'!openProject 	"Create and schedule a Project."	Smalltalk at: #ProjectView ifPresent:		[:c | c open: Project new].! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 7/6/1998 18:59'!openSimpleChangeSorter	ChangeSorter new open! !!ScreenController methodsFor: 'menu messages' stamp: 'sma 4/30/2000 10:13'!restoreDisplay 	"Clear the screen to gray and then redisplay all the scheduled views."	Smalltalk isMorphic ifTrue: [^ World restoreDisplay].	Display extent = DisplayScreen actualScreenSize		ifFalse:			[DisplayScreen startUp.			ScheduledControllers unCacheWindows].	ScheduledControllers restore! !!ScreenController methodsFor: 'menu messages' stamp: 'bf 9/18/1999 20:01'!setDisplayDepth	"Let the user choose a new depth for the display. "	| result |	(result _ (SelectionMenu selections: Display supportedDisplayDepths) startUpWithCaption: 'Choose a display depth(it is currently ' , Display depth printString , ')') == nil ifFalse:		[Display newDepth: result]! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 6/11/1999 20:23'!staggerPolicyString	^ Preferences staggerPolicyString! !!ScreenController methodsFor: 'menu messages' stamp: 'sw 7/13/1999 20:19'!windowSpecificationPanel	Smalltalk hasMorphic ifFalse:		[^ self inform: 'Sorry, this feature requires the presence of Morphic.'].	Preferences windowSpecificationPanel! !!ScreenController methodsFor: 'nested menus' stamp: 'jm 5/31/2003 19:03'!appearanceMenu	"Answer the appearance menu to be put up as a screen submenu"	"ScreenController new appearanceMenu startUp"	^ SelectionMenu		labelList: #(			'set display depth...'			'set desktop color...'			'full screen on'			'full screen off'			'window colors...'			'system fonts...'		) 		lines: #(2 4)		selections: #(setDisplayDepth setDesktopColorfullScreenOn fullScreenOffwindowSpecificationPanel configureFonts)! !!ScreenController methodsFor: 'nested menus' stamp: 'jm 12/2/2003 20:51'!changesMenu	"Answer a menu for changes-related items."	"ScreenController new changesMenu startUp"	^ SelectionMenu		labelList: #(			'create new change set...'			'check change set for slips'			'simple change sorter'			'dual change sorter'			'recover recent changes...'		)		lines: #(2 4)		selections: #(			newChangeSet lookForSlips			openSimpleChangeSorter openChangeManager			browseRecentLog)! !!ScreenController methodsFor: 'nested menus' stamp: 'jm 5/31/2003 17:13'!helpMenu 	"Answer the help menu to be put up as a screen submenu"	"ScreenController new helpMenu startUp"	^ SelectionMenu		labelList: #(			'about this system'			'command-key help'			'edit preferences...'			'set author initials...'			'memory statistics'			'space left')		lines: #(3)		selections: #(aboutThisSystem openCommandKeyHelp editPreferencessetAuthorInitials vmStatisticsgarbageCollect).! !!ScreenController methodsFor: 'nested menus' stamp: 'jm 8/3/2003 15:11'!openMenu	"ScreenController new openMenu startUp"	^ SelectionMenu		labelList: #(			'browser'			'workspace'			'file list'			'transcript'			'simple change sorter'			'dual change sorter'			'mvc project'			'morphic project')		lines: #(5 7)		selections: #(openBrowser openWorkspace openFileList openTranscriptopenSimpleChangeSorter openChangeManageropenProject openMorphicProject)! !!ScreenController methodsFor: 'nested menus' stamp: 'sma 3/11/2000 12:23'!popUpMenuFor: aSymbol	(self perform: aSymbol) invokeOn: self! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/13/1999 18:07'!presentAppearanceMenu	self popUpMenuFor: #appearanceMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:14'!presentChangesMenu	self popUpMenuFor: #changesMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:15'!presentHelpMenu	self popUpMenuFor: #helpMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:15'!presentOpenMenu	self popUpMenuFor: #openMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'sw 7/6/1998 21:16'!presentWindowMenu	self popUpMenuFor: #windowMenu! !!ScreenController methodsFor: 'nested menus' stamp: 'jm 5/31/2003 19:08'!projectScreenMenu	"Answer the project screen menu."	^ SelectionMenu labelList: #(			'previous project'			'jump to project...'			'restore display'			'open...'			'windows...'			'changes...'			'help...'			'appearance...'			'save'			'save as...'			'save and quit'			'quit')		lines: #(2 3 8)		selections: #(returnToPreviousProject jumpToProjectrestoreDisplaypresentOpenMenu presentWindowMenu presentChangesMenu presentHelpMenu presentAppearanceMenusnapshot saveAs snapshotAndQuit quit).! !!ScreenController methodsFor: 'nested menus' stamp: 'jm 5/31/2003 16:01'!windowMenu	"Answer a menu for windows-related items."	"ScreenController new windowMenu startUp"	^ SelectionMenu		labelList: #(			'find window...'			'find changed browsers...'			'find changed windows...'			'collapse all windows'			'expand all windows'			'close unchanged windows'), 			(Array				with: self bitCachingString				with: self staggerPolicyString)		lines: #(3 6)		selections: #(findWindow chooseDirtyBrowser chooseDirtyWindowcollapseAll expandAll closeUnchangedWindowsfastWindows changeWindowPolicy)! !I am the superclass of all viewable and scriptable Scratch morphs.Viewable morphs allow viewing of their variables and command blocks.Scriptable morphs are viewable plus:  1. They allow the user to add new scripts.  2. They allow the user to add user-defined variables.  3. When they are copied, their scripts and variables are copied,     so script changes to the original and the copy are entirely independent.  4. They can be exported and shared.The message "isScriptable" can used to tell the difference between scritable and non-scriptable Scratch morphs.Note: The 'scripts' instance variable is not yet being used. Soon!!!!ScriptableScratchMorph methodsFor: 'initialization' stamp: 'jm 9/25/2003 12:30'!initialize	super initialize.	objName _ self class nextInstanceName.	vars _ Dictionary new.	blocksBin _ ScratchScriptsMorph new.! !!ScriptableScratchMorph methodsFor: 'accessing' stamp: 'jm 11/21/2003 19:11'!asPathRelativeToProject: fullFilePath	"Convert the given absolute path name to a path relative to the my project directory."	| myFrame |	(myFrame _ self ownerThatIsA: ScratchFrameMorph)		ifNotNil: [^ myFrame projectDirectory fullToRelativePath: fullFilePath]		ifNil: [^ FileDirectory default fullToRelativePath: fullFilePath]! !!ScriptableScratchMorph methodsFor: 'accessing' stamp: 'jm 12/10/2003 18:06'!blockReceiver	"Answer the object that is the receiver of my blocks. By default that is myself, but subclasses may re-direct block operations to another object."	^ self! !!ScriptableScratchMorph methodsFor: 'accessing' stamp: 'jm 9/25/2003 12:45'!blocksBin	^ blocksBin! !!ScriptableScratchMorph methodsFor: 'accessing' stamp: 'jm 10/2/2003 11:34'!layer	owner ifNil: [^ 1].	^ owner submorphs indexOf: self! !!ScriptableScratchMorph methodsFor: 'accessing' stamp: 'jm 10/2/2003 11:42'!layer: aNumber	| n submorphsMinusMe newSubmorphs |	owner ifNil: [^ 1].	n _ (aNumber rounded max: 1) min: owner submorphCount.	submorphsMinusMe _ owner submorphs copyWithout: self.	newSubmorphs _		(submorphsMinusMe copyFrom: 1 to: (n - 1 min: submorphsMinusMe size)),		(Array with: self),		(submorphsMinusMe copyFrom: n to: submorphsMinusMe size).	owner privateSubmorphs: newSubmorphs.	self changed.! !!ScriptableScratchMorph methodsFor: 'accessing' stamp: 'jm 8/23/2003 12:48'!maxFor: aVariable	| varRec |	varRec _ self class varSpecs		detect: [:v | v first = aVariable]		ifNone: [^ 100].	^ varRec at: 3! !!ScriptableScratchMorph methodsFor: 'accessing' stamp: 'jm 8/23/2003 12:49'!minFor: aVariable	| varRec |	varRec _ self class varSpecs		detect: [:v | v first = aVariable]		ifNone: [^ 0].	^ varRec at: 2! !!ScriptableScratchMorph methodsFor: 'accessing' stamp: 'jm 3/15/2003 19:27'!objName	^ objName! !!ScriptableScratchMorph methodsFor: 'accessing' stamp: 'jm 6/22/2003 22:21'!objName: aString	objName _ aString.! !!ScriptableScratchMorph methodsFor: 'accessing' stamp: 'jm 8/17/2003 11:20'!randomFrom: min to: max	RandomGen ifNil: [RandomGen _ Random new].	^ (RandomGen next * (max - min)) + min! !!ScriptableScratchMorph methodsFor: 'accessing' stamp: 'jm 11/13/2003 12:30'!referencePosition	^ bounds center - Origin! !!ScriptableScratchMorph methodsFor: 'accessing' stamp: 'jm 11/13/2003 12:30'!referencePosition: aPoint	self position: Origin + aPoint - (bounds extent // 2).! !!ScriptableScratchMorph methodsFor: 'accessing' stamp: 'jm 9/25/2003 12:56'!x	^ self referencePosition x! !!ScriptableScratchMorph methodsFor: 'accessing' stamp: 'jm 9/25/2003 12:57'!x: newX	self referencePosition: newX@self y.! !!ScriptableScratchMorph methodsFor: 'accessing' stamp: 'jm 9/25/2003 12:56'!y	^ self referencePosition y! !!ScriptableScratchMorph methodsFor: 'accessing' stamp: 'jm 9/25/2003 12:57'!y: newY	self referencePosition: self x@newY.! !!ScriptableScratchMorph methodsFor: 'queries' stamp: 'jm 3/2/2003 12:14'!isScriptable	"I am a scriptable Scratch object."	^ true! !!ScriptableScratchMorph methodsFor: 'dropping/grabbing' stamp: 'jm 8/3/2003 10:17'!justDroppedInto: aMorph event: evt	"If I'm dropped anywhere on a ScratchFrameMorph, reject the drop unless it is on the work pane. For developers, accept drops onto the World completely outside any ScratchFrameMorph. If the drop succeeds, record my pen state."	| f |	aMorph = World ifTrue: [  "accepts drops into the world only when not over a ScratchFrameMorph"		World submorphs do: [:m |			((m isKindOf: ScratchFrameMorph) and:			 [m bounds intersects: self bounds]) ifTrue: [				^ self rejectDropEvent: evt]]].	(f _ aMorph ownerThatIsA: ScratchFrameMorph) ifNotNil: [  "only allow drops onto the work pane or a thumbnail"		((aMorph = f workPane) or:		 [aMorph isKindOf: ScratchThumbnailMorph]) ifFalse: [			^ self rejectDropEvent: evt]].	self penDown ifTrue: [self penDown: false; penDown: true].! !!ScriptableScratchMorph methodsFor: 'dropping/grabbing' stamp: 'jm 8/3/2003 13:21'!rejectDropEvent: evt	"Reject being dropped by the given event."	evt hand rejectDropMorph: self event: evt.! !!ScriptableScratchMorph methodsFor: 'event handling' stamp: 'jm 9/25/2003 12:26'!click: evt	"Start or stop all my clickable scripts."	| clickableScripts |	clickableScripts _ self scripts select: [:s | s isClickable].	(clickableScripts anySatisfy: [:s | s isRunning])		ifTrue:	[  "if any clickable scripts were running, this click means stop all"			clickableScripts do: [:s | s stop]]		ifFalse:	[  "start all clickable scripts"			clickableScripts do: [:s | s start]].! !!ScriptableScratchMorph methodsFor: 'event handling' stamp: 'jm 7/19/2003 15:49'!doubleClick: evt	"Show my viewer and script editor."	self viewBlocksAndScripts.! !!ScriptableScratchMorph methodsFor: 'event handling' stamp: 'jm 7/16/2003 19:43'!handlesMouseDown: evt	^ true! !!ScriptableScratchMorph methodsFor: 'event handling' stamp: 'jm 8/19/2003 13:31'!mouseDown: evt	"Handle a mouse click. Left button either drags or performs click action. Right button brings up a menu."	evt yellowButtonPressed		ifTrue: [Sensor waitNoButton. self rightButtonMenu]		ifFalse:	[evt hand waitForClicksOrDrag: self event: evt].! !!ScriptableScratchMorph methodsFor: 'event handling' stamp: 'jm 8/3/2003 23:42'!startDrag: evt	"This is a drag gesture; pick me up."	| rootForGrab |	rootForGrab _ owner rootForGrabOf: self.	rootForGrab ifNil: [^ self].	rootForGrab position: evt hand position + (self topLeft - evt cursorPoint).	evt hand grabMorph: rootForGrab.! !!ScriptableScratchMorph methodsFor: 'right button menu' stamp: 'jm 8/3/2003 21:47'!duplicate	self world activeHand attachMorph: self fullCopy.! !!ScriptableScratchMorph methodsFor: 'right button menu' stamp: 'jm 7/8/2003 01:27'!findViewer: viewerClass	"Answer a blocks or script viewer of the given class."	| frame |	"first look for a viewer at the top level"	self world submorphsDo: [:m |		(m isKindOf: viewerClass) ifTrue: [^ m]].	"then look for a viewer as a submorph of a ScratchFrameMorph"	frame _ self world		submorphs detect: [:m | m isKindOf: ScratchFrameMorph]		ifNone: [^ nil].	frame submorphsDo: [:m |		(m isKindOf: viewerClass) ifTrue: [^ m]].	"if all else fails, make one"	^ viewerClass new openInWorld! !!ScriptableScratchMorph methodsFor: 'right button menu' stamp: 'jm 11/13/2003 20:44'!projectDirectory	"Answer the directory containing this Scratch project or the default directory."	| frame |	(frame _ self ownerThatIsA: ScratchFrameMorph) ifNil: [^ FileDirectory default].	^ frame projectDirectory! !!ScriptableScratchMorph methodsFor: 'right button menu' stamp: 'jm 11/18/2003 18:33'!rightButtonMenu	"Present the right button menu."	| menu |	menu _ CustomMenu new.	menu add: 'view blocks' action: #viewBlocks.	self isScriptable ifTrue: [menu add: 'view scripts' action: #viewScripts].	menu addLine.	menu add: 'copy' action: #duplicate.	menu add: 'delete' action: #delete.	menu addLine.	(self isKindOf: ImageBoxMorph) ifTrue: [		menu add: 'load from file' action: #readFromFile].	(self isKindOf: SpriteMorph) ifTrue: [		menu add: 'edit image' action: #editDrawing.		menu add: 'load from file' action: #readFromFile.		menu add: 'grab from screen' action: #grabFromScreen.		menu addLine.		menu add: 'set rotation center' action: #setRotationCenter.		menu add: 'set rotation style' action: #setRotationStyle].	(self isKindOf: SoundMorph) ifTrue: [		menu add: 'edit sound' action: #editSound.		menu add: 'load from file' action: #readFromFile.		menu add: 'record sound' action: #recordSound].	menu addLine.	menu invokeOn: self.! !!ScriptableScratchMorph methodsFor: 'right button menu' stamp: 'jm 10/19/2003 08:15'!viewBlocks	| viewer |	viewer _ self findViewer: ScratchViewerMorph.	viewer target: self.	self zoomRectFrom: self bounds to: viewer bounds.! !!ScriptableScratchMorph methodsFor: 'right button menu' stamp: 'jm 10/19/2003 08:07'!viewBlocksAndScripts	| editor viewer |	self isScriptable ifFalse: [^ self viewBlocks].	editor _ self findViewer: ScratchScriptEditorMorph.	viewer _ self findViewer: ScratchViewerMorph.	editor target: self.	viewer target: self.	self		zoomRectFrom: self bounds		to: (editor bounds merge: viewer bounds).! !!ScriptableScratchMorph methodsFor: 'right button menu' stamp: 'jm 10/19/2003 08:13'!viewScripts	| editor |	editor _ self findViewer: ScratchScriptEditorMorph.	editor target: self.	self zoomRectFrom: self bounds to: editor bounds.! !!ScriptableScratchMorph methodsFor: 'right button menu' stamp: 'jm 10/19/2003 08:17'!zoomRectFrom: startRect to: finalRect	| steps r p1 p2 |	steps _ 10.	r _ startRect.	Display border: r width: 2 rule: Form reverse fillColor: Color gray.	0 to: steps do: [:i |		Delay waitMSecs: 35.		Display border: r width: 2 rule: Form reverse fillColor: Color gray.		p1 _ startRect origin + ((i * (finalRect origin - startRect origin)) // steps).		p2 _ startRect corner + ((i * (finalRect corner - startRect corner)) // steps).		r _ p1 corner: p2.		Display border: r width: 2 rule: Form reverse fillColor: Color gray].	Delay waitMSecs: 35.	Display border: r width: 2 rule: Form reverse fillColor: Color gray.! !!ScriptableScratchMorph methodsFor: 'variables' stamp: 'TIS 7/11/2003 08:48'!addVariable: varName	"Add a new user variable with the given name to this object. Do nothing if the variable already exists or is built in."	"do nothing if varName is built in"	(self builtinVars includes: varName asSymbol) ifTrue: [^ self].	(vars includesKey: varName asString) ifFalse: [		vars at: varName asString put: 0].! !!ScriptableScratchMorph methodsFor: 'variables' stamp: 'jm 8/23/2003 12:48'!builtinVars	"Answer a list of built-in variable names."	^ self class varSpecs collect: [:v | v first]! !!ScriptableScratchMorph methodsFor: 'variables' stamp: 'jm 2/6/2003 16:42'!deleteVariable: varName	"Delete the variable with the given name. Do nothing if the varible doesn't exist or if it is built-in."	vars removeKey: varName asString ifAbsent: [].! !!ScriptableScratchMorph methodsFor: 'variables' stamp: 'jm 3/20/2003 15:12'!getUserVar: varName	"Answer the value of the given user variable of this object, or nil if the variable has been deleted."	^ vars at: varName asString ifAbsent: [nil]! !!ScriptableScratchMorph methodsFor: 'variables' stamp: 'TIS 7/11/2003 08:48'!set: varName to: anObject	"This method is called from a set:to: block."	| selector |	(self builtinVars includes: varName)		ifTrue: [			selector _ (varName, ':') asSymbol.			(self perform: selector with: anObject)]		ifFalse: [			selector _ #setUserVar:to:.			(self perform: selector with: varName with: anObject)].! !!ScriptableScratchMorph methodsFor: 'variables' stamp: 'jm 9/13/2003 21:15'!setUserVar: varName to: newValue	"Set the value of the given user variable of this object to the given value."	(vars includesKey: varName asString) ifFalse: [^ self].  "can happen when variable is deleted"	vars at: varName asString put: newValue.! !!ScriptableScratchMorph methodsFor: 'variables' stamp: 'jm 3/3/2003 11:05'!userVars	"Answer a list of user user variable names."	^ vars keys asArray sort! !!ScriptableScratchMorph methodsFor: 'scripts' stamp: 'jm 9/25/2003 12:26'!hasScriptNamed: aString	"I return true only if I have a script with the same name as the given string."	^ (self scripts collect: [:s | s scriptName]) includes: aString! !!ScriptableScratchMorph methodsFor: 'scripts' stamp: 'jm 11/18/2003 16:21'!scriptBlocks	"I return a collection of MethodCallBlockMorph for invoking my scripts sorted by name."	| sortedScripts |	self isScriptable ifFalse: [^ #()].	sortedScripts _ self scripts asArray sort: [:s1 :s2 | s1 scriptName < s2 scriptName].	^ sortedScripts collect: [:s |		MethodCallBlockMorph new script: s; receiver: self]! !!ScriptableScratchMorph methodsFor: 'scripts' stamp: 'jm 9/25/2003 12:47'!scripts	"Answer my scripts, a collection of HatBlockMorphs."	^ blocksBin submorphs select: [:m | m isKindOf: HatBlockMorph]! !!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'jm 11/18/2003 18:31'!blockCategoriesFor: aSymbol	"Answer the block categories for my object-specific, type-specific, or generic blocks, depending on the given symbol."	#object = aSymbol ifTrue: [		self isScriptable ifFalse: [^ #()].		self scripts size > 0			ifTrue: [^ #('scripts' 'variables')]			ifFalse: [^ #('variables')]].	#type = aSymbol ifTrue: [		^ (self class classBlockSpecs select: [:el | el isKindOf: String]) asArray sort].	"generic"	^ (self class genericBlockSpecs select: [:el | el isKindOf: String]) asArray sort! !!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'jm 12/10/2003 18:06'!blockFromSpec: spec	"Create a block from the given block specification. Answer nil if I don't implement the block spec selector."	| blockLabelSpec blockType selector block |	blockLabelSpec _ spec at: 1.	blockType _ spec at: 2.	selector _ (spec at: 3) asSymbol.	((blockType includes: $s) or:	 [selector isInfix or:	 [self blockReceiver respondsTo: selector]]) ifFalse: [^ nil].	"basic block type: normal or C-shaped"	(blockType includes: $c)		ifTrue:	[block _ CBlockMorph new]		ifFalse:	[block _ CommandBlockMorph new].	block isReporter: (blockType includes: $r).	block isSpecialForm: (blockType includes: $s).	block isTimed: (blockType includes: $t).	(blockType includes: $u) ifFalse: [  "wants owner name"		block wantsName: true.		block isReporter ifTrue: [block wantsPossession: true]].	^ block		commandSpec: blockLabelSpec;		selector: selector;		receiver: self! !!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'jm 11/18/2003 17:45'!blocksFor: aCategory	| allSpecs blocksList category b |	aCategory = 'scripts' ifTrue: [^ self scriptBlocks].	allSpecs _ self class classBlockSpecs, self class genericBlockSpecs.	blocksList _ OrderedCollection new.	category _ nil.	allSpecs do: [:spec |		(spec isKindOf: String)			ifTrue: [category _ spec]			ifFalse: [				category = aCategory ifTrue: [					(b _ self blockFromSpec: spec) ifNotNil: [						blocksList addLast: b]]]].	^ blocksList asArray! !!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'jm 12/11/2003 19:07'!makeSetterFor: aVar	"Create a block for the form 'set x to...' to set the value of the given variable."	| varSetter |	varSetter _ SetterBlockMorph new		variable: aVar;		receiver: self blockReceiver.	self activeHand attachMorph: varSetter.	self world startSteppingSubmorphsOf: varSetter.! !!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'jm 12/11/2003 19:10'!variablesPage	"Answer a morph containing my variables."	| bin y w setter setButton b |	bin _ PasteUpMorph new		color: (Color gray: 0.9);		borderWidth: 0;		isPartsBin: true;		enableDragNDrop: false.	setButton _ SimpleButtonMorph new		label: 'set';		actWhen: #buttonUp;		target: self blockReceiver;		actionSelector: #makeSetterFor:.	y _ 4.	"built in variables"	self builtinVars do: [:varName |		b _ setButton fullCopy			arguments: (Array with: varName);			position: 5@(y + 4).		w _ WatcherMorph new target: self blockReceiver getSelector: varName.		setter _ (varName, ':') asSymbol.		(self blockReceiver respondsTo: setter) ifTrue: [			bin addMorphBack: b.			w putSelector: setter].		w position: 34@y.		bin addMorphBack: w.		y _ y + w height + 2].	"user variables"	self userVars do: [:varName |		b _ setButton fullCopy			arguments: (Array with: varName);			position: 5@(y + 4).		bin addMorphBack: b.		w _ WatcherMorph new			target: self blockReceiver getSelector: #getUserVar: varName: varName;			putSelector: #setUserVar:to:.		w position: 34@y.		bin addMorphBack: w.		y _ y + w height + 2].	^ bin! !!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'jm 11/18/2003 17:14'!viewerPageForCategory: aCategoryName	"Answer a morph containing blocks for the given category for use in the given ScratchViewer."	| bin x y |	aCategoryName = 'variables' ifTrue: [^ self variablesPage].	bin _ PasteUpMorph new		color: (Color gray: 0.9);		borderWidth: 0;		isPartsBin: true;		enableDragNDrop: false.	x _ y _ 5.	(self blocksFor: aCategoryName) do: [:blockM |		blockM position: x@y.		bin addMorphBack: blockM.		y _ y + blockM height].	^ bin! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 8/23/2003 18:57'!absoluteValue: aNumber	^ aNumber abs! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 8/5/2003 17:17'!doCopy	"Makes a copy of this object and add it to the world."	| friend |	friend _ self fullCopy.	self owner addMorphFront: friend.	^ friend! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 8/23/2003 12:23'!getKey	"Answer the next keyboard input from any hand or a space if no input is available."	| w evt |	(w _ self world) ifNil: [^ ' '].	w hands do: [:h |		evt _ h nextUnclaimedKeystrokeOrNil.		evt ifNotNil: [^ evt keyCharacter asString]].	^ ' '! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 11/25/2003 14:13'!goto: endPoint duration: duration elapsed: elapsed from: startPoint	"Interpolate my position from startPoint to endPoint over the given duration. If startPoint is nil, just answer my current position; this sets the starting point for the interpolation."	| fraction |	startPoint ifNil: [^ self referencePosition].	fraction _ elapsed asFloat / (1000.0 * duration).	fraction > 1.0 ifTrue: [fraction _ 1].	fraction < 0.0 ifTrue: [fraction _ 0].	self referencePosition: startPoint + (fraction * (endPoint - startPoint)) truncated.! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 8/23/2003 12:22'!isKeyAvailable	| w |	(w _ self world) ifNil: [^ false].	w hands do: [:h | h unclaimedKeystrokeAvailable ifTrue: [^ true]].	^ false! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 8/23/2003 12:22'!mousePosition	^ Sensor cursorPoint! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 8/23/2003 12:22'!mousePressed	^ Sensor redButtonPressed! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 10/19/2003 08:22'!mouseTouching	self world ifNil: [^ false].	^ self containsPoint: self world firstHand cursorPoint! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 11/25/2003 14:07'!mouseX	^ self mousePosition x! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 11/25/2003 14:08'!mouseY	^ self mousePosition y! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 10/19/2003 09:26'!timer	| now |	now _ Time millisecondClockValue.	TimerStartMSecs ifNil: [TimerStartMSecs _ now].	TimerStartMSecs > now ifTrue: [TimerStartMSecs _ now].	^ (now - TimerStartMSecs) asFloat / 1000.0! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 10/19/2003 09:20'!timerReset	TimerStartMSecs _ Time millisecondClockValue.! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 8/22/2003 19:29'!wait: duration elapsed: elapsed from: ignored	"Do nothing; just wait for the time interval to elapse."	^ nil! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 8/22/2003 19:59'!width: endWidth height: endHeight duration: duration elapsed: elapsed from: startExtent	"Interpolate my extent from startExtent to endWidth@endHeight over the given duration. If startExtent is nil, just answer my current extent; this sets the starting point for the interpolation."	| fraction |	startExtent ifNil: [^ self extent].	fraction _ elapsed asFloat / (1000.0 * duration).	fraction > 1.0 ifTrue: [fraction _ 1].	fraction < 0.0 ifTrue: [fraction _ 0].	self extent: startExtent + (fraction * ((endWidth@endHeight) - startExtent)) truncated.! !!ScriptableScratchMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 15:37'!fieldsVersion	^ 1! !!ScriptableScratchMorph methodsFor: 'object i/o' stamp: 'jm 9/25/2003 12:49'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		objName		vars		blocksBin	) from: anObjStream.! !!ScriptableScratchMorph methodsFor: 'object i/o' stamp: 'jm 9/25/2003 12:45'!storeFieldsOn: anObjStream	| oldBlockBinOwner |	super storeFieldsOn: anObjStream.	oldBlockBinOwner _ blocksBin owner.	blocksBin delete.	self storeFieldsNamed: #(		objName		vars		blocksBin	) on: anObjStream.	oldBlockBinOwner ifNotNil: [oldBlockBinOwner addMorph: blocksBin].! !!ScriptableScratchMorph methodsFor: 'private' stamp: 'jm 9/25/2003 12:47'!copyRecordingIn: dict	"Copy my fields and scripts."	| newCopy newBlocksBin |	newCopy _ super copyRecordingIn: dict.	newBlocksBin _ blocksBin fullCopy.	newBlocksBin allMorphsDo: [:m |		(m isKindOf: CommandBlockMorph) ifTrue: [m mapReceiver: self to: newCopy]]. 	newCopy vars: vars copy blocksBin: newBlocksBin.	^ newCopy! !!ScriptableScratchMorph methodsFor: 'private' stamp: 'jm 7/20/2003 20:46'!penDown	"Answer true if my pen is down (i.e., I should leave a trail when I move). Answer false by default."	^ false! !!ScriptableScratchMorph methodsFor: 'private' stamp: 'jm 7/20/2003 20:45'!penDown: aBoolean	"Set my pen up/down state. Does nothing by default."! !!ScriptableScratchMorph methodsFor: 'private' stamp: 'jm 10/21/2003 20:04'!removeAllScripts	"For emergency cleanups!!"	blocksBin _ ScratchScriptsMorph new.! !!ScriptableScratchMorph methodsFor: 'private' stamp: 'jm 11/21/2003 18:25'!scratchFrame	"Find a ScratchFrameMorph in my current world. Create a new one with no UI if necessary."	| sFrame |	(sFrame _ self ownerThatIsA: ScratchFrameMorph) ifNotNil: [^ sFrame].	self world ifNil: [^ self error: 'Must be in a world'].	sFrame _ self world submorphs		detect: [:m | m isKindOf: ScratchFrameMorph]		ifNone: [nil].	sFrame ifNil: [  "no ScratchFrameMorph? add one!!"		sFrame _ ScratchFrameMorph newNoUI.		self world addMorphBack: sFrame.		sFrame startStepping].	^ sFrame! !!ScriptableScratchMorph methodsFor: 'private' stamp: 'jm 9/25/2003 12:46'!vars: varsDict blocksBin: aBlocksBin	"Private!! Set my name, variables, and blocks bin. Used by copyRecordingIn:."	objName _ self class nextInstanceName.	vars _ varsDict.	blocksBin _ aBlocksBin.! !!ScriptableScratchMorph class methodsFor: 'class initialization' stamp: 'jm 11/13/2003 12:27'!initialize	Origin _ 0@0.	RandomGen _ Random new.	TimerStartMSecs _ Time millisecondClockValue.! !!ScriptableScratchMorph class methodsFor: 'scratch' stamp: 'jm 11/18/2003 14:40'!classBlockSpecs	"Answer the block specs for this specific kind of object. See the comment in genericBlockSpecs."	^ #()! !!ScriptableScratchMorph class methodsFor: 'scratch' stamp: 'jm 12/1/2003 15:43'!genericBlockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector>).	Explanation of flags:		-	no flags		c	c-shaped block containing a sequence of commands		r	reporter		s	special form with own evaluation rule		t	timed command, like wait or glide		u	unnamed block (neither possessive ('s) nor ask ('name,') forms)"	^ #(		'control'			('if %b'				csu	doIf)			('forever'			csu	doForever)			('repeat %n'			csu	doRepeat)			('while %b'			csu	doWhile)			('wait until %b'		su	doWaitUntil)			('done'				su	doReturn)			('answer %n'		su	doReturn)"xxx  comment out for class			('monitor %n %n'	rsu	doMonitor)			('ask %m to'			csu	doAsk)xxx"		'math'			('%n + %n'			ru	+)			('%n - %n'			ru	-)			('%n * %n'			ru	*)			('%n / %n'			ru	/)			('abs %n'			ru	absoluteValue:)			('%n mod %n'		ru	\\)			('%n < %n'			ru	<)			('%n = %n'			ru	=)			('%n > %n'			ru	>)		'math2'			('%b and %b'		ru	&)			('%b or %b'			ru	|)			('not %b'			ru	not)			('random from %n to %n'	ru	randomFrom:to:)			('point x %n y %n'	ru	@)		'mouse/keyboard'			('mouse pressed?'	ru	mousePressed)			('mouse position'	ru	mousePosition)			('mouse x'			ru	mouseX)			('mouse y'			ru	mouseY)			('mouse touching'	ru	mouseTouching)			('key available?'	ru	isKeyAvailable)			('get key'			ru	getKey)		'other'			('timer'				ru	timer)			('timer reset'		u	timerReset)			('wait %n'			tu	wait:elapsed:from:)			('copy'				r	doCopy)			('load %s'			-	loadFile:)			('save %s'			-	saveFile:)	).! !!ScriptableScratchMorph class methodsFor: 'scratch' stamp: 'jm 8/23/2003 12:42'!varSpecs	"Answer a collection of Arrays defining the built-in variables of this object. Each variable is represented by an array of the form (varName defaultMinVal defaultMaxVal). Scripts only read and write builtin variables via messages. For example, if #x is a builtin variable, then its value is retrieved by sending the message #x to the object. If the object also defines #x:, then the variable can be set by sending #x: to it; otherwise, 'x' is considered read-only variable. Note that built-in variables need not reflect an actual instance variable of the object. For example, the 'heading' instance variable can be implemented by defining the pair of messages #heading and #heading:."	"Note: User-defined variables are handled by a different mechanism."	^ #()! !!ScriptableScratchMorph class methodsFor: 'other' stamp: 'jm 8/13/2003 17:07'!fromUser	"Go into a mode asking the user to select an instance of me, displaying a crossHair cursor while in this mode. The mode ends with the next mouse click. If the click is over an instance of me, return it. Otherwise, return nil. Keep running the world while waiting for the mouse click."	| result p m mList |	World ifNil: [^ self].  "not in morphic"	result _ nil.	Cursor crossHair showWhile: [		[Sensor anyButtonPressed] whileFalse: [World doOneCycleNoInput].		p _ Sensor cursorPoint.		m _ (World rootMorphsAt: p) first.		(m isKindOf: ScratchFrameMorph) ifTrue: [			mList _ m workPane rootMorphsAt: p.			mList size > 0 ifTrue: [				m _ (m workPane rootMorphsAt: p) first]].		(m isKindOf: self) ifTrue: [result _ m].		Sensor waitNoButton].	^ result! !!ScriptableScratchMorph class methodsFor: 'other' stamp: 'jm 6/22/2003 21:31'!nextInstanceName	"Answer the name for a new object of my class. This name is created by appending a number to the class name. The instance count for the class is incremented each time this method is called so that successive calls give sequential names such as 'sprite1', 'sprite2', etc."	"Note: InstanceCounts is a dictionary that maps class names to the number of instance of that class created. This number is used to create a unique name for new objects. Create this dictionary if necessary."	| myClassName lastNum instanceNum instName |	InstanceCounts ifNil: [InstanceCounts _ Dictionary new].	myClassName _ self name.	lastNum _ InstanceCounts at: myClassName ifAbsent: [0].	instanceNum _ lastNum + 1.	InstanceCounts at: myClassName put: instanceNum.	(myClassName endsWith: 'Morph')		ifTrue: [instName _ myClassName copyFrom: 1 to: myClassName size - 'Morph' size]		ifFalse: [instName _ myClassName].	^ instName asLowercase, instanceNum asString! !!ScriptableScratchMorph class methodsFor: 'other' stamp: 'jm 11/13/2003 12:28'!origin	"Answer the origin for the Scratch coordinate system."	^ Origin! !!ScriptableScratchMorph class methodsFor: 'other' stamp: 'jm 11/13/2003 12:29'!origin: aPoint	"Set the origin for the Scratch coordinate system."	Origin _ aPoint.! !!ScriptableScratchMorph class methodsFor: 'other' stamp: 'jm 8/25/2003 01:18'!resetInstanceCounts	"Clear my InstanceCounts dictionary."	InstanceCounts _ Dictionary new.! !Inspired by an oiginal design of Hans-Martin Mosner, this ScrollBar is intended to exercise the handling of input events in Morphic.  With sufficient flexibility in this area, all particular behavior can be concentrated in this single class with no need to specialize any other morphs to achieve button, slider and menu-button behavior.Once we have this working, put in logic for horizontal operation as well.!!ScrollBar methodsFor: 'initialize' stamp: 'jm 10/13/2002 10:47'!initialize	super initialize.	scrollDelta _ 0.02.	pageDelta _ 0.2.! !!ScrollBar methodsFor: 'initialize' stamp: 'jm 6/15/2003 10:28'!initializeDownButton	downButton _ BorderedMorph		newBounds: (self innerBounds bottomRight - self buttonExtent extent: self buttonExtent)		color: Color lightGray.	downButton addMorphCentered: (ImageMorph new form: 		(UpArrow rotateBy: (bounds isWide ifTrue: [#right] ifFalse: [#pi]) centerAt: 0@0)).	downButton setBorderWidth: 1 borderColor: #raised.	self addMorph: downButton.! !!ScrollBar methodsFor: 'initialize' stamp: 'jm 6/15/2003 10:41'!initializeMenuButton	"Preferences disable: #scrollBarsWithoutMenuButton"	"Preferences enable: #scrollBarsWithoutMenuButton"	hasMenuButton ifNil: [		hasMenuButton _ (Preferences valueOfFlag: #scrollBarsWithoutMenuButton) not].	hasMenuButton ifFalse: [^ self].	menuButton _ BorderedMorph		newBounds: (self innerBounds topLeft extent: self buttonExtent)		color: Color lightGray.	menuButton addMorphCentered:		(BorderedMorph newBounds: (0@0 extent: 4@2) color: Color black).	menuButton setBorderWidth: 1 borderColor: #raised.	self addMorph: menuButton.! !!ScrollBar methodsFor: 'initialize' stamp: 'jm 6/15/2003 10:29'!initializePagingArea	pagingArea _ BorderedMorph		newBounds: self totalSliderArea		color: (Color r: 0.6 g: 0.6 b: 0.8).	pagingArea borderWidth: 0.	self addMorph: pagingArea.! !!ScrollBar methodsFor: 'initialize' stamp: 'jm 10/13/2002 11:16'!initializeSlider	"Note: we must initialize all the parts before initializing the slider itself."	self initializeMenuButton; initializeUpButton; initializeDownButton; initializePagingArea.	super initializeSlider.! !!ScrollBar methodsFor: 'initialize' stamp: 'jm 6/15/2003 10:29'!initializeUpButton	| where |	where _ menuButton		ifNil: [self innerBounds topLeft]		ifNotNil: [			bounds isWide				ifTrue: [menuButton bounds topRight]				ifFalse: [menuButton bounds bottomLeft]].	upButton _ BorderedMorph		newBounds: (where extent: self buttonExtent)		color: Color lightGray.	upButton addMorphCentered: (ImageMorph new form: 		(bounds isWide ifTrue: [UpArrow rotateBy: #left centerAt: 0@0] ifFalse: [UpArrow])).	upButton setBorderWidth: 1 borderColor: #raised.	self addMorph: upButton.! !!ScrollBar methodsFor: 'access' stamp: 'jm 2/4/2003 11:49'!hasMenuButton: aBoolean	hasMenuButton _ aBoolean.	hasMenuButton ifFalse: [menuButton _ nil].	self removeAllMorphs; initializeSlider.! !!ScrollBar methodsFor: 'access' stamp: 'dew 2/21/1999 03:08'!interval: d	"Supply an optional floating fraction so slider can expand to indicate range"	interval _ d min: 1.0.	self expandSlider.	self computeSlider.! !!ScrollBar methodsFor: 'access' stamp: 'dew 2/15/1999 18:25'!pagingArea	^pagingArea! !!ScrollBar methodsFor: 'geometry' stamp: 'dew 6/9/1999 02:02'!buttonExtent	^ bounds isWide		ifTrue: [11 @ self innerBounds height]		ifFalse: [self innerBounds width @ 11]! !!ScrollBar methodsFor: 'geometry' stamp: 'dew 2/27/1999 18:22'!expandSlider	"Compute the new size of the slider (use the old sliderThickness as a minimum)."	| r |	r _ self totalSliderArea.	slider extent: (bounds isWide		ifTrue: [((r width * interval) asInteger max: self sliderThickness) @ slider height]		ifFalse: [slider width @ ((r height * interval) asInteger max: self sliderThickness)])! !!ScrollBar methodsFor: 'geometry' stamp: 'dew 7/22/1999 19:03'!extent: p        p x > p y                ifTrue: [super extent: (p max: 42@8)]                ifFalse: [super extent: (p max: 8@42)]! !!ScrollBar methodsFor: 'geometry' stamp: 'dew 2/21/1999 03:08'!sliderExtent	"The sliderExtent is now stored in the slider itself, not hardcoded as it is in the superclass."	^slider extent! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/17/1998 09:39'!scrollByPage: event	nextPageDirection == nil ifTrue:		[nextPageDirection _ event cursorPoint y >= slider center y].	(self waitForDelay1: 300 delay2: 100) ifFalse: [^ self].	nextPageDirection		ifTrue: [self setValue: (value + pageDelta min: 1.0)]		ifFalse: [self setValue: (value - pageDelta max: 0.0)]! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/17/1998 09:40'!scrollDown	(self waitForDelay1: 300 delay2: 50) ifFalse: [^ self].	self setValue: (value + scrollDelta + 0.000001 min: 1.0)! !!ScrollBar methodsFor: 'scrolling' stamp: 'jm 10/13/2002 11:01'!scrollDown: count	"Used to scroll down by the given number of scrollDeltas in response to arrow keys. A negative count scrolls up."	self setValue: ((value + (count * scrollDelta) + 0.000001 min: 1.0) max: 0.0).! !!ScrollBar methodsFor: 'scrolling' stamp: 'di 8/17/1998 09:40'!scrollUp	(self waitForDelay1: 300 delay2: 50) ifFalse: [^ self].	self setValue: (value - scrollDelta - 0.000001 max: 0.0)! !!ScrollBar methodsFor: 'scrolling' stamp: 'dew 2/21/1999 03:08'!setValue: newValue	"Using roundTo: instead of truncateTo: ensures that scrollUp will scroll the same distance as scrollDown."	^ super setValue: (newValue roundTo: scrollDelta)! !!ScrollBar methodsFor: 'event handling' stamp: 'jm 10/13/2002 10:21'!handlesMouseDown: evt	^ true! !!ScrollBar methodsFor: 'event handling' stamp: 'jm 10/13/2002 11:14'!mouseDown: evt	| p |	p _ evt cursorPoint.	dragOffset _ slider position - p.	mouseTarget _ nil.	(slider containsPoint: p) ifTrue: [^ self mouseDownInSlider: evt].	(upButton containsPoint: p) ifTrue: [^ self mouseDownInUpButton: evt].	(downButton containsPoint: p) ifTrue: [^ self mouseDownInDownButton: evt].	(pagingArea containsPoint: p) ifTrue: [^ self mouseDownInPagingArea: evt].	(menuButton notNil and: [menuButton containsPoint: p]) ifTrue: [		^ self mouseDownInMenu: evt].! !!ScrollBar methodsFor: 'event handling' stamp: 'jm 10/13/2002 10:52'!mouseDownInDownButton: evt	mouseTarget _ downButton.	downButton borderInset.	self resetTimer.! !!ScrollBar methodsFor: 'event handling' stamp: 'jm 10/13/2002 10:33'!mouseDownInMenu: evt	"Send yellowButtonActivity: to my model, if I have one." 	model ifNil: [^ self].	model yellowButtonActivity: evt shiftPressed.! !!ScrollBar methodsFor: 'event handling' stamp: 'jm 10/13/2002 11:10'!mouseDownInPagingArea: evt	mouseTarget _ pagingArea.	self resetTimer.! !!ScrollBar methodsFor: 'event handling' stamp: 'jm 10/13/2002 10:48'!mouseDownInSlider: evt	mouseTarget _ slider.	super mouseDown: evt.! !!ScrollBar methodsFor: 'event handling' stamp: 'jm 10/13/2002 10:53'!mouseDownInUpButton: evt	mouseTarget _ upButton.	upButton borderInset.	self resetTimer.! !!ScrollBar methodsFor: 'event handling' stamp: 'jm 10/13/2002 11:11'!mouseMove: evt	mouseTarget == slider ifTrue: [^ super mouseMove: evt].	mouseTarget == upButton ifTrue: [^ self scrollUp].	mouseTarget == downButton ifTrue: [^ self scrollDown].	mouseTarget == pagingArea ifTrue: [^ self scrollByPage: evt].! !!ScrollBar methodsFor: 'event handling' stamp: 'jm 10/13/2002 10:51'!mouseUp: evt	mouseTarget == slider ifTrue: [^ super mouseUp: evt].	mouseTarget == upButton ifTrue: [^ upButton borderRaised].	mouseTarget == downButton ifTrue: [^ downButton borderRaised].! !!ScrollBar methodsFor: 'scroll timing' stamp: 'di 8/17/1998 09:22'!resetTimer	timeOfMouseDown _ Time millisecondClockValue.	timeOfLastScroll _ timeOfMouseDown - 1000 max: 0.	nextPageDirection _ nil.	currentScrollDelay _ nil! !!ScrollBar methodsFor: 'scroll timing' stamp: 'di 8/17/1998 09:38'!waitForDelay1: delay1 delay2: delay2	"Return true if an appropriate delay has passed since the last scroll operation.	The delay decreases exponentially from delay1 to delay2."	| now scrollDelay |	timeOfLastScroll == nil ifTrue: [self resetTimer]. "Only needed for old instances"	now _ Time millisecondClockValue.	now < timeOfLastScroll ifTrue: [self resetTimer  "rare clock rollover"].	(scrollDelay _ currentScrollDelay) == nil ifTrue: [scrollDelay _ delay1  "initial delay"].	now > (timeOfLastScroll + scrollDelay) ifFalse: [^ false  "not time yet"].	currentScrollDelay _ scrollDelay*9//10 max: delay2.  "decrease the delay"	timeOfLastScroll _ now.	^ true! !I represent control for scrolling using a scrollBar. I am a MouseMenuController that creates a scrollBar, rather than menus. My subclasses add the button menus. I keep control as long as the cursor is inside the view or the scrollBar area.	A scrollBar is a rectangular area representing the length of the information being viewed. It contains an inner rectangle whose top y-coordinate represents the relative position of the information visible on the screen with respect to all of the information, and whose size represents the relative amount of that information visible on the screen. The user controls which part of the information is visible by pressing the red button. If the cursor is to the right of the inner rectangle, the window onto the visible information moves upward, if the cursor is to the left, the window moves downward, and if the cursor is inside, the inner rectangle is grabbed and moved to a desired position.!!ScrollController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:17'!controlActivity	self scrollByKeyboard ifTrue: [^ self].	self scrollBarContainsCursor		ifTrue: [self scroll]		ifFalse: [self normalActivity]! !!ScrollController methodsFor: 'control defaults' stamp: 'ar 3/24/2000 00:45'!isControlActive 	super isControlActive ifTrue: [^ true].	sensor blueButtonPressed ifTrue: [^ false].	^ (scrollBar inside merge: view insetDisplayBox) containsPoint: sensor cursorPoint! !!ScrollController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:31'!isControlWanted	^ self viewHasCursor! !!ScrollController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:16'!normalActivity	super controlActivity! !!ScrollController methodsFor: 'scrolling' stamp: 'ls 7/11/1998 06:33'!scroll	"Check to see whether the user wishes to jump, scroll up, or scroll down."	| savedCursor |	savedCursor _ sensor currentCursor.			[self scrollBarContainsCursor]				whileTrue: 					[self interActivityPause.					sensor cursorPoint x <= self downLine								ifTrue: [self scrollDown]								ifFalse: [sensor cursorPoint x <= self upLine										ifTrue: [self scrollAbsolute]										ifFalse: [sensor cursorPoint x <= self yellowLine												ifTrue: [self scrollUp]												ifFalse: [sensor cursorPoint x <= scrollBar right														ifTrue: "Might not be, with touch pen"														[self changeCursor: Cursor menu.														sensor anyButtonPressed 														ifTrue: [self changeCursor: savedCursor. 																self anyButtonActivity]]]]]].	savedCursor show! !!ScrollController methodsFor: 'scrolling' stamp: 'th 12/11/1999 16:57'!scrollByKeyboard	| keyEvent |	keyEvent _ sensor keyboardPeek.	keyEvent ifNil: [^ false].	(sensor controlKeyPressed or:[sensor commandKeyPressed]) ifFalse: [^ false].	keyEvent asciiValue = 30		ifTrue: 			[sensor keyboard.			self scrollViewDown ifTrue: [self moveMarker].			^ true].	keyEvent asciiValue = 31		ifTrue: 			[sensor keyboard.			self scrollViewUp ifTrue: [self moveMarker].			^ true].	^ false! !!ScrollFrameMorph methodsFor: 'initialization' stamp: 'jm 8/2/2003 16:12'!initialize	super initialize.	self color: Color gray.	scrollBarThickness _ 12.	contentsChanged _ false.	contents _ PasteUpMorph new		color: (Color gray: 0.9);		borderWidth: 0;		enableDragNDrop: true.	hScrollbar _ ScrollBar new		model: self;		setValueSelector: #hScrollRelative:;		hasMenuButton: false.	vScrollbar _ ScrollBar new		model: self;		setValueSelector: #vScrollRelative:;		hasMenuButton: false.	cornerMorph _ BorderedMorph new		borderRaised; borderWidth: 2; color: hScrollbar color.	contents position: self position + borderWidth.	self addMorph: contents.	self addMorph: hScrollbar.	self addMorph: vScrollbar.	self addMorph: cornerMorph.	self extent: 160@120.! !!ScrollFrameMorph methodsFor: 'accessing' stamp: 'jm 8/2/2003 14:34'!contents	"Answer my contents morph."	^ contents! !!ScrollFrameMorph methodsFor: 'accessing' stamp: 'jm 8/3/2003 10:48'!contents: aMorph	"Replace my contents morph. The argument can be any morph. Typically it is a BorderedMorph or a PasteUpMorph."	contents ifNotNil: [contents delete].	contents _ aMorph.	contents position: self topLeft + borderWidth.	self addMorphBack: contents.	self extent: self extent.! !!ScrollFrameMorph methodsFor: 'scrolling' stamp: 'jm 9/9/2003 10:52'!hScrollPixels	"Answer the current horizontal scroll offset in pixels."	^ (self left + borderWidth) - contents left! !!ScrollFrameMorph methodsFor: 'scrolling' stamp: 'jm 9/10/2003 11:58'!hScrollPixels: hOffset	"Scroll to the given horizontal offset in pixels. Zero is scrolled to the left and increasing values scroll right."	| delta maxOffset |	delta _ (hOffset asInteger min: self maxScroll x) max: 0.	contents left: ((self left + borderWidth) - delta) truncated.	maxOffset _ self maxScroll x.	maxOffset > 0 ifTrue: [hScrollbar value: self hScrollPixels / maxOffset].! !!ScrollFrameMorph methodsFor: 'scrolling' stamp: 'jm 8/2/2003 20:25'!hScrollRelative: aFloat	"Sent by the horizontal scrollbar. Scroll to the given relative postion between 0.0 and 1.0."	self hScrollPixels: aFloat * self maxScroll x.! !!ScrollFrameMorph methodsFor: 'scrolling' stamp: 'jm 8/2/2003 20:25'!maxScroll	"Answer a point representing the maximum horizontal and vertical scroll offsets in pixels."	^ contents extent - self visibleExtent! !!ScrollFrameMorph methodsFor: 'scrolling' stamp: 'jm 9/9/2003 10:52'!vScrollPixels	"Answer the current vertical scroll offset in pixels."	^ (self top + borderWidth) - contents top! !!ScrollFrameMorph methodsFor: 'scrolling' stamp: 'jm 9/10/2003 11:58'!vScrollPixels: vOffset	"Scroll to the given vertical offset in pixels. Zero is scrolled to the top and increasing values scroll down."	| delta maxOffset |	delta _ (vOffset asInteger min: self maxScroll y) max: 0.	contents top: ((self top + borderWidth) - delta) truncated.	maxOffset _ self maxScroll y.	maxOffset > 0 ifTrue: [vScrollbar value: self vScrollPixels / maxOffset].! !!ScrollFrameMorph methodsFor: 'scrolling' stamp: 'jm 8/2/2003 15:25'!vScrollRelative: aFloat	"Sent by the vertical scrollbar. Scroll to the given relative postion between 0.0 and 1.0."	self vScrollPixels: aFloat * self maxScroll y.! !!ScrollFrameMorph methodsFor: 'scrollbar visibility' stamp: 'jm 8/2/2003 14:52'!showHorizontalScrollbar: aBoolean	"Show or hide my horizontal scrollbar."	aBoolean		ifTrue: [			self addMorph: hScrollbar.			vScrollbar owner = self ifTrue: [self addMorph: cornerMorph]]		ifFalse: [			hScrollbar delete.			cornerMorph delete].	self extent: self extent.! !!ScrollFrameMorph methodsFor: 'scrollbar visibility' stamp: 'jm 8/2/2003 14:52'!showVerticalScrollbar: aBoolean	"Show or hide my vertical scrollbar."	aBoolean		ifTrue: [			self addMorph: vScrollbar.			hScrollbar owner = self ifTrue: [self addMorph: cornerMorph]]		ifFalse: [			vScrollbar delete.			cornerMorph delete].	self extent: self extent.! !!ScrollFrameMorph methodsFor: 'drawing' stamp: 'jm 8/2/2003 18:32'!drawSubmorphsOn: aCanvas	"If my contents has changed, fix it's extent and update my scrollbar ranges. Clip submorph drawing to my bounds."	contentsChanged ifTrue: [		self updateContentsExtent.		self updateScrollbars.		contentsChanged _ false].	aCanvas		clipBy: self innerBounds		during: [:clippingCanvas | super drawSubmorphsOn: clippingCanvas].! !!ScrollFrameMorph methodsFor: 'layout' stamp: 'jm 8/2/2003 14:26'!hResizing	^ #spaceFill! !!ScrollFrameMorph methodsFor: 'layout' stamp: 'jm 8/2/2003 14:24'!isAlignmentMorph	"Answer true, since I can be laid out as if I were an AlignmentMorph. I pretend to be an AlignmentMorph so that I can be resized when I'm inside another AlignmentMorph."	^ true! !!ScrollFrameMorph methodsFor: 'layout' stamp: 'jm 8/2/2003 14:22'!layoutInWidth: w height: h	"Resize myself to the given width and height. Called during when I am in an AlignmentMorph."	self extent: w@h.! !!ScrollFrameMorph methodsFor: 'layout' stamp: 'jm 7/21/2003 21:06'!minHeight	^ 45! !!ScrollFrameMorph methodsFor: 'layout' stamp: 'jm 7/21/2003 21:06'!minWidth	^ 60! !!ScrollFrameMorph methodsFor: 'layout' stamp: 'jm 8/2/2003 14:26'!vResizing	^ #spaceFill! !!ScrollFrameMorph methodsFor: 'geometry' stamp: 'jm 8/2/2003 14:52'!extent: aPoint	"After setting my size, position and size my scrollbars and grow box. Also update my contents and scrollbar ranges."	| inner w h |	super extent: (aPoint truncated max: self minWidth@self minHeight).	inner _ self innerBounds.	w _ inner width.	vScrollbar owner = self ifTrue: [w _ w - scrollBarThickness].	hScrollbar position: inner left@(inner bottom - scrollBarThickness).	hScrollbar extent: w@scrollBarThickness.	h _ inner height.	hScrollbar owner = self ifTrue: [h _ h - scrollBarThickness].	vScrollbar position: (inner right - scrollBarThickness)@inner top.	vScrollbar extent: scrollBarThickness@h.	cornerMorph position: (inner bottomRight - scrollBarThickness).	cornerMorph extent: scrollBarThickness.	self updateContentsExtent.	self updateScrollbars.! !!ScrollFrameMorph methodsFor: 'geometry' stamp: 'jm 7/24/2003 18:15'!fullBounds	"Overridden to clip submorph hit detection to my bounds."	^ bounds! !!ScrollFrameMorph methodsFor: 'geometry' stamp: 'jm 8/3/2003 09:11'!invalidRect: damageRect	"Clip damage reports to my bounds, since drawing is clipped to my bounds."	| r |	r _ damageRect intersect: self bounds.	(r width > 0 and: [r height > 0]) ifTrue: [super invalidRect: r].! !!ScrollFrameMorph methodsFor: 'geometry' stamp: 'jm 8/2/2003 14:31'!layoutChanged	"If my contents morph's layout has changed, record that fact."	super layoutChanged.	contents mayNeedLayout ifTrue: [contentsChanged _ true].! !!ScrollFrameMorph methodsFor: 'private' stamp: 'jm 8/2/2003 20:02'!contentsBounds	"Answer a rectangle that encloses the bounds of all my submorphs."	| offset r |	offset _ contents topLeft negated.	r _ 0@0 extent: 1@1.	contents submorphsDo: [:m |		r _ r quickMerge: (m fullBounds translateBy: offset) truncated].	^ r! !!ScrollFrameMorph methodsFor: 'private' stamp: 'jm 8/3/2003 09:09'!updateContentsExtent	"Make sure my content morph is large enough to both enclose all it's submorphs and to fill me. Adjust the scroll offsets if my bounds have shrunk."	| r delta |	r _ self contentsBounds.	((r left < 0) or: [r top < 0]) ifTrue: [		"contents has morphs that stick out over its top or left edge"		delta _ (r topLeft truncated min: (0@0)) negated.		contents submorphsDo: [:m | m position: m position + delta]].  "move all submorphs by delta"	contents extent: (self visibleExtent max: (r extent + 8)).	contents position: (contents position max: ((self topLeft + borderWidth) - self maxScroll)).! !!ScrollFrameMorph methodsFor: 'private' stamp: 'jm 8/2/2003 20:30'!updateScrollbars	"Update my scrollbars based on my current contents."	| visibleExtent currentScroll maxScroll |	contents ifNil: [^ self].  "not fully initialized yet"	visibleExtent _ self visibleExtent.	hScrollbar interval: (visibleExtent x asFloat / contents width).	vScrollbar interval: (visibleExtent y asFloat / contents height).	currentScroll _ (self topLeft + borderWidth) - contents position.	maxScroll _ self maxScroll.	maxScroll x > 0		ifTrue: [			hScrollbar				scrollDelta: (4 / maxScroll x) asFloat 				pageDelta: ((visibleExtent x - 40) / maxScroll x) asFloat.			hScrollbar value: currentScroll x / maxScroll x]		ifFalse: [hScrollbar value: 0].	maxScroll y > 0		ifTrue: [			vScrollbar				scrollDelta: (4 / maxScroll y) asFloat 				pageDelta: ((visibleExtent y - 40) / maxScroll y) asFloat.			vScrollbar value: currentScroll y / maxScroll y]		ifFalse: [vScrollbar value: 0].! !!ScrollFrameMorph methodsFor: 'private' stamp: 'jm 8/2/2003 15:09'!visibleExtent	"Answer the extent of my visible area. That is, the area within my borders minus the space used for scrollbars."	| visibleW visibleH |	visibleW _ self width - (2 * borderWidth).	hScrollbar owner = self ifTrue: [visibleW _ visibleW - scrollBarThickness].	visibleH _ self height - (2 * borderWidth).	vScrollbar owner = self ifTrue: [visibleH _ visibleH - scrollBarThickness].	^ visibleW@visibleH! !The scroller (a transform) of a scrollPane is driven by the scrollBar. The scroll values vary from 0.0, meaning zero offset to 1.0 meaning sufficient offset such that the bottom of the scrollable material appears halfway down the pane. The total distance to achieve this range is called the totalScrollRange.!!ScrollPane methodsFor: 'initialization' stamp: 'tk 8/13/1998 13:05'!fullCopy	| copy |	self mouseEnter: nil.		 "Make sure scrollBar is in morphic structure"	copy _ super fullCopy.		"So that references are updated properly"		"Will fail of any Players with scripts are in the ScrollPane"	self mouseLeave: nil.	^ copy mouseLeave: nil! !!ScrollPane methodsFor: 'initialization' stamp: 'jm 10/10/2002 20:10'!initialize	super initialize.	hasFocus _ false.	borderWidth _ 2.	borderColor _ Color black.	retractableScrollBar _ (Preferences valueOfFlag: #inboardScrollbars) not.	scrollBarOnLeft _ (Preferences valueOfFlag: #scrollBarsOnRight) not.	scrollBar _ ScrollBar new model: self.	scrollBar borderWidth: 1; borderColor: Color black.	scroller _ TransformMorph new color: Color transparent.	scroller offset: -3@0.	self addMorph: scroller.	retractableScrollBar ifFalse: [self addMorph: scrollBar].	self extent: 150@120.! !!ScrollPane methodsFor: 'initialization' stamp: 'dew 10/17/1999 19:41'!setScrollDeltas	| range delta |	self hideOrShowScrollBar.	scroller hasSubmorphs ifFalse: [scrollBar interval: 1.0.  ^ self].	range _ self leftoverScrollRange.	delta _ self scrollDeltaHeight.	range = 0 ifTrue: [^ scrollBar scrollDelta: 0.02 pageDelta: 0.2; interval: 1.0].	"Set up for one line (for arrow scrolling), or a full pane less one line (for paging)."	scrollBar scrollDelta: (delta / range) asFloat 			pageDelta: ((self innerBounds height - delta) / range) asFloat.	scrollBar interval: ((self innerBounds height - delta) / self totalScrollRange) asFloat.! !!ScrollPane methodsFor: 'access' stamp: 'jm 10/4/2002 17:35'!colorForInsets	"My submorphs use the surrounding color."	(owner color isKindOf: Color)		ifTrue: [^ owner color]		ifFalse: [^ Color white].! !!ScrollPane methodsFor: 'access' stamp: 'dew 10/17/1999 19:40'!hasFocus	"hasFocus is currently set by mouse enter/leave events.	This inst var should probably be moved up to a higher superclass."	^ hasFocus ifNil: [false]! !!ScrollPane methodsFor: 'access' stamp: 'jm 10/3/2002 17:57'!model	^ model! !!ScrollPane methodsFor: 'access' stamp: 'jm 10/8/2002 10:43'!model: anObject	"Set my model and make me me a dependent of the given object."	model ifNotNil: [model removeDependent: self].	anObject ifNotNil: [anObject addDependent: self].	model _ anObject.! !!ScrollPane methodsFor: 'geometry' stamp: 'go 4/26/1999 10:06'!extent: newExtent        super extent: (newExtent max: (self scrollbarWidth + 20)@16).        self resizeScrollBar; resizeScroller; setScrollDeltas! !!ScrollPane methodsFor: 'geometry' stamp: 'dew 10/17/1999 19:41'!innerBounds	| inner w |	inner _ super innerBounds.	w _ self scrollbarWidth.	retractableScrollBar | (submorphs includes: scrollBar) not		ifTrue: [^ inner]		ifFalse: [^ (scrollBarOnLeft					ifTrue: [inner topLeft + ((w-1)@0) corner: inner bottomRight]					ifFalse: [inner topLeft corner: inner bottomRight - ((w-2)@0)])]! !!ScrollPane methodsFor: 'geometry' stamp: 'dew 2/19/1999 18:46'!leftoverScrollRange	"Return the entire scrolling range minus the currently viewed area."	^ self totalScrollRange - (bounds height * 3 // 4) max: 0! !!ScrollPane methodsFor: 'geometry' stamp: 'dew 10/17/1999 19:41'!resetExtent	"Reset the extent. (may be overridden by subclasses which need to do more than this)"	self resizeScroller! !!ScrollPane methodsFor: 'geometry' stamp: 'di 11/11/1998 09:11'!resizeScrollBar	| w topLeft |	w _ self scrollbarWidth.	topLeft _ scrollBarOnLeft		ifTrue: [retractableScrollBar ifTrue: [bounds topLeft - ((w-1)@0)]									ifFalse: [bounds topLeft]]		ifFalse: [retractableScrollBar ifTrue: [bounds topRight]									ifFalse: [bounds topRight - ((w-1)@0)]].	scrollBar bounds: (topLeft extent: w @ bounds height)! !!ScrollPane methodsFor: 'geometry' stamp: 'di 11/11/1998 09:48'!resizeScroller	scroller bounds: self innerBounds! !!ScrollPane methodsFor: 'geometry' stamp: 'di 8/16/1998 01:09'!scrollBarFills: aRectangle	"Return true if a flop-out scrollbar fills the rectangle"	^ (retractableScrollBar and: [submorphs includes: scrollBar]) and:		[scrollBar bounds containsRect: aRectangle]! !!ScrollPane methodsFor: 'geometry' stamp: 'dew 2/19/1999 18:49'!scrollBy: delta	"Move the contents in the direction delta."	"For now, delta is assumed to have a zero x-component"	| newYoffset r |	newYoffset _ scroller offset y - delta y max: 0.	scroller offset: scroller offset x @ newYoffset.	(r _ self leftoverScrollRange) = 0		ifTrue: [scrollBar value: 0.0]		ifFalse: [scrollBar value: newYoffset asFloat / r]! !!ScrollPane methodsFor: 'geometry' stamp: 'dew 2/19/1999 17:08'!scrollDeltaHeight	"Return the increment in pixels which this pane should be scrolled (normally a subclass responsibility)."	^ 12! !!ScrollPane methodsFor: 'geometry' stamp: 'di 12/6/1999 08:35'!scrollbarWidth  "Includes border"	(Preferences valueOfFlag: #scrollBarsNarrow)		ifTrue: [^ 12]		ifFalse: [^ 16]! !!ScrollPane methodsFor: 'geometry' stamp: 'dew 2/19/1999 20:24'!totalScrollRange	"Return the entire scrolling range."	^ (scroller submorphBounds encompass: 0@0) height! !!ScrollPane methodsFor: 'geometry' stamp: 'dew 10/17/1999 19:41'!unadjustedScrollRange	"Return the difference between the height extent of the receiver's submorphs and its own height extent (plus an extra 1/2 line height)."	scroller submorphBounds ifNil: [^ 0].	^ self totalScrollRange - bounds height + (self scrollDeltaHeight / 2) max: 0! !!ScrollPane methodsFor: 'event handling' stamp: 'jm 10/10/2002 20:08'!handlesMouseDown: evt	^ true! !!ScrollPane methodsFor: 'event handling' stamp: 'di 1/18/2000 15:29'!handlesMouseOver: evt	"Could just ^ true, but this ensures that scroll bars won't flop out	if you mouse-over appendages such as connecting pins."	| cp |	cp _ evt cursorPoint.	(bounds containsPoint: cp)		ifTrue: [^ true]					ifFalse: [self submorphsDo:					[:m | (m containsPoint: cp) ifTrue:							[m == scrollBar								ifTrue: [^ true]								ifFalse: [^ false]]].				^ false]! !!ScrollPane methodsFor: 'event handling' stamp: 'jm 10/10/2002 20:09'!keyStroke: evt	"If pane is not full, pass the event to the last submorph, assuming it is the most appropriate recipient (!!)"	(self scrollByKeyboard: evt) ifTrue: [^ self].	scroller submorphs last keyStroke: evt.! !!ScrollPane methodsFor: 'event handling' stamp: 'di 6/30/1998 08:48'!mouseDown: evt	evt yellowButtonPressed  "First check for option (menu) click"		ifTrue: [^ self yellowButtonActivity: evt shiftPressed].	"If pane is not full, pass the event to the last submorph,	assuming it is the most appropriate recipient (!!)"	scroller hasSubmorphs ifTrue:		[scroller submorphs last mouseDown: (evt transformedBy: (scroller transformFrom: self))]! !!ScrollPane methodsFor: 'event handling' stamp: 'dew 5/22/2000 15:55'!mouseEnter: event	hasFocus _ true.	(owner isKindOf: SystemWindow)		ifTrue: [owner paneTransition: event].	self hideOrShowScrollBar.! !!ScrollPane methodsFor: 'event handling' stamp: 'dew 10/17/1999 19:41'!mouseLeave: event	hasFocus _ false.	retractableScrollBar		ifTrue: [self hideScrollBar].	(owner isKindOf: SystemWindow)		ifTrue: [owner paneTransition: event]! !!ScrollPane methodsFor: 'event handling' stamp: 'jm 10/13/2002 10:58'!scrollByKeyboard: event 	"If event is ctrl+up/down then scroll and answer true."	(event controlKeyPressed or: [event commandKeyPressed]) ifFalse: [^ false].	event keyValue = 30		ifTrue:  [scrollBar scrollDown: -3. ^ true].	event keyValue = 31		ifTrue: [scrollBar scrollDown: 3. ^ true].	^ false! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:31'!scrollBarMenuButtonPressed: event	^ self yellowButtonActivity: event shiftPressed! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'dew 2/19/1999 18:48'!scrollBarValue: scrollValue	scroller hasSubmorphs ifFalse: [^ self].	scroller offset: -3 @ (self leftoverScrollRange * scrollValue)! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:31'!shiftedYellowButtonActivity	^ self yellowButtonActivity: true! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'di 6/26/1998 13:32'!unshiftedYellowButtonActivity	^ self yellowButtonActivity: false! !!ScrollPane methodsFor: 'scroll bar events' stamp: 'sma 6/5/2000 13:36'!yellowButtonActivity: shiftKeyState	| menu |	(menu _ self getMenu: shiftKeyState) ifNotNil:		[menu setInvokingView: self.		menu popUpEvent: self activeHand lastEvent]! !!ScrollPane methodsFor: 'menu' stamp: 'jm 10/10/2002 20:07'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	retractableScrollBar		ifTrue: [aCustomMenu add: 'make scrollbar permanent' action: #retractableOrNot]		ifFalse: [aCustomMenu add: 'make scrollbar retractable' action: #retractableOrNot].	scrollBarOnLeft		ifTrue: [aCustomMenu add: 'scroll bar on right' action: #toggleScrollBarOnLeft]		ifFalse: [aCustomMenu add: 'scroll bar on left' action: #toggleScrollBarOnLeft].! !!ScrollPane methodsFor: 'menu' stamp: 'sw 9/23/1998 08:47'!getMenu: shiftKeyState	"Answer the menu for this text view, supplying an empty menu to be filled in. If the menu selector takes an extra argument, pass in the current state of the shift key."	| menu aMenu aTitle |	getMenuSelector == nil ifTrue: [^ nil].	menu _ MenuMorph new defaultTarget: model.	aTitle _ getMenuTitleSelector ifNotNil: [model perform: getMenuTitleSelector].	getMenuSelector numArgs = 1 ifTrue:		[aMenu _ model perform: getMenuSelector with: menu.		aTitle ifNotNil:  [aMenu addTitle: aTitle].		^ aMenu].	getMenuSelector numArgs = 2 ifTrue:		[aMenu _ model perform: getMenuSelector with: menu with: shiftKeyState.		aTitle ifNotNil:  [aMenu addTitle: aTitle].		^ aMenu].	^ self error: 'The getMenuSelector must be a 1- or 2-keyword symbol'! !!ScrollPane methodsFor: 'menu' stamp: 'sw 8/18/1998 12:38'!menuTitleSelector: aSelector	getMenuTitleSelector _ aSelector! !!ScrollPane methodsFor: 'menu' stamp: 'sw 11/5/1998 14:14'!retractable: aBoolean	retractableScrollBar == aBoolean ifFalse: [self retractableOrNot "toggles it"]! !!ScrollPane methodsFor: 'menu' stamp: 'jm 10/10/2002 20:06'!toggleScrollBarOnLeft	"Put the scroll bar ont the other side."	scrollBarOnLeft _ scrollBarOnLeft not.	self extent: self extent.! !!ScrollPane methodsFor: 'scrolling' stamp: 'dew 5/22/2000 15:18'!hideOrShowScrollBar	"Hide or show the scrollbar depending on if the pane is scrolled/scrollable."	"Don't do anything with the retractable scrollbar unless we have focus"	retractableScrollBar & self hasFocus not ifTrue: [^self].	self isScrollable not & self isScrolledFromTop not ifTrue: [self hideScrollBar].	self isScrollable | self isScrolledFromTop ifTrue: [self showScrollBar].! !!ScrollPane methodsFor: 'scrolling' stamp: 'RAA 6/8/2000 12:34'!hideScrollBar	(submorphs includes: scrollBar) ifFalse: [^self].	self privateRemoveMorph: scrollBar.	scrollBar privateOwner: nil.	retractableScrollBar ifFalse: [self resetExtent].! !!ScrollPane methodsFor: 'scrolling' stamp: 'dew 5/22/2000 16:28'!isScrollable	(Preferences valueOfFlag: #hiddenScrollBars) ifFalse: [^ true].	"If the contents of the pane are too small to scroll, return false."	^ self unadjustedScrollRange > 0		"treat a single line as non-scrollable"		and: [self totalScrollRange > (self scrollDeltaHeight * 3/2)]! !!ScrollPane methodsFor: 'scrolling' stamp: 'dew 5/22/2000 15:17'!isScrolledFromTop	"Have the contents of the pane been scrolled, so that the top of the contents are not visible?"	^scroller offset y > 0! !!ScrollPane methodsFor: 'scrolling' stamp: 'RAA 6/8/2000 12:35'!showScrollBar	(submorphs includes: scrollBar) ifTrue: [^self].	self privateAddMorph: scrollBar atIndex: 1.	self resizeScrollBar.	scrollBar changed.	retractableScrollBar ifFalse: [self resetExtent].! !!SelectionMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 11:38'!selections	^ selections! !!SelectionMenu methodsFor: 'accessing' stamp: 'sma 5/28/2000 11:38'!selections: selectionArray	selections _ selectionArray! !!SelectionMenu methodsFor: 'basic control sequence' stamp: 'sma 5/28/2000 15:28'!invokeOn: targetObject	"Pop up this menu and return the result of sending to the target object 	the selector corresponding to the menu item selected by the user. Return 	nil if no item is selected."	| sel |	sel _ self startUp.	sel = nil ifFalse: [^ targetObject perform: sel].	^ nil"Example:	(SelectionMenu labels: 'sincosneg' lines: #() selections: #(sin cos negated)) invokeOn: 0.7"! !!SelectionMenu methodsFor: 'basic control sequence' stamp: 'sma 5/28/2000 15:28'!startUpWithCaption: captionOrNil at: location	"Overridden to return value returned by manageMarker."	| index |	index _ super startUpWithCaption: captionOrNil at: location.	(selections = nil or: [(index between: 1 and: selections size) not])		ifTrue: [^ nil].	^ selections at: index! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sw 11/8/1999 17:52'!fromArray: anArray	"Construct a menu from anArray.  The elements of anArray must be either:	*  A pair of the form: <label> <selector>or	*  The 'dash' (or 'minus sign') symbol	Refer to the example at the bottom of the method"	| labelList lines selections anIndex |	labelList _ OrderedCollection new.	lines _ OrderedCollection new.	selections _ OrderedCollection new.	anIndex _ 0.	anArray do:		[:anElement |			anElement size == 1				ifTrue:					[(anElement == #-) ifFalse: [self error: 'badly-formed menu constructor'].					lines add: anIndex]				ifFalse:					[anElement size == 2 ifFalse: [self error: 'badly-formed menu constructor'].					anIndex _ anIndex + 1.					labelList add: anElement first.					selections add: anElement second]].	^ self labelList: labelList lines: lines selections: selections"(SelectionMenu fromArray:	#(	('first label'		moja)		('second label'	mbili)		-		('third label' 	tatu)		-		('fourth label'	nne)		('fifth label'	tano))) startUp"! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:04'!labelList: labelList	^ self labelArray: labelList! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:04'!labelList: labelList lines: lines	^ self labelArray: lines lines: lines! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:04'!labelList: labelList lines: lines selections: selections	^ (self labelArray: labelList lines: lines) selections: selections! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:04'!labelList: labelList selections: selections	^ self		labelList: labelList		lines: #()		selections: selections! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:09'!labels: labels lines: linesArray	"Answer an instance of me whose items are in labels, with lines drawn  	after each item indexed by linesArray. Labels can be either a string 	with embedded CRs, or a collection of strings."	(labels isKindOf: String)		ifTrue: [^ super labels: labels lines: linesArray]		ifFalse: [^ super labelArray: labels lines: linesArray]! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:09'!labels: labels lines: linesArray selections: selectionsArray	"Answer an instance of me whose items are in labels, with lines drawn  	after each item indexed by linesArray. Labels can be either a string  	with embedded CRs, or a collection of strings. Record the given array of 	selections corresponding to the items in labels."	^ (self labels: labels lines: linesArray) selections: selectionsArray! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:10'!labels: labels selections: selectionsArray	"Answer an instance of me whose items are in labels, recording 	the given array of selections corresponding to the items in labels."	^ self		labels: labels		lines: #()		selections: selectionsArray! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:10'!selections: selectionsArray	"Answer an instance of me whose labels and selections are identical."	^ self selections: selectionsArray lines: nil! !!SelectionMenu class methodsFor: 'instance creation' stamp: 'sma 5/28/2000 16:10'!selections: selectionsArray lines: linesArray	"Answer an instance of me whose labels and selections are identical."	^ self		labelList: (selectionsArray collect: [:each | each asString])		lines: linesArray		selections: selectionsArray! !I am a parse tree leaf representing a selector.!!SelectorNode methodsFor: 'code generation' stamp: 'di 1/7/2000 12:32'!size: encoder args: nArgs super: supered	| index |	self reserve: encoder.	(supered not and: [code - Send < SendLimit and: [nArgs < 3]])		ifTrue: [^1]. "short send"	(supered and: [code < Send]) ifTrue: 		["super special:"		code _ self code: (encoder sharableLitIndex: key) type: 5].	index _ code < 256 ifTrue: [code - Send] ifFalse: [code \\ 256].	(index <= 31 and: [nArgs <= 7])		ifTrue: [^ 2]. "medium send"	(supered not and: [index <= 63 and: [nArgs <= 3]])		ifTrue: [^ 2]. "new medium send"	^ 3 "long send"! !!SelectorNode methodsFor: 'printing' stamp: 'sw 11/17/1999 15:03'!printOn: aStream indent: level 	"nb: this method is seemingly never reached"	aStream withAttributes: (Preferences syntaxAttributesFor: #keyword)		do: [aStream nextPutAll: key]! !I provide synchronized communication of a single bit of information (a "signal") between Processes. A signal is sent by sending the message signal and received by sending the message wait. If no signal has been sent when a wait message is sent, the sending Process will be suspended until a signal is sent.!!Semaphore methodsFor: 'mutual exclusion' stamp: 'ar 10/8/1998 11:16'!critical: mutuallyExcludedBlock ifError: errorBlock	"Evaluate mutuallyExcludedBlock only if the receiver is not currently in 	the process of running the critical: message. If the receiver is, evaluate 	mutuallyExcludedBlock after the other critical: message is finished."	| blockValue hasError errMsg errRcvr |	self wait.	hasError _ false.	blockValue _ [mutuallyExcludedBlock value] ifError:[:msg :rcvr|		hasError _ true.		errMsg _ msg.		errRcvr _ rcvr].	hasError ifTrue:[		self signal.		^errorBlock value: errMsg value: errRcvr].	self signal.	^blockValue! !!Semaphore methodsFor: 'comparing' stamp: 'sma 4/22/2000 18:48'!= anObject	^ self == anObject! !!Semaphore methodsFor: 'comparing' stamp: 'sma 4/22/2000 18:48'!hash	^ self identityHash! !I represent the Squeak interface to a sensor board connected via a serial port. One such board, the GoGo board, has 8 10-bit sensor inputs capable of reading either voltage or resistive sensors plus three output ports with sufficient current to control DC motors, small lamps, or similar devices. See http://learning.media.mit.edu/projects/gogo/ for additional info about the GoGo board.To create an instance of me:	SensorBoardMorph new openInWorld(Note: You can only have one instance of me for each serial port that has a GoGo Board attached.)Use the "Port?" button to choose the serial port. Then click "Start" to start reading sensor data. To control motors, just use my motor control commands. When you're done, click the "Stop" button.!!SensorBoardMorph methodsFor: 'initialization' stamp: 'jm 11/18/2003 20:05'!addButtons	"Add buttons to choose a port and to start or stop the GoGo Board."	| b r |	b _ SimpleButtonMorph new target: self; borderColor: Color black.	r _ AlignmentMorph newRow.	r color: column color; borderWidth: 0; inset: 2.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'Port?';	actionSelector: #selectPort).	r addMorphBack: (b fullCopy label: 'Start';	actionSelector: #startReadingData).	r addMorphBack: (b fullCopy label: 'Stop';	actionSelector: #stopReadingData).	column addMorphBack: (Morph new color: column color; extent: 10@3).  "spacer"	column addMorphBack: (Morph new color: column color; extent: 10@5).  "spacer"	column addMorphBack: r.! !!SensorBoardMorph methodsFor: 'initialization' stamp: 'jm 12/1/2003 15:11'!addButtonsAndReadouts	column _ AlignmentMorph newColumn		centering: #center;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		color: (Color r: 0.9 g: 1.0 b: 0.9);		useRoundedCorners;		borderWidth: 2;		inset: 3.	titleMorph _ StringMorph		contents: 'Sensor Board 1'		font: TextStyle default defaultFont emphasis: 1.	column addMorph: titleMorph.	self removeAllMorphs.	self addButtons.	readouts _ (1 to: 8) collect: [:i | self addReadoutLabeled: i printString].	column position: self position - 2.	self addMorph: column.	self extent: column extent - 4.! !!SensorBoardMorph methodsFor: 'initialization' stamp: 'jm 3/16/2003 22:15'!addReadoutLabeled: aString	"Add a readout row with the given label. Answer the stringmorph that's the readout."	| row box readout |	row _ AlignmentMorph newRow color: column color.	row addMorphBack: (StringMorph contents: aString).	row addMorphBack: (Morph new color: column color; extent: 10@5). "spacer"	box _ AlignmentMorph newColumn		extent: 80@18;		hResizing: #rigid;		vResizing: #rigid;		borderWidth: 1;		centering: #center;		color: (Color gray: 0.84).	readout _ StringMorph contents: '0'.	box addMorph: readout.	row addMorphBack: box.	column addMorphBack: row.	^ readout! !!SensorBoardMorph methodsFor: 'initialization' stamp: 'jm 1/1/2004 11:54'!initialize	super initialize.	portNum _ 1.	sensorValues _ Array new: 8 withAll: 0.	inLows _ Array new: 8 withAll: 0.	inHighs _ Array new: 8 withAll: 1023.	outHighs _ Array new: 8 withAll: 1000.	calibrating _ Array new: 8 withAll: false.	currentState _ #idle.	highByte _ 0.	self addButtonsAndReadouts.! !!SensorBoardMorph methodsFor: 'accessing' stamp: 'jm 7/7/2003 21:29'!colorCode	^ Color r: 0.46 g: 0.86 b: 0.58! !!SensorBoardMorph methodsFor: 'accessing' stamp: 'jm 1/1/2004 11:38'!inputRangeFor: index low: low high: high	"Set the raw input value range for the given sensor. Incoming sensor values below low will map to zero. Values above high will map to the top of the output range. Values between low and high will be linearly mapped to values between zero and top of the output range."	inLows at: index put: low.	inHighs at: index put: high.! !!SensorBoardMorph methodsFor: 'accessing' stamp: 'jm 6/22/2003 23:39'!isScriptable	"I am not scriptable."	^ false! !!SensorBoardMorph methodsFor: 'accessing' stamp: 'jm 11/18/2003 20:10'!objName	^ 'Board ', portNum printString! !!SensorBoardMorph methodsFor: 'accessing' stamp: 'jm 1/1/2004 11:54'!outputRangeFor: index max: aNumber	"Set the output range for the given sensor. Values will range from zero to the given value."	outHighs at: index put: aNumber asInteger.! !!SensorBoardMorph methodsFor: 'sensor ops' stamp: 'jm 1/1/2004 11:26'!sensor: n	| i raw |	"Answer the value of sensor n. Sensors are numbered 1-8."	i _ (n asInteger max: 1) min: 8.	raw _ sensorValues at: i.	^ (raw * 1000) // 1023! !!SensorBoardMorph methodsFor: 'sensor ops' stamp: 'jm 1/1/2004 12:03'!sensorAt: i put: val	"For testing. Force the given sensor to take on the given value."	(i >= 1 and: [i <= 8]) ifFalse: [^ self].	sensorValues at: i put: val.	(calibrating at: i) ifTrue: [		inLows at: i put: ((inLows at: i) min: val).		inHighs at: i put: ((inHighs at: i) max: val)].! !!SensorBoardMorph methodsFor: 'sensor ops' stamp: 'jm 1/1/2004 12:00'!startCalibrating: index	"Start calibrating the given sensor. To automatically calibrate the input range of a sensor, first call startCalibrating: on that sensor, then exercise that sensor over its entire expected range of input values. For example, for a light sensor you would expose it to the most and least amounts of light that it would encounter in normal operation. Call stopCalibrating: when you're done. It's also possible to leave the sensor in calibration mode all the time."	calibrating at: index put: true.	inLows at: index put: (sensorValues at: index).	inHighs at: index put: (sensorValues at: index).! !!SensorBoardMorph methodsFor: 'sensor ops' stamp: 'jm 12/12/2003 11:40'!startReadingData	"Ensure that the serial port is open, turn off all motors and put them into a known state, and begin streaming sensor data."	self openPort: portNum.	1 to: 6 do: [:motor |		self turnOffMotor: motor.		self thisWayMotor: motor.		self setPower: 3 motor: motor.		self turnOffMotor: motor].	self startStreamingSensors: 16rFF.  "all 8 sensors"! !!SensorBoardMorph methodsFor: 'sensor ops' stamp: 'jm 1/1/2004 11:56'!stopCalibrating: index	"Start calibrating the given sensor."	calibrating at: index put: false.! !!SensorBoardMorph methodsFor: 'sensor ops' stamp: 'jm 3/9/2003 10:19'!stopReadingData	"Turn off all motors, stop streaming data, and close the port."	(port notNil and: [port isOpen]) ifTrue: [		1 to: 6 do: [:motor | self turnOffMotor: motor].		self startStreamingSensors: 0].  "turn off streaming"	self closePort.! !!SensorBoardMorph methodsFor: 'motor ops' stamp: 'jm 3/5/2003 21:52'!coastToStopMotor: motorNum	"Let the given motor coast to a stop."	self portIsOpen ifFalse: [^ self].	self selectMotor: motorNum.	port nextPutAll: #(84 254 84) asByteArray.! !!SensorBoardMorph methodsFor: 'motor ops' stamp: 'jm 3/5/2003 21:50'!reverseMotor: motorNum	"Reverse the direction of the given motor."	self portIsOpen ifFalse: [^ self].	self selectMotor: motorNum.	port nextPutAll: #(84 254 72) asByteArray.! !!SensorBoardMorph methodsFor: 'motor ops' stamp: 'jm 3/9/2003 10:31'!selectMotor: anInteger	"Select the motor to which subsequent motor commands will be addressed. Motors are numbered 1-6."	| motorNum msg |	motorNum _ (anInteger truncated - 1 max: 0) min: 7. "motor bit index"	msg _ #(84 254 128 0) asByteArray.	msg at: 4 put: (1 bitShift: motorNum).	port nextPutAll: msg.! !!SensorBoardMorph methodsFor: 'motor ops' stamp: 'jm 3/9/2003 10:05'!setPower: aNumber motor: motorNum	"Set the power of the given motor to 0 to 7."	| power msg |	self portIsOpen ifFalse: [^ self].	self selectMotor: motorNum.	power _ (aNumber truncated max: 0) min: 7.	msg _ #(84 254 0) asByteArray.	msg at: 3 put: 96 + (power bitShift: 2).	port nextPutAll: msg.! !!SensorBoardMorph methodsFor: 'motor ops' stamp: 'jm 3/5/2003 21:46'!thatWayMotor: motorNum	"Set motor direction to that way."	self portIsOpen ifFalse: [^ self].	self selectMotor: motorNum.	port nextPutAll: #(84 254 80) asByteArray.! !!SensorBoardMorph methodsFor: 'motor ops' stamp: 'jm 3/5/2003 21:49'!thisWayMotor: motorNum	"Set motor direction to this way."	self portIsOpen ifFalse: [^ self].	self selectMotor: motorNum.	port nextPutAll: #(84 254 76) asByteArray.! !!SensorBoardMorph methodsFor: 'motor ops' stamp: 'jm 3/9/2003 10:31'!turnOffMotor: motorNum	self portIsOpen ifFalse: [^ self].	self selectMotor: motorNum.	port nextPutAll: #(84 254 68) asByteArray.! !!SensorBoardMorph methodsFor: 'motor ops' stamp: 'jm 3/9/2003 10:31'!turnOnMotor: motorNum	self portIsOpen ifFalse: [^ self].	self selectMotor: motorNum.	port nextPutAll: #(84 254 64) asByteArray.! !!SensorBoardMorph methodsFor: 'sound ops' stamp: 'jm 11/8/2003 22:30'!noteChangePitch: pitch	"Change the pitch of currently sounding note, if any."	note ifNil: [^ self].	note pitch: pitch.	note internalizeModulationAndRatio.! !!SensorBoardMorph methodsFor: 'sound ops' stamp: 'jm 11/8/2003 22:40'!noteOff	"Turn off the currently playing note, if any."	note ifNotNil: [note pause].	note _ nil.! !!SensorBoardMorph methodsFor: 'sound ops' stamp: 'jm 11/12/2003 08:54'!noteOn	"Turn on a note at 440 hertz. The note will play until it's turned off or another note is played."	self noteOff.	note _ FMSound oboe1 soundForPitch: 440 dur: 100000.0 loudness: 0.7.	note play.! !!SensorBoardMorph methodsFor: 'sound ops' stamp: 'jm 11/8/2003 22:22'!notePitch: pitch secs: seconds	"Play a note of the given pitch for the given duration in seconds."	self noteOff.	note _ FMSound oboe1 soundForPitch: pitch dur: seconds loudness: 1.0.	note play.! !!SensorBoardMorph methodsFor: 'stepping' stamp: 'jm 3/5/2003 21:36'!step	self portIsOpen ifFalse: [port _ nil. ^ self].	self processIncomingData.	1 to: 8 do: [:i |		(readouts at: i) contents: (sensorValues at: i) printString].! !!SensorBoardMorph methodsFor: 'stepping' stamp: 'jm 3/5/2003 19:41'!stepTime	^ 100! !!SensorBoardMorph methodsFor: 'serial port' stamp: 'jm 1/1/2004 12:07'!closePort	port ifNotNil: [port close].	port _ nil.	sensorValues atAllPut: 0.	1 to: 8 do: [:i | (readouts at: i) contents: '0'].! !!SensorBoardMorph methodsFor: 'serial port' stamp: 'jm 1/1/2004 12:07'!openPort: anInteger	self closePort.	port _ SerialPort new openPort: anInteger.	currentState _ #idle.	sensorValues atAllPut: 0.	self startStreamingSensors: 0.  "in case board was left in streaming mode"	(Delay forMilliseconds: 100) wait.	port flushInputBuffer.! !!SensorBoardMorph methodsFor: 'serial port' stamp: 'jm 3/5/2003 21:35'!portIsOpen	^ port notNil and: [port isOpen]! !!SensorBoardMorph methodsFor: 'serial port' stamp: 'jm 12/17/2003 15:33'!selectPort	| menu n |	menu _ CustomMenu new.	(0 to: 4) do: [:w | menu add: w printString action: w].	n _ menu startUp.	n ifNotNil: [		portNum _ n.		titleMorph contents: 'Sensor Board ', portNum printString].! !!SensorBoardMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 17:07'!fieldsVersion	^ 1! !!SensorBoardMorph methodsFor: 'object i/o' stamp: 'jm 10/20/2003 11:26'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		portNum	) from: anObjStream.	self addButtonsAndReadouts.! !!SensorBoardMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 17:08'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		portNum	) on: anObjStream.! !!SensorBoardMorph methodsFor: 'private' stamp: 'jm 3/5/2003 19:54'!ping	"Answer true if a GoGoBoard is connected to my serial port."	| buf |	port flushInputBuffer.	port nextPutAll: #(84 254 0) asByteArray.	buf _ port next: 3.	^ buf = #(85 255 170) asByteArray! !!SensorBoardMorph methodsFor: 'private' stamp: 'jm 1/1/2004 12:05'!processByte: aByte	"Process one byte of the incoming data stream."	"Details: This code recognizes three-byte sensor update messages starting with 16r0C using a simple, three-state finite state machine. We assume that sensor updates are always contiguous--that is, replies to motor or other GoGo board commands will not be inserted between the bytes of any given three-byte sensor update message. The sensor number is the top three bits of the byte two. The data value is the bottom two bits of byte two plus all eight bits of byte three."	| sensorNum val |	currentState = #idle ifTrue: [ 		aByte = 16r0C ifTrue: [currentState _ #startByteSeen].		^ self].	currentState = #startByteSeen ifTrue: [		highByte _ aByte.		currentState _ #highByteSeen.		^ self].	currentState = #highByteSeen ifTrue: [		"final byte of message: report the sensor value"		sensorNum _ highByte bitShift: -5.		val _ ((highByte bitAnd: 3) bitShift: 8) + aByte.		self sensorAt: sensorNum + 1 put: val.		currentState _ #idle].! !!SensorBoardMorph methodsFor: 'private' stamp: 'jm 3/5/2003 22:35'!processIncomingData	"Process incoming bytes from the serial port."	"On a Macintosh G4 Powerbook, I measured a sensor reading rate of 234 sensor readings/sec."	| buf |	buf _ port readByteArray.	buf do: [:b | self processByte: b].! !!SensorBoardMorph methodsFor: 'private' stamp: 'jm 3/9/2003 09:54'!startStreamingSensors: sensorByte	"Begin streaming data from the set of sensors specified by the bits of the given byte. Invoke this method with 0 to stop streaming. Incoming sensor data is processed by frequent calls to processIncomingData."	| cmd |	port flushInputBuffer.	cmd _ #(84 254 160 0) asByteArray.	cmd at: 4 put: sensorByte.	port nextPutAll: cmd.! !!SensorBoardMorph class methodsFor: 'scratch' stamp: 'jm 11/18/2003 20:16'!classBlockSpecs	^ #(		'sensor board'			('sensor %n'						r	sensor:)			('motor %n on'					-	turnOnMotor:)			('motor %n off'					-	turnOffMotor:)			('motor %n coast'				-	coastToStopMotor:)			('motor %n this way'			-	thisWayMotor:)			('motor %n that way'			-	thatWayMotor:)			('motor %n reverse'				-	reverseMotor:)		'sound (temp)'			('note pitch %n for %n secs'		-	notePitch:secs:)			('start note'						-	noteOn)			('change note pitch %n'			-	noteChangePitch:)			('stop note'						-	noteOff)	).! !Scratch Sensor Board Serial ProtocolWhen the sensor board is powered up or reset, it immediately begins sendingsensor data. Sensor data is sent as two byte messages, one message for eachof the available sensors. The first byte supplies the sensor number and thehigh 3 bits of the sensor value. The second byte supplies the low 7 bitsof the sensor value. The values of all the available sensors are sent inthis format, followed by a pause of two full byte transmission times, thenthe entire cycle repeats. The pause allows the receiver's UART to regainsynchronization in the rare event that it is lost.Here is the byte format for the two bytes:  Byte1: <1><sensor number (4 bits)><sensor value high bits (3 bits)>  Byte2: <0><sensor value low bits (7 bits)>Note that the most significant bit is one for the first byte of a pairand zero for the second. This allows the receiver to tell if a givenbyte is the first or second byte of a message.Sensor board have various numbers of sensors. A given board with N sensorswill cycle through sensors numbers 0 through N-1, then repeat. For example,a four-sensor board would send data for sensors 0 through 3.  Up to sixteensensors can be handled by this protocol.Sensor values should be normalized to fit a 10-bit, unsigned integer range.That is, sensor values should range from 0 to ~1023. For example, if a givensensor board only collects 8-bit values, these values should be shifted leftby two bits so that the maximum value is 1020. Likewise, a board that readsover 10-bits of sensor resolution should shift its sensor values right sothat only the 10 most-significant bits of the data are sent.The serial port should be set to 9600 baud, one start bit, one stop bit,and no parity.!!SensorBoardMorph2 methodsFor: 'as yet unclassified' stamp: 'jm 10/31/2003 20:18'!processByte: aByte	"Process one byte of the incoming data stream."	"Here is the byte format for a two byte sensor message:		Byte1: <1><sensor number (4 bits)><sensor value high bits (3 bits)>		Byte2: <0><sensor value low bits (7 bits)>"	| sensorNum val |	currentState = #idle ifTrue: [  "first byte of message"		(aByte bitAnd: 16r80) > 0 ifTrue: [			currentState _ #firstByteSeen.			highByte _ aByte].		^ self].	currentState = #firstByteSeen ifTrue: [		(aByte bitAnd: 16r80) > 0 ifTrue: [  "must have lost second byte; stay in firstByteSeen state"			highByte _ aByte.			^ self].		"good second byte: report the sensor value"		sensorNum _ (highByte bitShift: -3) bitAnd: 16rF.		val _ ((highByte bitAnd: 7) bitShift: 7) + aByte.		sensorValues at: sensorNum + 1 put: val.		currentState _ #idle].! !I am an abstract superclass for collections that have a well-defined order associated with their elements. Thus each element is externally-named by integers referred to as indices.!!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:34'!allButFirst	"Answer a copy of the receiver containing all but the first	element. Raise an error if there are not enough elements."	^ self allButFirst: 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:35'!allButFirst: n	"Answer a copy of the receiver containing all but the first n	elements. Raise an error if there are not enough elements."	^ self copyFrom: n + 1 to: self size! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:35'!allButLast	"Answer a copy of the receiver containing all but the last	element. Raise an error if there are not enough elements."	^ self allButLast: 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:35'!allButLast: n	"Answer a copy of the receiver containing all but the last n	elements. Raise an error if there are not enough elements."	^ self copyFrom: 1 to: self size - n! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:11'!at: index ifAbsent: exceptionBlock 	"Answer the element at my position index. If I do not contain an element 	at index, answer the result of evaluating the argument, exceptionBlock."	(index between: 1 and: self size) ifTrue: [^ self at: index].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:14'!atAll: indexArray	"Answer a new collection like the receiver which contains all elements	of the receiver at the indices of indexArray."	| newCollection |	newCollection _ self species new: indexArray size.	1 to: indexArray size do:		[:index |		newCollection at: index put: (self at: (indexArray at: index))].	^ newCollection! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:17'!atAll: aCollection put: anObject 	"Put anObject at every index specified by the elements of aCollection."	aCollection do: [:index | self at: index put: anObject].	^ anObject! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 4/22/2000 17:45'!atAllPut: anObject 	"Put anObject at every one of the receiver's indices."	| size |	(size _ self size) > 26 "first method faster from 27 accesses and on"		ifTrue: [self from: 1 to: size put: anObject]		ifFalse: [1 to: size do: [:index | self at: index put: anObject]]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'di 11/6/1998 14:32'!atPin: index 	"Return the index'th element of me if possible.	Return the first or last element if index is out of bounds."	index < 1 ifTrue: [^ self first].	index > self size ifTrue: [^ self last].	^ self at: index! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:36'!atRandom	"Answer a random element of the receiver.  Uses a shared random 	number generator owned by class Collection.  If you use this a lot, 	define your own instance of Random and use #atRandom:.  Causes 	an error if self has no elements."	^ self atRandom: Collection randomForPicking"Examples:	#('one' 'or' 'the' 'other') atRandom	(1 to: 10) atRandom	'Just pick one of these letters at random' atRandom"! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 12:50'!atRandom: aGenerator	"Answer a random element of the receiver.  Uses aGenerator which	should be kept by the user in a variable and used every time. Use	this instead of #atRandom for better uniformity of random numbers 	because only you use the generator.  Causes an error if self has no 	elements."	^ self at: (aGenerator nextInt: self size)! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:51'!atWrap: index 	"Answer the index'th element of the receiver.  If index is out of bounds,	let it wrap around from the end to the beginning until it is in bounds."	^ self at: index - 1 \\ self size + 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 5/12/2000 13:52'!atWrap: index put: value	"Store value into the index'th element of the receiver.  If index is out	of bounds, let it wrap around from the end to the beginning until it 	is in bounds. Answer value."	^ self at: index  - 1 \\ self size + 1 put: value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'jm 6/20/2003 10:01'!fifth	"Answer the fifth element of the receiver."	^ self at: 5! !!SequenceableCollection methodsFor: 'accessing' stamp: 'jm 6/20/2003 10:01'!first	"Answer the first element of the receiver."	^ self at: 1! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:31'!first: n	"Answer the first n elements of the receiver.	Raise an error if there are not enough elements."	^ self copyFrom: 1 to: n! !!SequenceableCollection methodsFor: 'accessing' stamp: 'jm 6/20/2003 10:01'!fourth	"Answer the fourth element of the receiver."	^ self at: 4! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 4/22/2000 17:52'!from: startIndex to: endIndex put: anObject	"Put anObject in all indexes between startIndex 	and endIndex. Very fast. Faster than to:do: for	more than 26 positions. No range checks are 	performed. Answer anObject."	| written toWrite thisWrite |	self at: startIndex put: anObject.	written _ 1.	toWrite _ endIndex - startIndex + 1.	[written < toWrite] whileTrue:		[thisWrite _ written min: toWrite - written.		self 			replaceFrom: startIndex + written			to: startIndex + written + thisWrite - 1			with: self startingAt: startIndex.		written _ written + thisWrite].	^ anObject! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 8/14/1998 21:21'!identityIndexOf: anElement ifAbsent: exceptionBlock	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer the result of evaluating the argument, 	exceptionBlock."	1 to: self size do:		[:i | (self at: i) == anElement ifTrue: [^ i]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:46'!indexOf: anElement	"Answer the index of the first occurence of anElement within the  	receiver. If the receiver does not contain anElement, answer 0."	^ self indexOf: anElement ifAbsent: [0]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:47'!indexOf: anElement ifAbsent: exceptionBlock	"Answer the index of the first occurence of anElement within the  	receiver. If the receiver does not contain anElement, answer the 	result of evaluating the argument, exceptionBlock."	^ self indexOf: anElement startingAt: 1 ifAbsent: exceptionBlock! !!SequenceableCollection methodsFor: 'accessing' stamp: 'sma 6/1/2000 15:47'!indexOf: anElement startingAt: start ifAbsent: exceptionBlock	"Answer the index of the first occurence of anElement after start	within the receiver. If the receiver does not contain anElement, 	answer the 	result of evaluating the argument, exceptionBlock."	start to: self size do:		[:index |		(self at: index) = anElement ifTrue: [^ index]].	^ exceptionBlock value! !!SequenceableCollection methodsFor: 'accessing' stamp: 'di 6/2/2000 09:15'!last	"Answer the last element of the receiver.	Raise an error if the collection is empty."	| size |	(size _ self size) = 0 ifTrue: [self errorEmptyCollection].	^ self at: size! !!SequenceableCollection methodsFor: 'accessing' stamp: 'ar 1/20/98 16:22'!replaceAll: oldObject with: newObject 	"Replace all occurences of oldObject with newObject"	| index |	index _ self				indexOf: oldObject				startingAt: 1				ifAbsent: [0].	[index = 0]		whileFalse: 			[self at: index put: newObject.			index _ self						indexOf: oldObject						startingAt: index + 1						ifAbsent: [0]]! !!SequenceableCollection methodsFor: 'accessing' stamp: 'jm 6/20/2003 10:02'!second	"Answer the second element of the receiver."	^ self at: 2! !!SequenceableCollection methodsFor: 'accessing' stamp: 'jm 6/20/2003 10:02'!third	"Answer the third element of the receiver."	^ self at: 3! !!SequenceableCollection methodsFor: 'testing' stamp: 'sma 5/12/2000 14:08'!includes: anObject	"Answer whether anObject is one of the receiver's elements."	^ (self indexOf: anObject) ~= 0! !!SequenceableCollection methodsFor: 'comparing' stamp: 'sma 5/12/2000 14:04'!= otherCollection 	"Answer true if the receiver is equivalent to the otherCollection.	First test for identity, then rule out different species and sizes of	collections. As a last resort, examine each element of the receiver	and the otherCollection."	self == otherCollection ifTrue: [^ true].	self species == otherCollection species ifFalse: [^ false].	^ self hasEqualElements: otherCollection! !!SequenceableCollection methodsFor: 'comparing' stamp: 'sma 5/12/2000 14:04'!hasEqualElements: otherCollection	"Answer whether the receiver's size is the same as otherCollection's	size, and each of the receiver's elements equal the corresponding 	element of otherCollection.	This should probably replace the current definition of #= ."	| size |	(size _ self size) = otherCollection size ifFalse: [^ false].	1 to: size do:		[:index |		(self at: index) = (otherCollection at: index) ifFalse: [^ false]].	^ true! !!SequenceableCollection methodsFor: 'comparing' stamp: 'di 11/24/1999 20:30'!hash"Answer an integer hash value for the receiver such that,  -- the hash value of an unchanged object is constant over time, and  -- two equal objects have equal hash values."    | size |	(size _ self size) = 0 ifTrue: [^ 17171].	^ size + (self at: 1) hash + (self at: size) hash! !!SequenceableCollection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:32'!asArray	"Answer an Array whose elements are the elements of the receiver."	^ Array withAll: self! !!SequenceableCollection methodsFor: 'converting' stamp: 'sma 5/12/2000 17:36'!asByteArray	"Answer a ByteArray whose elements are the elements of the receiver."	^ ByteArray withAll: self! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 9/14/1998 23:47'!asFloatArray	"Answer a FloatArray whose elements are the elements of the receiver, in 	the same order."	| floatArray |	floatArray _ FloatArray new: self size.	1 to: self size do:[:i| floatArray at: i put: (self at: i) asFloat ].	^floatArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 10/10/1998 16:19'!asIntegerArray	"Answer an IntegerArray whose elements are the elements of the receiver, in 	the same order."	| intArray |	intArray _ IntegerArray new: self size.	1 to: self size do:[:i| intArray at: i put: (self at: i)].	^intArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'djm 11/20/1998 05:44'!asStringWithCr	"Convert to a string with returns between items.  Elements areusually strings.	 Useful for labels for PopUpMenus."	| labelStream |	labelStream _ WriteStream on: (String new: 200).	self do: [:each |		(each isKindOf: String)			ifTrue: [labelStream nextPutAll: each; cr]			ifFalse: [each printOn: labelStream. labelStream cr]].	self size > 0 ifTrue: [labelStream skip: -1].	^ labelStream contents! !!SequenceableCollection methodsFor: 'converting' stamp: 'ar 10/10/1998 16:20'!asWordArray	"Answer a WordArray whose elements are the elements of the receiver, in 	the same order."	| wordArray |	wordArray _ WordArray new: self size.	1 to: self size do:[:i| wordArray at: i put: (self at: i)].	^wordArray! !!SequenceableCollection methodsFor: 'converting' stamp: 'jm 4/27/98 04:09'!reversed	"Answer a copy of the receiver with element order reversed."	"Example: 'frog' reversed"	| n result src |	n _ self size.	result _ self species new: n.	src _ n + 1.	1 to: n do: [:i | result at: i put: (self at: (src _ src - 1))].	^ result! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 6/1/2000 16:07'!copyEmpty	^ self species new: 0! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 6/1/2000 16:00'!copyUpTo: anElement 	"Answer all elements up to but not including anObject. If there	is no such object, answer a copy of the receiver."	^ self first: (self indexOf: anElement ifAbsent: [^ self copy]) - 1! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 4/22/2000 18:01'!forceTo: length paddingWith: elem	"Force the length of the collection to length, padding	if necessary with elem.  Note that this makes a copy."	| newCollection copyLen |	newCollection _ self species new: length.	copyLen _ self size min: length.	newCollection replaceFrom: 1 to: copyLen with: self startingAt: 1.	newCollection from: copyLen + 1 to: length put: elem.	^ newCollection! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 5/12/2000 12:36'!shuffled	^ self shuffledBy: Collection randomForPicking"Examples:	($A to: $Z) shuffled"! !!SequenceableCollection methodsFor: 'copying' stamp: 'djp 10/23/1999 22:12'!shuffledBy: aRandom	| copy | 	copy _ self shallowCopy.	copy size to: 1 by: -1 do: 		[:i | copy swap: i with: ((1 to: i) atRandom: aRandom)].	^ copy! !!SequenceableCollection methodsFor: 'copying' stamp: 'sma 4/28/2000 18:34'!sortBy: aBlock	"Create a copy that is sorted.  Sort criteria is the block that accepts two arguments.	When the block is true, the first arg goes first ([:a :b | a > b] sorts in descending	order)."	^ (self asSortedCollection: aBlock) asOrderedCollection! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:46'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newCollection |	newCollection _ self species new: self size.	1 to: self size do:		[:index |		newCollection at: index put: (aBlock value: (self at: index))].	^ newCollection! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 6/1/2000 11:47'!collect: aBlock from: firstIndex to: lastIndex	"Refer to the comment in Collection|collect:."	| size result j |	size _ lastIndex - firstIndex + 1.	result _ self species new: size.	j _ firstIndex.	1 to: size do: [:i | result at: i put: (aBlock value: (self at: j)). j _ j + 1].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ar 6/3/2000 15:54'!findBinaryIndex: aBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, raise an error.	Examples:		#(1 3 5 7 11 15 23) findBinaryIndex:[:arg| 11 - arg]	"	^self findBinaryIndex: aBlock ifNone: [self errorNotFound: aBlock]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'ar 6/3/2000 15:54'!findBinaryIndex: aBlock ifNone: exceptionBlock	"Search for an element in the receiver using binary search.	The argument aBlock is a one-element block returning		0 	- if the element is the one searched for		<0	- if the search should continue in the first half		>0	- if the search should continue in the second half	If no matching element is found, evaluate exceptionBlock."	| index low high test |	low _ 1.	high _ self size.	[index _ high + low // 2.	low > high] whileFalse:[		test _ aBlock value: (self at: index).		test = 0 			ifTrue:[^index]			ifFalse:[test > 0				ifTrue: [low _ index + 1]				ifFalse: [high _ index - 1]]].	^exceptionBlock value! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 5/12/2000 18:13'!keysAndValuesDo: aBlock 	"Enumerate the receiver with all the keys (aka indices) and values."	1 to: self size do: [:index | aBlock value: index value: (self at: index)]! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 11/12/1998 15:01'!pairsDo: aBlock 	"Evaluate aBlock with my elements taken two at a time.  If there's an odd number of items, ignore the last one.  Allows use of a flattened array for things that naturally group into pairs.  See also pairsCollect:"	1 to: self size // 2 do:		[:index | aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index)]"#(1 'fred' 2 'charlie' 3 'elmer') pairsDo:	[:a :b | Transcript cr; show: b, ' is number ', a printString]"! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'sma 6/1/2000 16:00'!upTo: anObject	"Deprecated. Use copyUpTo:"	^ self copyUpTo: anObject! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 8/31/1999 13:13'!with: otherCollection collect: twoArgBlock 	"Collect and return the result of evaluating twoArgBlock with corresponding elements from this collection and otherCollection."	| result |	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].	result _ self species new: self size.	1 to: self size do:		[:index | result at: index put:		(twoArgBlock			value: (self at: index)			value: (otherCollection at: index))].	^ result! !!SequenceableCollection methodsFor: 'enumerating' stamp: 'di 8/3/1999 15:26'!with: otherCollection do: twoArgBlock 	"Evaluate twoArgBlock with corresponding elements from this collection and otherCollection."	otherCollection size = self size ifFalse: [self error: 'otherCollection must be the same size'].	1 to: self size do:		[:index |		twoArgBlock value: (self at: index)				value: (otherCollection at: index)]! !!SequenceableCollection methodsFor: 'private' stamp: 'sma 5/12/2000 11:33'!anyOne	^ self first! !!SequentialSound methodsFor: 'accessing' stamp: 'jm 8/17/1998 14:04'!duration	"Answer the duration of this sound in seconds."	| dur |	dur _ 0.	sounds do: [:snd | dur _ dur + snd duration].	^ dur! !!SequentialSound methodsFor: 'composition' stamp: 'jm 4/14/1999 10:05'!pruneFinishedSounds	"Remove any sounds that have been completely played."	| newSnds |	(currentIndex > 1 and: [currentIndex < sounds size]) ifFalse: [^ self].	newSnds _ sounds copyFrom: currentIndex to: sounds size.	currentIndex _ 1.	sounds _ newSnds.! !!SerialPort methodsFor: 'open/close' stamp: 'jm 10/21/2002 15:55'!isOpen	"Return true iff the serial port is open."	"Details: Try to read zero bytes. If the read primitive fails because the port is not open, it will return nil. If the port is open, the primitive will return 0."	| buf n |	port ifNil: [^ false].	buf _ ByteArray new: 1.	n _ self primNoErrorReadPort: port into: buf startingAt: 1 count: 0.	^ n notNil! !!SerialPort methodsFor: 'open/close' stamp: 'jm 1/8/2003 17:28'!openPort: portNumber	"Open the given serial port, using the settings specified by my instance variables."	self		openPort: portNumber		ifFail: [self error: 'could not open serial port ', portNumber printString].! !!SerialPort methodsFor: 'open/close' stamp: 'jm 1/8/2003 17:28'!openPort: portNumber ifFail: failBlock	"Open the given serial port, using the settings specified by my instance variables. If the port cannot be opened, such as when it is alreay in use, return the result of evaluating failBlock."	self close.	self primClosePort: portNumber.	(self primOpenPort: portNumber		baudRate: baudRate		stopBitsType: stopBitsType		parityType: parityType		dataBits: dataBits		inFlowControlType: inputFlowControlType		outFlowControlType: outputFlowControlType		xOnByte: xOnByte		xOffByte: xOffByte) isNil ifTrue: [^ failBlock value].	port _ portNumber.! !!SerialPort methodsFor: 'input/output' stamp: 'jm 1/8/2003 12:55'!flushInputBuffer	"Read and discard bytes until there are no more bytes in the input buffer."	| buf |	buf _ ByteArray new: 1000.	[(self primReadPort: port into: buf startingAt: 1 count: buf size) > 0]		whileTrue: ["keep reading"].! !!SerialPort methodsFor: 'input/output' stamp: 'jm 1/8/2003 12:58'!next: byteCount	"Answer a ByteArray of length byteCount with the next byteCount bytes read from this port. Wait indefinitely until enough bytes arrive."	| buf i count |	buf _ ByteArray new: byteCount.	i _ 1.	[i <= byteCount] whileTrue: [		count _ self readInto: buf startingAt: i.		i _ i + count].	^ buf! !!SerialPort methodsFor: 'input/output' stamp: 'jm 9/23/2000 21:12'!nextPutAll: aStringOrByteArray	"Send the given bytes out this serial port. The port must be open."	^ self primWritePort: port		from: aStringOrByteArray		startingAt: 1		count: aStringOrByteArray size.! !!SerialPort methodsFor: 'input/output' stamp: 'jm 1/8/2003 12:51'!readBytes: byteCount	"Answer a ByteArray of length byteCount with the next byteCount bytes read from this port. Wait indefinitely until byteCount bytes arrive."	| buf i count |	buf _ ByteArray new: byteCount.	i _ 1.	[i <= byteCount] whileTrue: [		count _ self readInto: buf startingAt: i.		i _ i + count].	^ buf! !!SerialPort methodsFor: 'primitives' stamp: 'jm 10/24/2000 17:53'!primClosePort: portNumber	"Try to close the given port. Do nothing if the primitive fails."	<primitive: 239>! !!SerialPort methodsFor: 'primitives' stamp: 'jm 11/1/2003 12:27'!primNewClosePort: portNumber	"Try to close the given port. Do nothing if the primitive fails."	<primitive: 'primClose' module: 'SerialPort2'>! !!SerialPort methodsFor: 'primitives' stamp: 'jm 11/1/2003 12:27'!primNewOpenPort: portNumber baudRate: baud stopBitsType: stop	parityType: parity dataBits: numDataBits	inFlowControlType: inFlowCtrl outFlowControlType: outFlowCtrl	xOnByte: xOn xOffByte: xOff	<primitive: 'primOpen' module: 'SerialPort2'>	^ nil! !!SerialPort methodsFor: 'primitives' stamp: 'jm 10/21/2002 15:43'!primNoErrorReadPort: portNumber into: byteArray startingAt: startIndex count: count	<primitive: 'primitiveSerialPortRead' module: 'SerialPlugin'>	^ nil! !!SerialPort methodsFor: 'primitives' stamp: 'jm 1/8/2003 17:25'!primOpenPort: portNumber baudRate: baud stopBitsType: stop	parityType: parity dataBits: numDataBits	inFlowControlType: inFlowCtrl outFlowControlType: outFlowCtrl	xOnByte: xOn xOffByte: xOff	<primitive: 238>	^ nil! !!SerialPort methodsFor: 'primitives' stamp: 'jm 10/24/2000 22:37'!primReadPort: portNumber into: byteArray startingAt: startIndex count: count	<primitive: 241>	^ 0! !!SerialPort methodsFor: 'primitives' stamp: 'jm 10/24/2000 22:37'!primWritePort: portNumber from: byteArray startingAt: startIndex count: count	<primitive: 240>	^ 0! !!SerialPort class methodsFor: 'as yet unclassified' stamp: 'jm 11/1/2003 12:29'!primPortCount	"Answer the number of available serial ports. Answer 0 if this primitive is not implemented."	"self primPortCount"	<primitive: 'primPortCount' module: 'SerialPort2'>	^ 0! !!SerialPort class methodsFor: 'as yet unclassified' stamp: 'jm 11/1/2003 19:55'!primPortName: portNum	"Answer the number of available serial ports. Answer nil if the port number is out of range or if this primitive is not implemented."	"self primPortName: 3"	<primitive: 'primPortName' module: 'SerialPort2'>	^ nil! !!Set methodsFor: 'adding' stamp: 'sma 5/12/2000 17:28'!add: newObject	"Include newObject as one of the receiver's elements, but only if	not already present. Answer newObject."	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index _ self findElementOrNil: newObject.	(array at: index) ifNil: [self atNewIndex: index put: newObject].	^ newObject! !!Set methodsFor: 'converting' stamp: 'ar 11/20/1998 16:34'!asSet	^self! !!Set methodsFor: 'copying' stamp: 'sma 5/12/2000 14:54'!copy	^ self shallowCopy withArray: array shallowCopy! !!Set methodsFor: 'enumerating' stamp: 'sma 5/12/2000 11:49'!collect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.  	Collect the resulting values into a collection like the receiver. Answer  	the new collection."	| newSet |	newSet _ Set new: self size.	array do: [:each | each ifNotNil: [newSet add: (aBlock value: each)]].	^ newSet! !!Set methodsFor: 'enumerating' stamp: 'sma 5/12/2000 14:36'!do: aBlock 	tally = 0 ifTrue: [^ self].	1 to: array size do:		[:index |		| each |		(each _ array at: index) ifNotNil: [aBlock value: each]]! !!Set methodsFor: 'removing' stamp: 'sma 5/12/2000 14:45'!copyWithout: oldElement 	"Answer a copy of the receiver that does not contain any	elements equal to oldElement."	^ self copy		remove: oldElement ifAbsent: [];		yourself! !!Set methodsFor: 'testing' stamp: 'sma 5/12/2000 14:46'!occurrencesOf: anObject 	^ (self includes: anObject) ifTrue: [1] ifFalse: [0]! !I am a block for setting a variable.!!SetterBlockMorph methodsFor: 'initialization' stamp: 'jm 11/25/2003 13:03'!initialize	super initialize.	isReporter _ false.	isSpecialForm _ false.	isTimed _ false.	wantsName _ true.	wantsPossession _ false.! !!SetterBlockMorph methodsFor: 'accessing' stamp: 'TIS 10/4/2003 13:49'!argumentAt: index	"Returns the argument morph at the given index."	index = 1 ifTrue: [^ VariableArgMorph new variable: variable].	^ argMorphs at: index - 1! !!SetterBlockMorph methodsFor: 'accessing' stamp: 'TIS 10/4/2003 13:48'!argumentCount	"Returns the number of arguments to this command block."	^ 2! !!SetterBlockMorph methodsFor: 'accessing' stamp: 'jm 11/25/2003 13:03'!variable	^ variable! !!SetterBlockMorph methodsFor: 'accessing' stamp: 'jm 11/25/2003 13:04'!variable: aVar	variable _ aVar.	self commandSpec: 'set ', aVar, ' to %n'.	self selector: #set:to:.! !!SetterBlockMorph methodsFor: 'object i/o' stamp: 'jm 12/1/2003 10:52'!fieldsVersion	^ 1! !!SetterBlockMorph methodsFor: 'object i/o' stamp: 'jm 12/1/2003 10:53'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		variable	) from: anObjStream.! !!SetterBlockMorph methodsFor: 'object i/o' stamp: 'jm 12/1/2003 10:56'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		variable	) on: anObjStream.! !I provide synchronized communication of arbitrary objects between Processes. An object is sent by sending the message nextPut: and received by sending the message next. If no object has been sent when a next message is sent, the Process requesting the object will be suspended until one is sent.!!SharedQueue methodsFor: 'private' stamp: 'sma 4/22/2000 18:04'!makeRoomAtEnd	| contentsSize |	readPosition = 1		ifTrue: [contentsArray _ contentsArray , (Array new: 10)]		ifFalse: 			[contentsSize _ writePosition - readPosition.			"BLT direction ok for this. Lots faster!!!!!!!!!!!! SqR!!!! 4/10/2000 10:47"			contentsArray				replaceFrom: 1				to: contentsSize				with: contentsArray				startingAt: readPosition.			readPosition _ 1.			writePosition _ contentsSize + 1]! !I am a simple button with a string label. I can have a target object, selector, and optional argument list so that when I'm activated I can send the target a specific message. I can act either on mouse-down or mouse-up.!!SimpleButtonMorph methodsFor: 'initialization' stamp: 'jm 10/4/2002 08:40'!adaptToWorld: aWorld	super adaptToWorld: aWorld.	target isMorph ifTrue: [		target isWorldMorph ifTrue: [self target: aWorld].		target isHandMorph ifTrue: [self target: aWorld primaryHand]].! !!SimpleButtonMorph methodsFor: 'initialization' stamp: 'di 6/5/2000 09:08'!initialize	self initializeAllButLabel; setDefaultLabel! !!SimpleButtonMorph methodsFor: 'initialization' stamp: 'jm 10/13/2002 17:37'!initializeAllButLabel	super initialize.	self borderWidth: 1.	self cornerStyle: #rounded.	self color: (Color r: 0.4 g: 0.8 b: 0.6).	self borderColor: self color darker.	target _ nil.	actionSelector _ #flash.	arguments _ Array empty.	actWhen _ #buttonUp! !!SimpleButtonMorph methodsFor: 'initialization' stamp: 'di 6/5/2000 09:09'!initializeWithLabel: labelString	self initializeAllButLabel; label: labelString! !!SimpleButtonMorph methodsFor: 'initialization' stamp: 'sw 9/28/1999 14:05'!setDefaultLabel	self label: 'Flash'.! !!SimpleButtonMorph methodsFor: 'menu' stamp: 'jm 12/8/2003 12:01'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	self hasLabel ifTrue: [		aCustomMenu add: 'change label' action: #setLabel].	((self world rootMorphsAt: aHandMorph targetOffset) size > 1) ifTrue: [		aCustomMenu add: 'set target' action: #setTarget:].	aCustomMenu add: 'change action selector' action: #setActionSelector.	aCustomMenu add: 'change arguments' action: #setArguments.	aCustomMenu add: 'change when to act' action: #setActWhen.! !!SimpleButtonMorph methodsFor: 'accessing' stamp: 'jm 11/6/2003 08:23'!fitContents	| oldCenter m |	submorphs size = 0 ifTrue: [^ self].	oldCenter _ self center.	m _ submorphs first.	self extent: m extent + (borderWidth + 6).	self center: oldCenter.	m position: oldCenter - (m extent // 2).! !!SimpleButtonMorph methodsFor: 'accessing' stamp: 'jm 12/8/2003 11:59'!hasLabel	"I have a text label."	^ true! !!SimpleButtonMorph methodsFor: 'accessing' stamp: 'jm 11/6/2003 08:21'!label: aString	self label: aString font: TextStyle defaultFont.! !!SimpleButtonMorph methodsFor: 'accessing' stamp: 'jm 11/6/2003 08:26'!label: aString font: aFont	| oldLabel m |	(oldLabel _ self findA: StringMorph) ifNotNil: [oldLabel delete].	m _ StringMorph contents: aString font: (aFont ifNil: [Preferences standardButtonFont]).	self extent: m extent + (borderWidth + 6).	m position: self center - (m extent // 2).	self addMorph: m.	m lock.! !!SimpleButtonMorph methodsFor: 'accessing' stamp: 'sw 6/11/1999 18:40'!labelString: aString	| existingLabel |	(existingLabel _ self findA: StringMorph)		ifNil:			[self label: aString]		ifNotNil:			[existingLabel contents: aString.			self fitContents]! !!SimpleButtonMorph methodsFor: 'events' stamp: 'di 5/23/2000 16:17'!mouseDown: evt	| now dt |	oldColor _ color.	now _ Time millisecondClockValue.	actWhen == #buttonDown		ifTrue: [self doButtonAction].	dt _ Time millisecondClockValue - now max: 0.  "Time it took to do"	dt < 200 ifTrue: [(Delay forMilliseconds: 200-dt) wait]! !!SimpleButtonMorph methodsFor: 'events' stamp: 'jm 8/11/2003 20:57'!mouseMove: evt	actWhen == #buttonDown ifTrue: [^ self].	(self containsPoint: evt cursorPoint)		ifTrue: [			oldColor ifNotNil: [				self color: (oldColor mixed: 1/2 with: Color white)].			(actWhen == #whilePressed and:			 [evt anyButtonPressed])				 ifTrue: [self doButtonAction]]		ifFalse: [oldColor ifNotNil: [self color: oldColor]].! !!SimpleButtonMorph methodsFor: 'events' stamp: 'sma 4/22/2000 17:29'!mouseUp: evt	oldColor ifNotNil:		["if oldColor nil, it signals that mouse had not gone DOWN		inside me, e.g. because of a cmd-drag; in this case we want		to avoid triggering the action!!"		self color: oldColor.		oldColor _ nil.		(actWhen == #buttonUp and: [self containsPoint: evt cursorPoint])			ifTrue: [self doButtonAction]]! !!SimpleButtonMorph methodsFor: 'object i/o' stamp: 'jm 9/25/2003 09:59'!fieldsVersion	^ 1! !!SimpleButtonMorph methodsFor: 'object i/o' stamp: 'jm 9/25/2003 10:07'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		target		actionSelector		arguments		actWhen	) from: anObjStream.! !!SimpleButtonMorph methodsFor: 'object i/o' stamp: 'jm 9/25/2003 10:07'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		target		actionSelector		arguments		actWhen	) on: anObjStream.! !!SimpleButtonMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:01'!includeInNewMorphMenu	^ true! !!SimpleButtonMorph class methodsFor: 'instance creation' stamp: 'di 6/5/2000 08:42'!newWithLabel: labelString	^ self basicNew initializeWithLabel: labelString! !This class supports client for simple network protocols based on sending textual commands and responses. Examples of such protocols include POP3 (mail retrieval), SMTP (mail posting), HTTP (web browsing), and NTTP (network news). Some simple examples are presented as class methods, but a full-service client of some service should be implemented as a subclass.The basic services provided by this class are:	sendCommand:			-- sends a command line terminate with <CR><LF>	getResponse				-- gets a single-line response to a command	getMultilineResponse	-- gets a multiple line response terminated by a period							-- on a line by itselfThere are variants of the getResponse commands that display lines on the screen as they are being received. Linefeeds are stripped out of all responses.The 'get' commands above make use of an internal buffer.  So intermixing these two commands and regular Socket recieve commands can cause problems.!!SimpleClientSocket methodsFor: 'as yet unclassified' stamp: 'di 4/13/1999 14:43'!displayString: aString	"Display the given string on the Display. Used for testing."	| s |	aString isEmpty ifTrue: [^ self].	aString size > 60		ifTrue: [s _ aString copyFrom: 1 to: 60]  "limit to 60 characters"		ifFalse: [s _ aString].	s displayOn: Display.! !!SimpleClientSocket methodsFor: 'as yet unclassified' stamp: 'ls 9/11/1998 03:34'!getMultilineResponseShowing: showFlag	"Get a multiple line response to the last command. A multiple line response ends with a line containing only a single period (.) character. Linefeed characters are filtered out. If showFlag is true, each line is shown in the upper-left corner of the Display as it is received."	| response done chunk |	response _ WriteStream on: ''.	done _ false.	[done] whileFalse: [		showFlag			ifTrue: [chunk _ self getResponseShowing: true]			ifFalse: [chunk _ self getResponse].		(chunk beginsWith: '.')			ifTrue: [ response nextPutAll: (chunk copyFrom: 2 to: chunk size) ]			ifFalse: [ response nextPutAll: chunk ].		done _ (chunk = ('.', String cr)) ].	^ response contents! !!SimpleClientSocket methodsFor: 'as yet unclassified' stamp: 'ls 9/11/1998 02:10'!getResponse	"Get a one-line response from the server.  The final LF is removed from the line, but the CR is left, so that the line is in Squeak's text format"	^ self getResponseShowing: false! !!SimpleClientSocket methodsFor: 'as yet unclassified' stamp: 'ls 9/11/1998 03:27'!getResponseShowing: showFlag	| line idx |	line _ WriteStream on: String new.	buffer ifNil: [		buffer _ String new.		bufferPos _ 0 ].	[		"look for a LF in the buffer"		idx _ buffer indexOf: Character lf startingAt: bufferPos+1 ifAbsent: [ 0 ].		idx > 0 ifTrue: [			"found it!! we have a line"			line nextPutAll: (buffer copyFrom: bufferPos+1 to: idx-1).			bufferPos _ idx.			^line contents ].				"didn't find it.  add the whole buffer to the line, and retrieve some more data"		line nextPutAll: (buffer copyFrom: bufferPos+1 to: buffer size).		bufferPos _ 0.		buffer _ String new.		self waitForDataQueryingUserEvery: 30.		buffer _ self getData.		true	] whileTrue.! !!SimpleClientSocket methodsFor: 'as yet unclassified' stamp: 'jm 9/16/1998 14:37'!waitForDataQueryingUserEvery: seconds	"Wait for data to arrive, asking the user periodically if they wish to keep waiting. If they don't wish to keep waiting, destroy the socket and raise an error."	| gotData |	gotData _ false.	[gotData]		whileFalse: [			gotData _ self waitForDataUntil: (Socket deadlineSecs: seconds).			gotData ifFalse: [				self isConnected ifFalse: [					self destroy.					self error: 'server closed connection'].				(self confirm: 'server not responding; keep trying?')					ifFalse: [						self destroy.						self error: 'no response from server']]].! !!SimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'di 4/13/1999 14:42'!remoteCursorReceiver	"Wait for a connection, then display data sent by the client until the client closes the stream. This server process is usually started first (optionally in a forked process), then the sender process is started (optionally on another machine). Note this machine's address, which is printed in the transcript, since the sender process will ask for it."	"[SimpleClientSocket remoteCursorReceiver] fork"	| sock response |	Transcript show: 'starting remote cursor receiver'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork.	Transcript show: 'my address is ', NetNameResolver localAddressString; cr.	Transcript show: 'opening connection'; cr.	sock _ SimpleClientSocket new.	sock listenOn: 54323.	sock waitForConnectionUntil: (Socket deadlineSecs: 60).	sock isConnected		ifFalse: [			 sock destroy.			Transcript show: 'remote cursor receiver did not receive a connection in 60 seconds; aborting.'.			^ self].	Transcript show: 'connection established'; cr.	[sock isConnected]		whileTrue: [			sock dataAvailable				ifTrue: [					response _ sock getResponse.					response displayOn: Display at: 10@10]				ifFalse: [					"if no data available, let other processes run for a while"					(Delay forMilliseconds: 20) wait]].	sock destroy.	Transcript show: 'remote cursor receiver done'; cr.! !!SimpleClientSocket class methodsFor: 'remote cursor example' stamp: 'di 4/13/1999 14:43'!remoteCursorTest	"This version of the remote cursor test runs both the client and the server code in the same loop."	"SimpleClientSocket remoteCursorTest"	| sock1 sock2 samplesToSend samplesSent done t |	Transcript show: 'starting remote cursor test'; cr.	Transcript show: 'initializing network'; cr.	Socket initializeNetwork.	Transcript show: 'opening connection'; cr.	sock1 _ SimpleClientSocket new.	sock2 _ SimpleClientSocket new.	sock1 listenOn: 54321.	sock2 connectTo: (NetNameResolver localHostAddress) port: 54321.	sock1 waitForConnectionUntil: self standardDeadline.	sock2 waitForConnectionUntil: self standardDeadline.	(sock1 isConnected) ifFalse: [self error: 'sock1 not connected'].	(sock2 isConnected) ifFalse: [self error: 'sock2 not connected'].	Transcript show: 'connection established'; cr.	samplesToSend _ 100.	t _ Time millisecondsToRun: [		samplesSent _ 0.		done _ false.		[done]			whileFalse: [				(sock1 sendDone and: [samplesSent < samplesToSend]) ifTrue: [					sock1 sendCommand: self sensorStateString.					samplesSent _ samplesSent + 1].				sock2 dataAvailable ifTrue: [					sock2 getResponse displayOn: Display at: 10@10].				done _ samplesSent = samplesToSend]].	sock1 destroy.	sock2 destroy.	Transcript show: 'remote cursor test done'; cr.	Transcript show:		samplesSent printString, ' samples sent in ',		t printString, ' milliseconds'; cr.	Transcript show: ((samplesSent * 1000) // t) printString, ' samples/sec'; cr.! !!SimpleClientSocket class methodsFor: 'other examples' stamp: 'jm 6/8/1998 16:05'!httpTestHost: hostName port: port url: url	"This test fetches a URL from the given host and port."	"SimpleClientSocket httpTestHost: 'www.disney.com' port: 80 url: '/'"	"Tests URL fetch through a local HTTP proxie server:		(SimpleClientSocket			httpTestHost: '127.0.0.1'			port: 8080			url: 'HTTP://www.exploratorium.edu/index.html')"	| hostAddr s result buf bytes totalBytes t |	Transcript cr; show: 'starting http test'; cr.	Socket initializeNetwork.	hostAddr _ NetNameResolver addressForName: hostName timeout: 10.	hostAddr = nil ifTrue: [^ self inform: 'Could not find an address for ', hostName].	s _ SimpleClientSocket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: hostAddr port: port.	s waitForConnectionUntil: "self standardDeadline" (Socket deadlineSecs: 10).	(s isConnected) ifFalse: [		s destroy.		^ self inform: 'could not connect'].	Transcript show: 'connection open; waiting for data'; cr.	s sendCommand: 'GET ', url, ' HTTP/1.0'.	s sendCommand: 'User-Agent: Squeak 1.19'.	s sendCommand: 'ACCEPT: text/html'.	"always accept plain text"	s sendCommand: 'ACCEPT: application/octet-stream'.  "also accept binary data"	s sendCommand: ''.  "blank line"	result _ WriteStream on: (String new: 10000).	buf _ String new: 10000.	totalBytes _ 0.	t _ Time millisecondsToRun: [		[s isConnected] whileTrue: [			s waitForDataUntil: (Socket deadlineSecs: 5).			bytes _ s receiveDataInto: buf.			1 to: bytes do: [:i | result nextPut: (buf at: i)].			totalBytes _ totalBytes + bytes.			Transcript show: totalBytes printString, ' bytes received'; cr]].	s destroy.	Transcript show: '---------- Connection Closed ----------'; cr; endEntry.	Transcript show: 'http test done; ', totalBytes printString, ' bytes read in '.	Transcript show: ((t / 1000.0) roundTo: 0.01) printString, ' seconds'; cr.	Transcript show: ((totalBytes asFloat / t) roundTo: 0.01) printString, ' kBytes/sec'; cr.	Transcript endEntry.	(StringHolder new contents: (result contents))		openLabel: 'HTTP Test Result: URL Contents'.! !This is a first cut at a simple MIDI output port.!!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 1/13/1999 08:10'!close	"Close this MIDI port."	portNumber ifNotNil: [self primMIDIClosePort: portNumber].	accessSema _ nil.	lastCommandByteOut _ nil.! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 1/13/1999 08:23'!ensureOpen	"Make sure this MIDI port is open. It is good to call this before starting to use a port in case an intervening image save/restore has caused the underlying hardware port to get closed."	portNumber ifNil: [^ self error: 'Use "openOn:" to open a MIDI port initially'].	self primMIDIClosePort: portNumber.	self primMIDIOpenPort: portNumber readSemaIndex: 0 interfaceClockRate: InterfaceClockRate.	accessSema _ Semaphore forMutualExclusion.	lastCommandByteOut _ Array new: 16 withAll: 0.  "clear running status"! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 1/13/1999 08:09'!openOnPortNumber: portNum	"Open this MIDI port on the given port number."	self close.	portNumber _ portNum.	accessSema _ Semaphore forMutualExclusion.	self ensureOpen.! !!SimpleMIDIPort methodsFor: 'open/close' stamp: 'jm 10/12/1998 15:48'!portNumber	"Answer my port number."	^ portNumber! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/28/1998 22:00'!midiCmd: cmd channel: channel byte: dataByte	"Immediately output the given MIDI command with the given channel and argument byte to this MIDI port. Assume that the port is open."	accessSema critical: [		self primMIDIWritePort: portNumber			from: (ByteArray					with: (cmd bitOr: channel)					with: dataByte)			at: 0].! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/28/1998 22:00'!midiCmd: cmd channel: channel byte: dataByte1 byte: dataByte2	"Immediately output the given MIDI command with the given channel and argument bytes to this MIDI port. Assume that the port is open."	accessSema critical: [		self primMIDIWritePort: portNumber			from: (ByteArray					with: (cmd bitOr: channel)					with: dataByte1					with: dataByte2)			at: 0].! !!SimpleMIDIPort methodsFor: 'output' stamp: 'jm 9/28/1998 22:00'!midiOutput: aByteArray	"Output the given bytes to this MIDI port immediately. Assume that the port is open."	accessSema critical: [		self primMIDIWritePort: portNumber from: aByteArray at: 0].! !!SimpleMIDIPort methodsFor: 'input' stamp: 'jm 10/8/1998 19:47'!bufferTimeStampFrom: aByteArray	"Return the timestamp from the given MIDI input buffer. Assume the given buffer is at least 4 bytes long."	^ ((aByteArray at: 1) bitShift: 24) +	  ((aByteArray at: 2) bitShift: 16) +	  ((aByteArray at: 3) bitShift: 8) +	   (aByteArray at: 4)! !!SimpleMIDIPort methodsFor: 'input' stamp: 'jm 10/8/1998 19:53'!flushInput	"Read any lingering MIDI data from this port's input buffer."	| buf |	buf _ ByteArray new: 1000.	[(self readInto: buf) > 0] whileTrue.! !!SimpleMIDIPort methodsFor: 'input' stamp: 'jm 10/12/1998 15:49'!readInto: aByteArray	"Read any data from this port into the given buffer."	^ self primMIDIReadPort: portNumber into: aByteArray! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 10/12/1998 16:04'!primMIDIClosePort: portNum	"Close the given MIDI port. Don't fail if port is already closed."	<primitive: 521>! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 9/10/1998 15:11'!primMIDIOpenPort: portNum readSemaIndex: readSemaIndex interfaceClockRate: interfaceClockRate	"Open the given MIDI port. If non-zero, readSemaIndex specifies the index in the external objects array of a semaphore to be signalled when incoming MIDI data is available. Not all platforms support signalling the read semaphore. InterfaceClockRate specifies the clock rate of the external MIDI interface adaptor on Macintosh computers; it is ignored on other platforms."	<primitive: 526>	self primitiveFailed.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 10/8/1998 19:48'!primMIDIReadPort: portNum into: byteArray	"Read any available MIDI data into the given buffer (up to the size of the buffer) and answer the number of bytes read."	<primitive: 528>	self primitiveFailed.! !!SimpleMIDIPort methodsFor: 'primitives' stamp: 'jm 10/8/1998 19:49'!primMIDIWritePort: portNum from: byteArray at: midiClockValue	"Queue the given data to be sent through the given MIDI port at the given time. If midiClockValue is zero, send the data immediately."	<primitive: 529>	self primitiveFailed.! !!SimpleMIDIPort class methodsFor: 'class initialization' stamp: 'jm 9/10/1998 15:33'!initialize	"SimpleMIDIPort initialize"	InterfaceClockRate _ 1000000.	DefaultPortNumber _ 0.! !!SimpleMIDIPort class methodsFor: 'instance creation' stamp: 'jm 9/10/1998 18:36'!openDefault	"Answer a new instance of me opened on the default MIDI port."	^ self openOnPortNumber: DefaultPortNumber! !!SimpleMIDIPort class methodsFor: 'instance creation' stamp: 'tk 6/24/1999 11:42'!openOnPortNumber: portNum	"Answer a new instance of me for the given MIDI port number."	"Details: All clients of a particular MIDI port should share the same instance of me. This allows accesses to the port to be serialized and shared port-related state state to be maintained."	SimpleMIDIPort allSubInstancesDo: [:p |		p portNumber = portNum ifTrue: [			"share the existing port object for this port number"			^ p]].	^ super new openOnPortNumber: portNum! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 1/13/1999 08:11'!closeAllPorts	"Close all MIDI ports."	"SimpleMIDIPort closeAllPorts"	| lastPortNum |	lastPortNum _ self primPortCount - 1.	0 to: lastPortNum do: [:portNum | self basicNew primMIDIClosePort: portNum].! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 17:57'!inputPortNumFromUser	"Prompt the user for a MIDI input port. Answer a port number, or nil if the user does not select a port or if MIDI is not supported on this platform."	"SimpleMIDIPort inputPortNumFromUser"	| portCount aMenu dir |	portCount _ self primPortCount.	portCount = 0 ifTrue: [^ nil].	aMenu _ CustomMenu new title: 'MIDI port for input:'.	0 to: portCount - 1 do:[:i |		dir _ self primPortDirectionalityOf: i.		(dir = 1) | (dir = 3) ifTrue:[			aMenu add: (self portDescription: i) action: i]].	 ^ aMenu startUp! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 18:10'!midiIsSupported	"Answer true if this platform supports MIDI."	^ self primPortCount > 0! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 17:58'!outputPortNumFromUser	"Prompt the user for a MIDI output port. Answer a port number, or nil if the user does not select a port or if MIDI is not supported on this platform."	"SimpleMIDIPort outputPortNumFromUser"	| portCount aMenu dir |	portCount _ self primPortCount.	portCount = 0 ifTrue: [^ nil].	aMenu _ CustomMenu new title: 'MIDI port for output:'.	0 to: portCount - 1 do:[:i |		dir _ self primPortDirectionalityOf: i.		(dir = 2) | (dir = 3) ifTrue:[			aMenu add: (self portDescription: i) action: i]].	 ^ aMenu startUp! !!SimpleMIDIPort class methodsFor: 'utilities' stamp: 'jm 10/12/1998 17:46'!portDescription: portNum	"Answer a string indicating the directionality of the given MIDI port."	"(0 to: SimpleMIDIPort primPortCount - 1) collect:		[:i | SimpleMIDIPort portDescription: i]"	| portName dir |	portName _ self primPortNameOf: portNum.	dir _ self primPortDirectionalityOf: portNum.	dir = 1 ifTrue: [^ portName, ' (in)'].	dir = 2 ifTrue: [^ portName, ' (out)'].	dir = 3 ifTrue: [^ portName, ' (in/out)'].	^ self error: 'unknown MIDI port directionality'! !!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'jm 10/12/1998 17:22'!primPortCount	"Answer the number of MIDI ports supported by this platform, or zero if this primitive is not implemented."	<primitive: 523>	^ 0! !!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'jm 10/12/1998 17:27'!primPortDirectionalityOf: portNum	"Answer the platform-specific name for the given MIDI port."	<primitive: 524>	self primitiveFailed.! !!SimpleMIDIPort class methodsFor: 'primitives' stamp: 'jm 10/12/1998 17:23'!primPortNameOf: portNum	"Answer the platform-specific name for the given MIDI port."	<primitive: 525>	self primitiveFailed.! !I'm a simple slider. I can be either vertical or horizontal, depending on which dimensions is larger.I know my max and min values and I can optionally truncate the values I provide to my target.I have a target object, selector, and optional argument list so that as I'm dragged I can send my target a specific message with the new slider value.!!SimpleSliderMorph methodsFor: 'initialization' stamp: 'jm 8/4/2003 14:36'!initialize	sliderThickness _ 7.	super initialize.	target _ nil.	arguments _ Array empty.	minVal _ 0.0.	maxVal _ 1.0.	truncate _ false.! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 8/4/2003 11:47'!sliderThickness		^ sliderThickness! !!SimpleSliderMorph methodsFor: 'accessing' stamp: 'jm 8/4/2003 11:47'!sliderThickness: aNumber		sliderThickness _ aNumber asFloat truncated.! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'sw 3/12/2000 11:39'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'set action selector' action: #setActionSelector.	aCustomMenu add: 'change arguments' action: #setArguments.	aCustomMenu add: 'set minimum value' action: #setMinVal.	aCustomMenu add: 'set maximum value' action: #setMaxVal.	aCustomMenu addUpdating: #descendingString action: #toggleDescending.	aCustomMenu addUpdating: #truncateString action: #toggleTruncate.	((self world rootMorphsAt: aHandMorph targetOffset) size > 1) ifTrue: [		aCustomMenu add: 'set target' action: #setTarget:].	target ifNotNil: [		aCustomMenu add: 'clear target' action: #clearTarget].! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'sw 3/12/2000 11:38'!descendingString	^ self descending		ifTrue:			['switch to ascending']		ifFalse:			['switch to descending']! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'sw 3/6/2000 17:13'!setMinVal: newMinVal	minVal _ newMinVal asNumber.	maxVal _ maxVal max: minVal! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'sw 3/12/2000 11:40'!toggleDescending	descending _ self descending not! !!SimpleSliderMorph methodsFor: 'menu' stamp: 'sw 3/12/2000 18:37'!truncateString	^ truncate		ifTrue:			['turn off truncation']		ifFalse:			['turn on truncation']! !!SimpleSliderMorph methodsFor: 'object i/o' stamp: 'jm 9/25/2003 11:44'!fieldsVersion	^ 1! !!SimpleSliderMorph methodsFor: 'object i/o' stamp: 'jm 9/25/2003 11:51'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		target		arguments		minVal		maxVal		truncate		sliderThickness	) from: anObjStream.! !!SimpleSliderMorph methodsFor: 'object i/o' stamp: 'jm 9/25/2003 11:51'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		target		arguments		minVal		maxVal		truncate		sliderThickness	) on: anObjStream.! !!SimpleSliderMorph methodsFor: 'private' stamp: 'TIS 7/11/2003 08:53'!adjustToValue: aNumber	| divisor |	"Adjust the position of this slider to correspond to the given value in the range minVal..maxVal."	"Details: Internal values are normalized to the range 0..1."	maxVal = minVal		ifTrue: [divisor _  0.0001] "handles division by 0"		ifFalse: [divisor _ maxVal - minVal].	self value:		(aNumber - minVal) asFloat / divisor.! !!SimpleSliderMorph methodsFor: 'private' stamp: 'sw 3/12/2000 11:48'!getScaledValue	| aValue |	aValue _ (value * (maxVal - minVal)) + minVal.	^ truncate ifTrue: [aValue truncated] ifFalse: [aValue]! !!SimpleSliderMorph methodsFor: 'private' stamp: 'sw 3/6/2000 17:19'!setMaxVal: newMaxVal	maxVal _ newMaxVal asNumber.	minVal _ maxVal min: minVal! !!SimpleSliderMorph methodsFor: 'private' stamp: 'sw 3/8/2000 16:22'!setScaledValue: aNumber	| denom |	(denom _ maxVal - minVal) > 0		ifTrue:			[self setValue: (aNumber - minVal) / denom]		ifFalse:			[self setValue: maxVal]	"If minVal = maxVal, that value is the only one this (rather unuseful!!) slider can bear"! !!SimpleSliderMorph methodsFor: 'private' stamp: 'sw 3/12/2000 11:54'!truncate	^ truncate == true! !!SimpleSliderMorph methodsFor: 'private' stamp: 'sw 3/12/2000 11:53'!truncate: aBoolean	truncate _ aBoolean! !!SimpleSliderMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:04'!includeInNewMorphMenu	^ true! !I should perhaps be called 'ToggleButton' morph because I can be used to toggle some target setting between on and off.!!SimpleSwitchMorph methodsFor: 'as yet unclassified' stamp: 'di 6/5/2000 08:44'!initialize	^ self initializeWithLabel: 'Toggle'! !!SimpleSwitchMorph methodsFor: 'as yet unclassified' stamp: 'di 6/5/2000 08:43'!initializeWithLabel: labelString	super initializeWithLabel: labelString.	self borderWidth: 3.	self extent: self extent + 2.	onColor _ Color r: 1.0 g: 0.6 b: 0.6.	offColor _ Color lightGray.! !!SimpleSwitchMorph class methodsFor: 'as yet unclassified' stamp: 'jm 5/31/2003 20:05'!includeInNewMorphMenu	^ true! !I am a subclass of WaveEditor with fewer buttons and menu commands.!!SimpleWaveEditor methodsFor: 'all' stamp: 'jm 6/15/2003 19:44'!addControls	| slider b r m |	b _ SimpleButtonMorph new target: self; borderColor: Color black; useSquareCorners.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'X';						actionSelector: #delete).	r addMorphBack: (b fullCopy label: 'Menu'; actWhen: #buttonDown;																actionSelector: #invokeMenu).	r addMorphBack: (b fullCopy label: 'Play';					actionSelector: #play).	r addMorphBack: (b fullCopy label: 'Play Before Cursor';		actionSelector: #playBeforeCursor).	r addMorphBack: (b fullCopy label: 'Play After Cursor';		actionSelector: #playAfterCursor).	r addMorphBack: (b fullCopy label: 'Save to File';			actionSelector: #saveToFile).	self addMorphBack: r.	r _ AlignmentMorph newRow.	r color: self color; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #rigid; extent: 5@20; centering: #center.	m _ StringMorph new contents: 'Cursor: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #cursor; putSelector: #cursor:;		growable: false; width: 50; step.	r addMorphBack: m.	m _ Morph new color: r color; extent: 15@5.  "spacer"	r addMorphBack: m.	m _ StringMorph new contents: 'Value: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #valueAtCursor; putSelector: #valueAtCursor:;		growable: false; width: 50; step.	r addMorphBack: m.	m _ Morph new color: r color; extent: 15@5.  "spacer"	r addMorphBack: m.	slider _ SimpleSliderMorph new		color: color;		extent: 200@2;		target: self;		actionSelector: #scrollTime:.	r addMorphBack: slider.	self addMorphBack: r.! !!SimpleWaveEditor methodsFor: 'all' stamp: 'jm 6/15/2003 19:30'!addLoopPointControls	"Do nothing..."! !!SimpleWaveEditor methodsFor: 'all' stamp: 'jm 6/15/2003 20:32'!invokeMenu	"Invoke a menu of additonal functions for this WaveEditor."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('show envelope'			showEnvelope)		-		('trim before cursor'		trimBeforeCursor)		('trim after cursor'			trimAfterCursor)		-		('add to instrument library'	saveInstrument)		('delete instrument'			deleteInstrument)		-		('save to file'				saveToFile)		('read from file'			readFromFile)).	aMenu invokeOn: self defaultSelection: nil.! !!SimpleWaveEditor class methodsFor: 'instance creation' stamp: 'jm 6/15/2003 19:23'!includeInNewMorphMenu	^ true! !I represent a color bitmapped image that can be rotated, scaled, and edited using the PaintBox (SketchEditorMorph and PaintBoxMorph).originalForm holds the original bitmap, before any rotation or scaling. rotatedForm is cache of the rotated and scaled version of originalForm.rotationCenter is the center of rotation in originalForm. When the rotation or scaling is changed, the system keeps the location of the rotation center on the screen fixed. Thus, rotation centers can be used as the registration points for a sequence of instance of me representing animation frames.rotationStyle has several possible values:	normal		continuous rotation	leftRight	rotatation with an x component < 0, flip bitmap around the y-axis, otherwise it is not rotated	upDown		rotatation with an y component < 0, flip bitmap around the x-axis, otherwise it is not rotated	none		never rotate!!SketchMorph methodsFor: 'initialization' stamp: 'jm 12/9/2003 17:49'!initialize	^ self initializeWith: ImageMorph defaultForm! !!SketchMorph methodsFor: 'initialization' stamp: 'jm 1/11/2003 09:46'!initializeWith: aForm	super initialize.	originalForm _ aForm.	rotationCenter _ aForm extent // 2.	"relative to the top-left corner of the Form"	rotationDegrees _ 0.0.				"clockwise angle of rotation"	rotationStyle _ #normal.				"#normal, #leftRight, #upDown, or #none"	scalePoint _ 1.0@1.0.	rotatedForm _ originalForm.			"cached rotated/scaled copy of originalForm"	offsetWhenRotated _ 0@0.			"offset for rotated form"	self extent: originalForm extent.! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 8/22/2003 20:42'!rotationDegrees: angleInDegrees	rotationDegrees ~= angleInDegrees ifTrue: [		rotationDegrees _ angleInDegrees \\ 360.0.		self layoutChanged].! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 8/22/2003 20:42'!rotationDegrees: newRotationDegrees scalePoint: newScalePoint	((newRotationDegrees ~= rotationDegrees) or:	 [scalePoint ~= newScalePoint]) ifTrue: [		rotationDegrees _ newRotationDegrees \\ 360.0.		scalePoint _ newScalePoint.		self layoutChanged].! !!SketchMorph methodsFor: 'accessing' stamp: 'jm 10/15/2002 16:08'!rotationStyle: aSymbol	"Set my rotation style to #normal, #leftRight, #upDown, or #none. Styles mean:		#normal		-- continuous 360 degree rotation		#leftRight		-- quantize angle to left or right facing		#upDown		-- quantize angle to up or down facing		#none			-- do not rotate"	| oldStyle |	oldStyle _ rotationStyle.	rotationStyle _ aSymbol.	((aSymbol = #normal) and: [oldStyle ~= #normal]) ifTrue: [self rotationDegrees: 0.0].	self layoutChanged.! !!SketchMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:07'!drawOn: aCanvas	aCanvas paintImage: self rotatedForm at: bounds origin.! !!SketchMorph methodsFor: 'drawing' stamp: 'jm 5/29/2003 18:03'!generateRotatedForm	"Compute my rotatedForm and offsetWhenRotated."	| adjustedAngle smoothPix pair |	(rotationStyle = #normal)		ifTrue: [adjustedAngle _ rotationDegrees]  "smooth rotation"		ifFalse: [adjustedAngle _ 0.0].  "leftRight, upDown, none"	((adjustedAngle = 0.0) and: [1.0@1.0 = scalePoint])		ifTrue: [  "no rotation or scaling; use original"			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0]		ifFalse: [  "generated rotated and/or scaled form"			((scalePoint x < 1.0) or: [scalePoint y < 1.0])				ifTrue: [smoothPix _ 2]				ifFalse: [smoothPix _ 1].			pair _ WarpBlt				rotate: originalForm				degrees: adjustedAngle negated				center: rotationCenter				scaleBy: self scalePoint				smoothing: smoothPix.			rotatedForm _ pair first.			offsetWhenRotated _ pair last].	((rotationStyle = #leftRight) and: [rotationDegrees < 0.0]) ifTrue: [		"headed left; use flipped"		rotatedForm _ rotatedForm flipBy: #horizontal centerAt: 0@0.		offsetWhenRotated _ offsetWhenRotated + 			(((2 * (rotationCenter x - (originalForm width // 2)))@0) * scalePoint).		^ self].	((rotationStyle = #upDown) and: [(rotationDegrees > 90.0) or: 		[rotationDegrees < -90.0]]) ifTrue: [			"headed down; use flipped"			rotatedForm _ rotatedForm flipBy: #vertical centerAt: 0@0.			offsetWhenRotated _ offsetWhenRotated + 				((0@(2 * (rotationCenter y - (originalForm height // 2)))) * scalePoint).			^ self].! !!SketchMorph methodsFor: 'menu' stamp: 'jm 10/1/2003 20:18'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'grab from screen' action: #grabFromScreen.	aCustomMenu add: 'read from file' action: #readFromFile.	aCustomMenu addLine.	aCustomMenu add: 'save as BMP' action: #saveAsBMP.	aCustomMenu add: 'save as GIF' action: #saveAsGIF.	aCustomMenu add: 'save as JPEG' action: #saveAsJPEG.	aCustomMenu addLine.	aCustomMenu add: 'set rotation center' action: #setRotationCenter.	aCustomMenu add: 'set rotation style' action: #setRotationStyle.	aCustomMenu add: 'erase pixels of color' action: #erasePixelsOfColor:.	aCustomMenu add: 'recolor of pixels of color' action: #recolorPixelsOfColor:.	aCustomMenu addLine.	aCustomMenu add: 'repaint' action: #editDrawing.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 12/9/2003 18:17'!editDrawing	"Edit my original form with the paint editor."	| myPaint |	self world abandonAllHalos; displayWorld.	myPaint _ MyPaintFrame new.	owner addMorph: myPaint.	myPaint withStartingObject: self.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 6/18/1999 17:00'!erasePixelsOfColor: evt	| c r |	c _ evt hand chooseColor.	originalForm mapColor: c to: Color transparent.	r _ originalForm rectangleEnclosingPixelsNotOfColor: Color transparent.	self form: (originalForm copy: r).! !!SketchMorph methodsFor: 'menu' stamp: 'jm 11/13/2002 10:55'!grabFromScreen	self form: Form fromUser.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 8/3/2003 16:06'!readFromFile	| result fileName |	result _ StandardFileMenu oldFileExtensions: #(jpg jpeg gif bmp png).	result ifNil: [^ self].	fileName _ result directory pathName, FileDirectory slash, result name.	self form: (Form fromFileNamed: fileName).! !!SketchMorph methodsFor: 'menu' stamp: 'jm 10/1/2003 20:19'!saveAsBMP	| formToSave  fileName |	formToSave _ originalForm asFormOfDepth: 32.	fileName _ FillInTheBlank request: 'File name?'.	fileName size = 0 ifTrue: [^ self].	(fileName asLowercase endsWith: '.bmp') ifFalse: [		fileName _ fileName, '.bmp'].	formToSave writeBMPfileNamed: fileName.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 6/5/2003 22:29'!saveAsGIF	| formToSave  fileName |	formToSave _ originalForm.	formToSave depth > 8 ifTrue: [		formToSave _ originalForm colorReduced.		formToSave depth > 8 ifTrue: [			(self confirm:'Saving as GIF will reduce to 8-bit colorwith some loss of quality. Continue?') ifFalse: [^ self].			formToSave _ originalForm asFormOfDepth: 8]].	fileName _ FillInTheBlank request: 'File name?'.	fileName size = 0 ifTrue: [^ self].	(fileName asLowercase endsWith: '.gif') ifFalse: [		fileName _ fileName, '.gif'].	GIFReadWriter putForm: formToSave onFileNamed: fileName.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 6/5/2003 22:39'!saveAsJPEG	"Save my originalForm in JPEG format. Convert to 16-bit color if necessary."	| formToSave quality fileName bytes f |	formToSave _ originalForm.	formToSave depth < 16 ifTrue: [		formToSave _ originalForm asFormOfDepth: 16].	quality _ FillInTheBlank request: 'JPEG Quality (1-100):' initialAnswer: '50'.	((quality size = 0) or: [quality first isDigit not]) ifTrue: [^ self].	fileName _ FillInTheBlank request: 'File name?'.	fileName size = 0 ifTrue: [^ self].	(fileName asLowercase endsWith: '.jpg') ifFalse: [		fileName _ fileName, '.jpg'].	bytes _ FastJPEG compress: formToSave quality: quality asNumber.	f _ (FileStream newFileNamed: fileName) binary.	f nextPutAll: bytes; close.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 1/11/2003 09:24'!setRotationCenter	"Interactively set the rotation center in my original form."	| w p oldRotation oldScale |	(w _ self world) ifNil: [^ self].	"undo current rotation and scale..."	oldRotation _ rotationDegrees.	oldScale _ scalePoint.	self rotationDegrees: 0.0 scalePoint: 1.0@1.0.	w displayWorldSafely.	Cursor crossHair showWhile: [p _ Sensor waitButton].	Sensor waitNoButton.	self rotationCenter: (self transformFromWorld globalPointToLocal: p) - bounds origin.	"restore old rotation and scale:"	self rotationDegrees: oldRotation scalePoint: oldScale.! !!SketchMorph methodsFor: 'menu' stamp: 'jm 6/15/2003 10:44'!setRotationStyle	| menu newStyle |	menu _ CustomMenu new.	#('rotate smoothly' 'left-right flip only' 'up-down flip only' 'don''t rotate')		with: #(normal leftRight upDown none)		 do: [:name :action | menu add: name action: action].	newStyle _ menu startUp.	newStyle ifNotNil: [self rotationStyle: newStyle].! !!SketchMorph methodsFor: 'change reporting' stamp: 'jm 1/11/2003 08:58'!layoutChanged	"Update rotatedForm and offsetWhenRotated and compute new bounds."	| unrotatedOrigin |	self changed.	unrotatedOrigin _ bounds origin - offsetWhenRotated.	(rotationStyle == #none and: [scalePoint = (1.0@1.0)])		ifTrue: [			"zero rotation and scale; use original Form"			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0]		ifFalse: [self generateRotatedForm].	"changes offsetWhenRotated"	bounds _ (unrotatedOrigin + offsetWhenRotated) extent: rotatedForm extent.	super layoutChanged.	self changed.! !!SketchMorph methodsFor: 'other' stamp: 'jm 12/9/2003 18:14'!editedForm: aForm	"Accept a new form after editing."	originalForm _ aForm.	self layoutChanged.! !!SketchMorph methodsFor: 'other' stamp: 'jm 10/14/2002 09:15'!isColorable	^ false! !!SketchMorph methodsFor: 'other' stamp: 'jm 12/9/2003 18:05'!isPaintable	"Answer true if my image can be repainted."	^ true! !!SketchMorph methodsFor: 'other' stamp: 'jm 10/15/2002 15:56'!releaseCachedState	"Clear cache of rotated, scaled Form."	super releaseCachedState.	rotatedForm _ nil.	originalForm hibernate.! !!SketchMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:03'!includeInNewMorphMenu	^ true! !!SketchMorph class methodsFor: 'instance creation' stamp: 'jm 1/11/2003 09:41'!withForm: aForm	"Note: 'SketchMorph withForm: f' is faster than 'SketchMorph new form: f'."	^ self basicNew initializeWith: aForm! !!Slider methodsFor: 'initialize' stamp: 'sw 3/10/2000 13:05'!initialize	super initialize.	bounds := 0@0 corner: 16@100.	color := Color gray.	borderWidth := 1.	borderColor := #inset.	value _ 0.0.	descending _ false.	self initializeSlider! !!Slider methodsFor: 'initialize' stamp: 'jm 6/15/2003 10:38'!initializeSlider	slider _ BorderedMorph newBounds: self totalSliderArea color: self sliderColor.	sliderShadow _ BorderedMorph		newBounds: self totalSliderArea		color: self pagingArea color.	slider setBorderWidth: 1 borderColor: #raised.	sliderShadow setBorderWidth: 1 borderColor: #inset.	"Note: shadow must have the pagingArea as its owner to highlight properly."	self pagingArea addMorph: sliderShadow.	sliderShadow isHidden: true.	self addMorph: slider.	self computeSlider.! !!Slider methodsFor: 'initialize' stamp: 'jm 10/14/2003 10:40'!slider	^ slider! !!Slider methodsFor: 'access' stamp: 'sw 3/10/2000 13:05'!descending	^ descending == true! !!Slider methodsFor: 'access' stamp: 'sw 3/12/2000 11:57'!descending: aBoolean	descending _ aBoolean.	self value: value! !!Slider methodsFor: 'access' stamp: 'jm 10/3/2002 18:01'!model	^ model! !!Slider methodsFor: 'access' stamp: 'jm 10/3/2002 18:01'!model: anObject	model _ anObject.! !!Slider methodsFor: 'access' stamp: 'dew 2/15/1999 18:24'!pagingArea	^self! !!Slider methodsFor: 'access' stamp: 'jm 2/4/2003 11:32'!setValueSelector	^ setValueSelector! !!Slider methodsFor: 'access' stamp: 'jm 2/4/2003 11:34'!setValueSelector: aStringOrSymbolOrNil	setValueSelector _ aStringOrSymbolOrNil.	(setValueSelector isKindOf: String)		ifTrue: [setValueSelector _ setValueSelector asSymbol].! !!Slider methodsFor: 'access' stamp: 'di 11/9/1999 13:25'!sliderColor	sliderColor ifNil: [^ Color veryLightGray].	^ sliderColor! !!Slider methodsFor: 'access' stamp: 'sw 3/7/2000 15:39'!sliderColor: newColor	sliderColor _ newColor.	slider ifNotNil: [slider color: sliderColor]! !!Slider methodsFor: 'geometry' stamp: 'sw 3/10/2000 13:44'!computeSlider	| r |	r _ self roomToMove.	self descending		ifFalse:			[slider position: (bounds isWide				ifTrue: [r topLeft + ((r width * value) asInteger @ 0)]				ifFalse: [r topLeft + (0 @ (r height * value)  asInteger)])]		ifTrue:			[slider position: (bounds isWide				ifTrue:	[r bottomRight - ((r width * value) asInteger @ 0)]				ifFalse:	[r bottomRight - ((0 @ (r height * value) asInteger))])].	slider extent: self sliderExtent! !!Slider methodsFor: 'geometry' stamp: 'dew 2/21/1999 03:08'!extent: newExtent	newExtent = bounds extent ifTrue: [^ self].	bounds isWide		ifTrue: [super extent: (newExtent x max: self sliderThickness * 2) @ newExtent y]		ifFalse: [super extent: newExtent x @ (newExtent y max: self sliderThickness * 2)].	self removeAllMorphs; initializeSlider! !!Slider methodsFor: 'scrolling' stamp: 'jm 10/13/2002 09:58'!scrollAbsolute: event	| r p |	r _ self roomToMove.	bounds isWide		ifTrue: [r width = 0 ifTrue: [^ self]]		ifFalse: [r height = 0 ifTrue: [^ self]].	p _ event cursorPoint + dragOffset adhereTo: r.	self descending		ifFalse:			[self setValue: (bounds isWide 				ifTrue: [(p x - r left) asFloat / r width]				ifFalse: [(p y - r top) asFloat / r height])]		ifTrue:			[self setValue: (bounds isWide				ifTrue: [(r right - p x) asFloat / r width]				ifFalse:	[(r bottom - p y) asFloat / r height])]! !!Slider methodsFor: 'model access' stamp: 'jm 10/11/2002 19:28'!setValue: newValue	"Called internally for propagation to model"	self value: newValue.	setValueSelector ifNil: [setValueSelector _ #scrollBarValue:].	model ifNotNil: [model perform: setValueSelector with: value].! !!Slider methodsFor: 'event handling' stamp: 'jm 10/13/2002 09:49'!handlesMouseDown: evt	^ slider containsPoint: evt cursorPoint! !!Slider methodsFor: 'event handling' stamp: 'jm 10/14/2002 08:58'!mouseDown: evt	slider color: self sliderColor lighter lighter.	sliderShadow bounds: slider bounds.	sliderShadow isHidden: false.	dragOffset _ slider position - evt cursorPoint.! !!Slider methodsFor: 'event handling' stamp: 'jm 10/13/2002 09:52'!mouseMove: evt	self scrollAbsolute: evt.! !!Slider methodsFor: 'event handling' stamp: 'jm 10/13/2002 18:14'!mouseUp: evt	slider color: self sliderColor.	sliderShadow isHidden: true.! !!Slider methodsFor: 'object i/o' stamp: 'jm 9/25/2003 11:49'!fieldsVersion	^ 1! !!Slider methodsFor: 'object i/o' stamp: 'jm 9/25/2003 11:50'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		slider		value		setValueSelector		sliderShadow		sliderColor		descending		model	) from: anObjStream.! !!Slider methodsFor: 'object i/o' stamp: 'jm 9/25/2003 11:50'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		slider		value		setValueSelector		sliderShadow		sliderColor		descending		model	) on: anObjStream.! !My instances are 30-bit numbers, stored in twos complement form. The allowable range is approximately +- 1 billion (see SmallInteger minVal, maxVal).!!SmallInteger methodsFor: 'arithmetic' stamp: 'di 2/1/1999 21:29'!* aNumber 	"Primitive. Multiply the receiver by the argument and answer with the	result if it is a SmallInteger. Fail if the argument or the result is not a	SmallInteger. Essential. No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 9>	^ super * aNumber! !!SmallInteger methodsFor: 'arithmetic' stamp: 'di 2/1/1999 21:31'!+ aNumber 	"Primitive. Add the receiver to the argument and answer with the result	if it is a SmallInteger. Fail if the argument or the result is not a	SmallInteger  Essential  No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 1>	^ super + aNumber! !!SmallInteger methodsFor: 'arithmetic' stamp: 'jm 5/22/2003 19:58'!/ aNumber 	"Primitive. This primitive (for /) divides the receiver by the argument	and returns the result if the division is exact. Fail if the result is not a	whole integer. Fail if the argument is 0 or is not a SmallInteger. Optional.	No Lookup. See Object documentation whatIsAPrimitive."	<primitive: 10>	aNumber = 0 ifTrue: [^ self error: 'division by 0'].	(aNumber isMemberOf: SmallInteger)		ifTrue: [^(Fraction numerator: self denominator: aNumber) reduced]		ifFalse: [^super / aNumber]! !!SmallInteger methodsFor: 'arithmetic' stamp: 'jm 5/22/2003 19:59'!quo: aNumber 	"Primitive. Divide the receiver by the argument and answer with the 	result. Round the result down towards zero to make it a whole integer. 	Fail if the argument is 0 or is not a SmallInteger. Optional. See Object 	documentation whatIsAPrimitive."	<primitive: 13>	aNumber = 0 ifTrue: [^ self error: 'division by 0'].	(aNumber isMemberOf: SmallInteger)		ifFalse: [^ super quo: aNumber].	(aNumber == -1 and: [self == self class minVal])		ifTrue: ["result is aLargeInteger" ^ self negated].	self primitiveFailed! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:07'!highBit	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. Raise an error if the receiver is negative, since  	negative integers are defined to have an infinite number of leading 1's 	in 2's-complement arithmetic. Use >>highBitOfMagnitude if you want to 	get the highest bit of the magnitude."	self < 0 ifTrue: [^ self error: 'highBit is not defined for negative integers'].	^ self highBitOfPositiveReceiver! !!SmallInteger methodsFor: 'bit manipulation' stamp: 'sr 6/8/2000 02:08'!highBitOfMagnitude	"Answer the index of the high order bit of the receiver, or zero if the  	receiver is zero. This method is used for negative SmallIntegers as well,  	since Squeak's LargeIntegers are sign/magnitude."	^ self abs highBitOfPositiveReceiver! !!SmallInteger methodsFor: 'copying' stamp: 'tk 6/26/1998 11:34'!clone! !!SmallInteger methodsFor: 'printing' stamp: 'MPW 1/1/1901 00:15'!destinationBuffer:digitLength  ^ LargePositiveInteger new: digitLength.! !!SmallInteger methodsFor: 'system primitives' stamp: 'tk 3/24/1999 20:28'!digitAt: n 	"Answer the value of an indexable field in the receiver.  LargePositiveInteger uses bytes of base two number, and each is a 'digit' base 256.  Fail if the argument (the index) is not an Integer or is out of bounds."	n>4 ifTrue: [^ 0].	self < 0		ifTrue: 			[self = SmallInteger minVal ifTrue:				["Can't negate minVal -- treat specially"				^ #(0 0 0 64) at: n].			^ ((0-self) bitShift: (1-n)*8) bitAnd: 16rFF]		ifFalse: [^ (self bitShift: (1-n)*8) bitAnd: 16rFF]! !!SmallInteger methodsFor: 'system primitives' stamp: 'tk 5/14/1999 20:54'!nextInstance	"SmallIntegers can't be enumerated this way.  There are a finite number of them from from (SmallInteger minVal) to (SmallInteger maxVal), but you'll have to enumerate them yourself with:	(SmallInteger minVal) to: (SmallInteger maxVal) do: [:integer | <your code here>].	"	self shouldNotImplement ! !!SmallInteger methodsFor: 'private' stamp: 'sr 6/8/2000 01:14'!highBitOfPositiveReceiver	| shifted bitNo |	"Answer the index of the high order bit of the receiver, or zero if the 	receiver is zero. Receiver has to be positive!!"	shifted _ self.	bitNo _ 0.	[shifted < 16]		whileFalse: 			[shifted _ shifted bitShift: -4.			bitNo _ bitNo + 4].	[shifted = 0]		whileFalse: 			[shifted _ shifted bitShift: -1.			bitNo _ bitNo + 1].	^ bitNo! !!SmallInteger class methodsFor: 'instance creation' stamp: 'tk 4/20/1999 14:17'!basicNew	self error: 'SmallIntegers can only be created by performing arithmetic'! !!SmallInteger class methodsFor: 'instance creation' stamp: 'tk 4/20/1999 14:18'!new	self basicNew	"generates an error"! !A Socket represents a network connection point. Current sockets are designed to support the TCP/IP and UDP protocolsSubclasses of socket provide support for network protocols such as POP, NNTP, HTTP, and FTP. Sockets also allow you to implement your own custom services and may be used to support Remote Procedure Call or Remote Method Invocation some day.JMM June 2nd 2000 Macintosh UDP support was added if you run open transport.!]style[(196 4 6 3 228)f1,f1LHTTPSocket Comment;,f1,f1LFTPSocket Comment;,f1!!Socket methodsFor: 'initialize-destroy' stamp: 'jm 12/3/2003 11:26'!acceptFrom: aSocket	"Initialize a new socket handle from an accept call"	| semaIndex readSemaIndex writeSemaIndex |	primitiveOnlySupportsOneSemaphore _ false.	semaphore _ Semaphore new.	readSemaphore _ Semaphore new.	writeSemaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	readSemaIndex _ Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex _ Smalltalk registerExternalObject: writeSemaphore.	socketHandle _ self primAcceptFrom: aSocket socketHandle						receiveBufferSize: 8000						sendBufSize: 8000						semaIndex: semaIndex						readSemaIndex: readSemaIndex						writeSemaIndex: writeSemaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		readSemaphore _ writeSemaphore _ semaphore _ nil	] ifFalse: [self class register: self].! !!Socket methodsFor: 'initialize-destroy' stamp: 'jm 12/3/2003 11:25'!destroy	"Destroy this socket. Its connection, if any, is aborted and its resources are freed. Do nothing if the socket has already been destroyed (i.e., if its socketHandle is nil)."	socketHandle = nil ifFalse: 		[self isValid ifTrue: [self primSocketDestroy: socketHandle].		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		socketHandle _ nil.		readSemaphore _ writeSemaphore _ semaphore _ nil.		self class unregister: self].! !!Socket methodsFor: 'initialize-destroy' stamp: 'jm 12/3/2003 11:27'!initialize: socketType	"Initialize a new socket handle. If socket creation fails, socketHandle will be set to nil."	| semaIndex readSemaIndex writeSemaIndex |	primitiveOnlySupportsOneSemaphore _ false.	semaphore _ Semaphore new.	readSemaphore _ Semaphore new.	writeSemaphore _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: semaphore.	readSemaIndex _ Smalltalk registerExternalObject: readSemaphore.	writeSemaIndex _ Smalltalk registerExternalObject: writeSemaphore.	socketHandle _		self primSocketCreateNetwork: 0			type: socketType			receiveBufferSize: 8000			sendBufSize: 8000			semaIndex: semaIndex			readSemaIndex: readSemaIndex			writeSemaIndex: writeSemaIndex.	socketHandle = nil ifTrue: [  "socket creation failed"		Smalltalk unregisterExternalObject: semaphore.		Smalltalk unregisterExternalObject: readSemaphore.		Smalltalk unregisterExternalObject: writeSemaphore.		readSemaphore _ writeSemaphore _ semaphore _ nil	] ifFalse: [self class register: self].! !!Socket methodsFor: 'accessing' stamp: 'ar 4/30/1999 04:25'!address	"Shortcut"	^self localAddress! !!Socket methodsFor: 'accessing' stamp: 'JMM 5/10/2000 14:37'!localAddress	self waitForConnectionUntil: Socket standardDeadline.	self isConnected ifFalse: [^ByteArray new: 4].	^ self primSocketLocalAddress: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'JMM 5/10/2000 14:31'!localPort	self waitForConnectionUntil: Socket standardDeadline.	self isConnected ifFalse: [^0 ].	^ self primSocketLocalPort: socketHandle! !!Socket methodsFor: 'accessing' stamp: 'ar 4/30/1999 04:25'!port	"Shortcut"	^self localPort! !!Socket methodsFor: 'accessing' stamp: 'JMM 6/5/2000 10:12'!primitiveOnlySupportsOneSemaphore	^primitiveOnlySupportsOneSemaphore! !!Socket methodsFor: 'accessing' stamp: 'JMM 5/22/2000 22:49'!readSemaphore	primitiveOnlySupportsOneSemaphore ifTrue: [^semaphore].	^readSemaphore! !!Socket methodsFor: 'accessing' stamp: 'JMM 5/9/2000 15:32'!semaphore	^semaphore! !!Socket methodsFor: 'accessing' stamp: 'ar 7/16/1999 17:22'!socketHandle	^socketHandle! !!Socket methodsFor: 'accessing' stamp: 'JMM 5/22/2000 22:49'!writeSemaphore	primitiveOnlySupportsOneSemaphore ifTrue: [^semaphore].	^writeSemaphore! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:52'!dataAvailable	"Return true if this socket has unread received data."	socketHandle == nil ifTrue: [^ false].	^ self primSocketReceiveDataAvailable: socketHandle! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:52'!isConnected	"Return true if this socket is connected."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == Connected! !!Socket methodsFor: 'queries' stamp: 'JMM 5/5/2000 12:15'!isOtherEndClosed	"Return true if this socket had the other end closed."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == OtherEndClosed! !!Socket methodsFor: 'queries' stamp: 'JMM 5/5/2000 12:17'!isThisEndClosed	"Return true if this socket had the this end closed."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == ThisEndClosed! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:54'!isUnconnected	"Return true if this socket's state is Unconnected."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == Unconnected! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:54'!isUnconnectedOrInvalid	"Return true if this socket is completely disconnected or is invalid."	| status |	socketHandle == nil ifTrue: [^ true].	status _ self primSocketConnectionStatus: socketHandle.	^ (status = Unconnected) | (status = InvalidSocket)! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:51'!isValid	"Return true if this socket contains a valid, non-nil socket handle."	| status |	socketHandle == nil ifTrue: [^ false].	status _ self primSocketConnectionStatus: socketHandle.	^ status ~= InvalidSocket! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:54'!isWaitingForConnection	"Return true if this socket is waiting for a connection."	socketHandle == nil ifTrue: [^ false].	^ (self primSocketConnectionStatus: socketHandle) == WaitingForConnection! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:54'!sendDone	"Return true if the most recent send operation on this socket has completed."	socketHandle == nil ifTrue: [^ false].	^ self primSocketSendDone: socketHandle! !!Socket methodsFor: 'queries' stamp: 'JMM 5/8/2000 23:24'!socketError	^self primSocketError: socketHandle! !!Socket methodsFor: 'queries' stamp: 'jm 2/25/1999 13:56'!statusString	"Return a string describing the status of this socket."	| status |	socketHandle == nil ifTrue: [^ 'destroyed'].	status _ self primSocketConnectionStatus: socketHandle.	status = InvalidSocket ifTrue: [^ 'invalidSocketHandle'].	status = Unconnected ifTrue: [^ 'unconnected'].	status = WaitingForConnection ifTrue: [^ 'waitingForConnection'].	status = Connected ifTrue: [^ 'connected'].	status = OtherEndClosed ifTrue: [^ 'otherEndClosedButNotThisEnd'].	status = ThisEndClosed ifTrue: [^ 'thisEndClosedButNotOtherEnd'].	^ 'unknown socket status'! !!Socket methodsFor: 'connection open/close' stamp: 'bolot 7/16/1999 14:36'!accept	"Accept a connection from the receiver socket.	Return a new socket that is connected to the client"	^Socket acceptFrom: self.! !!Socket methodsFor: 'connection open/close' stamp: 'ar 7/16/1999 18:26'!listenOn: portNumber backlogSize: backlog	"Listen for a connection on the given port.	If this method succeeds, #accept may be used to establish a new connection"	| status |	status _ self primSocketConnectionStatus: socketHandle.	(status == Unconnected)		ifFalse: [self error: 'Socket status must Unconnected before listening for a new connection'].	self primSocket: socketHandle listenOn: portNumber backlogSize: backlog.! !!Socket methodsFor: 'sending-receiving' stamp: 'JMM 6/3/2000 21:48'!getData	"Get some data"	| buf bytesRead |	(self waitForDataUntil: Socket standardDeadline) ifFalse: [self error: 'getData timeout'].	buf _ String new: 4000.	bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 count: buf size.	^ buf copyFrom: 1 to: bytesRead! !!Socket methodsFor: 'sending-receiving' stamp: 'jm 7/31/2001 07:30'!readInto: aStringOrByteArray startingAt: aNumber	"Read data into the given buffer starting at the given index and return the number of bytes received. Note the given buffer may be only partially filled by the received data. If no data is available, do nothing and return zero."	^ self primSocket: socketHandle		receiveDataInto: aStringOrByteArray		startingAt: aNumber		count: aStringOrByteArray size - aNumber + 1! !!Socket methodsFor: 'sending-receiving' stamp: 'ar 7/20/1999 17:23'!sendData: buffer count: n	"Send the amount of data from the given buffer"	| sent |	sent _ 0.	[sent < n] whileTrue:[		sent _ sent + (self sendSomeData: buffer startIndex: sent+1 count: (n-sent))].! !!Socket methodsFor: 'sending-receiving' stamp: 'jm 7/31/2001 07:30'!sendDataNoWait: aStringOrByteArray startIndex: startIndex	"Send zero or more bytes of data from the given array starting at the given index, and return the number of bytes sent. Do not wait; if the socket is not ready to accept more data, just do nothing and return zero."	^ self primSocket: socketHandle		sendData: aStringOrByteArray		startIndex: startIndex		count: aStringOrByteArray size + 1 - startIndex! !!Socket methodsFor: 'sending-receiving' stamp: 'ls 1/5/1999 15:05'!sendSomeData: aStringOrByteArray	"Send as much of the given data as possible and answer the number of bytes actually sent."	"Note: This operation may have to be repeated multiple times to send a large amount of data."	^ self		sendSomeData: aStringOrByteArray		startIndex: 1		count: aStringOrByteArray size! !!Socket methodsFor: 'sending-receiving' stamp: 'ls 3/3/1999 18:59'!sendSomeData: aStringOrByteArray startIndex: startIndex	"Send as much of the given data as possible starting at the given index. Answer the number of bytes actually sent."	"Note: This operation may have to be repeated multiple times to send a large amount of data."	^ self		sendSomeData: aStringOrByteArray		startIndex: startIndex		count: (aStringOrByteArray size - startIndex + 1)! !!Socket methodsFor: 'sending-receiving' stamp: 'ls 1/5/1999 15:05'!sendSomeData: aStringOrByteArray startIndex: startIndex count: count	"Send up to count bytes of the given data starting at the given index. Answer the number of bytes actually sent."	"Note: This operation may have to be repeated multiple times to send a large amount of data."	| bytesSent |	(self waitForSendDoneUntil: (Socket deadlineSecs: 20))		ifTrue: [			bytesSent _ self primSocket: socketHandle				sendData: aStringOrByteArray				startIndex: startIndex				count: count]		ifFalse: [self error: 'send data timeout; data not sent'].	^ bytesSent! !!Socket methodsFor: 'waiting' stamp: 'ar 7/20/1999 17:21'!waitForAcceptUntil: deadLine	"Wait and accept an incoming connection"	self waitForConnectionUntil: deadLine.	^self isConnected		ifTrue:[self accept]		ifFalse:[nil]! !!Socket methodsFor: 'waiting' stamp: 'JMM 5/22/2000 22:04'!waitForDataUntil: deadline	"Wait up until the given deadline for data to arrive. Return true if data arrives by the deadline, false if not."	| dataArrived |	[self isConnected & 	 (dataArrived _ self primSocketReceiveDataAvailable: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			self readSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ dataArrived! !!Socket methodsFor: 'waiting' stamp: 'JMM 5/17/2000 14:52'!waitForDisconnectionUntil: deadline	"Wait up until the given deadline for the the connection to be broken. Return true if it is broken by the deadline, false if not."	"Note: The client should know the the connect is really going to be closed (e.g., because he has called 'close' to send a close request to the other end) before calling this method.JMM 00/5/17 note that other end can close which will terminate wait"	| extraBytes status |	extraBytes _ 0.	status _ self primSocketConnectionStatus: socketHandle.	[((status = Connected) or: [(status = ThisEndClosed)]) and:	 [Time millisecondClockValue < deadline]] whileTrue: [		self dataAvailable			ifTrue: [extraBytes _ extraBytes + self discardReceivedData].		semaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue).		status _ self primSocketConnectionStatus: socketHandle].	extraBytes > 0		ifTrue: [self inform: 'Discarded ', extraBytes printString, ' bytes while closing connection.'].	^ status ~= Connected! !!Socket methodsFor: 'waiting' stamp: 'JMM 5/22/2000 22:05'!waitForSendDoneUntil: deadline	"Wait up until the given deadline for the current send operation to complete. Return true if it completes by the deadline, false if not."	| sendDone |	[self isConnected & (sendDone _ self primSocketSendDone: socketHandle) not			"Connection end and final data can happen fast, so test in this order"		and: [Time millisecondClockValue < deadline]] whileTrue: [			self writeSemaphore waitTimeoutMSecs: (deadline - Time millisecondClockValue)].	^ sendDone! !!Socket methodsFor: 'primitives' stamp: 'ar 7/16/1999 17:14'!primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex	"Create and return a new socket handle based on accepting the connection from the given listening socket"	<primitive: 225>	^self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/22/2000 22:55'!primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"Create and return a new socket handle based on accepting the connection from the given listening socket"	<primitive: 'primitiveSocketAccept3Semaphores' module: 'SocketPlugin'>	primitiveOnlySupportsOneSemaphore _ true.	^self primAcceptFrom: aHandle receiveBufferSize: rcvBufSize sendBufSize: sndBufSize semaIndex: semaIndex ! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/25/2000 21:48'!primSocket: socketID getOption: aString 	"Get some option information on this socket. Refer to the UNIX 	man pages for valid SO, TCP, IP, UDP options. In case of doubt	refer to the source code.	TCP_NODELAY, SO_KEEPALIVE are valid options for example	returns an array containing the error code and the option value"	<primitive: 'primitiveSocketGetOptions' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 7/16/1999 18:25'!primSocket: aHandle listenOn: portNumber backlogSize: backlog	"Primitive. Set up the socket to listen on the given port.	Will be used in conjunction with #accept only."	<primitive: 218>	self destroy. "Accept not supported so clean up"! !!Socket methodsFor: 'primitives' stamp: 'jm 6/16/2002 12:35'!primSocket: socketID receiveDataInto: aStringOrByteArray startingAt: startIndex count: count	"Receive data from the given socket into the given array starting at the given index. Return the number of bytes read or zero if no data is available."	<primitive: 221>	^ 0! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/24/2000 17:19'!primSocket: socketID receiveUDPDataInto: aStringOrByteArray startingAt: startIndex count: count	"Receive data from the given socket into the given array starting at the given index. 	Return an Array containing the amount read, the host address byte array, the host port, and the more flag"	<primitive: 'primitiveSocketReceiveUDPDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/25/2000 00:08'!primSocket: socketID sendUDPData: aStringOrByteArray toHost: hostAddress  port: portNumber startIndex: startIndex count: count	"Send data to the remote host through the given socket starting with the given byte index of the given byte array. The data sent is 'pushed' immediately. Return the number of bytes of data actually sent; any remaining data should be re-submitted for sending after the current send operation has completed."	"Note: In general, it many take several sendData calls to transmit a large data array since the data is sent in send-buffer-sized chunks. The size of the send buffer is determined when the socket is created."	<primitive:  'primitiveSocketSendUDPDataBufCount' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/25/2000 20:12'!primSocket: socketID setOption: aString value: aStringValue	"Set some option information on this socket. Refer to the UNIX 	man pages for valid SO, TCP, IP, UDP options. In case of doubt	refer to the source code.	TCP_NODELAY, SO_KEEPALIVE are valid options for example	returns an array containing the error code and the negotiated value"	<primitive: 'primitiveSocketSetOptions' module: 'SocketPlugin'>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'ar 4/30/1999 04:31'!primSocket: socketID setPort: port	"Set the local port associated with a UDP socket.	Note: this primitive is overloaded.  The primitive will not fail on a TCP socket, but	the effects will not be what was desired.  Best solution would be to split Socket into	two subclasses, TCPSocket and UDPSocket."	<primitive: 218>	self primitiveFailed! !!Socket methodsFor: 'primitives' stamp: 'JMM 6/3/2000 21:53'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex	"Return a new socket handle for a socket of the given type and buffer sizes. Return nil if socket creation fails.	The netType parameter is platform dependent and can be used to encode both the protocol type (IP, Xerox XNS, etc.) and/or the physical network interface to use if this host is connected to multiple networks. A zero netType means to use IP protocols and the primary (or only) network interface.	The socketType parameter specifies:		0	reliable stream socket (TCP if the protocol is IP)		1	unreliable datagram socket (UDP if the protocol is IP)	The buffer size parameters allow performance to be tuned to the application. For example, a larger receive buffer should be used when the application expects to be receiving large amounts of data, especially from a host that is far away. These values are considered requests only; the underlying implementation will ensure that the buffer sizes actually used are within allowable bounds. Note that memory may be limited, so an application that keeps many sockets open should use smaller buffer sizes. Note the macintosh implementation ignores this buffer size. Also see setOption to get/set socket buffer sizes which allows you to set/get the current buffer sizes for reading and writing. 	If semaIndex is > 0, it is taken to be the index of a Semaphore in the external objects array to be associated with this socket. This semaphore will be signalled when the socket status changes, such as when data arrives or a send completes. All processes waiting on the semaphore will be awoken for each such event; each process must then query the socket state to figure out if the conditions they are waiting for have been met. For example, a process waiting to send some data can see if the last send has completed."	<primitive: 209>	^ nil  "socket creation failed"! !!Socket methodsFor: 'primitives' stamp: 'JMM 5/22/2000 22:48'!primSocketCreateNetwork: netType type: socketType receiveBufferSize: rcvBufSize sendBufSize: sendBufSize semaIndex: semaIndex readSemaIndex: aReadSema writeSemaIndex: aWriteSema	"See comment in primSocketCreateNetwork: with one semaIndex. However you should know that some implementations	ignore the buffer size and this interface supports three semaphores,  one for open/close/listen and the other two for	reading and writing"	<primitive: 'primitiveSocketCreate3Semaphores' module: 'SocketPlugin'>	primitiveOnlySupportsOneSemaphore _ true.	^ self primSocketCreateNetwork: netType			type: socketType			receiveBufferSize: rcvBufSize			sendBufSize: sendBufSize			semaIndex: semaIndex! !!Socket methodsFor: 'primitives' stamp: 'ar 3/21/98 17:43'!primSocketDestroyGently: socketID	"Release the resources associated with this socket. If a connection is open, it is aborted.	Do not fail if the receiver is already closed."	<primitive: 210>! !!Socket methodsFor: 'finalization' stamp: 'JMM 5/22/2000 22:52'!finalize	self primSocketDestroyGently: socketHandle.	Smalltalk unregisterExternalObject: semaphore.	Smalltalk unregisterExternalObject: readSemaphore.	Smalltalk unregisterExternalObject: writeSemaphore.! !!Socket methodsFor: 'printing' stamp: 'jm 11/23/1998 11:57'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '[', self statusString, ']'.! !!Socket methodsFor: 'datagrams' stamp: 'JMM 6/7/2000 14:58'!receiveDataInto: aStringOrByteArray fromHost: hostAddress port: portNumber	| datagram |	"Receive a UDP packet from the given hostAddress/portNumber, storing the data in the given buffer, and return the number of bytes received. Note the given buffer may be only partially filled by the received data."	primitiveOnlySupportsOneSemaphore ifTrue:		[self setPeer: hostAddress port: portNumber.		^self receiveDataInto: aStringOrByteArray].	[true] whileTrue: 		[datagram _ self receiveUDPDataInto: aStringOrByteArray.		((datagram at: 2) = hostAddress and: [(datagram at: 3) = portNumber]) 			ifTrue: [^datagram at: 1]			ifFalse: [^0]]! !!Socket methodsFor: 'datagrams' stamp: 'JMM 6/3/2000 21:54'!receiveUDPDataInto: aStringOrByteArray	"Receive UDP data into the given buffer and return the number of bytes received. Note the given buffer may be only partially filled by the received data. What is returned is an array, the first element is the bytes read, the second the sending bytearray address, the third the senders port, the fourth, true if more of the datagram awaits reading"	^ self primSocket: socketHandle		receiveUDPDataInto: aStringOrByteArray		startingAt: 1		count: aStringOrByteArray size! !!Socket methodsFor: 'datagrams' stamp: 'JMM 5/25/2000 00:05'!sendData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	primitiveOnlySupportsOneSemaphore ifTrue:		[self setPeer: hostAddress port: portNumber.		^self sendData: aStringOrByteArray].	^self sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber! !!Socket methodsFor: 'datagrams' stamp: 'JMM 5/25/2000 00:07'!sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	| bytesToSend bytesSent count |	bytesToSend _ aStringOrByteArray size.	bytesSent _ 0.	[bytesSent < bytesToSend] whileTrue: [		(self waitForSendDoneUntil: (Socket deadlineSecs: 20))			ifFalse: [self error: 'send data timeout; data not sent'].		count _ self primSocket: socketHandle			sendUDPData: aStringOrByteArray			toHost: hostAddress			port: portNumber			startIndex: bytesSent + 1			count: bytesToSend - bytesSent.		bytesSent _ bytesSent + count].	^ bytesSent! !!Socket methodsFor: 'datagrams' stamp: 'ar 4/30/1999 04:29'!setPeer: hostAddress port: port	"Set the default send/recv address."	self primSocket: socketHandle connectTo: hostAddress port: port.! !!Socket methodsFor: 'datagrams' stamp: 'ar 4/30/1999 04:29'!setPort: port	"Associate a local port number with a UDP socket.  Not applicable to TCP sockets."	self primSocket: socketHandle setPort: port.! !!Socket methodsFor: 'other' stamp: 'JMM 6/3/2000 19:39'!getOption: aName 	"Get options on this socket, see Unix man pages for values for 	sockets, IP, TCP, UDP. IE SO_KEEPALIVE	returns an array, element one is an status number (0 ok, -1 read only option)	element two is the resulting of the requested option"	(socketHandle == nil or: [self isValid not])		ifTrue: [self error: 'Socket status must valid before getting an option'].	^self primSocket: socketHandle getOption: aName"| foo options |Socket initializeNetwork.foo _ Socket newTCP.foo connectTo: (NetNameResolver addressFromString: '192.168.1.1') port: 80.foo waitForConnectionUntil: (Socket standardDeadline).options _ {'SO_DEBUG'. 'SO_REUSEADDR'. 'SO_REUSEPORT'. 'SO_DONTROUTE'.'SO_BROADCAST'. 'SO_SNDBUF'. 'SO_RCVBUF'. 'SO_KEEPALIVE'.'SO_OOBINLINE'. 'SO_PRIORITY'. 'SO_LINGER'. 'SO_RCVLOWAT'.'SO_SNDLOWAT'. 'IP_TTL'. 'IP_HDRINCL'. 'IP_RCVOPTS'.'IP_RCVDSTADDR'. 'IP_MULTICAST_IF'. 'IP_MULTICAST_TTL'.'IP_MULTICAST_LOOP'. 'UDP_CHECKSUM'. 'TCP_MAXSEG'.'TCP_NODELAY'. 'TCP_ABORT_THRESHOLD'. 'TCP_CONN_NOTIFY_THRESHOLD'. 'TCP_CONN_ABORT_THRESHOLD'. 'TCP_NOTIFY_THRESHOLD'.'TCP_URGENT_PTR_TYPE'}.1 to: options size do: [:i | | fum |	fum _foo getOption: (options at: i).	Transcript show: (options at: i),fum printString;cr].foo _ Socket newUDP.foo setPeer: (NetNameResolver addressFromString: '192.168.1.9') port: 7.foo waitForConnectionUntil: (Socket standardDeadline).1 to: options size do: [:i | | fum |	fum _foo getOption: (options at: i).	Transcript show: (options at: i),fum printString;cr]."! !!Socket methodsFor: 'other' stamp: 'ar 4/30/1999 06:00'!getResponseNoLF	"Get the response to the last command."	| buf response bytesRead c lf |	(self waitForDataUntil: (Socket deadlineSecs: 20)) ifFalse: [		self error: 'getResponse timeout'].	lf _ Character lf.	buf _ String new: 1000.	response _ WriteStream on: ''.	[self dataAvailable] whileTrue: [		bytesRead _ self primSocket: socketHandle receiveDataInto: buf startingAt: 1 count: buf size.		1 to: bytesRead do: [ :i |			(c _ buf at: i) ~= lf ifTrue: [response nextPut: c]]].	^ response contents! !!Socket methodsFor: 'other' stamp: 'JMM 6/3/2000 19:39'!setOption: aName value: aValue 	| value |	"setup options on this socket, see Unix man pages for values for 	sockets, IP, TCP, UDP. IE SO_KEEPALIVE	returns an array, element one is the error number	element two is the resulting of the negotiated value.	See getOption for list of keys"	(socketHandle == nil or: [self isValid not])		ifTrue: [self error: 'Socket status must valid before setting an option'].	value _ aValue asString.	aValue == true ifTrue: [value _ '1'].	aValue == false ifTrue: [value _ '0'].	^ self primSocket: socketHandle setOption: aName value: value! !!Socket class methodsFor: 'class initialization' stamp: 'ar 4/30/1999 04:12'!initialize	"Socket initialize"	"Socket Types"	TCPSocketType _ 0.	UDPSocketType _ 1.	"Socket Status Values"	InvalidSocket _ -1.	Unconnected _ 0.	WaitingForConnection _ 1.	Connected _ 2.	OtherEndClosed _ 3.	ThisEndClosed _ 4.! !!Socket class methodsFor: 'instance creation' stamp: 'jm 5/23/2003 12:25'!acceptFrom: aSocket	| sock |	sock _ super new acceptFrom: aSocket.	sock isValid ifFalse: [  "try to reclaim a socket by doing a GC"		Smalltalk garbageCollect.		sock _ super new acceptFrom: aSocket].	^ sock! !!Socket class methodsFor: 'instance creation' stamp: 'ar 4/30/1999 04:15'!createIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	"Note: The default creates a TCP socket"	^self tcpCreateIfFail: failBlock! !!Socket class methodsFor: 'instance creation' stamp: 'ar 4/30/1999 04:13'!new	"Return a new, unconnected Socket. Note that since socket creation may fail, it is safer to use the method createIfFail: to handle such failures gracefully; this method is primarily for backward compatibility and may be disallowed in a future release."	"Note: The default creates a TCP socket - this is also backward compatibility."	^self newTCP! !!Socket class methodsFor: 'instance creation' stamp: 'jm 5/23/2003 12:26'!newTCP	"Create a new socket and initialise it for TCP."	| sock |	sock _ super new initialize: TCPSocketType.	sock isValid ifFalse: [  "try to reclaim a socket by doing a GC"		Smalltalk garbageCollect.		sock _ super new initialize: TCPSocketType].	^ sock! !!Socket class methodsFor: 'instance creation' stamp: 'jm 5/23/2003 12:27'!newUDP	"Create a new socket and initialise it for TCP."	| sock |	sock _ super new initialize: UDPSocketType.	sock isValid ifFalse: [  "try to reclaim a socket by doing a GC"		Smalltalk garbageCollect.		sock _ super new initialize: UDPSocketType].	^ sock! !!Socket class methodsFor: 'instance creation' stamp: 'ar 4/30/1999 04:14'!tcpCreateIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	sock _ super new initialize: TCPSocketType.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!Socket class methodsFor: 'instance creation' stamp: 'ar 4/30/1999 04:14'!udpCreateIfFail: failBlock	"Attempt to create a new socket. If successful, return the new socket. Otherwise, return the result of evaluating the given block. Socket creation can fail if the network isn't available or if there are not sufficient resources available to create another socket."	| sock |	sock _ super new initialize: UDPSocketType.	sock isValid ifFalse: [^ failBlock value].	^ sock! !!Socket class methodsFor: 'tests' stamp: 'JMM 5/19/2000 22:13'!loopbackTest	"Send data from one socket to another on the local machine. Tests most of the socket primitives."	"100 timesRepeat: [Socket loopbackTest]"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived t extraBytes packetsSent packetsRead |	Transcript cr; show: 'starting loopback test'; cr.	Transcript show: '---------- Connecting ----------'; cr.	Socket initializeNetwork.	sock1 _ Socket new.	sock2 _ Socket new.	sock1 listenOn: 54321.	sock2 connectTo: (NetNameResolver localHostAddress) port: 54321.	sock1 waitForConnectionUntil: self standardDeadline.	sock2 waitForConnectionUntil: self standardDeadline.	(sock1 isConnected) ifFalse: [self error: 'sock1 not connected'].	(sock2 isConnected) ifFalse: [self error: 'sock2 not connected'].	Transcript show: 'connection established'; cr.	bytesToSend _ 5000000.	sendBuf _ String new: 5000 withAll: $x.	receiveBuf _ String new: 50000.	done _ false.	packetsSent _ packetsRead _ bytesSent _ bytesReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse: [			(sock1 sendDone and: [bytesSent < bytesToSend]) ifTrue: [				packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (sock1 sendSomeData: sendBuf)].			sock2 dataAvailable ifTrue: [				packetsRead _ packetsRead + 1.				bytesReceived _ bytesReceived +					(sock2 receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend) and: [bytesReceived = bytesSent]]].		Transcript show: 'closing connection'; cr.	sock1 waitForSendDoneUntil: self standardDeadline.	sock1 close.	sock2 waitForDisconnectionUntil: self standardDeadline.	extraBytes _ sock2 discardReceivedData.	extraBytes > 0 ifTrue: [		Transcript show: ' *** received ', extraBytes size printString, ' extra bytes ***'; cr.	].	sock2 close.	sock1 waitForDisconnectionUntil: self standardDeadline.	(sock1 isUnconnectedOrInvalid) ifFalse: [self error: 'sock1 not closed'].	(sock2 isUnconnectedOrInvalid) ifFalse: [self error: 'sock2 not closed'].	Transcript show: '---------- Connection Closed ----------'; cr.	sock1 destroy.	sock2 destroy.	Transcript show: 'loopback test done; time = ', t printString; cr.	Transcript show: ((bytesToSend asFloat / t) roundTo: 0.01) printString, ' 1000Bytes/sec'; cr.	Transcript endEntry.! !!Socket class methodsFor: 'tests' stamp: 'JMM 5/22/2000 23:06'!sendTest	"Send data to the 'discard' socket of the given host. Tests the speed of one-way data transfers across the network to the given host. Note that many host hosts do not run a discard server."	"Socket sendTest"	| sock bytesToSend sendBuf bytesSent t serverName serverAddr |	Transcript cr; show: 'starting send test'; cr.	Socket initializeNetwork.	serverName _ FillInTheBlank		request: 'What is the destination server?'		initialAnswer: 'create.ucsb.edu'.	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [^ self inform: 'Could not find an address for ', serverName].	sock _ Socket new.	Transcript show: '---------- Connecting ----------'; cr.	sock connectTo: serverAddr port: 9.	sock waitForConnectionUntil: self standardDeadline.	(sock isConnected) ifFalse: [		sock destroy.		^ self inform: 'could not connect'].	Transcript show: 'connection established; sending data'; cr.	bytesToSend _ 1000000.	sendBuf _ String new: 64*1024 withAll: $x.	bytesSent _ 0.	t _ Time millisecondsToRun: [		[bytesSent < bytesToSend] whileTrue: [			sock sendDone ifTrue: [				bytesSent _ bytesSent + (sock sendSomeData: sendBuf)]]].	sock waitForSendDoneUntil: self standardDeadline.	sock destroy.	Transcript show: '---------- Connection Closed ----------'; cr.	Transcript show: 'send test done; time = ', t printString; cr.	Transcript show: ((bytesToSend asFloat / t) roundTo: 0.01) printString, ' 1000Bytes/sec'; cr.	Transcript endEntry.! !!Socket class methodsFor: 'utilities' stamp: 'jm 1/14/1999 12:13'!nameForWellKnownTCPPort: portNum	"Answer the name for the given well-known TCP port number. Answer a string containing the port number if it isn't well-known."	| portList entry |	portList _ #(		(7 'echo') (9 'discard') (13 'time') (19 'characterGenerator')		(21 'ftp') (23 'telnet') (25 'smtp')		(80 'http') (110 'pop3') (119 'nntp')).	entry _ portList detect: [:pair | pair first = portNum] ifNone: [^ 'port-', portNum printString].	^ entry last! !!Socket class methodsFor: 'utilities' stamp: 'jm 11/23/1998 17:19'!ping: hostName	"Ping the given host. Useful for checking network connectivity. The host must be running a TCP echo server."	"Socket ping: 'squeak.cs.uiuc.edu'"	| tcpPort sock serverAddr startTime echoTime |	tcpPort _ 7.  "7 = echo port, 13 = time port, 19 = character generator port"	Socket initializeNetwork.	serverAddr _ NetNameResolver addressForName: hostName timeout: 10.	serverAddr = nil ifTrue: [		^ self inform: 'Could not find an address for ', hostName].	sock _ Socket new.	sock connectTo: serverAddr port: tcpPort.	[sock waitForConnectionUntil: (Socket deadlineSecs: 10).	 sock isConnected] whileFalse: [		(self confirm: 'Continue to wait for connection to ', hostName, '?') ifFalse: [			sock destroy.			^ self]].	sock sendData: 'echo!!'.	startTime _ Time millisecondClockValue.	[sock waitForDataUntil: (Socket deadlineSecs: 15).	 sock dataAvailable] whileFalse: [		(self confirm: 'Packet sent but no echo yet; keep waiting?') ifFalse: [			sock destroy.			^ self]].	echoTime _ Time millisecondClockValue - startTime.	sock destroy.	self inform: hostName, ' responded in ', echoTime printString, ' milliseconds'.! !!Socket class methodsFor: 'utilities' stamp: 'jm 1/14/1999 17:24'!pingPorts: portList on: hostName timeOutSecs: timeOutSecs	"Attempt to connect to each of the given sockets on the given host. Wait at most timeOutSecs for the connections to be established. Answer an array of strings indicating the available ports."	"Socket pingPorts: #(7 13 19 21 23 25 80 110 119) on: 'squeak.cs.uiuc.edu' timeOutSecs: 15"	| serverAddr sockets sock deadline done unconnectedCount connectedCount waitingCount result |	Socket initializeNetwork.	serverAddr _ NetNameResolver addressForName: hostName timeout: 10.	serverAddr = nil ifTrue: [		self inform: 'Could not find an address for ', hostName.		^ #()].	sockets _ portList collect: [:portNum |		sock _ Socket new.		sock connectTo: serverAddr port: portNum].	deadline _ self deadlineSecs: timeOutSecs.	done _ false.	[done] whileFalse: [		unconnectedCount _ 0.		connectedCount _ 0.		waitingCount _ 0.		sockets do: [:s |			s isUnconnectedOrInvalid				ifTrue: [unconnectedCount _ unconnectedCount + 1]				ifFalse: [					s isConnected ifTrue: [connectedCount _ connectedCount + 1].					s isWaitingForConnection ifTrue: [waitingCount _ waitingCount + 1]]].		waitingCount = 0 ifTrue: [done _ true].		connectedCount = sockets size ifTrue: [done _ true].		Time millisecondClockValue > deadline ifTrue: [done _ true]].	result _ (sockets select: [:s | s isConnected])		collect: [:s | self nameForWellKnownTCPPort: s remotePort].	sockets do: [:s | s destroy].	^ result! !!Socket class methodsFor: 'utilities' stamp: 'jm 1/14/1999 17:25'!pingPortsOn: hostName	"Attempt to connect to a set of well-known sockets on the given host, and answer the names of the available ports."	"Socket pingPortsOn: 'www.disney.com'"	^ Socket		pingPorts: #(7 13 19 21 23 25 80 110 119)		on: hostName		timeOutSecs: 20! !!Socket class methodsFor: 'utilities' stamp: 'ar 4/30/1999 04:21'!wildcardAddress	"Answer a don't-care address for use with UDP sockets."	^ByteArray new: 4		"0.0.0.0"! !!Socket class methodsFor: 'utilities' stamp: 'ar 4/30/1999 04:21'!wildcardPort	"Answer a don't-care port for use with UDP sockets.  (The system will allocate an	unused port number to the socket.)"	^0! !!Socket class methodsFor: 'registry' stamp: 'ar 10/7/1998 14:40'!register: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry add: anObject! !!Socket class methodsFor: 'registry' stamp: 'ar 10/7/1998 14:40'!registry	WeakArray isFinalizationSupported ifFalse:[^nil].	^Registry isNil		ifTrue:[Registry := WeakRegistry new]		ifFalse:[Registry].! !!Socket class methodsFor: 'registry' stamp: 'ar 10/7/1998 15:22'!unregister: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry remove: anObject ifAbsent:[]! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/19/2000 21:38'!clientServerTestUDP	"Socket clientServerTestUDP"	"Performa 6400/200, Linux-PPC 2.1.24:		client/server UDP test done; time = 2820		2500 packets, 10000000 bytes sent (3546 kBytes/sec)		2500 packets, 10000000 bytes received (3546 kBytes/sec)		4000 bytes/packet, 886 packets/sec, 0 packets dropped"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t |	Transcript show: 'starting client/server UDP test'; cr.	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	Transcript show: 'creating endpoints'; cr.	sock1 _ Socket newUDP.	"the sender"	sock2 _ Socket newUDP.	"the recipient"	sock2 setPort: 54321.	sock1 setPeer: (NetNameResolver localHostAddress) port: (sock2 port).	Transcript show: 'endpoints created'; cr.	bytesToSend _ 10000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 50000.	done _ false.	bytesSent _ bytesReceived _ packetsSent _ packetsReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse: [			(sock1 sendDone and: [bytesSent < bytesToSend]) ifTrue: [				packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (sock1 sendData: sendBuf)].			sock2 dataAvailable ifTrue: [				packetsReceived _ packetsReceived + 1.				bytesReceived _ bytesReceived +					(sock2 receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend)].		sock1 waitForSendDoneUntil: self standardDeadline.		bytesReceived _ bytesReceived + sock2 discardReceivedData].	Transcript show: 'closing endpoints'; cr.	sock1 close.	sock2 close.	sock1 destroy.	sock2 destroy.	Transcript show: 'client/server UDP test done; time = ', t printString; cr.	Transcript show: packetsSent printString, ' packets, ',						bytesSent printString, ' bytes sent (',						(bytesSent * 1000 // t) printString, ' Bytes/sec)'; cr.	Transcript show: packetsReceived printString, ' packets, ',						bytesReceived printString, ' bytes received (',						(bytesReceived * 1000 // t) printString, ' Bytes/sec)'; cr.	Transcript show: (bytesSent // packetsSent) printString, ' bytes/packet, ',						(packetsReceived * 1000 // t) printString, ' packets/sec, ',						(packetsSent - packetsReceived) printString, ' packets dropped'; cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/28/2000 23:18'!clientServerTestUDP2	"Socket clientServerTestUDP2"	| sock1 sock2 bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t datagramInfo |	Transcript show: 'starting client/server UDP test'; cr.	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	Transcript show: 'creating endpoints'; cr.	sock1 _ Socket newUDP.	"the sender"	sock2 _ Socket newUDP.	"the recipient"	sock2 setPort: 54321.	Transcript show: 'endpoints created'; cr.	bytesToSend _ 100000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 2000.	done _ false.	bytesSent _ bytesReceived _ packetsSent _ packetsReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse: [			(sock1 sendDone and: [bytesSent < bytesToSend]) ifTrue: [				packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (sock1 sendData: sendBuf toHost: (NetNameResolver localHostAddress) port: (sock2 port))].				sock2 dataAvailable ifTrue: [				packetsReceived _ packetsReceived + 1.				datagramInfo _ sock2 receiveUDPDataInto: receiveBuf.				bytesReceived _ bytesReceived + (datagramInfo at: 1)].			done _ (bytesSent >= bytesToSend)].		sock1 waitForSendDoneUntil: self standardDeadline.		bytesReceived _ bytesReceived + sock2 discardReceivedData].	Transcript show: 'closing endpoints'; cr.	sock1 close.	sock2 close.	sock1 destroy.	sock2 destroy.	Transcript show: 'client/server UDP test done; time = ', t printString; cr.	Transcript show: packetsSent printString, ' packets, ',						bytesSent printString, ' bytes sent (',						(bytesSent * 1000 // t) printString, ' Bytes/sec)'; cr.	Transcript show: packetsReceived printString, ' packets, ',						bytesReceived printString, ' bytes received (',						(bytesReceived * 1000 // t) printString, ' Bytes/sec)'; cr.	Transcript show: (bytesSent // packetsSent) printString, ' bytes/packet, ',						(packetsReceived * 1000 // t) printString, ' packets/sec, ',						(packetsSent - packetsReceived) printString, ' packets dropped'; cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/19/2000 21:41'!remoteTestClientTCP	"FIRST start up another image, and execute: Socket remoteTestServerTCP.	THEN come back to this image and execute:"			"Socket remoteTestClientTCP"	"Performa 6400/200, Linux-PPC 2.1.24, both images on same CPU:		remoteClient TCP test done; time = 5680		250 packets, 1000000 bytes sent (176 kBytes/sec)		60 packets, 1000000 bytes received (176 kBytes/sec)"	| socket bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t serverName |	Transcript show: 'starting client/server TCP test'; cr.	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ Socket newTCP.	serverName _ FillInTheBlank		request: 'What is your remote Test Server?'		initialAnswer: ''.	socket connectTo: (NetNameResolver addressFromString: serverName) port: 54321.	socket waitForConnectionUntil: Socket standardDeadline.	Transcript show: 'client endpoint created'; cr.	bytesToSend _ 1000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 50000.	done _ false.	bytesSent _ bytesReceived _ packetsSent _ packetsReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse:			[(socket sendDone and: [bytesSent < bytesToSend]) ifTrue:				[packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (socket sendData: sendBuf)].			socket dataAvailable ifTrue:				[packetsReceived _ packetsReceived + 1.				bytesReceived _ bytesReceived + (socket receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend)].		[bytesReceived < bytesToSend] whileTrue:			[socket dataAvailable ifTrue:				[packetsReceived _ packetsReceived + 1.				bytesReceived _ bytesReceived + (socket receiveDataInto: receiveBuf)]]].	socket closeAndDestroy.	Transcript show: 'remoteClient TCP test done; time = ', t printString; cr.	Transcript show: packetsSent printString, ' packets, ',						bytesSent printString, ' bytes sent (',						(bytesSent * 1000 // t) printString, ' bytes/sec)'; cr.	Transcript show: packetsReceived printString, ' packets, ',						bytesReceived printString, ' bytes received (',						(bytesReceived * 1000 // t) printString, ' bytes/sec)'; cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/19/2000 22:08'!remoteTestClientTCPOpenClose1000	"Socket remoteTestClientTCPOpenClose1000"	| number t1 socket serverName |	Transcript show: 'starting client/server TCP test'; cr.	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	number _ 1000.	serverName _ FillInTheBlank		request: 'What is your remote Test Server?'		initialAnswer: ''.	t1 _ Time millisecondsToRun: 		[number timesRepeat: 		[socket _ Socket newTCP.		socket connectTo: (NetNameResolver addressFromString: serverName) port: 54321.		socket waitForConnectionUntil: Socket standardDeadline.		socket closeAndDestroy]].	Transcript cr;show: 'connects/close per second ', ((number/t1*1000.0) printString); cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/21/2000 14:13'!remoteTestClientTCPOpenClosePutGet	"Socket remoteTestClientTCPOpenClosePutGet"	| checkLength number bytesExpected sendBuf receiveBuf t1 socket bytesReceived serverName | 	Transcript show: 'starting client/server TCP test'; cr.	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your remote Test Server?'		initialAnswer: ''.	number _ 1000.		bytesExpected _ 20000.	sendBuf _ String new: 80 withAll: $x.	receiveBuf _ String new: 50000.	t1 _ Time millisecondsToRun: 		[number timesRepeat: 		[socket _ Socket newTCP.		socket connectTo: (NetNameResolver addressFromString: serverName) port: 54321.		socket waitForConnectionUntil: Socket standardDeadline.		socket sendData: sendBuf.		socket waitForSendDoneUntil: (Socket deadlineSecs: 5).		socket waitForDataUntil: (Socket deadlineSecs: 5).		bytesReceived _ 0.		[bytesReceived < bytesExpected] whileTrue:			[checkLength _ socket receiveDataInto: receiveBuf.			bytesReceived _ bytesReceived + checkLength].		socket closeAndDestroy]].	Transcript cr;show: 'connects/get/put/close per second ', ((number/t1*1000.0) printString); cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/23/2000 14:38'!remoteTestClientUDP	"FIRST start up another image, and execute: Socket remoteTestServerUDP.	THEN come back to this image and execute:"			"Socket remoteTestClientUDP"	"Performa 6400/200, Linux-PPC 2.1.24:		remoteClient UDP test done; time = 4580		2500 packets, 10000000 bytes sent (2183 kBytes/sec)		180 packets, 720000 bytes received (157 kBytes/sec)		4000 bytes/packet, 39 packets/sec, 2320 packets dropped"	| socket bytesToSend sendBuf receiveBuf done bytesSent bytesReceived packetsSent packetsReceived t serverName |	Transcript show: 'starting client/server UDP test'; cr.	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your remote Test Server?'		initialAnswer: ''.	socket _ Socket newUDP.	socket setPeer: (NetNameResolver addressFromString: serverName) port: 54321.	Transcript show: 'client endpoint created'; cr.	bytesToSend _ 10000000.	sendBuf _ String new: 4000 withAll: $x.	receiveBuf _ String new: 4000.	done _ false.	bytesSent _ bytesReceived _ packetsSent _ packetsReceived _ 0.	t _ Time millisecondsToRun: [		[done] whileFalse:			[(socket sendDone and: [bytesSent < bytesToSend]) ifTrue:				[packetsSent _ packetsSent + 1.				bytesSent _ bytesSent + (socket sendData: sendBuf)].			socket dataAvailable ifTrue:				[packetsReceived _ packetsReceived + 1.				bytesReceived _ bytesReceived + (socket receiveDataInto: receiveBuf)].			done _ (bytesSent >= bytesToSend)].	[socket waitForDataUntil: (Socket deadlineSecs: 1).	socket dataAvailable] whileTrue:		[packetsReceived _ packetsReceived + 1.		bytesReceived _ bytesReceived + (socket receiveDataInto: receiveBuf)]].	socket closeAndDestroy.	Transcript show: 'remoteClient UDP test done; time = ', t printString; cr.	Transcript show: packetsSent printString, ' packets, ',						bytesSent printString, ' bytes sent (',						(bytesSent * 1000 // t) printString, ' bytes/sec)'; cr.	Transcript show: packetsReceived printString, ' packets, ',						bytesReceived printString, ' bytes received (',						(bytesReceived * 1000 // t) printString, ' bytes/sec)'; cr.	Transcript show: (bytesSent // packetsSent) printString, ' bytes/packet, ',						(packetsReceived * 1000 // t) printString, ' packets/sec, ',						(packetsSent - packetsReceived) printString, ' packets dropped'; cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/23/2000 12:04'!remoteTestServerTCP	"See remoteTestClientTCP for instructions on running this method."	"Socket remoteTestServerTCP"	| socket buffer n |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ Socket newTCP.	socket listenOn: 54321.	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 4000.	socket waitForConnectionUntil: self standardDeadline.	[socket isConnected] whileTrue: [		socket dataAvailable ifTrue:			[n _ socket	receiveDataInto: buffer.			socket sendData: buffer count: n]].	socket closeAndDestroy.	Transcript cr; show: 'server endpoint destroyed'; cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/19/2000 22:12'!remoteTestServerTCPOpenClose1000	"The version of #remoteTestServerTCPOpenClose1000 using the BSD style accept() mechanism."	"Socket remoteTestServerTCPOpenClose1000"	| socket server |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	server _ Socket newTCP.	server listenOn: 54321 backlogSize: 20.	server isValid ifFalse:[self error:'Accept() is not supported'].	Transcript show: 'server endpoint created -- run client test in other image'; cr.	1000 timesRepeat: 		[socket _ server waitForAcceptUntil: (Socket deadlineSecs: 300).		socket closeAndDestroy].	server closeAndDestroy.	Transcript cr; show: 'server endpoint destroyed'; cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/19/2000 22:12'!remoteTestServerTCPOpenClosePutGet		"The version of #remoteTestServerTCPOpenClosePutGet using the BSD style accept() mechanism."	"Socket remoteTestServerTCPOpenClosePutGet"	| socket server bytesIWantToSend bytesExpected receiveBuf sendBuf checkLength |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	server _ Socket newTCP.	server listenOn: 54321 backlogSize: 20.	server isValid ifFalse:[self error:'Accept() is not supported'].	Transcript show: 'server endpoint created -- run client test in other image'; cr.	bytesIWantToSend _ 20000.	bytesExpected _ 80.	receiveBuf _ String new: 40000.	sendBuf _ String new: bytesIWantToSend withAll: $x.	1000 timesRepeat: 		[socket _ server waitForAcceptUntil: (Socket deadlineSecs: 300).		socket waitForDataUntil: (Socket deadlineSecs: 5).		checkLength _ socket receiveDataInto: receiveBuf.		(checkLength ~= bytesExpected) ifTrue: [self halt].		socket sendData: sendBuf.		socket waitForSendDoneUntil: (Socket deadlineSecs: 5).				socket closeAndDestroy].	server closeAndDestroy.	Transcript cr; show: 'server endpoint destroyed'; cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/23/2000 12:09'!remoteTestServerTCPUsingAccept	"The version of #remoteTestServer using the BSD style accept() mechanism."	"Socket remoteTestServerTCPUsingAccept"	| socket buffer n server |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	server _ Socket newTCP.	server listenOn: 54321 backlogSize: 4.	server isValid ifFalse:[self error:'Accept() is not supported'].	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 40000.	10 timesRepeat: 		[socket _ server waitForAcceptUntil: (self deadlineSecs: 300).		[socket isConnected] whileTrue: [ 			socket dataAvailable ifTrue:				[n _ socket	receiveDataInto: buffer.				socket sendData: buffer count: n]]].	socket closeAndDestroy.	server closeAndDestroy.	Transcript cr; show: 'server endpoint destroyed'; cr.! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/23/2000 12:25'!remoteTestServerUDP	"See remoteTestClientUDP for instructions on running this method."	"Socket remoteTestServerUDP"	| socket buffer n |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ Socket newUDP.	socket setPort: 54321.	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 4000.	[true] whileTrue: [		socket dataAvailable ifTrue:			[n _ socket	receiveDataInto: buffer.				socket sendData: buffer count: n]].! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/24/2000 21:55'!remoteTestServerUDP2	"See remoteTestClientUDP for instructions on running this method."	"Socket remoteTestServerUDP2"	| socket buffer datagramInfo |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ Socket newUDP.	socket setPort: 54321.	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 65000.	[true] whileTrue: [		socket dataAvailable ifTrue:			[datagramInfo _ socket receiveUDPDataInto: buffer. 			Transcript show: datagramInfo printString;cr.				socket sendData: buffer count: (datagramInfo at: 1)]].! !!Socket class methodsFor: 'examples' stamp: 'JMM 5/17/2000 19:54'!remoteTestSinkTCP	"See sendTest for instructions on running this method."	"Socket remoteTestSinkTCP"	| socket buffer n |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	socket _ Socket newTCP.	socket listenOn: 9.	Transcript show: 'server endpoint created -- run client test in other image'; cr.	buffer _ String new: 64000.	socket waitForConnectionUntil: self standardDeadline.	[socket isConnected] whileTrue: [		socket dataAvailable ifTrue:			[n _ socket	receiveDataInto: buffer]].	socket closeAndDestroy.	Transcript cr; show: 'sink endpoint destroyed'; cr.! !!Socket class methodsFor: 'examples' stamp: 'sge 2/13/2000 07:57'!timeTest	"Socket timeTest"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your time server?'		initialAnswer: 'localhost'.	serverName isEmpty ifTrue: [^ Transcript show: 'never mind'; cr].	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', serverName].	s _ Socket new.	Transcript show: '---------- Connecting ----------'; cr.	s connectTo: serverAddr port: 13.  "13 is the 'daytime' port number"	s waitForConnectionUntil: (self deadlineSecs: 1).	Transcript show: 'the time server reports: ' , s getResponseNoLF.	s closeAndDestroy.	Transcript show: '---------- Connection Closed ----------'; cr.! !!Socket class methodsFor: 'examples' stamp: 'sge 2/13/2000 07:57'!timeTestUDP	"Socket timeTestUDP"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your time server?'		initialAnswer: 'localhost'.	serverName isEmpty ifTrue: [^ Transcript show: 'never mind'; cr].	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', serverName].	s _ Socket newUDP.		"a 'random' port number will be allocated by the system"	"Send a packet to the daytime port and it will reply with the current date."	Transcript show: '---------- Sending datagram from port ' , s port printString , ' ----------'; cr.	s sendData: '!!' toHost: serverAddr port: 13.	"13 is the daytime service"	Transcript show: 'the time server reports: ' , s getResponseNoLF.	s closeAndDestroy.	Transcript show: '---------- Socket closed ----------'; cr.! !!Socket class methodsFor: 'examples' stamp: 'sge 2/13/2000 07:58'!timeTestUDP2	"Socket timeTestUDP2"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your time server?'		initialAnswer: 'localhost'.	serverName isEmpty ifTrue: [^ Transcript show: 'never mind'; cr].	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', serverName].	s _ Socket newUDP.	"The following associates a port with the UDP socket, but does NOT create a connectable endpoint"	s setPort: 54321.	"Send a packet to the daytime port and it will reply with the current date."	Transcript show: '---------- Sending datagram from port ' , s port printString , ' ----------'; cr.	s sendData: '!!' toHost: serverAddr port: 13.	Transcript show: 'the time server reports: ' , s getResponseNoLF.	s closeAndDestroy.	Transcript show: '---------- Socket closed ----------'; cr.! !!Socket class methodsFor: 'examples' stamp: 'sge 2/13/2000 07:59'!timeTestUDP3	"Socket timeTestUDP3"	| serverName serverAddr s |	Transcript show: 'initializing network ... '.	Socket initializeNetworkIfFail: [^Transcript show:'failed'].	Transcript show:'ok';cr.	serverName _ FillInTheBlank		request: 'What is your time server?'		initialAnswer: 'localhost'.	serverName isEmpty ifTrue: [^ Transcript show: 'never mind'; cr].	serverAddr _ NetNameResolver addressForName: serverName timeout: 10.	serverAddr = nil ifTrue: [self error: 'Could not find the address for ', serverName].	s _ Socket newUDP.	"The following associates a port with the UDP socket, but does NOT create a connectable endpoint"	s setPort: (Socket wildcardPort).		"explicitly request a default port number"	"Send a packet to the daytime port and it will reply with the current date."	Transcript show: '---------- Sending datagram from port ' , s port printString , ' ----------'; cr.	s sendData: '!!' toHost: serverAddr port: 13.	Transcript show: 'the time server reports: ' , s getResponseNoLF.	s closeAndDestroy.	Transcript show: '---------- Socket closed ----------'; cr.! !Sonograms are imageMorphs that will repeatedly plot arrays of values as black on white columns moving to the right in time and scrolling left as necessary.!!Sonogram methodsFor: 'all' stamp: 'jm 11/13/2002 10:58'!extent: newExtent	super form: (Form extent: newExtent depth: Display depth).	lastX _ -1.	columnForm _ Form extent: (32//form depth)@(form height) depth: form depth.	pixValMap _ ((1 to: 256) collect: [:i |		(Color gray: (256-i)/255.0) pixelValueForDepth: columnForm depth])			as: Bitmap.! !!Sonogram methodsFor: 'all' stamp: 'di 8/26/1999 09:01'!extent: extent minVal: min maxVal: max scrollDelta: d	minVal _ min.	maxVal _ max.	scrollDelta _ d.	self extent: extent." try following with scrolldelta = 1, 20, 200	| s data |	s _ Sonogram new extent: 200@50				minVal: 0.0 maxVal: 1.0 scrollDelta: 20.	World addMorph: s.	data _ (1 to: 133) collect: [:i | 0.0].	1 to: 300 do:		[:i | data at: (i\\133)+1 put: 1.0.		s plotColumn: data.		data at: (i\\133)+1 put: 0.0.		World doOneCycleNow].	s delete	"! !!Sonogram methodsFor: 'all' stamp: 'jm 11/13/2002 10:59'!plotColumn: dataArray	| chm1 i normVal r |	columnForm unhibernate.	chm1 _ columnForm height - 1.	0 to: chm1 do:		[:y | 		i _ y*(dataArray size-1)//chm1 + 1.		normVal _ ((dataArray at: i) - minVal) / (maxVal - minVal).		normVal < 0.0 ifTrue: [normVal _ 0.0].		normVal > 1.0 ifTrue: [normVal _ 1.0].		columnForm bits at: chm1-y+1 put: (pixValMap at: (normVal * 255.0) truncated + 1)].	(lastX _ lastX + 1) > (form width - 1) ifTrue:		[self scroll].	form copy: (r _ (lastX@0 extent: 1@form height))			from: (32//form depth-1)@0			in: columnForm rule: Form over.	self invalidRect: (r translateBy: self position).! !!Sonogram methodsFor: 'all' stamp: 'jm 11/13/2002 10:58'!scroll	form copy: (scrollDelta@0 extent: (form width-scrollDelta)@form height)			from: form to: 0@0 rule: Form over.	lastX _ lastX - scrollDelta.	self changed.! !I represent a collection of objects ordered by some property of the objects themselves. The ordering is specified in a BlockContext.!!SortedCollection methodsFor: 'accessing' stamp: 'sma 4/28/2000 17:47'!at: anInteger put: anObject	self shouldNotImplement! !!SortedCollection methodsFor: 'accessing' stamp: 'stp 12/05/1999 07:09'!sortBlock: aBlock 	"Make the argument, aBlock, be the criterion for ordering elements of the 	receiver."	aBlock		ifNotNil: [sortBlock := aBlock fixTemps]		ifNil: [sortBlock := aBlock].	"The sortBlock must copy its home context, so as to avoid circularities!!"	"Therefore sortBlocks with side effects may not work right"	self size > 0 ifTrue: [self reSort]! !!SortedCollection methodsFor: 'adding' stamp: 'go 4/27/2000 13:19'!add: newObject	^ super insert: newObject before: (self indexForInserting: newObject)! !!SortedCollection methodsFor: 'adding' stamp: 'sma 4/28/2000 18:35'!addAll: aCollection	aCollection size > (self size // 3)		ifTrue:			[aCollection do: [:each | self addLast: each].			self reSort]		ifFalse: [aCollection do: [:each | self add: each]].	^ aCollection! !!SortedCollection methodsFor: 'adding' stamp: 'go 4/26/2000 17:26'!addFirst: newObject	self shouldNotImplement! !!SortedCollection methodsFor: 'enumerating' stamp: 'sma 2/5/2000 15:22'!collect: aBlock 	"Evaluate aBlock with each of my elements as the argument. Collect the 	resulting values into an OrderedCollection. Answer the new collection. 	Override the superclass in order to produce an OrderedCollection instead	of a SortedCollection."	| newCollection | 	newCollection _ OrderedCollection new: self size.	self do: [:each | newCollection addLast: (aBlock value: each)].	^ newCollection! !!SortedCollection methodsFor: 'private' stamp: 'stp 04/23/1999 05:32'!defaultSort: i to: j 	"Sort elements i through j of self to be nondescending according to	sortBlock."	"Assume the default sort block ([:x :y | x <= y])."	| di dij dj tt ij k l n |	"The prefix d means the data at that index."	(n _ j + 1  - i) <= 1 ifTrue: [^self].	"Nothing to sort." 	 "Sort di,dj."	di _ array at: i.	dj _ array at: j.	(di <= dj) "i.e., should di precede dj?"		ifFalse: 			[array swap: i with: j.			 tt _ di.			 di _ dj.			 dj _ tt].	n > 2		ifTrue:  "More than two elements."			[ij _ (i + j) // 2.  "ij is the midpoint of i and j."			 dij _ array at: ij.  "Sort di,dij,dj.  Make dij be their median."			 (di <= dij) "i.e. should di precede dij?"			   ifTrue: 				[(dij <= dj) "i.e., should dij precede dj?"				  ifFalse: 					[array swap: j with: ij.					 dij _ dj]]			   ifFalse:  "i.e. di should come after dij"				[array swap: i with: ij.				 dij _ di].			n > 3			  ifTrue:  "More than three elements."				["Find k>i and l<j such that dk,dij,dl are in reverse order.				Swap k and l.  Repeat this procedure until k and l pass each other."				 k _ i.				 l _ j.				 [[l _ l - 1.  k <= l and: [dij <= (array at: l)]]				   whileTrue.  "i.e. while dl succeeds dij"				  [k _ k + 1.  k <= l and: [(array at: k) <= dij]]				   whileTrue.  "i.e. while dij succeeds dk"				  k <= l]				   whileTrue:					[array swap: k with: l]. 	"Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk	through dj.  Sort those two segments."				self defaultSort: i to: l.				self defaultSort: k to: j]]! !!SortedCollection methodsFor: 'private' stamp: 'stp 04/23/1999 05:36'!indexForInserting: newObject	| index low high |	low _ firstIndex.	high _ lastIndex.	sortBlock isNil		ifTrue: [[index _ high + low // 2.  low > high]			whileFalse: 				[((array at: index) <= newObject)					ifTrue: [low _ index + 1]					ifFalse: [high _ index - 1]]]		ifFalse: [[index _ high + low // 2.  low > high]			whileFalse: 				[(sortBlock value: (array at: index) value: newObject)					ifTrue: [low _ index + 1]					ifFalse: [high _ index - 1]]].	^low! !!SortedCollection methodsFor: 'private' stamp: 'go 4/26/2000 17:17'!insert: anObject before: spot	self shouldNotImplement! !!SortedCollection methodsFor: 'private' stamp: 'sma 4/28/2000 17:46'!reSort	self sort: firstIndex to: lastIndex! !!SortedCollection methodsFor: 'private' stamp: 'stp 04/23/1999 05:33'!sort: i to: j 	"Sort elements i through j of self to be nondescending according to	sortBlock."	| di dij dj tt ij k l n |	sortBlock ifNil: [^self defaultSort: i to: j].	"The prefix d means the data at that index."	(n _ j + 1  - i) <= 1 ifTrue: [^self].	"Nothing to sort." 	 "Sort di,dj."	di _ array at: i.	dj _ array at: j.	(sortBlock value: di value: dj) "i.e., should di precede dj?"		ifFalse: 			[array swap: i with: j.			 tt _ di.			 di _ dj.			 dj _ tt].	n > 2		ifTrue:  "More than two elements."			[ij _ (i + j) // 2.  "ij is the midpoint of i and j."			 dij _ array at: ij.  "Sort di,dij,dj.  Make dij be their median."			 (sortBlock value: di value: dij) "i.e. should di precede dij?"			   ifTrue: 				[(sortBlock value: dij value: dj) "i.e., should dij precede dj?"				  ifFalse: 					[array swap: j with: ij.					 dij _ dj]]			   ifFalse:  "i.e. di should come after dij"				[array swap: i with: ij.				 dij _ di].			n > 3			  ifTrue:  "More than three elements."				["Find k>i and l<j such that dk,dij,dl are in reverse order.				Swap k and l.  Repeat this procedure until k and l pass each other."				 k _ i.				 l _ j.				 [[l _ l - 1.  k <= l and: [sortBlock value: dij value: (array at: l)]]				   whileTrue.  "i.e. while dl succeeds dij"				  [k _ k + 1.  k <= l and: [sortBlock value: (array at: k) value: dij]]				   whileTrue.  "i.e. while dij succeeds dk"				  k <= l]				   whileTrue:					[array swap: k with: l]. 	"Now l<k (either 1 or 2 less), and di through dl are all less than or equal to dk	through dj.  Sort those two segments."				self sort: i to: l.				self sort: k to: j]]! !!SortedCollection class methodsFor: 'instance creation' stamp: 'stp 04/23/1999 05:34'!new: anInteger 	"The default sorting function is a <= comparison on elements."	^(super new: anInteger) "sortBlock: [:x :y | x <= y]" 		"nil sortBlock OK"! !SoundBuffers store 16 bit unsigned quantities.  !!SoundBuffer methodsFor: 'accessing' stamp: 'tk 3/13/2000 14:46'!bytesPerElement	"Number of bytes in each item.  This multiplied by (self size)*8 gives the number of bits stored."	^ 2! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/15/1998 13:03'!asByteArray	"Answer a ByteArray containing my sample data serialized in most-significant byte first order."	| sampleCount bytes dst s |	sampleCount _ self monoSampleCount.	bytes _ ByteArray new: 2 * sampleCount.	dst _ 0.	1 to: sampleCount do: [:src |		s _ self at: src.		bytes at: (dst _ dst + 1) put: ((s bitShift: -8) bitAnd: 255).		bytes at: (dst _ dst + 1) put: (s bitAnd: 255)].	^ bytes	! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:49'!downSampledLowPassFiltering: doFiltering	"Answer a new SoundBuffer half the size of the receiver consisting of every other sample. If doFiltering is true, a simple low-pass filter is applied to avoid aliasing of high frequencies. Assume that receiver is monophonic."	"Details: The simple low-pass filter in the current implementation could be improved, at some additional cost."	| n resultBuf j |	n _ self monoSampleCount.	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.	j _ 0.	doFiltering		ifTrue: [			1 to: n by: 2 do: [:i |				resultBuf at: (j _ j + 1) put:					(((self at: i) + (self at: i + 1)) bitShift: -1)]]		ifFalse: [			1 to: n by: 2 do: [:i |				resultBuf at: (j _ j + 1) put: (self at: i)]].	^ resultBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:52'!extractLeftChannel	"Answer a new SoundBuffer half the size of the receiver consisting of only the left channel of the receiver, which is assumed to contain stereo sound data."	| n resultBuf j |	n _ self monoSampleCount.	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.	j _ 0.	1 to: n by: 2 do: [:i | resultBuf at: (j _ j + 1) put: (self at: i)].	^ resultBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 8/18/1998 06:53'!extractRightChannel	"Answer a new SoundBuffer half the size of the receiver consisting of only the right channel of the receiver, which is assumed to contain stereo sound data."	| n resultBuf j |	n _ self monoSampleCount.	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.	j _ 0.	2 to: n by: 2 do: [:i | resultBuf at: (j _ j + 1) put: (self at: i)].	^ resultBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 10/21/2001 10:43'!lowPassFiltered	"Answer a simple low-pass filtered copy of this buffer. Assume it is monophonic."	| sz out last this |	sz _ self monoSampleCount.	out _ self clone.	last _ self at: 1.	2 to: sz do: [:i |		this _ self at: i.		out at: i put: (this + last) // 2.		last _ this].	^ out! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 11/15/2001 18:26'!mergeStereo	"Answer a new SoundBuffer half the size of the receiver that mixes the left and right stereo channels of the receiver, which is assumed to contain stereo sound data."	| n resultBuf j |	n _ self monoSampleCount.	resultBuf _ SoundBuffer newMonoSampleCount: n // 2.	j _ 0.	1 to: n by: 2 do: [:i | resultBuf at: (j _ j + 1) put: (((self at: i) + (self at: i + 1)) // 2)].	^ resultBuf! !!SoundBuffer methodsFor: 'utilities' stamp: 'jm 3/28/1999 07:23'!splitStereo	"Answer an array of two SoundBuffers half the size of the receiver consisting of the left and right channels of the receiver (which is assumed to contain stereo sound data)."	| n leftBuf rightBuf leftIndex rightIndex |	n _ self monoSampleCount.	leftBuf _ SoundBuffer newMonoSampleCount: n // 2.	rightBuf _ SoundBuffer newMonoSampleCount: n // 2.	leftIndex _ rightIndex _ 0.	1 to: n by: 2 do: [:i |		leftBuf at: (leftIndex _ leftIndex + 1) put: (self at: i).		rightBuf at: (rightIndex _ rightIndex + 1) put: (self at: i + 1)].	^ Array with: leftBuf with: rightBuf! !!SoundBuffer methodsFor: 'objects from disk' stamp: 'jm 12/3/2003 14:17'!reverseEndiannessStereo: stereoFlag	"Swap the bytes of each 16-bit word, using a fast BitBlt hack. If stereoFlag is true the channels must also be reversed."	| hack blt |	hack _ Form new hackBits: self.	blt _ (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: 0; destY: 0; height: self size.	blt width: 1. "one-byte wide columns"	stereoFlag		ifTrue: [			blt sourceX: 0; destX: 3; copyBits.  "swap byte-wide columns 0 and 3 using XOR"			blt sourceX: 3; destX: 0; copyBits.			blt sourceX: 0; destX: 3; copyBits.			blt sourceX: 1; destX: 2; copyBits.  "swap byte-wide columns 1 and 2 using XOR"			blt sourceX: 2; destX: 1; copyBits.			blt sourceX: 1; destX: 2; copyBits]		ifFalse: [			blt sourceX: 0; destX: 1; copyBits.  "swap byte-wide columns 0 and 1 using XOR"			blt sourceX: 1; destX: 0; copyBits.			blt sourceX: 0; destX: 1; copyBits.			blt sourceX: 2; destX: 3; copyBits.  "swap byte-wide columns 2 and 3 using XOR"			blt sourceX: 3; destX: 2; copyBits.			blt sourceX: 2; destX: 3; copyBits].! !!SoundBuffer methodsFor: 'objects from disk' stamp: 'jm 12/3/2003 13:07'!storeOn: aBinaryStream bigEndian: bigEndianFlag stereo: stereo	"Store my samples onto the given stream. If bigEndianFlag is true, the samples will be stored in big-endian format (most-significant byte first, as in an AIFF file) otherwise they will be stored in little-endian format (least-significant byte first, as in a WAV file)."	| reverseBytes |	reverseBytes _ bigEndianFlag ~= Smalltalk isBigEndian.	reverseBytes ifTrue: [self reverseEndiannessStereo: stereo].	(aBinaryStream isKindOf: StandardFileStream)		ifTrue: [  "optimization for file streams: store directly to file"			aBinaryStream next: (self size // 2) putAll: self startingAt: 1]  "size is in 32-bit words"		ifFalse: [  "for non-file streams:"			1 to: self monoSampleCount do: [:i | aBinaryStream int16: (self at: i)]].	reverseBytes ifTrue: [self reverseEndiannessStereo: stereo].  "revert to original endianness"! !!SoundBuffer methodsFor: 'objects from disk' stamp: 'jm 12/3/2003 10:18'!swapStereoChannels	"Swap my left and right stereo channels."	| hack blt |	hack _ Form new hackBits: self.	blt _ (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: 0; destY: 0; height: self size; width: 2.	blt sourceX: 0; destX: 2; copyBits.  "swap 16-bit words using XOR"	blt sourceX: 2; destX: 0; copyBits.	blt sourceX: 0; destX: 2; copyBits.! !I am an abstract class that describes the protocol for sound codecs. Each codec (the name stems from "COder/DECoder") describes a particular algorithm for compressing and decompressing sound data. Most sound codecs are called 'lossy' because they lose information; the decompressed sound data is not exactly the same as the original data.!!SoundCodec methodsFor: 'initialization' stamp: 'jm 5/30/2003 10:32'!initialize	self reset.! !!SoundCodec methodsFor: 'compress/decompress' stamp: 'jm 2/2/1999 16:01'!compressAndDecompress: aSound	"Compress and decompress the given sound. Useful for testing."	"(MuLawCodec new compressAndDecompress: (SampledSound soundNamed: 'camera')) play"	^ (self compressSound: aSound) asSound! !!SoundCodec methodsFor: 'compress/decompress' stamp: 'jm 2/2/1999 16:01'!compressSound: aSound	"Compress the entirety of the given sound with this codec. Answer a CompressedSoundData."	| compressed channels |	compressed _ CompressedSoundData new		codecName: self class name;		soundClassName: aSound class name.	(aSound isKindOf: SampledSound) ifTrue: [		channels _ Array new: 1.		channels at: 1 put: (self encodeSoundBuffer: aSound samples).		compressed			channels: channels;			samplingRate: aSound originalSamplingRate;			firstSample: 1;			loopEnd: aSound samples size;			loopLength: 0.0;			perceivedPitch: 100.0;			gain: aSound loudness.		^ compressed].	(aSound isKindOf: LoopedSampledSound) ifTrue: [		aSound isStereo			ifTrue: [				channels _ Array new: 2.				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples).				channels at: 2 put: (self encodeSoundBuffer: aSound rightSamples)]			ifFalse: [				channels _ Array new: 1.				channels at: 1 put: (self encodeSoundBuffer: aSound leftSamples)].		compressed			channels: channels;			samplingRate: aSound originalSamplingRate;			firstSample: aSound firstSample;			loopEnd: aSound loopEnd;			loopLength: aSound loopLength;			perceivedPitch: aSound perceivedPitch;			gain: aSound gain.		^ compressed].	self error: 'you can only compress sampled sounds'.! !!SoundCodec methodsFor: 'compress/decompress' stamp: 'jm 3/30/1999 08:03'!decompressSound: aCompressedSound	"Decompress the entirety of the given compressed sound with this codec and answer the resulting sound."	| channels sound |	channels _ aCompressedSound channels		collect: [:compressed | self decodeCompressedData: compressed].	'SampledSound' = aCompressedSound soundClassName ifTrue: [		sound _ SampledSound			samples: channels first			samplingRate: (aCompressedSound samplingRate).		sound loudness: aCompressedSound gain.		^ sound].	'LoopedSampledSound' = aCompressedSound soundClassName ifTrue: [		aCompressedSound loopLength = 0			ifTrue: [				sound _ LoopedSampledSound					unloopedSamples: channels first					pitch: aCompressedSound perceivedPitch					samplingRate: aCompressedSound samplingRate]			ifFalse: [				sound _ LoopedSampledSound					samples: channels first					loopEnd: aCompressedSound loopEnd					loopLength: aCompressedSound loopLength					pitch: aCompressedSound perceivedPitch					samplingRate: aCompressedSound samplingRate].		channels size > 1 ifTrue: [sound rightSamples: channels last].		sound			firstSample: aCompressedSound firstSample;			gain: aCompressedSound gain.		sound			setPitch: 100.0			dur: (channels first size / aCompressedSound samplingRate)			loudness: 1.0.		^ sound].	self error: 'unknown sound class'.! !!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'di 2/8/1999 14:23'!bytesPerEncodedFrame	"Answer the number of bytes required to hold one frame of compressed sound data. Answer zero if this codec produces encoded frames of variable size."	self subclassResponsibility.! !!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/2/1999 15:38'!decodeFrames: frameCount from: srcByteArray at: srcIndex into: dstSoundBuffer at: dstIndex	"Decode the given number of monophonic frames starting at the given index in the given ByteArray of compressed sound data and storing the decoded samples into the given SoundBuffer starting at the given destination index. Answer a pair containing the number of bytes of compressed data consumed and the number of decompressed samples produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	self subclassResponsibility.! !!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/2/1999 15:39'!encodeFrames: frameCount from: srcSoundBuffer at: srcIndex into: dstByteArray at: dstIndex	"Encode the given number of frames starting at the given index in the given monophonic SoundBuffer and storing the encoded sound data into the given ByteArray starting at the given destination index. Encode only as many complete frames as will fit into the destination. Answer a pair containing the number of samples consumed and the number of bytes of compressed data produced."	"Note: Assume that the sender has ensured that the given number of frames will not exhaust either the source or destination buffers."	self subclassResponsibility.! !!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/4/1999 11:30'!reset	"Reset my encoding and decoding state. Optional. This default implementation does nothing."! !!SoundCodec methodsFor: 'subclass responsibilities' stamp: 'jm 2/2/1999 15:45'!samplesPerFrame	"Answer the number of sound samples per compression frame."	self subclassResponsibility.! !!SoundCodec methodsFor: 'private' stamp: 'di 2/8/1999 19:53'!decodeCompressedData: aByteArray	"Decode the entirety of the given encoded data buffer with this codec. Answer a monophonic SoundBuffer containing the uncompressed samples."	| frameCount result increments |	frameCount _ self frameCount: aByteArray.	result _ SoundBuffer newMonoSampleCount: frameCount * self samplesPerFrame.	self reset.	increments _ self decodeFrames: frameCount from: aByteArray at: 1 into: result at: 1.	((increments first = aByteArray size) and: [increments last = result size]) ifFalse: [		self error: 'implementation problem; increment sizes should match buffer sizes'].	^ result! !!SoundCodec methodsFor: 'private' stamp: 'di 2/8/1999 14:20'!encodeSoundBuffer: aSoundBuffer	"Encode the entirety of the given monophonic SoundBuffer with this codec. Answer a ByteArray containing the compressed sound data."	| codeFrameSize frameSize fullFrameCount lastFrameSamples result increments finalFrame i lastIncs |	frameSize _ self samplesPerFrame.	fullFrameCount _ aSoundBuffer monoSampleCount // frameSize.	lastFrameSamples _ aSoundBuffer monoSampleCount - (fullFrameCount * frameSize).	codeFrameSize _ self bytesPerEncodedFrame.	codeFrameSize = 0 ifTrue:		["Allow room for 1 byte per sample for variable-length compression"		codeFrameSize _ frameSize].	lastFrameSamples > 0		ifTrue: [result _ ByteArray new: (fullFrameCount + 1) * codeFrameSize]		ifFalse: [result _ ByteArray new: fullFrameCount * codeFrameSize].	self reset.	increments _ self encodeFrames: fullFrameCount from: aSoundBuffer at: 1 into: result at: 1.	lastFrameSamples > 0 ifTrue: [		finalFrame _ SoundBuffer newMonoSampleCount: frameSize.		i _ fullFrameCount * frameSize.		1 to: lastFrameSamples do: [:j |			finalFrame at: j put: (aSoundBuffer at: (i _ i + 1))].		lastIncs _ self encodeFrames: 1 from: finalFrame at: 1 into: result at: 1 + increments second.		increments _ Array with: increments first + lastIncs first							with: increments second + lastIncs second].	increments second < result size		ifTrue: [^ result copyFrom: 1 to: increments second]		ifFalse: [^ result]! !!SoundCodec methodsFor: 'private' stamp: 'di 2/8/1999 19:54'!frameCount: aByteArray	"Compute the frame count for this byteArray.  This default computation will have to be overridden by codecs with variable frame sizes."	| codeFrameSize |	codeFrameSize _ self bytesPerEncodedFrame.	(aByteArray size \\ codeFrameSize) = 0 ifFalse:		[self error: 'encoded buffer is not an even multiple of the encoded frame size'].	^ aByteArray size // codeFrameSize! !I am a player for streamable sound files. The sound is played from disk, but a condensed loudness envelope is kept in memory to provide a visual display of the sound data.!!SoundFilePlayer methodsFor: 'initialization' stamp: 'jm 12/30/2002 18:56'!addControls	| b r m |	b _ SimpleButtonMorph new target: self; borderColor: #raised; borderWidth: 1; useSquareCorners.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'Menu';			actionSelector: #invokeMenu).	r addMorphBack: (b fullCopy label: 'Stop';			actionSelector: #stopPlaying).	r addMorphBack: (b fullCopy label: 'Play';			actionSelector: #startPlaying).	r addMorphBack: (b fullCopy label: 'Add Mark';		actionSelector: #addNamedBookmark).	r addMorphBack: (b fullCopy label: 'Edit Mark';		actionSelector: #editBookmark).	r addMorphBack: (b fullCopy label: 'Delete Mark';	actionSelector: #deleteBookmark).	r addMorphBack: (b fullCopy label: 'Select';			actionSelector: #selectBookmark).	r addMorphBack: (b fullCopy label: 'Unselect';		actionSelector: #unselectBookmark).	r addMorphBack: (b fullCopy label: '<<';				actionSelector: #previousSelectedBookmark).	r addMorphBack: (b fullCopy label: '<';				actionSelector: #previousBookmark).	r addMorphBack: (b fullCopy label: '>';				actionSelector: #nextBookmark).	r addMorphBack: (b fullCopy label: '>>';				actionSelector: #nextSelectedBookmark).	self addMorphBack: r.	r _ AlignmentMorph newRow.	r color: self color; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #rigid; extent: 5@20; centering: #center.	m _ StringMorph new contents: 'Time: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #timeString;		useStringFormat;		growable: false; width: 80; step.	r addMorphBack: m.	m _ StringMorph new contents: ' Bookmark: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #currentBookmark;		growable: false; width: 250; step.	r addMorphBack: m.	self addMorphBack: r.	scrollBar _ SimpleSliderMorph new		color: color;		extent: graph width@10;		target: self;		actionSelector: #scroll:.	self addMorphBack: graph.	self addMorphBack: scrollBar.! !!SoundFilePlayer methodsFor: 'initialization' stamp: 'jm 12/26/2002 19:56'!initialize	super initialize.	self orientation: #vertical.	self hResizing: #shrinkWrap.	self vResizing: #shrinkWrap.	self borderWidth: 2; inset: 2.	graph _ GraphWithBookmarksMorph new extent: 950@100; borderWidth: 1.	mSecsPerEnvSample _ 18.	lastBookmarkID _ 0.	self addControls.! !!SoundFilePlayer methodsFor: 'buttons' stamp: 'jm 12/28/2002 09:35'!addNamedBookmark	"Add a bookmark at the current cursor location."	| label |	label _ FillInTheBlank request: 'Bookmark name?'.	label size = 0 ifTrue: [^ self].	graph bookmarkAt: graph cursor put: (Array with: label with: false).	self redrawGraph.! !!SoundFilePlayer methodsFor: 'buttons' stamp: 'jm 1/1/2003 18:15'!deleteBookmark	"Delete the last bookmark before the current cursor position. Do nothing if there is no such bookmark."	| mark |	mark _ graph bookmarkAt: graph cursor.	mark ifNil: [^ ''].	(self confirm: 'Delete last bookmark?') ifFalse: [^ self].	graph bookmarks: (graph bookmarks copyWithout: mark).	self redrawGraph.! !!SoundFilePlayer methodsFor: 'buttons' stamp: 'jm 1/1/2003 18:14'!editBookmark	"Change the label of the last bookmark before the current cursor position. Do nothing if there is no such bookmark."	| mark label |	mark _ graph bookmarkAt: graph cursor.	mark ifNil: [^ ''].	label _ FillInTheBlank		request: 'Bookmark name?'		initialAnswer: mark value first.	label size = 0 ifTrue: [^ self].	mark value at: 1 put: label.! !!SoundFilePlayer methodsFor: 'buttons' stamp: 'jm 12/28/2002 09:25'!nextBookmark	"Move the cursor to the next bookmark."	| wasPlaying mark i |	graph bookmarks isEmpty ifTrue: [^ self].	wasPlaying _ streamingSound isPlaying.	self stopPlaying.	mark _ graph bookmarkAt: graph cursor.	mark		ifNil: [self goToBookmark: graph bookmarks first]		ifNotNil: [			i _ graph bookmarks indexOf: mark ifAbsent: [graph bookmarks size + 1].			i < graph bookmarks size ifTrue: [				self goToBookmark: (graph bookmarks at: i + 1)]].	wasPlaying ifTrue: [self startPlaying].! !!SoundFilePlayer methodsFor: 'buttons' stamp: 'jm 12/30/2002 18:55'!nextSelectedBookmark	"Move the cursor to the next selected bookmark."	| wasPlaying mark i m |	graph bookmarks isEmpty ifTrue: [^ self].	wasPlaying _ streamingSound isPlaying.	self stopPlaying.	mark _ graph bookmarkAt: graph cursor.	mark		ifNil: [			m _ graph bookmarks first.			(m value at: 2) ifTrue: [self goToBookmark: m]]		ifNotNil: [			i _ graph bookmarks indexOf: mark ifAbsent: [graph bookmarks size + 1].			[i < graph bookmarks size] whileTrue: [				m _ graph bookmarks at: i + 1.				(m value at: 2) ifTrue: [					self goToBookmark: m.					i _ graph bookmarks size + 1].				i _ i + 1]].	wasPlaying ifTrue: [self startPlaying].! !!SoundFilePlayer methodsFor: 'buttons' stamp: 'jm 12/28/2002 09:29'!previousBookmark	"Move the cursor to the start of the previous bookmark."	| wasPlaying mark i |	graph bookmarks isEmpty ifTrue: [^ self].	wasPlaying _ streamingSound isPlaying.	self stopPlaying.	mark _ graph bookmarkAt: graph cursor.	mark ifNotNil: [		i _ graph bookmarks indexOf: mark ifAbsent: [-1].		i > 1 ifTrue: [			self goToBookmark: (graph bookmarks at: i - 1)]].	wasPlaying ifTrue: [self startPlaying].! !!SoundFilePlayer methodsFor: 'buttons' stamp: 'jm 12/30/2002 18:55'!previousSelectedBookmark	"Move the cursor to the start of the previous selected bookmark."	| wasPlaying mark i m |	graph bookmarks isEmpty ifTrue: [^ self].	wasPlaying _ streamingSound isPlaying.	self stopPlaying.	mark _ graph bookmarkAt: graph cursor.	mark ifNotNil: [		i _ graph bookmarks indexOf: mark ifAbsent: [-1].		[i > 1] whileTrue: [			m _ graph bookmarks at: i - 1.			(m value at: 2) ifTrue: [				self goToBookmark: m.				i _ 0].			i _ i - 1]].	wasPlaying ifTrue: [self startPlaying].! !!SoundFilePlayer methodsFor: 'buttons' stamp: 'jm 12/26/2002 18:56'!selectBookmark	"Select the last bookmark before the current cursor position. Do nothing if there is no such bookmark."	| mark |	mark _ graph bookmarkAt: graph cursor.	mark ifNotNil: [		mark value at: 2 put: true.		self redrawGraph].! !!SoundFilePlayer methodsFor: 'buttons' stamp: 'jm 12/28/2002 09:26'!startPlaying	"Start playing at the current cursor position."	self world ifNotNil: [self world primaryHand newKeyboardFocus: self].	streamingSound play.	streamingSound soundPosition: (graph cursor / graph data size).! !!SoundFilePlayer methodsFor: 'buttons' stamp: 'jm 12/28/2002 09:26'!stopPlaying	| fraction |	self world ifNotNil: [self world primaryHand newKeyboardFocus: self].	streamingSound isPlaying ifFalse: [^ self].	streamingSound pause.	fraction _ (streamingSound millisecondsSinceStart) asFloat / (1000.0 * streamingSound duration).	graph cursor: (fraction * graph data size) rounded.	graph changed.! !!SoundFilePlayer methodsFor: 'buttons' stamp: 'jm 12/26/2002 18:56'!unselectBookmark	"Unselect the last bookmark before the current cursor position. Do nothing if there is no such bookmark."	| mark |	mark _ graph bookmarkAt: graph cursor.	mark ifNotNil: [		mark value at: 2 put: false.		self redrawGraph].! !!SoundFilePlayer methodsFor: 'menu' stamp: 'jm 12/30/2002 21:27'!invokeMenu	"Invoke a menu of additonal functions."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('open'			openFile)		('save'			saveFile)		-		('reset bookmark numbers' resetBookmarkNumbers)		('play selected'	playSelected)).	aMenu invokeOn: self defaultSelection: nil.! !!SoundFilePlayer methodsFor: 'menu' stamp: 'jm 1/6/2003 15:45'!openFile	"Open a new sound file."	| result fileName |	result _ StandardFileMenu oldFile.	result ifNil: [^ self].	fileName _ result directory pathName, FileDirectory slash, result name.	streamingSound ifNotNil: [self stopPlaying].	self openFileNamed: fileName.! !!SoundFilePlayer methodsFor: 'menu' stamp: 'jm 12/30/2002 21:30'!playSelected	| snd |	"Extract and play all selected bookmarks."	snd _ SequentialSound new.	(graph bookmarks select: [:m | m value at: 2]) do: [:m |		snd add: (self extractSegmentAtBookmark: m)].	snd play.		! !!SoundFilePlayer methodsFor: 'menu' stamp: 'jm 12/30/2002 21:27'!resetBookmarkNumbers	lastBookmarkID _ 0.! !!SoundFilePlayer methodsFor: 'menu' stamp: 'jm 12/28/2002 10:06'!saveFile	"Save the bookmarks file."	| fileName i root bmFileName f |	fileName _ streamingSound fileName.	(i _ fileName findLast: [:c | c = $.]) > 0		ifTrue: [root _ fileName copyFrom: 1 to: i - 1]		ifFalse: [root _ fileName].	bmFileName _ root, '.bmk'.	FileDirectory default deleteFileNamed: bmFileName ifAbsent: [].	f _ (FileDirectory default newFileNamed: bmFileName) binary.	self writeBookmarksAndEnvelopeOn: f.	f close.! !!SoundFilePlayer methodsFor: 'accessing' stamp: 'jm 12/26/2002 17:34'!currentBookmark	"Answer the bookmark string for the current cursor position, or the empty string."	| mark |	mark _ graph bookmarkAt: graph cursor.	mark ifNil: [^ ''].	^ mark value first! !!SoundFilePlayer methodsFor: 'accessing' stamp: 'jm 12/22/2002 19:05'!scroll: fraction	"Scroll to the given fraction of the total sound file, between 0.0 and 1.0."	graph startIndex: (fraction * (graph data size - (graph width - 2))).	graph changed.! !!SoundFilePlayer methodsFor: 'accessing' stamp: 'jm 12/28/2002 09:36'!timeString	"Answer as string representing the time for the current cursor position."	| mSecs hundredths seconds minutes hours result |	mSecs _ (graph cursor - 1) * mSecsPerEnvSample.	hundredths _ (mSecs // 10) \\ 100.	seconds _ (mSecs // 1000) \\ 60.	minutes _ (mSecs // (60 * 1000)) \\ 60.	hours _ mSecs // (60 * 60 * 1000).	result _ WriteStream on: (String new: 100).	result nextPutAll: (hours printString padded: #left to: 2 with: $0).	result nextPut: $:.	result nextPutAll: (minutes printString padded: #left to: 2 with: $0).	result nextPut: $:.	result nextPutAll: (seconds printString padded: #left to: 2 with: $0).	result nextPut: $..	result nextPutAll: (hundredths printString padded: #left to: 2 with: $0).	^ result contents! !!SoundFilePlayer methodsFor: 'events' stamp: 'jm 12/23/2002 08:02'!handlesMouseOver: evt	^ true! !!SoundFilePlayer methodsFor: 'events' stamp: 'jm 12/28/2002 09:36'!keyStroke: evt	"Toggle playing."	evt keyCharacter = Character space ifTrue: [		streamingSound isPlaying			ifTrue: [self stopPlaying]			ifFalse: [self startPlaying].		^ self].	streamingSound isPlaying ifTrue: [		lastBookmarkID _ lastBookmarkID + 1.		graph			bookmarkAt: graph cursor			put: (Array with: lastBookmarkID printString with: false).		self redrawGraph].! !!SoundFilePlayer methodsFor: 'events' stamp: 'jm 12/23/2002 08:04'!mouseEnter: evt	"Make myself be the keyboard focus so the space bar can be used to toggle playing."		evt hand newKeyboardFocus: self.! !!SoundFilePlayer methodsFor: 'stepping' stamp: 'jm 12/26/2002 18:55'!redrawGraph	"Redraw the graph."	graph flushCachedForm.	graph changed.! !!SoundFilePlayer methodsFor: 'stepping' stamp: 'jm 12/26/2002 16:57'!step	| fraction |	streamingSound ifNil: [^ self].	streamingSound isPlaying ifTrue: [		fraction _ (streamingSound millisecondsSinceStart - 150) asFloat / (1000.0 * streamingSound duration).		graph cursor: (fraction * graph data size) rounded.		graph changed].	scrollBar adjustToValue: graph startIndex / graph data size.! !!SoundFilePlayer methodsFor: 'stepping' stamp: 'jm 12/22/2002 10:19'!stepTime	^ 15! !!SoundFilePlayer methodsFor: 'private' stamp: 'jm 12/28/2002 19:09'!extractEnvelope	"Extract the envelope data from my sound file."	| result n buf peak v totalSamples |	result _ WriteStream on: (ByteArray new: 100000).	n _ (mSecsPerEnvSample * streamingSound streamSamplingRate) // 1000.	n odd ifTrue: [n _ n + 1].	streamingSound reset.	totalSamples _ streamingSound samplesRemaining.	'Scanning file...'		displayProgressAt: Sensor cursorPoint		from: 0 to: totalSamples		during: [:bar |			[streamingSound samplesRemaining > 0] whileTrue: [				buf _ streamingSound loadBuffersForSampleCount: n.				peak _ 0.				1 to: buf monoSampleCount do: [:i |					v _ buf at: i.					v < 0 ifTrue: [v _ 0 - v].					v > peak ifTrue: [peak _ v]].				result nextPut: (peak bitShift: -7).				bar value: (totalSamples - streamingSound samplesRemaining)]].	graph data: result contents.! !!SoundFilePlayer methodsFor: 'private' stamp: 'jm 12/30/2002 21:09'!extractSegmentAtBookmark: anAssociation	"Answer a SampledSound for the section of sound between the given bookmark and the following bookmark, or the end of the sound file if it is the last bookmark."	| start i end |	start _ anAssociation key.	i _ graph bookmarks indexOf: anAssociation ifAbsent: [self error: 'bookmark missing'].	i = graph bookmarks size		ifTrue: [end _ graph data size - 2]		ifFalse: [end _ (graph bookmarks at: (i + 1)) key].	^ self extractSoundFrom: start to: end! !!SoundFilePlayer methodsFor: 'private' stamp: 'jm 12/30/2002 21:25'!extractSoundFrom: startIndex to: stopIndex	"Extract sound samples between the given indices in the envelope. Trim the start and stop to the nearest zero crossing. Answer a SampledSound."	| mSecs n buf start end |	mSecs _ ((stopIndex - startIndex) + 3) * mSecsPerEnvSample.	n _ (mSecs * streamingSound streamSamplingRate) // 1000.	n > 5000000 ifTrue: [self error: 'sound segment too large'].	n odd ifTrue: [n _ n + 1].	streamingSound play; pause.	streamingSound soundPosition: ((startIndex - 2) max: 0) / graph data size.	buf _ streamingSound loadBuffersForSampleCount: n.	start _ self indexOfFirstZeroCrossingIn: buf.	end _ self indexOfLastZeroCrossingIn: buf.	buf _ buf copyFrom: start to: end.	(end - start) even ifTrue: [buf at: buf monoSampleCount put: (buf at: buf monoSampleCount - 1)].	^ SampledSound samples: buf samplingRate: streamingSound streamSamplingRate! !!SoundFilePlayer methodsFor: 'private' stamp: 'jm 12/30/2002 19:02'!goToBookmark: bookmarkEntry	"Position the cursor at the start of the given bookmark and highlight the bookmark selection."	| newCursor start end |	newCursor _ bookmarkEntry key + 1 max: 1.	start _ graph startIndex.	end _ start + (graph width - (2 * graph borderWidth)).	((newCursor > start) and: [newCursor < end]) ifFalse: [		graph startIndex: ((newCursor - 15) max: 1)].	graph cursor: newCursor.	self redrawGraph.! !!SoundFilePlayer methodsFor: 'private' stamp: 'jm 12/30/2002 20:52'!indexOfFirstZeroCrossingIn: aSoundBuffer	| lastSign |	"Answer the index of the first zero crossing in the given SoundBuffer."	lastSign _ (aSoundBuffer at: 1) sign.	lastSign = 0 ifTrue: [^ 1].	2 to: aSoundBuffer monoSampleCount do: [:i |		(aSoundBuffer at: i) sign = lastSign ifFalse: [			(aSoundBuffer at: i - 1) abs < (aSoundBuffer at: i) abs				ifTrue: [^ i - 1]				ifFalse: [^ i]]].	^ 1  "no zero crossings found"! !!SoundFilePlayer methodsFor: 'private' stamp: 'jm 12/30/2002 20:54'!indexOfLastZeroCrossingIn: aSoundBuffer	"Answer the index of the first zero crossing in the given SoundBuffer."	| sz lastSign |	sz _ aSoundBuffer monoSampleCount.	lastSign _ (aSoundBuffer at: sz) sign.	lastSign = 0 ifTrue: [^ 1].	(sz - 1) to: 1 by: -1 do: [:i |		(aSoundBuffer at: i) sign = lastSign ifFalse: [			(aSoundBuffer at: i + 1) abs < (aSoundBuffer at: i) abs				ifTrue: [^ i + 1]				ifFalse: [^ i]]].	^ sz  "no zero crossings found"! !!SoundFilePlayer methodsFor: 'private' stamp: 'jm 12/30/2002 19:58'!openFileNamed: fileName	"Open the given sound file."	| i root bmFileName f |	(fileName asLowercase endsWith: '.mp3')		ifTrue: [streamingSound _ StreamingMP3Sound onFileNamed: fileName]		ifFalse: [streamingSound _ StreamingMonoSound onFileNamed: fileName].	(i _ fileName findLast: [:c | c = $.]) > 0		ifTrue: [root _ fileName copyFrom: 1 to: i - 1]		ifFalse: [root _ fileName].	bmFileName _ root, '.bmk'.	(FileDirectory default fileExists: bmFileName)		ifTrue: [			f _ (FileDirectory default readOnlyFileNamed: bmFileName) binary.			self readBookmarksAndEnvelopeFrom: f.			f close]		ifFalse: [			self extractEnvelope.			graph bookmarks: #().			lastBookmarkID _ 0].	graph cursor: 0.! !!SoundFilePlayer methodsFor: 'private' stamp: 'jm 12/28/2002 19:13'!readBookmarksAndEnvelopeFrom: aBinaryStream	"Read the bookmarks and envelope data on the given stream."	| startPos version sampleMSecs lastID envOffset bmCount newBookmarks k selected label envSize envData |	"read header"	startPos _ aBinaryStream position.	(aBinaryStream next: 3) asString = 'bkm' ifFalse: [		self error: 'bad file type'].	version _ aBinaryStream next.	sampleMSecs _ aBinaryStream uint32.	lastID _ aBinaryStream uint32.	envOffset _ aBinaryStream uint32.	aBinaryStream skip: 20.	"read bookmarks"	bmCount _ aBinaryStream uint32.	newBookmarks _ OrderedCollection new.	1 to: bmCount do: [:i |		k _ aBinaryStream uint32.		selected _ aBinaryStream boolean.		label _ aBinaryStream string.		newBookmarks addLast: (k -> (Array with: label with: selected))].	aBinaryStream position = (startPos + envOffset)		ifFalse: [self error: 'bad bookmark data size'].	envSize _ aBinaryStream uint32.	envData _ aBinaryStream next: envSize.	envData size = envSize ifFalse: [self error: 'not enough envelope data'].	mSecsPerEnvSample _ sampleMSecs.	lastBookmarkID _ lastID.	graph data: envData.	graph bookmarks: newBookmarks asArray sort.! !!SoundFilePlayer methodsFor: 'private' stamp: 'jm 12/26/2002 20:59'!writeBookmarksAndEnvelopeOn: aBinaryStream	"Write the bookmarks and envelope data on the given stream."	| startPos envStartPosition envStart |	startPos _ aBinaryStream position.	"write header"	aBinaryStream nextPutAll: 'bkm' asByteArray.  "file type"	aBinaryStream nextPut: 1.  "file version"	aBinaryStream uint32: mSecsPerEnvSample.	aBinaryStream uint32: lastBookmarkID.	envStartPosition _ aBinaryStream position.	aBinaryStream uint32: 0.  "filled in later with envelope start offset"	aBinaryStream nextPutAll: (ByteArray new: 20).  "reserved"	"write bookmarks"	aBinaryStream uint32: graph bookmarks size.	graph bookmarks do: [:bm |		aBinaryStream uint32: bm key.		aBinaryStream boolean: (bm value at: 2).		aBinaryStream string: (bm value at: 1)].	"write envelope data"	envStart _ aBinaryStream position - startPos.	aBinaryStream uint32: graph data size.	aBinaryStream nextPutAll: graph data.	aBinaryStream position: envStartPosition.	aBinaryStream uint32: envStart.! !This subclass of SoundRecorder supports real-time processing of incoming sound data. The sound input process queues raw sound buffers, allowing them to be read and processed by the client as they become available. A semaphore is used to synchronize between the record process and the client process. Since sound data is buffered, the client process may lag behind the input process without losing data.!!SoundInputStream methodsFor: 'initialization' stamp: 'jm 9/8/1999 15:22'!initialize	super initialize.	bufferSize _ 1024.	mutex _ nil.! !!SoundInputStream methodsFor: 'accessing' stamp: 'jm 9/8/1999 15:26'!bufferCount	"Answer the number of sound buffers that have been queued."	| n |	mutex ifNil: [^ 0].  "not recording"	mutex critical: [n _ recordedBuffers size].	^ n! !!SoundInputStream methodsFor: 'accessing' stamp: 'jm 9/6/1999 10:36'!bufferSize	^ bufferSize! !!SoundInputStream methodsFor: 'accessing' stamp: 'jm 9/8/1999 15:26'!bufferSize: aNumber	"Set the sound buffer size. Buffers of this size will be queued for the client to process."	bufferSize _ aNumber truncated.! !!SoundInputStream methodsFor: 'accessing' stamp: 'jm 9/8/1999 15:23'!isRecording	"Answer true if the sound input process is running."	^ recordProcess ~~ nil! !!SoundInputStream methodsFor: 'accessing' stamp: 'jm 9/6/1999 10:32'!nextBufferOrNil	"Answer the next input buffer or nil if no buffer is available."	| result |	mutex ifNil: [^ nil].  "not recording"	mutex critical: [		recordedBuffers size > 0			ifTrue: [result _ recordedBuffers removeFirst]			ifFalse: [result _ nil]].	^ result! !!SoundInputStream methodsFor: 'recording controls' stamp: 'jm 9/8/1999 15:23'!startRecording	"Start the sound input process."	recordProcess ifNotNil: [self stopRecording].	recordedBuffers _ OrderedCollection new: 100.	mutex _ Semaphore forMutualExclusion.	super startRecording.	paused _ false.! !!SoundInputStream methodsFor: 'recording controls' stamp: 'jm 9/8/1999 15:23'!stopRecording	"Turn off the sound input process and close the driver."	super stopRecording.	recordedBuffers _ nil.	mutex _ nil.! !!SoundInputStream methodsFor: 'private' stamp: 'jm 9/8/1999 15:24'!allocateBuffer	"Allocate a new buffer and reset nextIndex. This message is sent by the sound input process."	currentBuffer _ SoundBuffer newMonoSampleCount: bufferSize.	nextIndex _ 1.! !!SoundInputStream methodsFor: 'private' stamp: 'jm 9/8/1999 15:24'!emitBuffer: buffer	"Queue a buffer for later processing. This message is sent by the sound input process."	mutex critical: [recordedBuffers addLast: buffer].! !!SoundInputStream methodsFor: 'private' stamp: 'jm 1/1/2004 18:49'!writeAIFFHeaderOn: aBinaryStream sampleCount: sampleCount		"Write the header for a 16-bit AIFF file for the given number of 16-bit samples at my sampling rate."	"Here's a do-it for recording an AIFF file:		f _ (FileStream newFileNamed: 'test.aif') binary.		(FileDirectory forFileName: f name) setMacFileNamed: f localName type: 'AIFF' creator: 'SCPL'.		rec _ SoundInputStream new samplingRate: 22050.		sampleCount _ 0.		rec writeAIFFHeaderOn: f sampleCount: 0.		rec startRecording.		[Sensor anyButtonPressed] whileFalse: [			buf _ rec nextBufferOrNil.			buf ifNotNil: [				sampleCount _ sampleCount + buf monoSampleCount.				f nextPutAll: buf]].		rec stopRecording.		f position: 0.		rec writeAIFFHeaderOn: f sampleCount: sampleCount.		f close."	| sampleBytes |	sampleBytes _ 2 * sampleCount.	"write AIFF file header:"	aBinaryStream nextPutAll: 'FORM' asByteArray.	aBinaryStream int32: (54 - 8) + sampleBytes.  "total header size - 8 bytes for 'FORM' and size"	aBinaryStream nextPutAll: 'AIFF' asByteArray.	aBinaryStream nextPutAll: 'COMM' asByteArray.	aBinaryStream int32: 18.	aBinaryStream int16: (stereo ifTrue: [2] ifFalse: [1]).	aBinaryStream int32: sampleCount.	aBinaryStream int16: 16.  "bits/sample"	AbstractSound new storeExtendedFloat: self samplingRate on: aBinaryStream.  "10 bytes"	aBinaryStream nextPutAll: 'SSND' asByteArray.	aBinaryStream int32: sampleBytes + 8.	aBinaryStream int32: 0.  "block offset; no blocking"	aBinaryStream int32: 0.  "block size; no blocking"	"... sample data follows ..."! !I represent a sound object that can be played or edited.!!SoundMorph methodsFor: 'initialize' stamp: 'jm 12/10/2003 16:10'!initialize	super initialize.	self color: Color lightGray.	self extent: (SoundSkin at: #scratchSound ifAbsent: [0@0 extent: 20@20]) extent.	originalSound _ (SampledSound soundNamed: 'camera').	volume _ 0.5.	balance _ 0.5.	playbackRate _ 1.0.! !!SoundMorph methodsFor: 'accessing' stamp: 'jm 8/23/2003 13:38'!colorCode	^ Color r: 0.89 g: 0.44 b: 0.80! !!SoundMorph methodsFor: 'accessing' stamp: 'jm 8/23/2003 16:07'!sound	^ originalSound! !!SoundMorph methodsFor: 'accessing' stamp: 'jm 8/23/2003 16:47'!sound: aSampledSound	"Set my sound."	self pausePlaying.	playingSound _ nil.	originalSound _ aSampledSound.! !!SoundMorph methodsFor: 'drawing' stamp: 'jm 8/23/2003 13:40'!drawOn: aCanvas	| f |	f _ SoundSkin at: #scratchSound ifAbsent: [^ super drawOn: aCanvas].	aCanvas paintImage: f at: bounds origin.! !!SoundMorph methodsFor: 'copying' stamp: 'jm 8/23/2003 17:02'!updateReferencesUsing: aDictionary	"Nil out my playing sound."	super updateReferencesUsing: aDictionary.	playingSound _ nil.! !!SoundMorph methodsFor: 'scratch vars' stamp: 'jm 12/10/2003 16:03'!balance	^ balance! !!SoundMorph methodsFor: 'scratch vars' stamp: 'jm 12/10/2003 16:04'!balance: aNumber	balance _ (aNumber asFloat max: 0.0) min: 1.0.	playingSound ifNotNil: [		playingSound setPan: balance volume: volume for: 1].! !!SoundMorph methodsFor: 'scratch vars' stamp: 'jm 8/23/2003 18:45'!currentSeconds	playingSound		ifNil: [^ 0]		ifNotNil: [^ playingSound sounds first currentPosition].! !!SoundMorph methodsFor: 'scratch vars' stamp: 'jm 9/13/2003 21:12'!currentSeconds: ignored	"Currently, this doesn't do anything. It should jump to the given seconds offset."! !!SoundMorph methodsFor: 'scratch vars' stamp: 'jm 8/23/2003 16:37'!playbackRate	^ playbackRate! !!SoundMorph methodsFor: 'scratch vars' stamp: 'jm 8/23/2003 18:20'!playbackRate: aNumber	"Set the playback rate. A rate of 1.0 yields original rate."	playbackRate _ aNumber asFloat max: 0.1.	playingSound ifNotNil: [playingSound sounds first playbackRate: playbackRate].! !!SoundMorph methodsFor: 'scratch vars' stamp: 'jm 8/23/2003 16:59'!volume	^ volume! !!SoundMorph methodsFor: 'scratch vars' stamp: 'jm 12/10/2003 16:10'!volume: aNumber	volume _ (aNumber asFloat max: 0.0) min: 1.0.	playingSound ifNotNil: [		playingSound setPan: balance volume: volume for: 1].! !!SoundMorph methodsFor: 'scratch ops' stamp: 'jm 12/5/2003 18:52'!loadFile: relativeFilePath	"Read my samples from a sound file."	| fullName snd |	fullName _ self projectDirectory relativeToFullPath: relativeFilePath.	(FileDirectory default fileExists: fullName)		ifFalse: [^ self inform: 'File not found: ', relativeFilePath].	snd _ SampledSound fromFileNamed: fullName.	self sound: snd.! !!SoundMorph methodsFor: 'scratch ops' stamp: 'jm 8/23/2003 16:48'!pausePlaying	"Pauses sound playback."	playingSound ifNotNil: [playingSound pause].! !!SoundMorph methodsFor: 'scratch ops' stamp: 'jm 8/23/2003 16:48'!playFrom: secs	"Play from the given point through the end of the sound."	self playFrom: secs to: self totalSeconds.! !!SoundMorph methodsFor: 'scratch ops' stamp: 'jm 12/10/2003 16:10'!playFrom: startSecs to: endSecs	"Play the given portion of the sound. The start and end offsets are in seconds at the original sound's sampling rate regardless of the current playback rate."	| totalSecs sampleCount startIndex endIndex snd |	self pausePlaying.	originalSound ifNil: [^ self].	totalSecs _ self totalSeconds.	sampleCount _ originalSound samples monoSampleCount.	startIndex _ (startSecs * sampleCount // totalSecs) max: 1.	endIndex _ (endSecs * sampleCount // totalSecs) min: sampleCount.	startIndex < endIndex ifFalse: [^ self].	playingSound _ MixedSound new.	snd _ (SampledSound new		setSamples: originalSound samples		from: startIndex to: endIndex		samplingRate: originalSound originalSamplingRate		loudness: 1.0).	playingSound add: snd pan: balance volume: volume.	playingSound play.	snd playbackRate: playbackRate.! !!SoundMorph methodsFor: 'scratch ops' stamp: 'jm 9/13/2003 21:01'!playFromStart	"Play my sound from beginning to end."	self playFrom: 0 to: self totalSeconds.! !!SoundMorph methodsFor: 'scratch ops' stamp: 'jm 8/23/2003 16:49'!resumePlaying	"Resume playing if the sound was paused before the end. Otherwise, start playing from the beginning."	(playingSound isNil or:	 [playingSound isEmpty or:	 [playingSound samplesRemaining = 0]])		ifTrue: [self playFromStart]		ifFalse: [playingSound resumePlaying].! !!SoundMorph methodsFor: 'scratch ops' stamp: 'jm 8/23/2003 17:17'!saveFile: fileName	"Save my sound to the given file."	| fName f |	fName _ fileName.	(fName asLowercase endsWith: '.aif') ifFalse: [fName _ fName, '.aif'].	f _ (FileStream newFileNamed: fName) binary.	originalSound storeAIFFSamplesOn: f.	f close.! !!SoundMorph methodsFor: 'scratch ops' stamp: 'jm 8/23/2003 16:02'!totalSeconds	originalSound		ifNil: [^ 0]		ifNotNil: [^ originalSound samples size asFloat / originalSound originalSamplingRate].! !!SoundMorph methodsFor: 'right button menu' stamp: 'jm 9/29/2003 20:55'!editSound	| editor |	self pausePlaying.	playingSound _ nil.	editor _ ScratchSoundEditor new sound: originalSound.	editor position: self bottomLeft + (0@10).	owner addMorph: editor.	editor position: (owner center - (editor extent // 2)).	self world ifNotNil: [self world startSteppingSubmorphsOf: editor].! !!SoundMorph methodsFor: 'right button menu' stamp: 'jm 12/5/2003 18:50'!readFromFile	"Read my sound from a file."	| result fullName |	result _ StandardFileMenu oldFileExtensions: #(aif aiff wav).	result ifNil: [^ self].	fullName _ result directory pathName, FileDirectory slash, result name.	self loadFile: (self asPathRelativeToProject: fullName).! !!SoundMorph methodsFor: 'right button menu' stamp: 'jm 9/29/2003 20:47'!recordSound	| recorder |	self pausePlaying.	playingSound _ nil.	recorder _ ScratchRecordingMorph new soundMorph: self.	recorder position: self bottomLeft + (0@10).	owner addMorph: recorder.	self world ifNotNil: [self world startSteppingSubmorphsOf: recorder].! !!SoundMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 17:03'!fieldsVersion	^ 1! !!SoundMorph methodsFor: 'object i/o' stamp: 'jm 12/10/2003 16:05'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		originalSound		volume		balance		playbackRate	) from: anObjStream.! !!SoundMorph methodsFor: 'object i/o' stamp: 'jm 12/10/2003 16:05'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		originalSound		volume		balance		playbackRate	) on: anObjStream.! !!SoundMorph class methodsFor: 'scratch' stamp: 'jm 11/18/2003 16:24'!classBlockSpecs	^ #(		'playing'			('play'							-	playFromStart)			('resume'						-	resumePlaying)			('pause'							-	pausePlaying)					('play from %n secs to %n secs'	-	playFrom:to:)			('total secs'						r	totalSeconds)	).! !!SoundMorph class methodsFor: 'scratch' stamp: 'jm 12/10/2003 16:05'!varSpecs	^ #((x 0 1000)		(y 0 1000)		(layer 1 100)		(currentSeconds 0 10)		(volume 0 1)		(balance 0 1)		(playbackRate 0.1 3))! !!SoundMorph class methodsFor: 'default skin' stamp: 'jm 8/23/2003 13:38'!readSoundSkinFrom: aDirectory	"Read the Forms for my default skin from the given directory and store them in my DefaultSkin dictionary."	"self readSoundSkinFrom: (FileDirectory default directoryNamed: 'ScratchSkin')"	SoundSkin _ Dictionary new.	#(scratchSound downArrow) do: [:n |		SoundSkin at: n put: (Utilities form: n from: aDirectory)].! !!SoundMorph class methodsFor: 'default skin' stamp: 'jm 9/29/2003 16:10'!scratchSoundForm	^ SoundSkin at: #scratchSound ifAbsent: [nil]! !!SoundMorph class methodsFor: 'default skin' stamp: 'jm 8/4/2003 11:52'!soundSkin	^ SoundSkin! !!SoundPlayer class methodsFor: 'initialization' stamp: 'jm 1/14/1999 13:13'!initialize	"SoundPlayer initialize; shutDown; startUp"	"Details: BufferMSecs represents a tradeoff between latency and quality. If BufferMSecs is too low, the sound will not play smoothly, especially during long-running primitives such as large BitBlts. If BufferMSecs is too high, there will be a long time lag between when a sound buffer is submitted to be played and when that sound is actually heard. BufferMSecs is typically in the range 50-200."	SamplingRate _ 22050.	BufferMSecs _ 120.	Stereo _ true.	UseReverb ifNil: [UseReverb _ true].! !!SoundPlayer class methodsFor: 'initialization' stamp: 'jm 1/14/1999 13:14'!useShortBuffer	"Experimental support for real-time MIDI input. This only works on platforms whose hardware allows very short buffer sizes. It has been tested on a Macintosh Powerbook G3."	"SoundPlayer useShortBuffer"	self shutDown.	BufferMSecs _ 15.	SoundPlayer		startPlayerProcessBufferSize: (BufferMSecs * SamplingRate) // 1000		rate: SamplingRate		stereo: Stereo.! !!SoundPlayer class methodsFor: 'accessing' stamp: 'jm 8/13/1998 15:00'!bufferMSecs	^ BufferMSecs! !!SoundPlayer class methodsFor: 'playing' stamp: 'tk 6/24/1999 11:42'!canStartPlayer	"Some platforms do no support simultaneous record and play. If this is one of those platforms, return false if there is a running SoundRecorder."	SoundRecorder canRecordWhilePlaying ifTrue: [^ true].	SoundRecorder allSubInstancesDo: [:rec | rec isActive ifTrue: [^ false]].	^ true! !!SoundPlayer class methodsFor: 'playing' stamp: 'di 8/5/1998 23:08'!isPlaying: aSound	^ ActiveSounds includes: aSound! !!SoundPlayer class methodsFor: 'playing' stamp: 'jm 9/8/1998 17:54'!resumePlaying: aSound	"Start playing the given sound without resetting it; it will resume playing from where it last stopped."	"Implementation detail: On virtual machines that don't support the quickstart primitive, you may need to edit this method to pass false to resumePlaying:quickStart:."	self resumePlaying: aSound quickStart: true.! !!SoundPlayer class methodsFor: 'playing' stamp: 'sw 1/12/2000 22:43'!resumePlaying: aSound quickStart: quickStart	"Start playing the given sound without resetting it; it will resume playing from where it last stopped. If quickStart is true, then try to start playing the given sound immediately."	| doQuickStart |	Preferences soundsEnabled ifFalse: [^ self].	doQuickStart _ quickStart.	Preferences soundQuickStart ifFalse: [doQuickStart _ false].	PlayerProcess == nil ifTrue: [		self canStartPlayer ifFalse: [^ self].		self startUp.		"Check if startup was successful"		SoundSupported ifFalse:[^self].		doQuickStart _ false].	PlayerSemaphore critical: [		(ActiveSounds includes: aSound)			ifTrue: [doQuickStart _ false]			ifFalse: [				doQuickStart ifFalse: [ActiveSounds add: aSound]]].	"quick-start the given sound, unless the sound player has just started"	doQuickStart ifTrue: [self startPlayingImmediately: aSound].! !!SoundPlayer class methodsFor: 'player process' stamp: 'ar 12/5/1998 16:37'!startPlayerProcessBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag	"Start the sound player process. Terminate the old process, if any."	"SoundPlayer startPlayerProcessBufferSize: 1000 rate: 11025 stereo: false"	self stopPlayerProcess.	ActiveSounds _ OrderedCollection new.	Buffer _ SoundBuffer newStereoSampleCount: (bufferSize // 4) * 4.	PlayerSemaphore _ Semaphore forMutualExclusion.	SamplingRate _ samplesPerSecond.	Stereo _ stereoFlag.	ReadyForBuffer _ Semaphore new.	SoundSupported _ true. "Assume so"	UseReadySemaphore _ true.  "set to false if ready semaphore not supported by VM"	self primSoundStartBufferSize: Buffer stereoSampleCount		rate: samplesPerSecond		stereo: Stereo		semaIndex: (Smalltalk registerExternalObject: ReadyForBuffer).	"Check if sound start prim was successful"	SoundSupported ifFalse:[^self].	UseReadySemaphore		ifTrue: [PlayerProcess _ [SoundPlayer playLoop] newProcess]		ifFalse: [PlayerProcess _ [SoundPlayer oldStylePlayLoop] newProcess].	UseReverb ifTrue: [self startReverb].	PlayerProcess priority: Processor userInterruptPriority.	PlayerProcess resume.! !!SoundPlayer class methodsFor: 'player process' stamp: 'jm 6/7/1999 10:40'!startReverb	"Start a delay-line style reverb with the given tap delays and gains. Tap delays are given in samples and should be prime integers; the following comment gives an expression that generates primes."	"Integer primesUpTo: 22050"	UseReverb _ true.	ReverbState _ ReverbSound new		tapDelays: #(1601 7919) gains: #(0.12 0.07).! !!SoundPlayer class methodsFor: 'private' stamp: 'ar 12/5/1998 16:36'!primSoundStartBufferSize: bufferSize rate: samplesPerSecond stereo: stereoFlag	"Start double-buffered sound output with the given buffer size and sampling rate. This version has been superceded by primitive 171 (primSoundStartBufferSize:rate:stereo:semaIndex:)."	"ar 12/5/1998 Turn off the sound if not supported"	<primitive: 170>	SoundSupported _ false.! !!SoundPlayer class methodsFor: 'private' stamp: 'jm 6/7/1999 10:35'!startPlayingImmediately: aSound	"Private!! Start playing the given sound as soon as possible by mixing it into the sound output buffers of the underlying sound driver."	| totalSamples buf n leftover src rest |	"first, fill a double-size buffer with samples"	"Note: The code below assumes that totalSamples contains two	 buffers worth of samples, and the insertSamples primitive is	 expected to consume at least one buffer's worth of these	 samples. The remaining samples are guaranteed to fit into	 a single buffer."	totalSamples _ Buffer stereoSampleCount * 2.  "two buffer's worth"	buf _ SoundBuffer newStereoSampleCount: totalSamples.	aSound playSampleCount: totalSamples into: buf startingAt: 1.	ReverbState == nil ifFalse: [		ReverbState applyReverbTo: buf startingAt: 1 count: totalSamples].	PlayerSemaphore critical: [		"insert as many samples as possible into the sound driver's buffers"		n _ self primSoundInsertSamples: totalSamples			from: buf			samplesOfLeadTime: 1024.		leftover _ totalSamples - n.		"copy the remainder of buf into Buffer"		"Note: the following loop iterates over 16-bit words, not two-word stereo slices"		"assert: 0 < leftover <= Buffer stereoSampleCount"		src _ 2 * n.		1 to: 2 * leftover do:			[:dst | Buffer at: dst put: (buf at: (src _ src + 1))].		"generate enough additional samples to finish filling Buffer"		rest _ Buffer stereoSampleCount - leftover.		aSound playSampleCount: rest into: Buffer startingAt: leftover + 1.		ReverbState == nil ifFalse: [			ReverbState applyReverbTo: Buffer startingAt: leftover + 1 count: rest].		"record the fact that this sound has already been played into Buffer so that we don't process it again this time around"		SoundJustStarted _ aSound.		ActiveSounds add: aSound].! !!SoundRecorder methodsFor: 'initialization' stamp: 'jm 11/19/2003 12:42'!initialize	"SoundRecorder new"	stereo _ false.	samplingRate _ 22050.	recordLevel _ 0.5.	self initializeRecordingState.! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 11/16/2001 22:09'!closeFile	"Close my output file."	audioFile ifNotNil: [audioFile closeFile].	audioFile _ nil.! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 11/20/2003 08:42'!codec: aSoundCodec	codec _ aSoundCodec.! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 7/4/1998 15:03'!recordLevel	^ recordLevel! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 7/4/1998 15:04'!recordLevel: level	"Set the desired recording level to the given value in the range 0.0 to 1.0, where 0.0 is the lowest recording level and 1.0 is the maximum. Do nothing if the sound input hardware does not support changing the recording level."	"Details: On the Macintosh, the lowest possible record level attenuates the input signal, but does not silence it entirely." 	recordLevel _ (level asFloat min: 1.0) max: 0.0.	recordProcess ifNotNil: [		self primSetRecordLevel: (1000.0 * recordLevel) asInteger].! !!SoundRecorder methodsFor: 'accessing' stamp: 'jm 11/16/2001 22:13'!recordToFileNamed: fileName	"Begin recording to the file with the given name."	self closeFile.  "close previous file, if any"	audioFile _ SunAudioFileWriter onFileNamed: fileName.! !!SoundRecorder methodsFor: 'accessing' stamp: 'di 2/16/1999 09:58'!samplingRate: newRate	samplingRate _ newRate  "Best are 44100 22050 11025"! !!SoundRecorder methodsFor: 'recording controls' stamp: 'di 2/17/1999 10:54'!clearRecordedSound	"Clear the sound recorded thus far. Go into pause mode if currently recording."	paused _ true.	recordedSound _ SequentialSound new.	self allocateBuffer.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 10/20/2001 16:53'!pause	"Go into pause mode. The record level continues to be updated, but no sound is recorded."	paused _ true.	((currentBuffer ~~ nil) and: [nextIndex > 1])		ifTrue: [self emitPartialBuffer.				self allocateBuffer].	soundPlaying ifNotNil: [		soundPlaying pause.		soundPlaying _ nil].	self stopRecording.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 6/15/2003 23:54'!playback	"Playback the sound that has been recorded."	self pause.	soundPlaying _ self recordedSound.	soundPlaying ifNotNil: [soundPlaying play].! !!SoundRecorder methodsFor: 'recording controls' stamp: 'jm 12/2/2003 20:55'!resumeRecording	"Resume recording after being paused."	audioFile ifNotNil: [		audioFile			writeHeaderSamplingRate: samplingRate			format: (SunAudioFileWriter formatCodeForCompressionType: #none)].	self startRecording.	paused _ false.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'di 3/4/1999 22:38'!startRecording	"Turn of the sound input driver and start the recording process. Initially, recording is paused."	| semaIndex |	recordLevel ifNil: [recordLevel _ 0.5].  "lazy initialization"	CanRecordWhilePlaying ifFalse: [SoundPlayer shutDown].	recordProcess ifNotNil: [self stopRecording].	paused _ true.	meteringBuffer _ SoundBuffer newMonoSampleCount: 1024.	meterLevel _ 0.	self allocateBuffer.	bufferAvailableSema _ Semaphore new.	semaIndex _ Smalltalk registerExternalObject: bufferAvailableSema.	self primStartRecordingDesiredSampleRate: samplingRate asInteger		stereo: stereo		semaIndex: semaIndex.	samplingRate _ self primGetActualRecordingSampleRate.	self primSetRecordLevel: (1000.0 * recordLevel) asInteger.	recordProcess _ [self recordLoop] newProcess.	recordProcess priority: Processor userInterruptPriority.	recordProcess resume.! !!SoundRecorder methodsFor: 'recording controls' stamp: 'di 2/16/1999 09:13'!stopRecording	"Stop the recording process and turn of the sound input driver."	recordProcess ifNotNil: [recordProcess terminate].	recordProcess _ nil.	self primStopRecording.	Smalltalk unregisterExternalObject: bufferAvailableSema.	((currentBuffer ~~ nil) and: [nextIndex > 1])		ifTrue: [self emitPartialBuffer].	self initializeRecordingState.! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 2/16/1999 22:11'!endPlace	^ Array with: recordedBuffers size with: recordedBuffers last size! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 2/16/1999 22:11'!firstSampleOverThreshold: threshold dcOffset: dcOffset startingAt: startPlace	"Beginning at startPlace, this routine will return the first place at which a sample exceeds the given threshold."	| buf s iStart jStart nThreshold |	nThreshold _ threshold negated.	iStart _ startPlace first.	jStart _ startPlace second.	iStart to: recordedBuffers size do:		[:i | buf _ recordedBuffers at: i.		jStart to: buf size do:			[:j | s _ (buf at: j) - dcOffset.			(s < nThreshold or: [s > threshold]) ifTrue:				["found a sample over threshold"				^ Array with: i with: j]].		jStart _ 1].	^ self endPlace! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 2/16/1999 23:01'!place: startPlace plus: nSamples	"Return the place that is nSamples (may be negative) beyond thisPlace."	| i j remaining buf |	i _ startPlace first.	j _ startPlace second.	nSamples >= 0	ifTrue: [remaining _ nSamples.			[buf _ recordedBuffers at: i.			(j + remaining) <= buf size ifTrue: [^ Array with: i with: j + remaining].			i < recordedBuffers size]				whileTrue: [remaining _ remaining - (buf size - j + 1).							i _ i+1.  j _ 1].			^ self endPlace]	ifFalse: [remaining _ nSamples negated.			[buf _ recordedBuffers at: i.			(j - remaining) >= 1 ifTrue: [^ Array with: i with: j - remaining].			i > 1]				whileTrue: [remaining _ remaining - j.							i _ i-1.  j _ (recordedBuffers at: i) size].			^ #(1 1)]! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 2/16/1999 23:19'!scanForEndThreshold: threshold dcOffset: dcOffset minLull: lull startingAt: startPlace	"Beginning at startPlace, this routine will find the last sound that exceeds threshold, such that if you look lull samples later you will not find another sound over threshold within the following block of lull samples.	Return the place that is lull samples beyond to that last sound.	If no end of sound is found, return endPlace."	| buf s iStart jStart nThreshold n |	nThreshold _ threshold negated.	iStart _ startPlace first.	jStart _ startPlace second.	n _ 0.	iStart to: recordedBuffers size do:		[:i | buf _ recordedBuffers at: i.		jStart to: buf size do:			[:j | s _ (buf at: j) - dcOffset.			(s < nThreshold or: [s > threshold])				ifTrue: ["found a sample over threshold"						n _ 0]				ifFalse: ["still not over threshold"						n _ n + 1.						n >= lull ifTrue: [^ Array with: i with: j]]].		jStart _ 1].	^ self endPlace! !!SoundRecorder methodsFor: 'trimming' stamp: 'di 3/4/1999 22:13'!scanForStartThreshold: threshold dcOffset: dcOffset minDur: duration startingAt: startPlace	"Beginning at startPlace, this routine will find the first sound that exceeds threshold, such that if you look duration samples later you will find another sound over threshold within the following block of duration samples.	Return the place that is duration samples prior to that first sound.	If no sound is found, return endPlace."	| soundPlace lookPlace nextSoundPlace thirdPlace |	soundPlace _ self firstSampleOverThreshold: threshold dcOffset: dcOffset					startingAt: startPlace.	[soundPlace = self endPlace ifTrue: [^ soundPlace].	"Found a sound -- look duration later"	lookPlace _ self place: soundPlace plus: duration.	nextSoundPlace _ self firstSampleOverThreshold: threshold dcOffset: dcOffset					startingAt: lookPlace.	thirdPlace _ self place: lookPlace plus: duration.	nextSoundPlace first < thirdPlace first		or: [nextSoundPlace first = thirdPlace first			and: [nextSoundPlace second < thirdPlace second]]]		whileFalse: [soundPlace _ nextSoundPlace].	"Yes, there is sound in the next interval as well"	^ self place: soundPlace plus: 0-duration! !!SoundRecorder methodsFor: 'trimming' stamp: 'jm 6/15/2003 23:56'!trim: threshold normalizedVolume: percentOfMaxVolume	"Remove the leading and trailing parts of this recording that are below the given threshold. Remove any DC offset and scale the recording so that its peaks are the given percent of the maximum volume."	| max min sum totalSamples bufSize s dcOffset startPlace endPlace resultBuf nFactor |	recordedSound ifNil: [^ self].	stereo ifTrue: [self error: 'stereo trimming is not yet supported'].	paused ifFalse: [self error: 'must stop recording before trimming'].	recordedBuffers _ recordedSound sounds collect: [:snd | snd samples].	recordedBuffers isEmpty ifTrue: [^ self].	max _ min _ sum _ totalSamples _ 0.	recordedBuffers do: [:buf |		bufSize _ buf size.		totalSamples _ totalSamples + buf size.		1 to: bufSize do: [:i |			s _ buf at: i.			s > max ifTrue: [max _ s].			s < min ifTrue: [min _ s].			sum _ sum + s]].	dcOffset _ sum // totalSamples.	"a place is an array of <buffer index><index of sample in buffer>"	startPlace _ self scanForStartThreshold: threshold					dcOffset: dcOffset					minDur: (samplingRate/60.0) asInteger "at least 1/60th of a second"					startingAt: #(1 1).	startPlace = self endPlace ifTrue:		["no samples above threshold"		recordedBuffers _ nil.  ^ self].	endPlace _ self scanForEndThreshold: threshold					dcOffset: dcOffset					minLull: (samplingRate/5) asInteger					startingAt: startPlace.	nFactor _ self normalizeFactorFor: percentOfMaxVolume min: min max: max dcOffset: dcOffset.	resultBuf _ self copyFrom: startPlace to: endPlace normalize: nFactor dcOffset: dcOffset.	recordedSound _ SampledSound new setSamples: resultBuf samplingRate: samplingRate.	recordedBuffers _ nil! !!SoundRecorder methodsFor: 'results' stamp: 'jm 6/15/2003 23:56'!condensedSamples	"Return a single SoundBuffer that is the contatenation of all my recorded buffers."	| sz newBuf i |	recordedSound ifNil: [^ SoundBuffer new: 0].	recordedBuffers _ recordedSound sounds collect: [:snd | snd samples].	recordedBuffers isEmpty ifTrue: [^ SoundBuffer new: 0].	recordedBuffers size = 1 ifTrue: [^ recordedBuffers first copy].	sz _ recordedBuffers inject: 0 into: [:tot :buff | tot + buff size].	newBuf _ SoundBuffer newMonoSampleCount: sz.	i _ 1.	recordedBuffers do: [:b |		1 to: b size do: [:j |			newBuf at: i put: (b at: j).			i _ i + 1]].	recordedBuffers _ nil.	^ newBuf! !!SoundRecorder methodsFor: 'results' stamp: 'di 2/16/1999 20:49'!condensedStereoSound	"Decompose my buffers into left and right channels and return a mixed sound consisting of the those two channels. This may be take a while, since the data must be copied into new buffers."	| sz leftBuf rightBuf leftI rightI left |	sz _ recordedBuffers inject: 0 into: [:tot :buff | tot + buff size].	leftBuf _ SoundBuffer newMonoSampleCount: (sz + 1) // 2.	rightBuf _ SoundBuffer newMonoSampleCount: (sz + 1) // 2.	leftI _ rightI _ 1.	left _ true.	recordedBuffers do: [:b |		1 to: b size do: [:j |			left				ifTrue: [leftBuf at: leftI put: (b at: j). leftI _ leftI + 1. left _ false]				ifFalse: [rightBuf at: rightI put: (b at: j). rightI _ rightI + 1. left _ true]]].	^ MixedSound new		add: (SampledSound new setSamples: leftBuf samplingRate: samplingRate) pan: 0.0;		add: (SampledSound new setSamples: rightBuf samplingRate: samplingRate) pan: 1.0! !!SoundRecorder methodsFor: 'results' stamp: 'di 2/17/1999 11:07'!recordedSound	"Return the sound that was recorded."	^ recordedSound! !!SoundRecorder methodsFor: 'multitrack' stamp: 'jm 12/12/2001 10:47'!estimateRecordPlaySampleOffset	"Measure the number of samples of lag between the sound being played and the sound being recorded. Collect and answer 10 measurements. If there is little variation among these measurements, your sound hardware and OS can probably be used for multi-track recording. If there is wide variation, it may merely be that the record level needs to be adjusted. You can get a sense of this by setting viewBuffer to true to view the buffer from one test. If you are getting a clean recording with a strong (perhaps even clipped) signal and noise level well below the threshold, then the variation is due to variability in the timing of the OS sound driver startup sequence, and synchronization amoung tracks may be poor."	"Details: This estimate is made by playing a short pulse while recording, then finds the beginning of the pulse in the recorded sound. For this to work, the sound output must be fed into the input. The simplest way to do this is to place the recording microphone near the speaker and remain quiet while the test is run. You can also use a patch cord to connect the sound output to the input directly, in which case silence is not necessary."	| threshold recLevel viewBuffer rec snd buf |	threshold _ 10000.	recLevel _ 0.5.  "it may be necessary to adjust this to get a clean recording"	viewBuffer _ false.  "set this true to look at the buffer collected"	^ (1 to: 10) collect: [:i |		(Delay forMilliseconds: (1 to: 200) atRandom) wait.		rec _ SoundRecorder new.		rec recordLevel: recLevel.		snd _ FMSound new setPitch: 1000.0 dur: 0.005 loudness: 0.5.		rec startPlayingAndRecording.		snd play.		(Delay forMilliseconds: 500) wait.		rec stopRecording.		buf _ rec condensedSamples.		viewBuffer ifTrue: [WaveEditor openOn: buf. ^ true].		buf indexOfFirstSampleOver: threshold]! !!SoundRecorder methodsFor: 'multitrack' stamp: 'jm 12/18/2001 08:14'!mixed: trackList	"Answer a Mixed sound that mixes the given list of sounds. The track list contains SoundBuffers which are assumed to be monophonic sounds sampled at my sampling rate."	| mix snd |	self stopRecording; clearRecordedSound.	mix _ MixedSound new.	trackList do: [:buf |		snd _ SampledSound samples: buf samplingRate: samplingRate.		mix add: snd].	^ mix! !!SoundRecorder methodsFor: 'multitrack' stamp: 'jm 12/12/2001 12:21'!recordWhilePlaying: trackList offsetSampleCount: offsetSampleCount	"Record while playing the given set of tracks. Each track is a monophonic SoundBuffer. These are played as a bunch of LoopedSampledSounds mixed together. The offsetSampleCount parameter should be the average of the sample offsets measured by doing:	SoundRecorder new estimateRecordPlaySampleOffset"	| mixer buf |	mixer _ self mixed: trackList.	self startPlayingAndRecording.	mixer play.	self inform: 'Recording. Click OK to end recording'.	self stopRecording.	buf _ self condensedSamples.	^ buf copyFrom: offsetSampleCount to: buf size! !!SoundRecorder methodsFor: 'multitrack' stamp: 'jm 12/12/2001 14:47'!startPlayingAndRecording	"Start both the sound player and sound recorder so that (with luck) the time offset between the outgoing and incoming sample streams will be the same every time (with the same hardware and system configuration)."	"Note: Sets CanRecordWhilePlaying to true. Be sure your recording hardware can support simultaneous record and playback."	| rest restCount |	self class canRecordWhilePlaying ifFalse: [		^ self inform:			'Set the canRecordWhilePlaying preference to true if your hardware supports it'].	"first, shut down the sound player and recorder"	self stopRecording; clearRecordedSound.	SoundPlayer shutDown.	"clean up any garbage before starting"	Smalltalk garbageCollect.	"start the sound player and wait for the first interrupt"	rest _ RestSound dur: 0.1.	restCount _ rest samplesRemaining.	SoundPlayer startUp.	SoundPlayer resumePlaying: rest quickStart: false.	[rest samplesRemaining = restCount] whileTrue.  "wait for a buffer flip interrupt"	(Delay forMilliseconds: 5) wait.  "wait a bit longer"	"start the recorder"	self resumeRecording.! !!SoundRecorder methodsFor: 'private' stamp: 'di 2/17/1999 11:13'!allocateBuffer	"Allocate a new buffer and reset nextIndex."	| bufferTime |	bufferTime _ stereo  "Buffer time = 1/2 second"		ifTrue: [self samplingRate asInteger]		ifFalse: [self samplingRate asInteger // 2].	currentBuffer _ SoundBuffer newMonoSampleCount:		"Multiple of samplesPerFrame that is approx. bufferTime long"		(bufferTime truncateTo: self samplesPerFrame).	nextIndex _ 1.! !!SoundRecorder methodsFor: 'private' stamp: 'jm 11/20/2003 08:42'!emitBuffer: buffer	| sound |	audioFile ifNotNil: [  "recording to file"		audioFile appendSamples: buffer.		^ self].	sound _ SampledSound new setSamples: buffer samplingRate: samplingRate.	recordedSound add:		(codec == nil			ifTrue: [sound]			ifFalse: [codec compressSound: sound]).! !!SoundRecorder methodsFor: 'private' stamp: 'di 2/17/1999 11:13'!emitPartialBuffer	| s |	s _ self samplesPerFrame.	self emitBuffer: (currentBuffer copyFrom: 1 to: ((nextIndex-1) +( s-1) truncateTo: s))! !!SoundRecorder methodsFor: 'private' stamp: 'di 2/16/1999 08:55'!recordLoop	"Record process loop that records samples."	| n sampleCount |	n _ 0.	[true] whileTrue: [		n = 0 ifTrue: [bufferAvailableSema wait].		paused			ifTrue: [				n _ self primRecordSamplesInto: meteringBuffer startingAt: 1.				self meterFrom: 1 count: n in: meteringBuffer]			ifFalse: [				n _ self primRecordSamplesInto: currentBuffer startingAt: nextIndex.				self meterFrom: nextIndex count: n in: currentBuffer.				nextIndex _ nextIndex + n.				stereo					ifTrue: [sampleCount _ currentBuffer stereoSampleCount]					ifFalse: [sampleCount _ currentBuffer monoSampleCount].				nextIndex > sampleCount					ifTrue: [						self emitBuffer: currentBuffer.						self allocateBuffer]]].! !!SoundRecorder methodsFor: 'private' stamp: 'jm 11/20/2003 08:43'!samplesPerFrame	"Can be overridden to quantize buffer size for, eg, fixed-frame codecs"	codec == nil		ifTrue: [^ 1]		ifFalse: [^ codec samplesPerFrame].! !!SoundRecorder class methodsFor: 'class initialization' stamp: 'jm 11/20/2003 08:38'!initialize	"SoundRecorder initialize"	"Details: Some computers cannot record and playback sound at the same time. If CanRecordWhilePlaying is false, then the SoundRecorder alternates between recording and playing. If it is true, sounds can be playing during recording."	CanRecordWhilePlaying _ true.! !This class is an abstract superclass for source code access mechanisms. It defines the messages that need to be understood by those subclasses that store and retrieve source chunks on files, over the network or in databases.The first concrete subclass, StandardSourceFileArray, supports access to the traditional sources and changes files. Other subclasses might implement multiple source files for different applications, or access to a network source server.!]style[(254 23 184)f1,f1LStandardSourceFileArray Comment;,f1!!SourceFileArray methodsFor: 'accessing' stamp: 'hmm 4/26/2000 21:42'!at: index	self subclassResponsibility! !!SourceFileArray methodsFor: 'accessing' stamp: 'hmm 4/26/2000 21:43'!at: index put: aFileStream	self subclassResponsibility! !!SourceFileArray methodsFor: 'accessing' stamp: 'ar 5/17/2000 18:28'!collect: aBlock	| copy |	copy _ self species new: self size.	1 to: self size do:[:i| copy at: i put: (aBlock value: (self at: i))].	^copy! !!SourceFileArray methodsFor: 'accessing' stamp: 'hmm 4/26/2000 21:43'!size	self subclassResponsibility! !!SourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'hmm 4/25/2000 22:00'!fileIndexFromSourcePointer: anInteger	"Return the index of a source file corresponding to the given source pointer."	self subclassResponsibility! !!SourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'hmm 4/25/2000 22:00'!filePositionFromSourcePointer: anInteger	"Return the position within a source file for the given source pointer."	self subclassResponsibility! !!SourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'hmm 4/25/2000 22:01'!sourcePointerFromFileIndex: index andPosition: position	"Return a sourcePointer encoding the given file index and position"	self subclassResponsibility! !I am a tool for analyzing sound data from a microphone, CD, or other input source in real time. I have several display modes:	signal		snapshots of the raw signal data as it arrives	spectrum	frequency spectrum of the signal data as it arrives	sonogram	scrolling plot of the frequency spectrum over time,			      where the vertical axis is frequency, the horizontal				  axis is time, and amount of energy at a given				  frequency is shown as a grayscale value with				  larger values being darkerTo use this tool, be sure that you have selected the proper sound source using you host OS facilities. Set the desired sampling rate and FFT size (try 22050 samples/sec and an FFT size of 512) then click on the 'start' button. Use the slider to adjust the level so that the yellow level indicator peaks somewhere between the middle and the right edge at the maximum signal level.Note that if the level meter peaks hit the right edge, you will get 'clipping', which creates a bunch of spurious high frequency noise in the frequency spectrum. If the display is set to 'signal' mode, you can actually see the tops and bottoms of the waveform being cut off when clipping occurs.Many machines may not be able to perform spectrum analysis in real time, especially at higher sampling rates and larger FFT sizes. In both 'signal' and 'spectrum' modes, this tool will skip data to try to keep up with real time. However, in 'sonogram' mode it always processes all the data, even if it falls behind. This allows you to get a complete sonogram without dropouts even on a slower machine. However, as the sonogram display falls behind there will be a larger and larger time lag between when a sound is input and when it appears on the display.The smaller the FFT size, the less frequency resolution you get. The lower the sampling rate, the less total frequency range you get. For an FFT size of N and a sampling rate of R, each of the N/2 'bins' of the frequency spectrum has a frequency resolution of R / N. For example, at a sampleing rate of 22050 samples/second, the total frequency range is 0 to 11025 Hz and an FFT of size 256 would divide this range into 128 bins (the output of an FFT of size N has N/2 bins), each of which covers a frequency band about 86 Hz wide.To increase time resolution, increase the sampling rate and decrease the FFT size.!!SpectrumAnalyzerMorph methodsFor: 'initialization' stamp: 'jm 9/8/1999 17:59'!initialize	super initialize.	borderWidth _ 2.	orientation _ #vertical.	soundInput _ SoundInputStream new samplingRate: 22050.	fft _ FFT new: 512.	displayType _ 'sonogram'.	self addButtonRow.	self addLevelSlider.	self addMorphBack: self makeLevelMeter.	self addMorphBack: (Morph new extent: 10@10; color: Color transparent).  "spacer"	self resetDisplay.  "adds the display morph"! !!SpectrumAnalyzerMorph methodsFor: 'menu and buttons' stamp: 'jm 9/8/1999 15:11'!invokeMenu	"Invoke the settings menu."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('set sampling rate'		setSamplingRate)		('set FFT size'			setFFTSize)		('set display type'		setDisplayType)).	aMenu invokeOn: self defaultSelection: nil.! !!SpectrumAnalyzerMorph methodsFor: 'menu and buttons' stamp: 'jm 9/8/1999 12:52'!resetDisplay	"Recreate my display after changing some parameter such as FFT size."	displayType = 'signal' ifTrue: [self showSignal].	displayType = 'spectrum' ifTrue: [self showSpectrum].	displayType = 'sonogram' ifTrue: [self showSonogram].! !!SpectrumAnalyzerMorph methodsFor: 'menu and buttons' stamp: 'jm 9/8/1999 15:12'!setDisplayType	"Set the display type."	| aMenu choice on |	aMenu _ CustomMenu new title: 'display type (currently ', displayType, ')'.	aMenu addList:	#(		('signal'	'signal')		('spectrum'	'spectrum')		('sonogram'	'sonogram')).	choice _ aMenu startUp.	choice ifNil: [^ self].	on _ soundInput isRecording.	self stop.	displayType _ choice.	self resetDisplay.	on ifTrue: [self start].! !!SpectrumAnalyzerMorph methodsFor: 'menu and buttons' stamp: 'jm 9/8/1999 19:38'!setFFTSize	"Set the size of the FFT used for frequency analysis."	| aMenu sz on |	aMenu _ CustomMenu new title: 'FFT size (currently ', fft n printString, ')'.	((7 to: 10) collect: [:n | 2 raisedTo: n]) do:[:r | aMenu add: r printString action: r].	sz _ aMenu startUp.	sz ifNil: [^ self].	on _ soundInput isRecording.	self stop.	fft _ FFT new: sz.	self resetDisplay.	on ifTrue: [self start].! !!SpectrumAnalyzerMorph methodsFor: 'menu and buttons' stamp: 'jm 9/8/1999 15:12'!setSamplingRate	"Set the sampling rate to be used for incoming sound data."	| aMenu rate on |	aMenu _ CustomMenu new title:		'Sampling rate (currently ', soundInput samplingRate printString, ')'.	#(11025 22050 44100) do:[:r | aMenu add: r printString action: r].	rate _ aMenu startUp.	rate ifNil: [^ self].	on _ soundInput isRecording.	self stop.	soundInput samplingRate: rate.	self resetDisplay.	on ifTrue: [self start].! !!SpectrumAnalyzerMorph methodsFor: 'menu and buttons' stamp: 'jm 9/8/1999 15:12'!start	"Start displaying sound data."	displayType = 'signal'		ifTrue: [soundInput bufferSize: graphMorph width - (2 * graphMorph borderWidth)]		ifFalse: [soundInput bufferSize: fft n].	soundInput startRecording.! !!SpectrumAnalyzerMorph methodsFor: 'menu and buttons' stamp: 'jm 9/8/1999 15:12'!stop	"Stop displaying sound data."	soundInput stopRecording.! !!SpectrumAnalyzerMorph methodsFor: 'stepping' stamp: 'jm 9/8/1999 19:05'!step	"Update the record light, level meter, and display."	| w |	"update the record light and level meter"	soundInput isRecording		ifTrue: [statusLight color: Color yellow]		ifFalse: [statusLight color: Color gray].	w _ ((121 * soundInput meterLevel) // 100) max: 1.	levelMeter width ~= w ifTrue: [levelMeter width: w].	"update the display if any data is available"	self updateDisplay.! !!SpectrumAnalyzerMorph methodsFor: 'stepping' stamp: 'jm 9/7/1999 22:26'!stepTime	^ 0! !!SpectrumAnalyzerMorph methodsFor: 'stepping' stamp: 'jm 9/6/1999 12:12'!stopStepping	"Turn off recording."	super stopStepping.	soundInput stopRecording.! !!SpectrumAnalyzerMorph methodsFor: 'deletion' stamp: 'jm 9/6/1999 14:40'!delete	"Turn off recording when this morph is deleted."	super delete.	soundInput stopRecording.! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/8/1999 12:44'!addButtonRow	| r |	r _ AlignmentMorph newRow vResizing: #shrinkWrap.	r addMorphBack: (self buttonName: 'Menu' action: #invokeMenu).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Start' action: #start).	r addMorphBack: (Morph new extent: 4@1; color: Color transparent).	r addMorphBack: (self buttonName: 'Stop' action: #stop).	r addMorphBack: (Morph new extent: 12@1; color: Color transparent).	r addMorphBack: self makeStatusLight.	self addMorphBack: r.! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/7/1999 18:01'!addLevelSlider	| levelSlider r |	levelSlider _ SimpleSliderMorph new		color: color;		extent: 100@2;		target: soundInput;		actionSelector: #recordLevel:;		adjustToValue: soundInput recordLevel.	r _ AlignmentMorph newRow		color: color;		inset: 0;		centering: #center;		hResizing: #shrinkWrap;		vResizing: #rigid;		height: 24.	r addMorphBack: (StringMorph contents: '0 ').	r addMorphBack: levelSlider.	r addMorphBack: (StringMorph contents: ' 10').	self addMorphBack: r.! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jhm 10/15/97 14:30'!buttonName: aString action: aSymbol	^ SimpleButtonMorph new		target: self;		label: aString;		actionSelector: aSymbol! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 6/15/2003 10:29'!makeLevelMeter	| outerBox |	outerBox _ BorderedMorph new extent: 125@14; color: Color lightGray.	levelMeter _ Morph new extent: 2@10; color: Color yellow.	levelMeter position: outerBox topLeft + (2@2).	outerBox addMorph: levelMeter.	^ outerBox! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 6/15/2003 10:29'!makeStatusLight	| s |	statusLight _ BorderedMorph new extent: 24@19.	statusLight color: Color gray.	s _ StringMorph contents: 'On'.	s position: statusLight center - (s extent // 2).	statusLight addMorph: s.	^ statusLight! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/8/1999 18:41'!processBuffer: buf	"Analyze one buffer of data."	| data |	displayType = 'signal'		ifTrue: [data _ buf]		ifFalse: [data _ fft transformDataFrom: buf startingAt: 1].	graphMorph ifNotNil: [graphMorph data: data; changed].	sonogramMorph ifNotNil: [		data _ data collect: [:v | v sqrt].  "square root compresses dynamic range"		data /= 400.0.		sonogramMorph plotColumn: (data copyFrom: 1 to: data size // 1)].! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/8/1999 12:49'!removeAllDisplays	"Remove all currently showing displays."	sonogramMorph ifNotNil: [sonogramMorph delete].	graphMorph ifNotNil: [graphMorph delete].	sonogramMorph _ graphMorph _ nil.! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/8/1999 19:56'!showSignal	"Display the actual signal waveform."	displayType _ 'signal'.	self removeAllDisplays.	graphMorph _ GraphMorph new.	graphMorph extent: (400 + (2 * graphMorph borderWidth))@128.	graphMorph data: (Array new: 100 withAll: 0).	graphMorph color: (Color r: 0.8 g: 1.0 b: 1.0).	self addMorphBack: graphMorph.	self extent: 10@10.  "shrink to minimum size"! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/8/1999 19:43'!showSonogram	"Display a sonogram showing the frequency spectrum versus time."	| zeros h w |	displayType _ 'sonogram'.	self removeAllDisplays.	h _ fft n // 2.	h _ h min: 512 max: 64.	w _ 400.	sonogramMorph _		Sonogram new			extent: w@h			minVal: 0.0			maxVal: 1.0			scrollDelta: w.	zeros _ Array new: sonogramMorph height withAll: 0.	sonogramMorph width timesRepeat: [sonogramMorph plotColumn: zeros].	self addMorphBack: sonogramMorph.	self extent: 10@10.  "shrink to minimum size"! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/8/1999 15:10'!showSpectrum	"Display the frequency spectrum."	displayType _ 'spectrum'.	self removeAllDisplays.	graphMorph _ GraphMorph new.	graphMorph extent: ((fft n // 2) + (2 * graphMorph borderWidth))@128.	graphMorph data: (Array new: fft n // 2 withAll: 0).	self addMorphBack: graphMorph.	self extent: 10@10.  "shrink to minimum size"! !!SpectrumAnalyzerMorph methodsFor: 'private' stamp: 'jm 9/8/1999 19:39'!updateDisplay	"Update the display if any data is available."	| buf bufCount |	soundInput bufferCount = 0 ifTrue: [^ self].	graphMorph ifNotNil: [		[soundInput bufferCount > 0] whileTrue: [			"skip to the most recent buffer"			buf _ soundInput nextBufferOrNil].		^ self processBuffer: buf].	sonogramMorph ifNotNil: [		"at small buffer sizes we have to update the sonogram in		 batches or we may get behind; shoot for 8 updates/second"		bufCount _ (soundInput samplingRate / (8 * soundInput bufferSize)) truncated max: 1.		[bufCount > 0 and: [soundInput bufferCount > 0]] whileTrue: [			self processBuffer: (soundInput nextBufferOrNil)]].! !!SpectrumAnalyzerMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:03'!includeInNewMorphMenu	^ true! !I represent a scriptable scratch morph argument for a command block.  Clicking on me and then another point on the screen allows the user to set my value to the scriptable scratch morph that has been clicked on.!!SpriteArgMorph methodsFor: 'initialize' stamp: 'jm 6/30/2003 07:18'!initialize	super initialize.	self borderInset.	self borderWidth: 1.	self color: Color white.	self extent: 20@17.	labelMorph _ StringMorph new.	self addMorph: labelMorph.	morph _ nil.	self changeLabel: 'no sprite'.! !!SpriteArgMorph methodsFor: 'event handling' stamp: 'jm 6/30/2003 07:17'!handlesMouseDown: evt		^ true! !!SpriteArgMorph methodsFor: 'event handling' stamp: 'jm 8/13/2003 17:11'!mouseUp: evt	"Let the user select a Scratch object."	| m |	m _ ScriptableScratchMorph fromUser.	m ifNil: [^ self].	morph _ m.	self changeLabel: morph objName.! !!SpriteArgMorph methodsFor: 'evaluation' stamp: 'jm 8/24/2003 17:21'!changeLabel: aString	"Sets the string in the labelMorph to the name of that morph."	labelMorph contents: aString.	self width: labelMorph width + 6.	labelMorph position: self position + (3@2).! !!SpriteArgMorph methodsFor: 'evaluation' stamp: 'DaveF 7/11/2003 18:37'!evaluate	^ morph! !!SpriteArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:34'!fieldsVersion	^ 1! !!SpriteArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:35'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		morph	) from: anObjStream.! !!SpriteArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:39'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		morph	) on: anObjStream.! !I represent a bitmapped color image that can be rotated, scaled, and edited.The raw Form before any rotation or scaling is stored in originalForm. rotatedForm is a cache of the rotated and scaled version of originalForm.rotationCenter is the center of rotation in originalForm (relative to the top-left). When the rotation or scaling is changed, the system keeps the location of the rotation center on the screen invariant. Thus, the rotation center can also be used as the registration point for a sequence of instances of me representing animation frames.rotationStyle has three possible values:	normal		continuous rotation	leftRight	rotatation with an x component < 0, flip bitmap around the y-axis, otherwise it is not rotated	none		never rotateThe leftRight style is useful for side-views of things such as cars, horses, etc.!!SpriteMorph methodsFor: 'initialization' stamp: 'jm 9/29/2003 09:31'!initialize	super initialize.	originalForm _ DefaultSpriteForm.	transparency _ 1.0.	scalePoint _ 1.0@1.0.	rotationCenter _ originalForm extent // 2.  "relative to the top-left corner of the Form"	rotationDegrees _ 0.0.				"clockwise angle of rotation"	rotationStyle _ #normal.				"#normal, #leftRight, or #none"	rotatedForm _ originalForm.			"cached rotated/scaled copy of originalForm"	offsetWhenRotated _ 0@0.			"offset for rotated form needed to keep rotation center invariant"	penDown _ false.	penSize _ 1.	penColor _ Color black.	self extent: originalForm extent.! !!SpriteMorph methodsFor: 'accessing' stamp: 'jm 7/7/2003 21:30'!colorCode	^ Color r: 1.00 g: 0.84 b: 0.52! !!SpriteMorph methodsFor: 'accessing' stamp: 'ee 8/19/2003 15:08'!editedForm: aForm	originalForm _ aForm.	self layoutChanged.! !!SpriteMorph methodsFor: 'accessing' stamp: 'jm 8/23/2003 12:17'!form	"Answer my original form, without rotation or scaling."	^ originalForm! !!SpriteMorph methodsFor: 'accessing' stamp: 'jm 2/25/2003 12:17'!form: aForm	originalForm _ aForm.	scalePoint _ 1.0@1.0.	rotationDegrees _ 0.0.	rotationCenter _ aForm extent // 2.	self layoutChanged.! !!SpriteMorph methodsFor: 'accessing' stamp: 'jm 11/13/2003 12:31'!referencePosition	^ ((bounds origin - offsetWhenRotated) + rotationCenter) - Origin! !!SpriteMorph methodsFor: 'accessing' stamp: 'jm 11/13/2003 12:31'!referencePosition: aPoint	self position: Origin + ((aPoint - rotationCenter) + offsetWhenRotated).! !!SpriteMorph methodsFor: 'accessing' stamp: 'jm 8/23/2003 12:17'!rotatedForm	"Answer my rotated and scaled form."	rotatedForm ifNil: [self layoutChanged].	^ rotatedForm! !!SpriteMorph methodsFor: 'accessing'!rotationCenter	^ rotationCenter! !!SpriteMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!rotationCenter: aPoint	rotationCenter _ aPoint.	self layoutChanged.! !!SpriteMorph methodsFor: 'accessing'!rotationDegrees	^ rotationDegrees! !!SpriteMorph methodsFor: 'accessing' stamp: 'jm 2/25/2003 12:08'!rotationDegrees: newRotationDegrees	rotationDegrees ~= newRotationDegrees ifTrue: [		rotationDegrees _ newRotationDegrees asFloat \\ 360.0.		self layoutChanged].! !!SpriteMorph methodsFor: 'accessing' stamp: 'jm 2/25/2003 12:07'!rotationDegrees: newRotationDegrees scalePoint: newScalePoint	((newRotationDegrees ~= rotationDegrees) or:	 [scalePoint ~= newScalePoint]) ifTrue: [		rotationDegrees _ newRotationDegrees asFloat \\ 360.0.		scalePoint _ newScalePoint.		self layoutChanged].! !!SpriteMorph methodsFor: 'accessing'!rotationStyle	^ rotationStyle! !!SpriteMorph methodsFor: 'accessing' stamp: 'jm 2/25/2003 11:49'!rotationStyle: aSymbol	"Set my rotation style to #normal, #leftRight, or #none. Styles mean:		#normal		-- continuous 360 degree rotation		#leftRight		-- flip about the vertical axis		#none			-- do not rotate"	| oldStyle |	oldStyle _ rotationStyle.	rotationStyle _ aSymbol.	((aSymbol = #normal) and: [oldStyle ~= #normal]) ifTrue: [self rotationDegrees: 0.0].	self layoutChanged.! !!SpriteMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!scalePoint	scalePoint ifNil: [scalePoint _ 1.0@1.0].	^ scalePoint! !!SpriteMorph methodsFor: 'accessing' stamp: 'jm 7/24/97 15:06'!scalePoint: aPoint	scalePoint _ aPoint.	self layoutChanged.! !!SpriteMorph methodsFor: 'scratch vars' stamp: 'jm 8/22/2003 20:43'!heading	"Answer my heading in degrees, a number between 0 and 360."	^ rotationDegrees! !!SpriteMorph methodsFor: 'scratch vars' stamp: 'jm 8/22/2003 20:41'!heading: headingDegrees	"Set my heading in degrees, where 0 degrees means right."	self rotationDegrees: headingDegrees.! !!SpriteMorph methodsFor: 'scratch vars' stamp: 'jm 7/20/2003 20:42'!penColor	"Answer my pen color."	^ penColor! !!SpriteMorph methodsFor: 'scratch vars' stamp: 'jm 7/19/2003 18:14'!penColor: aColor	penColor _ aColor.! !!SpriteMorph methodsFor: 'scratch vars' stamp: 'jm 7/20/2003 20:43'!penDown	"Answer true if my pen is down (i.e., I should leave a trail when I move)."	^ penDown! !!SpriteMorph methodsFor: 'scratch vars' stamp: 'jm 7/20/2003 20:44'!penDown: aBoolean	"Set my pen up/down state."	penDown _ aBoolean.	(self owner respondsTo: #penUpOrDownChangeFor:)		ifTrue: [self owner penUpOrDownChangeFor: self].! !!SpriteMorph methodsFor: 'scratch vars' stamp: 'jm 7/20/2003 20:43'!penSize	"Answer my pen size."	^ penSize! !!SpriteMorph methodsFor: 'scratch vars' stamp: 'jm 7/19/2003 18:11'!penSize: aNumber	penSize _ aNumber asInteger.! !!SpriteMorph methodsFor: 'scratch vars' stamp: 'jm 7/4/2003 10:10'!transparency	"Answer my transparency, a number between 0.0 and 1.0."	^ transparency! !!SpriteMorph methodsFor: 'scratch vars' stamp: 'jm 7/4/2003 10:10'!transparency: aNumber	"Set my transparency, a number between 0.0 and 1.0."	transparency _ (aNumber asFloat max: 0.0) min: 1.0.	self changed.! !!SpriteMorph methodsFor: 'scratch vars' stamp: 'jm 2/25/2003 16:39'!xScale	"Answer my x scale factor."	^ self scalePoint x! !!SpriteMorph methodsFor: 'scratch vars' stamp: 'jm 2/25/2003 17:05'!xScale: aNumber	"Set my xScale to the given number. Limit the range to avoid accidentally making a really huge object."	| newXScale |	newXScale _ aNumber within: 3.0 / originalForm width and: 1000.0 / originalForm width.	self scalePoint: newXScale@self scalePoint y.! !!SpriteMorph methodsFor: 'scratch vars' stamp: 'jm 2/25/2003 16:39'!yScale	"Answer my y scale factor."	^ self scalePoint y! !!SpriteMorph methodsFor: 'scratch vars' stamp: 'jm 2/25/2003 17:28'!yScale: aNumber	"Set my yScale to the given number. Limit the range to avoid accidentally making a really huge object."	| newYScale |	newYScale _ aNumber within: 3.0 / originalForm height and: 1000.0 / originalForm height.	self scalePoint: self scalePoint x@newYScale.! !!SpriteMorph methodsFor: 'scratch ops' stamp: 'jm 8/22/2003 19:31'!color: sensitiveColor sees: soughtColor	"Return true if any of my pixels of sensitiveColor intersect with pixels of soughtColor in the world."	| myImage sensitivePixelsMask map index imageBelowMe |	(owner isKindOf: PasteUpMorph) ifFalse: [^ false].	"make a mask with 1 where pixel = sensitiveColor, 0 elsewhere"	myImage _ self imageForm.	sensitivePixelsMask _ Form extent: myImage extent depth: 1.	map _ Bitmap new: (1 bitShift: (myImage depth min: 15)).	map at: (index _ sensitiveColor indexInMap: map) put: 1.	sensitivePixelsMask		copyBits: sensitivePixelsMask boundingBox		from: myImage form		at: 0@0		colorMap: map.	"grab an image of the world below me"	imageBelowMe _ owner patchAt: self fullBounds without: self andNothingAbove: false.	"intersect world pixels of the color we're looking for with sensitive pixels mask"	map at: index put: 0.  "clear map and reuse it"	map at: (soughtColor indexInMap: map) put: 1.	sensitivePixelsMask		copyBits: imageBelowMe boundingBox		from: imageBelowMe at: 0@0 clippingBox: imageBelowMe boundingBox		rule: Form and		fillColor: nil		map: map.	^ (sensitivePixelsMask tallyPixelValues at: 2) > 0! !!SpriteMorph methodsFor: 'scratch ops' stamp: 'jm 8/22/2003 20:11'!distanceTo: aMorphOrPoint	"Answer the distance from my reference position to the given point or morph."	| targetPoint |	(aMorphOrPoint isKindOf: Morph)		ifTrue: [targetPoint _ aMorphOrPoint referencePosition]		ifFalse: [targetPoint _ aMorphOrPoint asPoint].	^ self referencePosition dist: targetPoint! !!SpriteMorph methodsFor: 'scratch ops' stamp: 'jm 8/22/2003 20:46'!forward: distance	"Move the object forward (i.e., the direction of its heading) by the given distance."	| radians deltaP |	radians _ rotationDegrees degreesToRadians.	deltaP _ ((radians cos)@(radians sin)) * distance.	self position: self position + deltaP.! !!SpriteMorph methodsFor: 'scratch ops' stamp: 'jm 6/30/2003 07:12'!gotoSprite: aMorph	"Jump to either the referencePosition or the center of the argument morph, depending on whether the sprite is a SpriteArgMorph or another type of scriptable scratch morph. "	(aMorph isKindOf: SpriteMorph)		ifTrue: [self referencePosition: aMorph referencePosition]		ifFalse: [self referencePosition: aMorph center].! !!SpriteMorph methodsFor: 'scratch ops' stamp: 'jm 9/30/2003 21:49'!headingTo: aMorphOrPoint	"Answer the heading from my reference position to the given point or morph."	| targetPoint |	(aMorphOrPoint isKindOf: Morph)		ifTrue: [targetPoint _ aMorphOrPoint referencePosition]		ifFalse: [targetPoint _ aMorphOrPoint asPoint].	^ (self referencePosition bearingToPoint: targetPoint) - 90! !!SpriteMorph methodsFor: 'scratch ops' stamp: 'jm 11/14/2003 10:10'!loadFile: relativeFilePath	"Read my Form from a file."	| fullName |	fullName _ self projectDirectory relativeToFullPath: relativeFilePath.	(FileDirectory default fileExists: fullName)		ifFalse: [^ self inform: 'File not found: ', relativeFilePath].	self form: (Form fromFileNamed: fullName).! !!SpriteMorph methodsFor: 'scratch ops' stamp: 'jm 10/3/2003 11:27'!lookLike: aMorph	"Make myself look like the given Sprite or ImageBox morph. Noop for other kinds of morphs."	(aMorph isKindOf: SpriteMorph) ifTrue: [self form: aMorph form].	(aMorph isKindOf: ImageBoxMorph) ifTrue: [self form: aMorph outForm].! !!SpriteMorph methodsFor: 'scratch ops' stamp: 'jm 9/25/2003 17:29'!putPenDown	self penDown: true.! !!SpriteMorph methodsFor: 'scratch ops' stamp: 'jm 9/25/2003 17:31'!putPenUp	self penDown: false.! !!SpriteMorph methodsFor: 'scratch ops' stamp: 'jm 9/29/2003 15:15'!saveFile: fileName	"Save my Form to the given file."	| fName |	originalForm depth = 8 ifTrue: [		(fileName asLowercase endsWith: '.gif')			ifTrue: [fName _ fileName]			ifFalse: [fName _ fileName, '.gif'].		GIFReadWriter putForm: originalForm colorReduced8Bit onFileNamed: fName.		^ self].	(fileName asLowercase endsWith: '.bmp')		ifTrue: [fName _ fileName]		ifFalse: [fName _ fileName, '.bmp'].	(originalForm asFormOfDepth: 32) writeBMPfileNamed: fileName.! !!SpriteMorph methodsFor: 'scratch ops' stamp: 'jm 6/30/2003 07:16'!spriteOverlapping: aSprite	"Sees if a particular sprite is overlapping or touching me."	(aSprite isKindOf: SpriteMorph) ifFalse: [^ false].	^ self bounds intersects: aSprite bounds! !!SpriteMorph methodsFor: 'scratch ops' stamp: 'jm 3/2/2003 11:38'!turn: degrees	"Turn clockwise the given number of degrees."	self rotationDegrees: rotationDegrees + degrees.! !!SpriteMorph methodsFor: 'drawing' stamp: 'jm 7/4/2003 10:19'!drawOn: aCanvas	"Draw myself if my transparency is > 0. If transparency is 1, draw using the normal 'paint' mode. Otherwise, draw using 'alpha' resulting in a partially transparent rendering."	| f alpha |	transparency ifNil: [transparency _ 1.0].  "for backwards compatability"	f _ self rotatedForm.	transparency < 1.0 ifTrue: [		transparency > 0.0 ifTrue: [			alpha _ (255.0 * transparency) truncated.			aCanvas paintImage: f at: bounds origin sourceRect: f boundingBox alpha: alpha].		^ self].	aCanvas paintImage: f at: bounds origin.! !!SpriteMorph methodsFor: 'drawing' stamp: 'jm 9/29/2003 19:39'!generateRotatedForm	"Compute my rotatedForm and offsetWhenRotated."	| adjustedAngle smoothPix pair |	(rotationStyle = #normal)		ifTrue: [adjustedAngle _ rotationDegrees]  "smooth rotation"		ifFalse: [adjustedAngle _ 0.0].  "leftRight or none"	((adjustedAngle = 0.0) and: [1.0@1.0 = scalePoint])		ifTrue: [  "no rotation or scaling; use original"			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0]		ifFalse: [  "generated rotated and/or scaled form"			((scalePoint x < 1.0) or: [scalePoint y < 1.0])				ifTrue: [smoothPix _ 2]				ifFalse: [smoothPix _ 1].			pair _ WarpBlt				rotate: originalForm				degrees: adjustedAngle negated				center: rotationCenter				scaleBy: self scalePoint				smoothing: smoothPix.			rotatedForm _ pair first.			offsetWhenRotated _ pair last].	((rotationStyle = #leftRight) and:	 [(rotationDegrees > 90.0) and: [rotationDegrees < 270.0]]) ifTrue: [		"headed left; use flipped"		rotatedForm _ rotatedForm flipBy: #horizontal centerAt: 0@0.		offsetWhenRotated _ offsetWhenRotated + 			(((2 * (rotationCenter x - (originalForm width // 2)))@0) * scalePoint).		^ self].! !!SpriteMorph methodsFor: 'geometry'!containsPoint: aPoint	^ (self bounds containsPoint: aPoint) and:	  [(self rotatedForm isTransparentAt: aPoint - bounds origin) not]! !!SpriteMorph methodsFor: 'geometry' stamp: 'jm 3/2/98 14:24'!extent: newExtent	"Change my scale to fit myself into the given extent."	| radians s c divisor w h origExtent |	radians _ rotationDegrees degreesToRadians.	s _ radians sin abs.	c _ radians cos abs.	divisor _ (c * c) - (s * s).	w _ ((c * newExtent x) - (s * newExtent y)) / divisor.	h _ ((c * newExtent y) - (s * newExtent x)) / divisor.	origExtent _ originalForm extent.	rotationStyle = #normal		ifTrue: [			scalePoint _				((w asFloat / origExtent x) max: 0.001) @				((h asFloat / origExtent y) max: 0.001).			divisor abs < 0.5 ifTrue: [  "avoid instability near multiples of 45 degrees"				s _ newExtent r / (origExtent r * 2 sqrt).				scalePoint _ s@s]]		ifFalse: [  "scaling for constraint rotation styles"			scalePoint _				((newExtent x max: 1) asFloat / origExtent x) @				((newExtent y max: 1) asFloat / origExtent y)].	self layoutChanged.! !!SpriteMorph methodsFor: 'menu' stamp: 'jm 3/17/2003 15:26'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'read from file' action: #readFromFile.	aCustomMenu add: 'grab from screen' action: #grabFromScreen.	aCustomMenu addLine.	aCustomMenu add: 'set rotation center' action: #setRotationCenter.	aCustomMenu add: 'set rotation style' action: #setRotationStyle.! !!SpriteMorph methodsFor: 'menu' stamp: 'jm 12/9/2003 18:10'!editDrawing	"Edit my original form with the paint editor."	| myPaint |	myPaint _ MyPaintFrame new.	owner addMorph: myPaint.	myPaint withStartingObject: self.! !!SpriteMorph methodsFor: 'menu' stamp: 'jm 8/23/2003 18:02'!grabFromScreen	"Set my form to be a rectangular portion of the screen."	| f |	f _ Form fromUser.	f mapColor: (f colorAt: 0@0) to: Color transparent.	f _ f trimBordersOfColor: Color transparent.	(f width > 0 and: [f height > 0]) ifTrue: [self form: f].! !!SpriteMorph methodsFor: 'menu' stamp: 'jm 8/3/2003 20:49'!readFromFile	"Read my form from an image file."	| result fileName |	result _ StandardFileMenu oldFileExtensions: #(jpg jpeg gif bmp png).	result ifNil: [^ self].	fileName _ result directory pathName, FileDirectory slash, result name.	self form: (Form fromFileNamed: fileName).! !!SpriteMorph methodsFor: 'menu' stamp: 'jm 1/11/2003 09:24'!setRotationCenter	"Interactively set the rotation center in my original form."	| w p oldRotation oldScale |	(w _ self world) ifNil: [^ self].	"undo current rotation and scale..."	oldRotation _ rotationDegrees.	oldScale _ scalePoint.	self rotationDegrees: 0.0 scalePoint: 1.0@1.0.	w displayWorldSafely.	Cursor crossHair showWhile: [p _ Sensor waitButton].	Sensor waitNoButton.	self rotationCenter: (self transformFromWorld globalPointToLocal: p) - bounds origin.	"restore old rotation and scale:"	self rotationDegrees: oldRotation scalePoint: oldScale.! !!SpriteMorph methodsFor: 'menu' stamp: 'jm 8/23/2003 17:38'!setRotationStyle	"Allow the user to set my rotation style from a menu."	| menu newStyle |	menu _ CustomMenu new.	#('rotate with heading' 'just flip left-right' 'don''t rotate')		with: #(normal leftRight none)		do: [:name :action | menu add: name action: action].	newStyle _ menu startUp.	newStyle ifNotNil: [self rotationStyle: newStyle].! !!SpriteMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 15:37'!fieldsVersion	^ 1! !!SpriteMorph methodsFor: 'object i/o' stamp: 'jm 12/1/2003 14:47'!initFieldsFrom: anObjStream version: classVersion	| p |	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		originalForm		transparency		scalePoint		rotationCenter		rotationDegrees		rotationStyle		penDown		penSize		penColor	) from: anObjStream.	"restore position of rotated sprites"	p _ self position.	self layoutChanged.  "compute offsetWhenRotated"	self position: p.! !!SpriteMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 15:26'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		originalForm		transparency		scalePoint		rotationCenter		rotationDegrees		rotationStyle		penDown		penSize		penColor	) on: anObjStream.! !!SpriteMorph methodsFor: 'other' stamp: 'jm 7/4/2003 10:50'!imageForm: depth forRectangle: rect	| saved f |	saved _ transparency.	transparency _ 1.0.	f _ super imageForm: depth forRectangle: rect.	transparency _ saved.	^ f! !!SpriteMorph methodsFor: 'other' stamp: 'jm 10/14/2002 09:15'!isColorable	^ false! !!SpriteMorph methodsFor: 'other' stamp: 'jm 12/9/2003 18:06'!isPaintable	"Answer true if my image can be repainted."	^ true! !!SpriteMorph methodsFor: 'other' stamp: 'jm 1/11/2003 08:58'!layoutChanged	"Update rotatedForm and offsetWhenRotated and compute new bounds."	| unrotatedOrigin |	self changed.	unrotatedOrigin _ bounds origin - offsetWhenRotated.	(rotationStyle == #none and: [scalePoint = (1.0@1.0)])		ifTrue: [			"zero rotation and scale; use original Form"			rotatedForm _ originalForm.			offsetWhenRotated _ 0@0]		ifFalse: [self generateRotatedForm].	"changes offsetWhenRotated"	bounds _ (unrotatedOrigin + offsetWhenRotated) extent: rotatedForm extent.	super layoutChanged.	self changed.! !!SpriteMorph methodsFor: 'other' stamp: 'jm 10/15/2002 15:56'!releaseCachedState	"Clear cache of rotated, scaled Form."	super releaseCachedState.	rotatedForm _ nil.	originalForm hibernate.! !!SpriteMorph class methodsFor: 'scratch' stamp: 'jm 11/18/2003 16:25'!classBlockSpecs	^ #(		'motion'			('forward %n'					-	forward:)			('turn %n'						-	turn:)			('goto %m'						-	gotoSprite: )			('goto %p'						-	referencePosition: )			('goto %p secs %n'				t	goto:duration:elapsed:from:)			('width %n height %n secs %n'	t	width:height:duration:elapsed:from:)			('look like %m'					-	lookLike:)			('pen up'						-	putPenUp)			('pen down'						-	putPenDown)			('pen color %c'					-	penColor:)		'sensing'			('color %c is over %c'			r	color:sees:)			('touching %m' 					r	spriteOverlapping:)			('dist to %p'						r	distanceTo:) 			('dist to %m'						r	distanceTo:)			('heading to %p' 				r	headingTo:)			('heading to %m'				r	headingTo:)	).! !!SpriteMorph class methodsFor: 'scratch' stamp: 'jm 10/2/2003 12:24'!varSpecs	^ #((x 0 1000)		(y 0 1000)		(layer 1 100)		(heading 0 360)		(width 0 500)		(height 0 500)		(xScale 0 10)		(yScale 0 10)		(transparency 0 1)		(penDown nil nil)		(penSize 1 100))! !!SpriteMorph class methodsFor: 'default form' stamp: 'jm 9/29/2003 08:56'!readDefaultFormFrom: fileName	"SpriteMorph readDefaultFormFrom: 'spriteShapeCat.gif'"	DefaultSpriteForm _ (Form fromFileNamed: fileName).! !I provide a way for the user to select a file or directory, possibly navigating the directory hierarchy to get to the target directory. I am actually a kind of SeletionMenu, so I work in both Morphic and MVC. The user interface is rather crude, but the functionality is useful.To use me, the client does a call such as:	result _ StandardFileMenu oldFileThe result is nil (if the user aborts), an instance of StandardFileMenuResult, or a FileDirectory (in the case of getFolder). The StandardFileMenuResult contains both the directory and the name of the selected file.Here are some examples:	StandardFileMenu oldFile inspect	(StandardFileMenu oldFileExtensions: #(st cs)) inspect	StandardFileMenu newFile inspect	StandardFileMenu getFolder inspect!!StandardFileMenu methodsFor: 'menu building' stamp: 'jm 12/8/2003 15:10'!makeFileMenuFor: aDirectory	"Initialize an instance of me to view the given directory."	| theMenu |	Cursor wait showWhile: [		self 			labels: 	(self menuLabelsString: aDirectory)			font: 	(MenuStyle fontAt: 1) 			lines: 	(self menuLinesArray: aDirectory).		theMenu _ self selections: (self menuSelectionsArray: aDirectory)].	^ theMenu! !!StandardFileMenu methodsFor: 'menu building' stamp: 'jm 12/8/2003 14:42'!menuLabelsString: aDirectory	"Answer a menu labels object corresponding to aDirectory."	^ String streamContents: [:s | 		canTypeFileName ifTrue: [			getFolder				ifTrue: [s nextPutAll: 'Choose this folder'; cr]				ifFalse: [s nextPutAll: 'Enter File Name...'; cr]].		s nextPutAll: (self pathPartsString: aDirectory).		aDirectory directoryNames do: [:n | s nextPutAll: n withBlanksTrimmed, ' [...]'; cr].		(self matchingFileNamesFor: aDirectory) do: [:n | s nextPutAll: n withBlanksTrimmed; cr].		s skip: -1]! !!StandardFileMenu methodsFor: 'menu building' stamp: 'jm 12/8/2003 14:43'!menuLinesArray: aDirectory	"Answer a menu lines object corresponding to aDirectory"	| typeCount nameCnt |	typeCount _ canTypeFileName ifTrue: [1] ifFalse: [0].	nameCnt _ aDirectory directoryNames size.	^ Array streamContents: [:s |		canTypeFileName ifTrue: [s nextPut: 1].		s nextPut: aDirectory pathParts size + typeCount + 1.		s nextPut: aDirectory pathParts size + typeCount + nameCnt + 1]! !!StandardFileMenu methodsFor: 'menu building' stamp: 'jm 12/8/2003 15:07'!menuSelectionsArray: dir"Answer a menu selections object corresponding to dir.  The object is an array corresponding to each item, each element itself constituting a two-element array, the first element of which contains a selector to operate on and the second element of which contains the parameters for that selector."	| count showIt ext |	count _ dir pathParts size.	^ Array streamContents: [:s |		canTypeFileName ifTrue: [			s nextPut: (StandardFileMenuResult new directory: dir name: nil)].		s nextPut: (StandardFileMenuResult new directory: FileDirectory root name: '').		dir pathParts doWithIndex: [:d :i |			s nextPut: (StandardFileMenuResult new				directory: (self advance: count - i containingDirectoriesFrom: dir) name: '')].		dir directoryNames do: [:dn |			s nextPut: (StandardFileMenuResult new				directory: (FileDirectory on: (dir fullNameFor: dn)) name: '')].		dir fileNames do: [:fn |			extensions				ifNil: [showIt _ true]				ifNotNil: [					ext _ (FileDirectory extensionFor: fn) asLowercase.					showIt _ extensions includes: ext].			showIt ifTrue: [				s nextPut: (StandardFileMenuResult new directory: dir name: fn)]]]! !!StandardFileMenu methodsFor: 'menu building' stamp: 'jm 6/6/2003 07:35'!pathPartsString: aDirectory	"Answer a string concatenating the path parts strings in aDirectory, each string followed by a cr."	^ String streamContents: [:s | 		s nextPutAll: '[]'; cr.		aDirectory pathParts asArray doWithIndex: [:part :i |			i timesRepeat: [s space].			s nextPutAll: part withBlanksTrimmed; cr]]! !!StandardFileMenu methodsFor: 'basic control sequences' stamp: 'acg 4/15/1999 21:52'!confirmExistingFiles: aResult	|choice|	(aResult directory fileExists: aResult name) ifFalse: [^aResult].		choice _ (PopUpMenu		labels:'overwrite that filechoose another namecancel')		startUpWithCaption: aResult name, 'already exists.'.	choice = 1 ifTrue: [		aResult directory 			deleteFileNamed: aResult name			ifAbsent: 				[^self startUpWithCaption: 'Can''t delete ', aResult name, 'Select another file'].		^aResult].	choice = 2 ifTrue: [^self startUpWithCaption: 'Select Another File'].	^nil ! !!StandardFileMenu methodsFor: 'basic control sequences' stamp: 'jm 12/8/2003 15:06'!getTypedFileName: aResult	| name |	name _ FillInTheBlank 		request: 'Enter a new file name' 		initialAnswer: ''.	name = '' ifTrue: [^self startUpWithCaption: 'Select a File:'].	name _ aResult directory fullNameFor: name.	^ StandardFileMenuResult new		directory: (FileDirectory forFileName: name)		name: (FileDirectory localNameFor: name)! !!StandardFileMenu methodsFor: 'basic control sequences' stamp: 'jm 12/8/2003 14:59'!startUpWithCaption: aString at: location	| result |	result _ super startUpWithCaption: aString at: location.	result ifNil: [^ nil].	result isDirectory ifTrue: [		self makeFileMenuFor: result directory.		self computeForm.		^ self startUpWithCaption: aString at: location].	result isCommand ifTrue: [		getFolder ifTrue: [^ result directory].		result _ self getTypedFileName: result.		result ifNil: [^ nil].		canTypeFileName ifTrue: [^ self confirmExistingFiles: result]].	^ result! !!StandardFileMenu methodsFor: 'private' stamp: 'jm 12/8/2003 14:53'!advance: anInteger containingDirectoriesFrom: aDirectory	| theDirectory |	theDirectory _ aDirectory.	1 to: anInteger do: [:i | theDirectory _ theDirectory containingDirectory].	^ theDirectory! !!StandardFileMenu methodsFor: 'private' stamp: 'jm 12/8/2003 13:19'!folderFrom: aDirectory	canTypeFileName _ true.	getFolder _ true.	^ self makeFileMenuFor: aDirectory! !!StandardFileMenu methodsFor: 'private' stamp: 'jm 12/8/2003 14:49'!matchingFileNamesFor: aDirectory	| ext |	getFolder ifTrue: [^ #()].	^ aDirectory fileNames select: [:fn |		extensions			ifNil: [true]			ifNotNil: [				ext _ (FileDirectory extensionFor: fn) asLowercase.				extensions includes: ext]].! !!StandardFileMenu methodsFor: 'private' stamp: 'jm 12/8/2003 13:19'!newFileFrom: aDirectory	canTypeFileName _ true.	getFolder _ false.	^ self makeFileMenuFor: aDirectory! !!StandardFileMenu methodsFor: 'private' stamp: 'jm 12/8/2003 13:20'!oldFileFrom: aDirectory extensions: arrayOrNil	canTypeFileName _ false.	getFolder _ false.	extensions _ arrayOrNil.	^ self makeFileMenuFor: aDirectory! !!StandardFileMenu class methodsFor: 'file selection' stamp: 'jm 12/8/2003 15:12'!getFolder	"Select a folder (directory), initially viewing the default directory."	^ self getFolderFrom: FileDirectory default! !!StandardFileMenu class methodsFor: 'file selection' stamp: 'jm 12/8/2003 15:11'!getFolderFrom: aDirectory	"Select a folder (directory), initially viewing the given directory."	^ (self basicNew folderFrom: aDirectory)		startUpWithCaption: 'Select a folder:'! !!StandardFileMenu class methodsFor: 'file selection' stamp: 'jm 12/8/2003 15:15'!newFile	"Select a file to overwrite, initially viewing the default directory. Show all files. Allow the user type the name for a new file."	^ self newFileFrom: FileDirectory default! !!StandardFileMenu class methodsFor: 'file selection' stamp: 'jm 12/8/2003 15:16'!newFileFrom: aDirectory	"Select a file to overwrite, initially viewing the given directory. Show all files. Allow the user type the name for a new file."	^ (self basicNew newFileFrom: aDirectory)		startUpWithCaption: 'Select a File:'! !!StandardFileMenu class methodsFor: 'file selection' stamp: 'jm 12/8/2003 15:14'!oldFile	"Select an existing file, initially viewing the default directory. Show all files."	^ self oldFileFrom: FileDirectory default extensions: nil! !!StandardFileMenu class methodsFor: 'file selection' stamp: 'jm 12/8/2003 15:13'!oldFileExtensions: anArrayOrNil	"Select an existing file, initially viewing the default directory. Show only files with one of the given list of extensions. If the list is nil, show all files."	^ self oldFileFrom: FileDirectory default extensions: anArrayOrNil! !!StandardFileMenu class methodsFor: 'file selection' stamp: 'jm 12/8/2003 15:14'!oldFileFrom: aDirectory extensions: anArrayOrNil	"Select an existing file, initially viewing the given directory. Show only files with one of the given list of extensions. If the list is nil, show all files."	^ (self basicNew oldFileFrom: aDirectory extensions: anArrayOrNil)		startUpWithCaption: 'Select a File:'! !I record the file name and directory result of a file selection. I have two special cases:	name = nil	- indicates that this is actually a command to type a file name or select a folder	name = ''	- indicates that this is a directory selection!!StandardFileMenuResult methodsFor: 'accessing' stamp: 'jm 8/3/2003 15:20'!directory	^ directory! !!StandardFileMenuResult methodsFor: 'accessing' stamp: 'jm 8/3/2003 15:20'!name	^ name! !!StandardFileMenuResult methodsFor: 'accessing' stamp: 'jm 8/3/2003 15:19'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	name printOn: aStream.	aStream nextPutAll: ' in '.	aStream nextPutAll: directory pathName.	aStream nextPut: $).! !!StandardFileMenuResult methodsFor: 'testing' stamp: 'jm 8/3/2003 15:20'!isCommand	^ name isNil! !!StandardFileMenuResult methodsFor: 'testing' stamp: 'jm 8/3/2003 15:20'!isDirectory	^ name = ''! !!StandardFileMenuResult methodsFor: 'private' stamp: 'jm 8/3/2003 15:21'!directory: aDirectory name: aString	directory _ aDirectory.	name _ aString.! !Provides a simple, platform-independent, interface to a file system.  This initial version ignores issues of Directories etc.  The instance-variable fallbackStream at the moment holds an instance of HFSMacFileStream, to bridge us to the new world while in the old.  The instance variable rwmode, inherited from class PositionableStream, here is used to hold a Boolean -- true means opened for read-write, false means opened for read-only.  2/12/96 sw!!StandardFileStream methodsFor: 'open/close' stamp: 'jm 12/3/2003 11:25'!close	"Close this file."	fileID ifNotNil: [		self primClose: fileID.		self class unregister: self.		fileID _ nil].! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 2/6/2002 08:33'!closed	"Answer true if this file is closed."	^ fileID isNil or: [(self primSizeNoError: fileID) isNil]! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/21/1998 16:20'!ensureOpen	"Make sure that this file really is open."	self closed ifTrue: [^ self reopen].	(self primSizeNoError: fileID) ifNotNil: [^ self].	self reopen.! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 12/3/2003 11:27'!open: fileName forWrite: writeMode 	"Open the file with the given name. If writeMode is true, allow writing, otherwise open the file in read-only mode."	"Changed to do a GC and retry before failing ar 3/21/98 17:25"	fileID _ self retryWithGC: [self primOpen: fileName writable: writeMode] until:[:id | id notNil].	fileID ifNil: [^ nil].  "allows sender to detect failure"	self class register: self.	name _ fileName.	rwmode _ writeMode.	buffer1 _ String new: 1.! !!StandardFileStream methodsFor: 'open/close' stamp: 'jm 9/21/1998 13:58'!reopen	"Close and reopen this file. The file position is reset to zero."	"Details: Files that were open when a snapshot occurs are no longer valid when the snapshot is resumed. This operation re-opens the file if that has happened."	fileID ifNotNil: [self primCloseNoError: fileID].	self open: name forWrite: rwmode.! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'tk 11/4/1998 19:17'!isReadOnly	^ rwmode not! !!StandardFileStream methodsFor: 'properties-setting' stamp: 'jm 9/21/1998 13:56'!readOnly	"Make this file read-only."	rwmode _ false.! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:16'!directory	"Return the directory containing this file."	^ FileDirectory forFileName: self fullName! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:19'!fullName	"Answer this file's full path name."	^ name! !!StandardFileStream methodsFor: 'access' stamp: 'ar 11/24/1998 14:00'!localName	^ name ifNotNil: [(name findTokens: FileDirectory pathNameDelimiter asString) last]! !!StandardFileStream methodsFor: 'access' stamp: 'jm 9/21/1998 14:19'!name	"Answer this file's full path name."	^ name! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'mir 2/25/2000 12:37'!basicNext	"Answer the next byte from this file, or nil if at the end of the file."	| count |	count _ self primRead: fileID into: buffer1 startingAt: 1 count: 1.	count = 1		ifTrue: [^ buffer1 at: 1]		ifFalse: [^ nil].! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'tk 3/15/2000 10:31'!compressFile	"Write a new file that has the data in me compressed in GZip format."	| zipped buffer |	self readOnly; binary.	zipped _ self directory newFileNamed: (self name, FileDirectory dot, 'gz').	zipped binary; setFileTypeToObject.		"Type and Creator not to be text, so can be enclosed in an email"	zipped _ GZipWriteStream on: zipped.	buffer _ ByteArray new: 50000.	'Compressing ', self fullName displayProgressAt: Sensor cursorPoint		from: 0 to: self size		during: [:bar |			[self atEnd] whileFalse: [				bar value: self position.				zipped nextPutAll: (self nextInto: buffer)].			zipped close.			self close].! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'mir 2/25/2000 12:37'!next	"Answer the next byte from this file, or nil if at the end of the file."	^ self basicNext! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ar 12/23/1999 15:02'!next: n into: aString startingAt: startIndex	"Read n bytes into the given string.	Return aString or a partial copy if less than	n elements have been read."	| count |	count _ self primRead: fileID into: aString				startingAt: startIndex count: n.	count = n		ifTrue:[^aString]		ifFalse:[^aString copyFrom: 1 to: startIndex+count-1]! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'ar 1/2/2000 15:33'!next: anInteger putAll: aString startingAt: startIndex	"Store the next anInteger elements from the given collection."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	self primWrite: fileID from: aString startingAt: startIndex count: anInteger.	^aString! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 13:55'!nextPut: char	"Write the given character to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	buffer1 at: 1 put: char.	self primWrite: fileID from: buffer1 startingAt: 1 count: 1.	^ char! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'tk 2/5/2000 21:43'!nextPutAll: aString	"Write all the characters of the given string to this file."	rwmode ifFalse: [^ self error: 'Cannot write a read-only file'].	self primWrite: fileID from: aString startingAt: 1 count: aString basicSize.	^ aString! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'mir 2/25/2000 12:37'!peek	"Answer what would be returned if the message next were sent to the receiver. If the receiver is at the end, answer nil.  "	| next |	self atEnd ifTrue: [^ nil].	next _ self basicNext.	self position: self position - 1.	^ next! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 10/27/2002 10:45'!upToEnd	"Answer a subcollection from the current access position through the last element of the receiver."	| buffer |	buffer _ buffer1 species new: (self size - self position).	self nextInto: buffer.	^ buffer! !!StandardFileStream methodsFor: 'read, write, position' stamp: 'jm 9/21/1998 13:56'!verbatim: aString	"A version of nextPutAll that can be called knowing it won't call nextPut: "	^ self nextPutAll: aString! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:18'!primAtEnd: id	"Answer true if the file position is at the end of the file."	<primitive: 150>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:02'!primClose: id	"Close this file."	<primitive: 151>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:02'!primCloseNoError: id	"Close this file. Don't raise an error if the primitive fails."	<primitive: 151>! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:04'!primGetPosition: id	"Get this files current position."	<primitive: 152>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:06'!primOpen: fileName writable: writableFlag	"Open a file of the given name, and return the file ID obtained.	If writableFlag is true, then		if there is none with this name, then create one		else prepare to overwrite the existing from the beginning	otherwise		if the file exists, open it read-only		else return nil"	<primitive: 153>	^ nil! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:18'!primRead: id into: byteArray startingAt: startIndex count: count	"Read up to count bytes of data from this file into the given string or byte array starting at the given index. Answer the number of bytes actually read."	<primitive: 154>	self closed ifTrue: [^ self error: 'File is closed'].	self error: 'File read failed'.! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 14:09'!primSetPosition: id to: anInteger	"Set this file to the given position."	<primitive: 155>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:17'!primSize: id	"Answer the size of this file."	<primitive: 157>	self primitiveFailed! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:17'!primSizeNoError: id	"Answer the size of this file. Answer nil if the primitive fails; this indicates that the file handle has become stale."	<primitive: 157>	^ nil! !!StandardFileStream methodsFor: 'primitives' stamp: 'jm 9/21/1998 16:18'!primWrite: id from: stringOrByteArray startingAt: startIndex count: count	"Write count bytes onto this file from the given string or byte array starting at the given index. Answer the number of bytes written."	<primitive: 158>	self closed ifTrue: [^ self error: 'File is closed'].	self error: 'File write failed'.! !!StandardFileStream methodsFor: 'finalization' stamp: 'ar 3/21/98 18:16'!actAsExecutor	super actAsExecutor.	name := nil.! !!StandardFileStream methodsFor: 'finalization' stamp: 'ar 10/7/1998 15:44'!finalize	self primCloseNoError: fileID.! !!StandardFileStream methodsFor: 'dnd requests' stamp: 'jm 5/3/2003 20:13'!primDropRequestFileHandle: dropIndex	"Answer a read-only file handle for the dropped file with the given index. The first dropped file is index 1. Answer nil if there is no dropped file with the given index or the primitive is not supported."	<primitive: 'primitiveDropRequestFileHandle' module:' DropPlugin'>	^ nil! !!StandardFileStream methodsFor: 'dnd requests' stamp: 'jm 5/3/2003 20:13'!primDropRequestFileName: dropIndex	"Answer the file name for the dropped file with the given index. The first dropped file is index 1. Answer nil if there is no dropped file with the given index or the primitive is not supported."	<primitive: 'primitiveDropRequestFileName' module: 'DropPlugin'>	^ nil! !!StandardFileStream methodsFor: 'dnd requests' stamp: 'jm 12/3/2003 11:27'!requestDropStream: dropIndex	"Initialize me to be a read-only stream for a file that the user has just dropped onto the Squeak window. The first dropped file is index 1. Answer nil if there is no dropped file with the given index."	name _ self primDropRequestFileName: dropIndex.	fileID _ self primDropRequestFileHandle: dropIndex.	fileID ifNil: [		name ifNil: [^ nil].		"try to open by name (needed for Squeak 3.0):"		self open: name forWrite: false.		fileID ifNil: [^ nil].		^ self].	self class register: self.	rwmode _ false.	buffer1 _ String new: 1.! !!StandardFileStream class methodsFor: 'file creation' stamp: 'TPR 8/13/1999 21:22'!fileNamed: fileName	"Open a file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	^ self new open: (self fullName: fileName) forWrite: true! !!StandardFileStream class methodsFor: 'file creation' stamp: 'mpw 9/18/1999 00:05'!isAFileNamed: fileName	"Answer true if a file of the given name exists."	| f |	f _ self new open: fileName forWrite: false.	f ifNil: [^ false].	f close.	^ true! !!StandardFileStream class methodsFor: 'file creation' stamp: 'sma 5/12/2000 10:36'!newFileNamed: fileName 	"Create a new file with the given name, and answer a stream opened for writing on that file. If the file already exists, ask the user what to do."	| dir localName choice newName fullName |	fullName _ self fullName: fileName.	(self isAFileNamed: fullName)		ifFalse: [^ self new open: fullName forWrite: true].	"file already exists:"	dir _ FileDirectory forFileName: fullName.	localName _ FileDirectory localNameFor: fullName.	choice _ (PopUpMenu		labels:'overwrite that filechoose another namecancel')		startUpWithCaption: localName, 'already exists.'.	choice = 1 ifTrue: [		dir deleteFileNamed: localName			ifAbsent: [self error: 'Could not delete the old version of that file'].		^ self new open: fullName forWrite: true].	choice = 2 ifTrue: [		newName _ FillInTheBlank request: 'Enter a new file name' initialAnswer: 'fullName'.		newName isEmpty ifFalse: [			fullName _ self fullName: newName.			^ self newFileNamed: fullName]].	self error: 'Please close this to abort file opening'! !!StandardFileStream class methodsFor: 'file creation' stamp: 'TPR 8/13/1999 21:26'!oldFileNamed: fileName	"Open an existing file with the given name for reading and writing. If the name has no directory part, then the file will be created in the default directory. If the file already exists, its prior contents may be modified or replaced, but the file will not be truncated on close."	| selection fullName newName |	fullName _ self fullName: fileName.	(self isAFileNamed: fullName) ifTrue:		[^ self new open: fullName forWrite: true].	"File does not exist..."	selection _ (PopUpMenu labels:'create a new filechoose another namecancel')			startUpWithCaption: (FileDirectory localNameFor: fullName) , 'does not exist.'.	selection = 1 ifTrue:		[^ self new open: fullName forWrite: true].	selection = 2 ifTrue:		[ newName _ FillInTheBlank request: 'Enter a new file name'						initialAnswer:  fullName.		^ self oldFileNamed:			(self fullName: newName)].	self halt! !!StandardFileStream class methodsFor: 'file creation' stamp: 'ar 12/17/1999 13:56'!readOnlyFileNamed: fileName 	"Open an existing file with the given name for reading."	"Changed to open a more usefull popup menu.  It now also includes the most likely choices.  jaf"	| selection dir files choices newName fullName |	fullName _ self fullName: fileName.	(self isAFileNamed: fullName)		ifTrue: [^ self new open: fullName forWrite: false].	"File does not exist..."	dir _ FileDirectory forFileName: fullName.	files _ dir fileNames.	choices _ (FileDirectory localNameFor: fullName) correctAgainst: files.	choices add: 'Choose another name'.	choices add: 'Cancel'.	selection _ (PopUpMenu labelArray: choices lines: (Array with: 5) )		startUpWithCaption: (FileDirectory localNameFor: fullName), 'does not exist.'.	selection < (choices size - 1) ifTrue: [		newName _ (dir pathName , FileDirectory slash , (choices at: selection))].	selection = (choices size - 1) ifTrue: [		newName _ FillInTheBlank 							request: 'Enter a new file name' 							initialAnswer: fileName].	newName = '' ifFalse: [^ self readOnlyFileNamed: (self fullName: newName)].	^ self error: 'Could not open a file'! !!StandardFileStream class methodsFor: 'registry' stamp: 'ar 10/7/1998 14:41'!register: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry add: anObject! !!StandardFileStream class methodsFor: 'registry' stamp: 'ar 10/7/1998 14:41'!registry	WeakArray isFinalizationSupported ifFalse:[^nil].	^Registry isNil		ifTrue:[Registry := WeakRegistry new]		ifFalse:[Registry].! !!StandardFileStream class methodsFor: 'registry' stamp: 'ar 10/7/1998 15:23'!unregister: anObject	WeakArray isFinalizationSupported ifFalse:[^anObject].	self registry remove: anObject ifAbsent:[]! !This class implements the source file management behavior of traditional Squeak, with a sources file and a changes file. File positions are mapped such that those files can be up to 32MBytes in size.Structure: files		Array -- storing the actual source files!!StandardSourceFileArray methodsFor: 'initialize-release' stamp: 'hmm 4/25/2000 21:20'!initialize	files _ Array new: 2.	files at: 1 put: (SourceFiles at: 1).	files at: 2 put: (SourceFiles at: 2)! !!StandardSourceFileArray methodsFor: 'initialize-release' stamp: 'ar 5/17/2000 18:28'!initialize: nFiles	files _ Array new: nFiles! !!StandardSourceFileArray methodsFor: 'accessing' stamp: 'hmm 4/25/2000 21:20'!at: index	^files at: index! !!StandardSourceFileArray methodsFor: 'accessing' stamp: 'hmm 4/25/2000 21:20'!at: index put: aFile	files at: index put: aFile! !!StandardSourceFileArray methodsFor: 'accessing' stamp: 'hmm 4/25/2000 21:20'!size	^files size! !!StandardSourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'hmm 4/25/2000 21:44'!fileIndexFromSourcePointer: anInteger	"Return the index of the source file which contains the source chunk addressed by anInteger"	"This implements the recent 32M source file algorithm"	| hi |	hi _ anInteger // 16r1000000.	^hi < 3		ifTrue: [hi]		ifFalse: [hi - 2]! !!StandardSourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'hmm 4/25/2000 21:44'!filePositionFromSourcePointer: anInteger	"Return the position of the source chunk addressed by anInteger"	"This implements the recent 32M source file algorithm"	| hi lo |	hi _ anInteger // 16r1000000.	lo _ anInteger \\ 16r1000000.	^hi < 3		ifTrue: [lo]		ifFalse: [lo + 16r1000000]! !!StandardSourceFileArray methodsFor: 'sourcePointer conversion' stamp: 'hmm 4/25/2000 21:48'!sourcePointerFromFileIndex: index andPosition: position	| hi lo |	"Return a source pointer according to the new 32M algorithm"	((index between: 1 and: 2) and: [position between: 0 and: 16r1FFFFFF])		ifFalse: [self error: 'invalid source code pointer'].	hi _ index.	lo _ position.	lo >= 16r1000000 ifTrue: [		hi _ hi+2.		lo _ lo - 16r1000000].	^hi * 16r1000000 + lo! !!StandardSourceFileArray class methodsFor: 'initialize-release' stamp: 'hmm 4/25/2000 21:19'!install	"Replace SourceFiles by an instance of me with the standard sources and changes files.	This only works if SourceFiles is either an Array or an instance of this class"	"StandardSourceFileArray install"	SourceFiles _ self new initialize! !!StandardSourceFileArray class methodsFor: 'initialize-release' stamp: 'ar 5/17/2000 18:27'!new: nFiles	^self new initialize: nFiles.! !I am a controller for StandardSystemViews, that is, those views that are at the top level of a project in the system user interface. I am a kind of MouseMenuController that creates a blue button menu for moving, framing, collapsing, and closing ScheduledViews, and for selecting views under the view of my instance.!!StandardSystemController methodsFor: 'initialize-release' stamp: 'sma 3/11/2000 11:48'!initialize	super initialize.	status _ #inactive! !!StandardSystemController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 12:01'!blueButtonActivity	ScheduledBlueButtonMenu ifNil: [^ super controlActivity].	ScheduledBlueButtonMenu invokeOn: self! !!StandardSystemController methodsFor: 'control defaults' stamp: 'sma 3/11/2000 15:20'!controlActivity	self checkForReframe.	^ super controlActivity! !!StandardSystemController methodsFor: 'control defaults' stamp: 'sma 3/15/2000 22:19'!redButtonActivity	"If cursor is in label of a window when red button is pushed,	check for closeBox or growBox, else drag the window frame	or edit the label."	| box p |	p _ sensor cursorPoint.	self labelHasCursor ifFalse: [super redButtonActivity. ^ self].	((box _ view closeBoxFrame) containsPoint: p)		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed: [self close. ^ self].			^ self].	((box _ view growBoxFrame) containsPoint: p)		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed:					[Sensor controlKeyPressed ifTrue: [^ self expand; fullScreen].					^ view isCollapsed						ifTrue: [self expand]						ifFalse: [self collapse]].			^ self].	(((box _ view labelTextRegion expandBy: 1) containsPoint: p)			and: [Preferences clickOnLabelToEdit or: [sensor leftShiftDown]])		ifTrue:			[Utilities				awaitMouseUpIn: box				repeating: []				ifSucceed: [^ self label].			^ self].	self move! !!StandardSystemController methodsFor: 'basic control sequence' stamp: 'sw 10/20/1999 09:52'!controlInitialize	view displayEmphasized.	view uncacheBits.  "Release cached bitmap while active"	model windowActiveOnFirstClick ifFalse: [sensor waitNoButton].	status _ #active.	view isCollapsed ifFalse: [model modelWakeUpIn: view]! !!StandardSystemController methodsFor: 'basic control sequence' stamp: 'di 5/11/1999 22:05'!controlTerminate	status == #closed		ifTrue: 			[view ~~ nil ifTrue: [view release].			ScheduledControllers unschedule: self.			^self].	view deEmphasize; cacheBits.	view isCollapsed ifFalse: [model modelSleep].! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:45'!adjustPaneBorders 	| side sub newRect outerFrame |	outerFrame _ view displayBox.	side _ #none.	VBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #left ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withLeft: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				side = #right ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withRight: sensor cursorPoint x)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]].	HBorderCursor showWhile:		[ [sub _ view subviewWithLongestSide: [:s | side _ s]						near: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue: [				self interActivityPause.				sensor redButtonPressed ifTrue:				[side = #top ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withTop: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				side = #bottom ifTrue:					[newRect _ sub stretchFrame:						[:f | (f withBottom: sensor cursorPoint y)								intersect: outerFrame]						startingWith: sub displayBox].				view reframePanesAdjoining: sub along: side to: newRect]]]! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:42'!adjustWindowBorders 	| side |	VBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #left) | (side = #right)]]			whileTrue:			[(sensor redButtonPressed and: [self cursorOnBorder]) ifTrue:				[side = #left ifTrue:					[view newFrame: [:f | f withLeft: sensor cursorPoint x]].				side = #right ifTrue:					[view newFrame: [:f | f withRight: sensor cursorPoint x]]].			self interActivityPause]. ].	HBorderCursor showWhile:		[ [side _ view displayBox sideNearestTo: sensor cursorPoint.		  self cursorOnBorder and: [(side = #top) | (side = #bottom)]]			whileTrue:			[(sensor redButtonPressed and: [self cursorOnBorder]) ifTrue:				[side = #top ifTrue:					[view newFrame: [:f | f withTop: sensor cursorPoint y]].				side = #bottom ifTrue:					[view newFrame: [:f | f withBottom: sensor cursorPoint y]]].		  self interActivityPause]]! !!StandardSystemController methodsFor: 'borders' stamp: 'ls 7/11/1998 07:38'!adjustWindowCorners 	| box cornerBox p clicked f2 |	box _ view windowBox.	clicked _ false.	#(topLeft topRight bottomRight bottomLeft)		do: [:readCorner |			cornerBox _ ((box insetBy: 2) perform: readCorner) - (10@10) extent: 20@20.			(cornerBox containsPoint: sensor cursorPoint)				ifTrue: 				["Display reverse: cornerBox."				(Cursor perform: readCorner) showWhile:					[[(cornerBox containsPoint: (p _ sensor cursorPoint))						and: [(clicked _ sensor anyButtonPressed) not]]						whileTrue: [ self interActivityPause ].				"Display reverse: cornerBox."				clicked ifTrue:					[view newFrame:						[:f | p _ sensor cursorPoint.						readCorner = #topLeft ifTrue:							[f2 _ p corner: f bottomRight].						readCorner = #bottomLeft ifTrue:							[f2 _ (f withBottom: p y) withLeft: p x].						readCorner = #bottomRight ifTrue:							[f2 _ f topLeft corner: p].						readCorner = #topRight ifTrue:							[f2 _ (f withTop: p y) withRight: p x].						f2]]]]].	^ clicked! !!StandardSystemController methodsFor: 'pluggable menus' stamp: 'sma 3/11/2000 15:12'!getPluggableYellowButtonMenu: shiftKeyState	^ nil! !!StandardSystemController class methodsFor: 'class initialization' stamp: 'sma 3/11/2000 11:57'!initialize	"StandardSystemController initialize"	ScheduledBlueButtonMenu _ SelectionMenu		labels:'edit labelchoose color...two-tone/full colormoveframefull screencollapseclose'	lines: #(3 7)	selections: #(label chooseColor toggleTwoTone move reframe fullScreen collapse close).	VBorderCursor _ Cursor extent: 16@16 fromArray: #(		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010010000100000		2r1010110000110000		2r1011111111111000		2r1010110000110000		2r1010010000100000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000		2r1010000000000000)			offset: 0@0.	HBorderCursor _ Cursor extent: 16@16 fromArray: #(		2r1111111111111111		2r0000000000000000		2r1111111111111111		2r0000000100000000		2r0000001110000000		2r0000011111000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000000100000000		2r0000011111000000		2r0000001110000000		2r0000000100000000		2r0000000000000000		2r0000000000000000		2r0000000000000000)			offset: 0@0.! !!StandardSystemController class methodsFor: 'cursor constants' stamp: 'jm 6/17/2003 11:31'!hBorderCursor	^ HBorderCursor! !!StandardSystemController class methodsFor: 'cursor constants' stamp: 'jm 6/17/2003 11:31'!vBorderCursor	^ VBorderCursor! !I represent a view that has a label above its top left corner. The text in the label identifies the kind of view. In addition to a label, I add control over the maximum and minimum size of the display box of my instance. My default controller is StandardSystemController. The elements of ScheduledControllers, the sole instance of ControlManager, are usually controllers for instances of me.!!StandardSystemView methodsFor: 'initialize-release' stamp: 'sw 10/29/1999 12:58'!initialize 	"Refer to the comment in View|initialize."	super initialize.	labelFrame _ Quadrangle new.	labelFrame region: (Rectangle origin: 0 @ 0 extent: 50 @ self labelHeight).	labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.	self label: nil.	isLabelComplemented _ false.	minimumSize _ 50 @ 50.	maximumSize _ Display extent.	collapsedViewport _ nil.	expandedViewport _ nil.	bitsValid _ false.	updatablePanes _ #()! !!StandardSystemView methodsFor: 'initialize-release' stamp: 'jm 8/20/1998 18:29'!release	model windowIsClosing.	self isCollapsed ifTrue: [savedSubViews do: [:v | v release]].	super release.! !!StandardSystemView methodsFor: 'label access' stamp: 'sw 12/9/1999 17:44'!label: aString 	"Set aString to be the receiver's label."	labelText _ Paragraph			withText: (Text string: ((aString == nil or: [aString isEmpty])								ifTrue: ['Untitled' copy]								ifFalse: [aString])							attributes: (Array with: TextEmphasis bold))			style: LabelStyle.	insetDisplayBox == nil ifTrue: [^ self].  "wait for further initialization"	self setLabelRegion! !!StandardSystemView methodsFor: 'label access' stamp: 'sw 12/9/1999 17:47'!labelHeight	^ ((LabelStyle fontAt: 1) height + 4) max: 20! !!StandardSystemView methodsFor: 'label access' stamp: 'sr 3/26/2000 04:26'!labelText	^labelText! !!StandardSystemView methodsFor: 'label access' stamp: 'di 6/10/1998 13:18'!relabel: aString 	"A new string for the label.  Window is assumed to be active.	Window will redisplay only if label bar has to grow."	| oldRegion oldWidth |	(model windowReqNewLabel: aString) ifFalse: [^ self].	oldRegion _ self labelTextRegion.	oldWidth _ self insetDisplayBox width.	self label: aString.	Display fill: ((oldRegion merge: self labelTextRegion) expandBy: 3@0)			fillColor: self labelColor.	self insetDisplayBox width = oldWidth		ifTrue: [self displayLabelText; emphasizeLabel]		ifFalse: [self uncacheBits; displayEmphasized].! !!StandardSystemView methodsFor: 'label access' stamp: 'sw 1/11/2000 15:27'!setLabelTo: aString 	"Force aString to be the new label of the receiver, bypassing any logic about whether it is acceptable and about propagating information about the change."	| oldRegion oldWidth |	oldRegion _ self labelTextRegion.	oldWidth _ self insetDisplayBox width.	self label: aString.	Display fill: ((oldRegion merge: self labelTextRegion) expandBy: 3@0)			fillColor: self labelColor.	self insetDisplayBox width = oldWidth		ifTrue: [self displayLabelText; emphasizeLabel]		ifFalse: [self uncacheBits; displayEmphasized].! !!StandardSystemView methodsFor: 'framing' stamp: 'sr 3/26/2000 03:47'!chooseCollapsePoint	"Answer the point at which to place the collapsed window."	| pt labelForm beenDown offset |	labelForm _ Form fromDisplay: self labelDisplayBox.	self uncacheBits.	self erase.	beenDown _ Sensor anyButtonPressed.	self isCollapsed ifTrue:		[offset _ self labelDisplayBox topLeft - self growBoxFrame topLeft.		labelForm follow: [pt _ (Sensor cursorPoint + offset max: 0@0) truncateTo: 8]				while: [Sensor anyButtonPressed							ifTrue: [beenDown _ true]							ifFalse: [beenDown not]].		^ pt].	^ (RealEstateAgent assignCollapseFrameFor: self) origin.! !!StandardSystemView methodsFor: 'framing' stamp: 'di 5/11/1999 22:09'!collapse	"If the receiver is not already collapsed, change its view to be that of its 	label only."	self isCollapsed ifFalse:			[model modelSleep.			(subViews ~~ nil and: [subViews size = 1 and: [subViews first isKindOf: MorphWorldView]])				ifTrue: [subViews first deEmphasizeView].			expandedViewport _ self viewport.			savedSubViews _ subViews.			self resetSubViews.			labelText isNil ifTrue: [self label: nil.  bitsValid _ false.].			self window: (self inverseDisplayTransform:					((self labelDisplayBox topLeft extent: (labelText extent x + 70) @ self labelHeight)						 intersect: self labelDisplayBox))]! !!StandardSystemView methodsFor: 'framing' stamp: 'sw 10/20/1999 09:46'!expand	"If the receiver is collapsed, change its view to be that of all of its subviews, not its label alone."	| newFrame |	self isCollapsed		ifTrue:			[newFrame _ self chooseFrame expandBy: borderWidth.			collapsedViewport _ self viewport.			subViews _ savedSubViews.			labelFrame borderWidthLeft: 2 right: 2 top: 2 bottom: 2.			savedSubViews _ nil.			self setWindow: nil.			self resizeTo: newFrame.			self displayDeEmphasized.			model modelWakeUpIn: self]! !!StandardSystemView methodsFor: 'framing' stamp: 'di 10/22/1998 16:15'!reframePanesAdjoining: subView along: side to: aDisplayBox 	| newBox delta newRect minDim theMin |	newRect _ aDisplayBox.	theMin _ 16.	"First check that this won't make any pane smaller than theMin screen dots"	minDim _ ((subViews select: [:sub | sub displayBox bordersOn: subView displayBox along: side])		collect: [:sub | sub displayBox adjustTo: newRect along: side])			inject: 999 into: [:was :rect | (was min: rect width) min: rect height].	"If so, amend newRect as required"	minDim < theMin ifTrue:		[delta _ minDim - theMin.		newRect _ newRect withSide: side setTo: 				((newRect perform: side) > (subView displayBox perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	subViews do:		[:sub | (sub displayBox bordersOn: subView displayBox along: side) ifTrue:			[newBox _ sub displayBox adjustTo: newRect along: side.			sub window: sub window viewport:				(sub transform: (sub inverseDisplayTransform: newBox)) rounded]].	"And adjust the growing pane itself"	subView window: subView window viewport:			(subView transform: (subView inverseDisplayTransform: newRect)) rounded.	"Finally force a recomposition of the whole window"	viewport _ nil.	self resizeTo: self viewport.	self uncacheBits; displayEmphasized! !!StandardSystemView methodsFor: 'displaying' stamp: 'hmm 7/21/1999 07:37'!displayDeEmphasized 	"Display this view with emphasis off.	If windowBits is not nil, then simply BLT if possible,		but force full display for top window so color is preserved."	(bitsValid and: [controller ~~ ScheduledControllers activeController])		ifTrue: [self lock.				windowBits displayAt: self windowOrigin]		ifFalse: [Display deferUpdates: true.				super display.				Display deferUpdates: false; forceToScreen: self windowBox.				CacheBits ifTrue: [self cacheBitsAsIs]]! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 9/10/1998 09:43'!displayLabelText	"The label goes in the center of the window"	| labelRect |	labelText foregroundColor: self foregroundColor			backgroundColor: self labelColor.	labelRect _ self labelTextRegion.	Display fill: (labelRect expandBy: 3@0) fillColor: self labelColor.	labelText displayOn: Display at: labelRect topLeft clippingBox: labelRect			rule: labelText rule fillColor: labelText fillColor.	labelText destinationForm: nil! !!StandardSystemView methodsFor: 'displaying' stamp: 'jm 5/12/2003 19:56'!displayOn: aBitBlt	bitsValid ifFalse: [		^ Display clippingTo: aBitBlt clipRect do: [super display]].	aBitBlt copyForm: windowBits to: self windowOrigin rule: Form over.! !!StandardSystemView methodsFor: 'displaying' stamp: 'di 8/10/1999 08:38'!makeMeVisible	| newLoc portRect |	((Display boundingBox insetBy: (0@0 corner: self labelHeight asPoint))		containsPoint: self displayBox topLeft) ifTrue: [^ self "OK -- my top left is visible"].	"window not on screen (probably due to reframe) -- move it now"	newLoc _ self isCollapsed		ifTrue: [RealEstateAgent assignCollapsePointFor: self]		ifFalse: [(RealEstateAgent initialFrameFor: self) topLeft].	portRect _ newLoc + self labelOffset				extent: self windowBox extent - self labelOffset.	self resizeTo: portRect.	self setLabelRegion.! !!StandardSystemView methodsFor: 'private' stamp: 'di 10/21/1998 16:12'!subviewWithLongestSide: sideBlock near: aPoint 	| theSub theSide theLen box |	theLen _ 0.	subViews do:		[:sub | box _ sub insetDisplayBox.		box forPoint: aPoint closestSideDistLen:			[:side :dist :len |			(dist <= 5 and: [len > theLen]) ifTrue:				[theSub _ sub.				theSide _ side.				theLen _ len]]].	sideBlock value: theSide.	^ theSub! !!StandardSystemView methodsFor: 'updating' stamp: 'sw 10/29/1999 12:57'!setUpdatablePanesFrom: getSelectors	| aList aPane |	"Set my updatablePanes inst var to the list of panes which are list panes with the given get-list selectors.  Order is important here!!  Note that the method is robust in the face of panes not found, but a warning is printed in the transcript in each such case"	aList _ OrderedCollection new.	getSelectors do:		[:sel | aPane _ self subViewSatisfying:				[:pane | (pane isKindOf: PluggableListView) and: [pane getListSelector == sel]].			aPane				ifNotNil:					[aList add: aPane]				ifNil:					[Transcript cr; show: 'Warning: view ', sel, ' not found.']].	updatablePanes _ aList asArray! !!StandardSystemView methodsFor: 'updating' stamp: 'sw 10/29/1999 21:20'!updatablePanes	"Answer the list of panes, in order, which might be sent the #verifyContents message upon window activation or expansion."	^ updatablePanes ifNil: [updatablePanes _ #()]! !!StandardSystemView methodsFor: 'updating' stamp: 'sw 1/11/2000 15:30'!update: aSymbol	aSymbol = #relabel		ifTrue: [^ self setLabelTo: model labelString].	^ super update: aSymbol! !!StandardSystemView class methodsFor: 'class initialization' stamp: 'sw 12/6/1999 23:42'!initialize		"StandardSystemView initialize"	self doCacheBits.	self setLabelStyle! !!StandardSystemView class methodsFor: 'class initialization' stamp: 'sw 12/9/1999 17:43'!setLabelStyle	| aFont |	"StandardSystemView setLabelStyle"	aFont _ Preferences windowTitleFont.	LabelStyle _ aFont textStyle copy consistOnlyOf: aFont.	LabelStyle gridForFont: 1 withLead: 0! !I am used as the contents for a StoryLineMorph. I support some special drop actions and mouse handling.!!StoryLineContentsMorph methodsFor: 'initialization' stamp: 'jm 9/9/2003 20:52'!initialize	super initialize.	self borderWidth: 0.	self color: Color veryLightGray.! !!StoryLineContentsMorph methodsFor: 'event handling' stamp: 'jm 9/10/2003 12:33'!handlesMouseDown: evt	"I handle the mouse in the top portion of myself (where the time scale appears)."	^ evt cursorPoint y < (self top + 35)! !!StoryLineContentsMorph methodsFor: 'event handling' stamp: 'jm 9/10/2003 12:34'!mouseMove: evt	| cursorX leftEdge pastRightEdge |	(owner respondsTo: #moveCursor:) ifTrue: [		cursorX _ evt cursorPoint x - self left.		leftEdge _ owner hScrollPixels.  "leftmost coordinate currently displayed on screen"		pastRightEdge _ cursorX - (leftEdge + owner visibleExtent x).		pastRightEdge > 0 ifTrue: [			owner hScrollPixels: leftEdge + pastRightEdge].  "scroll to keep cursor in view"		owner moveCursor: cursorX].! !!StoryLineContentsMorph methodsFor: 'dropping/grabbing' stamp: 'RG 11/26/2003 16:11'!acceptDroppingMorph: aMorph event: evt	aMorph left: (aMorph left max: self left).	(aMorph isKindOf: NarratorImageMorph) ifTrue: [		"adding code to set lastLocation, this enables Trash to know where the Image originated"		aMorph lastLocation: self.		aMorph top: self top + 35].	(aMorph isKindOf: NarratorSoundMorph) ifTrue: [		aMorph scaleToPixelsPerSecond: NarratorMorph pixelsPerSecond.		aMorph lastLocation: self.		(aMorph top - self top) < 165			ifTrue: [aMorph top: self top + 130]			ifFalse: [aMorph top: self top + 190]].	super acceptDroppingMorph: aMorph event: evt.! !!StoryLineContentsMorph methodsFor: 'dropping/grabbing' stamp: 'jm 9/9/2003 20:56'!wantsDroppedMorph: aMorph event: evt	^ (aMorph isKindOf: NarratorImageMorph) |	  (aMorph isKindOf: NarratorSoundMorph)! !I am a scrollable timeline containing thumbnails of images and sounds. When I am playing, my sounds play, my cursor moves, and I notify the Narrator when the cursor encounters each image thumbnail. The playing sound is used as a clock to move the cursor and determine when to display the next image.!!StoryLineMorph methodsFor: 'initialization' stamp: 'jm 9/12/2003 16:04'!initialize	| timeScale |	super initialize.	self contents: StoryLineContentsMorph new.	"configure the displayable area"	self color: Color gray.	self showVerticalScrollbar: false.	self extent: 750@(250 + scrollBarThickness).	pixelsPerSecond _ NarratorMorph pixelsPerSecond.	volume _ 0.5.	timeScale _ self buildTimeScale: 300.	timeScale position: 0@5.	self contents addMorph: timeScale.	cursorMorph _ Morph new		color: Color red;		extent: 1@300;		position: 0@5.	self contents addMorphFront: cursorMorph.! !!StoryLineMorph methodsFor: 'initialization' stamp: 'jm 9/10/2003 14:33'!narrator: aNarrator	narrator _ aNarrator.! !!StoryLineMorph methodsFor: 'stepping' stamp: 'jm 9/10/2003 15:06'!step	| mSecs cursorX m |	sound ifNil: [^ self].	sound isPlaying ifFalse: [		sound _ nil.		^ self].	mSecs _ sound millisecondsSinceStart min: (sound duration * 1000).	cursorX _ (pixelsPerSecond * mSecs) // 1000.	self moveCursor: cursorX.	(imageQueue size > 0 and:	 [(contents left + cursorX) >= imageQueue first left]) ifTrue: [		m _ imageQueue removeFirst.		narrator ifNotNil: [narrator showImage: m originalImage]].! !!StoryLineMorph methodsFor: 'stepping' stamp: 'jm 9/10/2003 09:07'!stepTime	^ 50! !!StoryLineMorph methodsFor: 'operating' stamp: 'jm 9/10/2003 08:01'!isPlaying	^ sound notNil and: [sound isPlaying]! !!StoryLineMorph methodsFor: 'operating' stamp: 'jm 9/12/2003 15:56'!rewind	self stopPlaying.	self moveCursor: 0.! !!StoryLineMorph methodsFor: 'operating' stamp: 'LY 10/2/2003 13:02'!save	| r f file z soundQueue |	r _ FillInTheBlank request: 'What would you like to save your project as?'					   initialAnswer: 'MyProject1'.	(r = '' )		ifTrue: [^self].	f _ FileDirectory default.	(f directoryExists: r)		ifFalse: [f createDirectory: r.].	z _ f directoryNamed: r.	imageQueue _ contents submorphs select: [:m | m isKindOf: NarratorImageMorph].	imageQueue do: [:image | 		file _ FileStream oldFileNamed: image fileName.		z putFile: file named: (FileDirectory localNameFor: (image fileName)).].			soundQueue _ contents submorphs select: [:n | n isKindOf: NarratorSoundMorph].	soundQueue do: [:n | 		n writeSoundFile: (z fullNameFor: (n title), '.wav').].		self writeFileNamed: (z fullNameFor: r,'.nar')			! !!StoryLineMorph methodsFor: 'operating' stamp: 'jm 9/10/2003 16:32'!setVolume: aNumber	volume _ aNumber.	sound ifNil: [^ self].	1 to: sound sounds size do: [:i | sound setPan: 0.5 volume: volume for: i].! !!StoryLineMorph methodsFor: 'operating' stamp: 'jm 9/13/2003 19:08'!startPlaying	| startSecs |	self stopPlaying.	"make sorted lists of images"	imageQueue _ contents submorphs select: [:m | m isKindOf: NarratorImageMorph].	imageQueue _ (imageQueue sort: [:m1 :m2 | m1 left < m2 left]) asOrderedCollection.	"make sound"	startSecs _ (cursorMorph left - contents left) asFloat / pixelsPerSecond.	sound _ self buildSound.	"advance up to cursor"	[imageQueue size > 1 and: [cursorMorph left > imageQueue second right]]		whileTrue: [imageQueue removeFirst].	sound reset; playSilentlyUntil: startSecs.	"start playing"	cursorMorph comeToFront.	sound resumePlaying.	self startStepping.! !!StoryLineMorph methodsFor: 'operating' stamp: 'jm 9/10/2003 15:02'!stopPlaying	sound ifNotNil: [sound pause].	sound _ nil.	imageQueue _ nil.! !!StoryLineMorph methodsFor: 'operating' stamp: 'jm 9/10/2003 11:33'!volume	^ volume! !!StoryLineMorph methodsFor: 'file i/o' stamp: 'jm 9/11/2003 15:55'!readFileNamed: fileName	"Read my date from the file by the given name. Image and sound files must be in the same directory as the given file."	| f dir lines fields cl x y m timeScale |	[f _ FileStream oldFileNamed: fileName] ifError: [^ self].	dir _ FileDirectory forFileName: fileName.	self contents removeAllMorphs.	"recreate morphs in timeline"	lines _ f contentsOfEntireFile findTokens: String crlf.	lines do: [:line |		fields _ line findTokens: String tab.		((fields size >= 4) and: [#('i' 's') includes: fields first]) ifTrue: [			cl _ fields first = 'i' ifTrue: [NarratorImageMorph] ifFalse: [NarratorSoundMorph].			x _ contents left + (fields at: 2) asNumber.			y _ contents top + (fields at: 3) asNumber.			m _ [cl fromFileNamed: (dir fullNameFor: (fields at: 4))] ifError: [nil].			m ifNotNil: [				m position: x@y.				contents acceptDroppingMorph: m event: MorphicEvent new]]].	timeScale _ self buildTimeScale: ((self contentDuration + 60) max: 300).	timeScale position: contents topLeft + (0@5).	self contents addMorph: timeScale.! !!StoryLineMorph methodsFor: 'file i/o' stamp: 'LY 11/20/2003 14:22'!writeFileNamed: fileName	"Store my data on a new file by the given name."	| f morphList |	[f _ FileStream newFileNamed: fileName] ifError: [^ self].	"collect image and sound morphs"	morphList _ contents submorphs select: [:m |		(m isKindOf: NarratorImageMorph) | (m isKindOf: NarratorSoundMorph)].	morphList sort: [:m1 :m2 | m1 left < m2 left].	morphList do: [:m |		(m isKindOf: NarratorImageMorph)			ifTrue: [f nextPut: $i; tab]			ifFalse: [f nextPut: $s; tab].		f nextPutAll: (m left - contents left) printString; tab.		f nextPutAll: (m top - contents top) printString; tab.		f nextPutAll: (FileDirectory localNameFor: m fileName); cr].	f close.	^f! !!StoryLineMorph methodsFor: 'private' stamp: 'jm 9/12/2003 16:05'!buildSound	"Create a composite sound that combines all the sounds in me. Set their volumes."	"Details: Build a MixedSound consisting of (a) a rest of the full duration of the timeline plus (b) a SequentialSound for each sound object in the story prefixed by a rest of the appropriate duration."	| mixer restDur |	mixer _ MixedSound new.	mixer add: (RestSound dur: self contentDuration).	contents submorphs do: [:m |		(m isKindOf: NarratorSoundMorph) ifTrue: [			restDur _ (m left - contents left) asFloat / pixelsPerSecond.		mixer add: ((RestSound dur: restDur), m sound copy reset) pan: 0.5 volume: volume]].	^ mixer! !!StoryLineMorph methodsFor: 'private' stamp: 'jm 9/11/2003 16:12'!buildTimeScale: seconds	"Build a time scale morph for the specified number of seconds."	| scale m s |	scale _ RectangleMorph new.	scale borderWidth: 1.	scale color: (Color white).	scale extent: (seconds * pixelsPerSecond + 10)@20.	1 to: seconds do: [:i |		m _ RectangleMorph new.		m position: (i * pixelsPerSecond)@0.		(i \\ 1) = 0			ifTrue: [ 				m extent: 1@5. 				scale addMorph: m.				s _ StringMorph contents: (i asString).				s center: (m center x + 1)@(m bottom + 6).				scale addMorph: s]			ifFalse: [ 				m extent: 1@2. 				scale addMorph: m]].	scale isSticky: true.	^ scale! !!StoryLineMorph methodsFor: 'private' stamp: 'jm 9/10/2003 16:27'!contentDuration	"Answer the content duration in seconds."	| activeMorphs lastX |	activeMorphs _ contents submorphs select: [:m |		(m isKindOf: NarratorImageMorph) or: [m isKindOf: NarratorSoundMorph]].	lastX _ activeMorphs inject: 0 into: [:t :m | t max: m right].	^ (lastX - contents left) asFloat / pixelsPerSecond! !!StoryLineMorph methodsFor: 'private' stamp: 'jm 9/10/2003 12:20'!moveCursor: aNumber	"Move the cursorMorph to xValue and scroll my contents if necessary."	| newX leftEdge |	newX _ aNumber truncated max: 0.	cursorMorph left = (contents left + newX) ifTrue: [^ self].  "no change"	cursorMorph comeToFront.	cursorMorph left: contents left + newX.  "move cursor"	leftEdge _ self hScrollPixels.  "leftmost coordinate currently displayed on screen"	((newX >= leftEdge) & (newX <= (leftEdge + self visibleExtent x))) ifFalse: [		self hScrollPixels: newX].  "scroll to keep cursor in view"! !I am an abstract class that represents an accessor for a sequence of objects. This sequence is referred to as my "contents".!!Stream methodsFor: 'accessing' stamp: 'sma 4/22/2000 17:07'!flush	"Do nothing by default"! !!Stream methodsFor: 'accessing' stamp: 'ls 9/12/1998 20:55'!upToEnd	"answer the remaining elements in the string"	| elements |	elements _ OrderedCollection new.	[ self atEnd ] whileFalse: [ 		elements add: self next ].	^elements! !!Stream methodsFor: 'printing' stamp: 'sma 6/1/2000 09:56'!print: anObject	"Have anObject print itself on the receiver."	anObject printOn: self! !I implement a streaming player for MPEG or MP3 files.Example of use:	(StreamingMP3Sound onFileNamed: 'song.mp3') play.!!StreamingMP3Sound methodsFor: 'initialization' stamp: 'jm 9/29/2003 16:53'!initMPEGFile: anMPEGFile streamIndex: anInteger	"Initialize for playing the given stream of the given MPEG or MP3 file."	volume _ 0.3.	leftRight _ 0.5.	repeat _ false.	mpegFile _ anMPEGFile.	mpegStreamIndex _ anInteger.	totalSamples _ mpegFile audioSamples: mpegStreamIndex.	self reset.! !!StreamingMP3Sound methodsFor: 'file ops' stamp: 'jm 11/25/2001 14:11'!closeFile	"Close the MP3 or MPEG file."	self pause.	mpegFile ifNil: [^ self].	mpegFile closeFile.	mpegFile _ nil.	mixer _ nil.! !!StreamingMP3Sound methodsFor: 'file ops' stamp: 'jm 11/16/2001 15:58'!mpegFileIsOpen	"Answer true if I have an open, valid MPEG file handle. If the handle is not valid, try to re-open the file."	mpegFile ifNil: [^ false].	mpegFile fileHandle ifNil: [		"try to reopen the file, which may have been saved in a snapshot"		mpegFile openFile: mpegFile fileName.		mpegFile fileHandle ifNil: [mpegFile _ nil]].	^ mpegFile notNil! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 11/16/2001 17:16'!duration	"Answer the duration of this sound in seconds."	^ totalSamples asFloat / streamSamplingRate! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 12/28/2002 09:42'!fileName	^ mpegFile fileName! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 6/3/2001 15:43'!repeat	"Answer the repeat flag."	repeat ifNil: [repeat _ false].	^ repeat! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 6/3/2001 18:39'!repeat: aBoolean	"Set the repeat flag. If true, this sound will loop back to the beginning when it gets to the end."	repeat _ aBoolean.! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 9/29/2003 17:31'!setPan: newPan volume: newVol for: channel	"Set the left-right balance and volume for the given channel."	| leftVol rightVol |	leftRight _ (newPan asFloat max: 0.0) min: 1.0.	volume _  (newVol asFloat max: 0.0) min: 1.0.	mixer ifNotNil: [		mixer sounds size = 1			ifTrue: [  "mono"				mixer setPan: leftRight volume: volume for: channel]			ifFalse: [  "stereo"				leftVol _ volume * ((2.0 * (1.0 - leftRight)) min: 1.0).				rightVol _ volume * ((2.0 * leftRight) min: 1.0).				mixer setPan: 0 volume: leftVol for: 1.				mixer setPan: 1 volume: rightVol for: 2]].! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 11/16/2001 16:18'!soundPosition	"Answer the relative position of sound playback as a number between 0.0 and 1.0."	self mpegFileIsOpen ifFalse: [^ 0.0].	mpegFile hasAudio ifFalse: [^ 0.0].	^ (mpegFile audioGetSample: 0) asFloat / totalSamples! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 11/16/2001 16:19'!soundPosition: fraction	"Jump to the position the given fraction through the sound file. The argument is a number between 0.0 and 1.0."	| sampleIndex |	self mpegFileIsOpen ifFalse: [^ self].	mpegFile hasAudio ifTrue: [		sampleIndex _ ((totalSamples * fraction) truncated max: 0) min: totalSamples.		mpegFile audioSetSample: 0 stream: 0.  "work around for library bug: first seek to zero"		mpegFile audioSetSample: sampleIndex stream: 0].! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 11/16/2001 15:34'!streamSamplingRate	"Answer the sampling rate of the MP3 stream."	^ streamSamplingRate! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 9/26/2000 07:49'!volume	"Answer my volume."	^ volume! !!StreamingMP3Sound methodsFor: 'accessing' stamp: 'jm 5/30/2001 16:53'!volume: aNumber	"Set my volume to the given number between 0.0 and 1.0."	volume _ aNumber.	self createMixer.! !!StreamingMP3Sound methodsFor: 'playing' stamp: 'jm 11/27/2001 10:16'!millisecondsSinceStart	"Answer the number of milliseconds since this sound started playing."	| i mSecs |	mpegFile ifNil: [^ 0].	mpegFile fileHandle ifNil: [^ 0].  "mpeg file not open"	i _ mpegFile audioGetSample: mpegStreamIndex.	i < 0 ifTrue: [^ 0].  "movie file has no audio"	mSecs _ i * 1000 // streamSamplingRate.	(self isPlaying and: [lastBufferMSecs > 0]) ifTrue: [		"adjust mSecs by the milliseconds since the last buffer"		mutex critical: [			mSecs _ i * 1000 // streamSamplingRate.			mSecs _ mSecs + ((Time millisecondClockValue - lastBufferMSecs) max: 0)]].	^ mSecs + 350 - (2 * SoundPlayer bufferMSecs)! !!StreamingMP3Sound methodsFor: 'playing' stamp: 'jm 11/27/2001 10:09'!playSampleCount: n into: aSoundBuffer startingAt: startIndex	"Mix the next n samples of this sound into the given buffer starting at the given index"	| current |	self repeat ifTrue: [  "loop if necessary"		current _ mpegFile audioGetSample: mpegStreamIndex.		(totalSamples - current) < n ifTrue: [			mpegFile audioSetSample: 0 stream: mpegStreamIndex]].	mutex critical: [		lastBufferMSecs _ Time millisecondClockValue.		self loadBuffersForSampleCount: (n * streamSamplingRate) // SoundPlayer samplingRate.		mixer playSampleCount: n into: aSoundBuffer startingAt: startIndex].! !!StreamingMP3Sound methodsFor: 'playing' stamp: 'jm 11/27/2001 10:06'!reset	super reset.	self createMixer.	mpegFile audioSetSample: 0 stream: mpegStreamIndex.	lastBufferMSecs _ 0.	mutex _ Semaphore forMutualExclusion.! !!StreamingMP3Sound methodsFor: 'playing' stamp: 'jm 11/16/2001 15:59'!samplesRemaining	| samplesPlayed |	mpegFile ifNil: [^ 0].	self repeat ifTrue: [^ 1000000].	samplesPlayed _ mpegFile audioGetSample: mpegStreamIndex.	samplesPlayed > totalSamples ifTrue: [^ 0].	^ totalSamples - samplesPlayed! !!StreamingMP3Sound methodsFor: 'converting' stamp: 'jm 12/13/2001 20:32'!saveAsFileNamed: newFileName compressionType: compressionTypeString	"Store this MP3 sound in a SunAudio file with the given name using the given compression type."	| outFile |	outFile _ (FileStream newFileNamed: newFileName) binary.	self storeSunAudioOn: outFile compressionType: compressionTypeString.	outFile close.! !!StreamingMP3Sound methodsFor: 'converting' stamp: 'jm 11/21/2003 17:39'!storeSunAudioOn: aBinaryStream compressionType: compressionName	"Store myself on the given stream as a monophonic sound compressed with the given type of compression. The sampling rate is reduced to 22050 samples/second if it is higher."	| fmt inBufSize samplesPerFrame codec inBuf compressed outSamplingRate audioWriter doDownSampling samplesRemaining outBuf counts byteCount |	self pause; reset.  "stop playing and return to beginning"	fmt _ SunAudioFileWriter formatCodeForCompressionType: compressionName.	inBufSize _ 64000.	samplesPerFrame _ 1.	codec _ SunAudioFileWriter codecForFormatCode: fmt.	codec ifNotNil: [		samplesPerFrame _ codec samplesPerFrame.		inBufSize _ inBufSize roundUpTo: (2 * samplesPerFrame).		compressed _ ByteArray new:			(inBufSize // samplesPerFrame) * codec bytesPerEncodedFrame].	inBuf _ SoundBuffer newMonoSampleCount: inBufSize.	outSamplingRate _ streamSamplingRate.	doDownSampling _ false.	streamSamplingRate = 44100 ifTrue: [		doDownSampling _ true.		outSamplingRate _ 22050].	"write audio header"	audioWriter _ SunAudioFileWriter onStream: aBinaryStream.	audioWriter writeHeaderSamplingRate: outSamplingRate format: fmt.	"convert and write sound data"	'Storing audio...' displayProgressAt: Sensor cursorPoint		from: 0 to: totalSamples during: [:bar |			samplesRemaining _ totalSamples.			[samplesRemaining > 0] whileTrue: [				bar value: totalSamples - samplesRemaining.				samplesRemaining < inBuf monoSampleCount ifTrue: [					inBuf _ SoundBuffer newMonoSampleCount:						(samplesRemaining roundUpTo: 2 * samplesPerFrame)].				mpegFile audioReadBuffer: inBuf stream: 0 channel: 0.				doDownSampling					ifTrue: [outBuf _ inBuf downSampledLowPassFiltering: true]					ifFalse: [outBuf _ inBuf].				codec					ifNil: [audioWriter appendSamples: outBuf]					ifNotNil: [						counts _ codec							encodeFrames: (outBuf size // samplesPerFrame)							from: outBuf at: 1							into: compressed at: 1.						byteCount _ counts last.						byteCount = compressed size							ifTrue: [audioWriter appendBytes: compressed]							ifFalse: [audioWriter appendBytes: (compressed copyFrom: 1 to: byteCount)]].				samplesRemaining _ samplesRemaining - inBuf monoSampleCount]].	"update audio header"	audioWriter updateHeaderDataSize.! !!StreamingMP3Sound methodsFor: 'private' stamp: 'jm 9/29/2003 16:54'!createMixer	"Create a mixed sound consisting of sampled sounds with one sound buffer's worth of samples. The sound has the same sampling rate and number of channels as the MPEG or MP3 file."	| channels pan snd |	mpegFile ifNil: [^ self error: 'No MPEG or MP3 file'].	channels _ mpegFile audioChannels: mpegStreamIndex.	streamSamplingRate _ mpegFile audioSampleRate: mpegStreamIndex.	mixer _ MixedSound new.	1 to: channels do: [:c |		channels = 1			ifTrue: [pan _ leftRight]			ifFalse: [pan _ (c - 1) asFloat / (channels - 1)].		snd _ SampledSound			samples: (SoundBuffer newMonoSampleCount: 2)  "buffer size will be adjusted dynamically"			samplingRate: streamSamplingRate.		mixer add: snd pan: pan volume: volume].! !!StreamingMP3Sound methodsFor: 'private' stamp: 'jm 12/22/2002 09:55'!loadBuffersForSampleCount: count	"Load the sound buffers for all tracks with the next count samples from the MPEG file sound track. Answer the buffer for the last track."	| snd buf |	1 to: mixer sounds size do: [:i |		snd _ mixer sounds at: i.		buf _ snd samples.		buf monoSampleCount = count ifFalse: [			buf _ SoundBuffer newMonoSampleCount: count.			snd setSamples: buf samplingRate: streamSamplingRate].		i = 1 ifTrue: [  "first channel"				mpegFile					audioReadBuffer: buf					stream: mpegStreamIndex					channel: 0]			ifFalse: [  "all other channels"				mpegFile					audioReReadBuffer: buf					stream: mpegStreamIndex					channel: 0]].	mixer reset.	^ buf! !!StreamingMP3Sound class methodsFor: 'instance creation' stamp: 'jm 11/20/2001 16:35'!onFileNamed: fileName	"Answer an instance of me for playing the sound track of the MPEG or MP3 file with the given name. Answer nil the file is not a valid MPEG or MP3 file."	| mpegFile |	(MPEGFile isFileValidMPEG: fileName) ifFalse: [^ nil].	mpegFile _ MPEGFile openFile: fileName.	^ self new initMPEGFile: mpegFile streamIndex: 0  "assume sound track is in stream 0"! !I implement a streaming player for monophonic Sun (.au) and AIFF (.aif) audio files.Example of use:	(StreamingMonoSound onFileNamed: 'song.aif') play.!!StreamingMonoSound methodsFor: 'initialization' stamp: 'jm 9/29/2003 16:58'!initStream: aStream headerStart: anInteger	"Initialize for streaming from the given stream. The audio file header starts at the given stream position."	stream _ aStream.	volume _ 1.0.	leftRight _ 0.5.	repeat _ false.	headerStart _ anInteger.	self reset.! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 11/16/2001 17:12'!duration	"Answer the duration of this sound in seconds."	^ totalSamples asFloat / streamSamplingRate! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 12/28/2002 09:44'!fileName	^ stream fullName! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 10/18/2001 15:46'!repeat	"Answer the repeat flag."	^ repeat! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 6/3/2001 18:39'!repeat: aBoolean	"Set the repeat flag. If true, this sound will loop back to the beginning when it gets to the end."	repeat _ aBoolean.! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 9/29/2003 16:59'!setPan: newPan volume: newVol for: channel	"Set the left-right balance and volume for the given channel."	leftRight _ newPan.	volume _ newVol.	mixer ifNotNil: [		mixer setPan: newPan volume: newVol for: channel].! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 11/16/2001 17:05'!soundPosition	"Answer the relative position of sound playback as a number between 0.0 and 1.0."	(stream isNil or: [stream closed]) ifTrue: [^ 0.0].	^ self currentSampleIndex asFloat / totalSamples! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 12/14/2001 11:29'!soundPosition: fraction	"Jump to the position the given fraction through the sound file. The argument is a number between 0.0 and 1.0."	| desiredSampleIndex |	(stream isNil or: [stream closed]) ifTrue: [^ self].	desiredSampleIndex _ ((totalSamples * fraction) truncated max: 0) min: totalSamples.	codec		ifNil: [stream position: audioDataStart + (desiredSampleIndex * 2)]		ifNotNil: [self positionCodecTo: desiredSampleIndex].	leftoverSamples _ SoundBuffer new.! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 11/20/2001 16:59'!streamSamplingRate	"Answer the sampling rate of the MP3 stream."	^ streamSamplingRate! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 9/26/2000 07:49'!volume	"Answer my volume."	^ volume! !!StreamingMonoSound methodsFor: 'accessing' stamp: 'jm 5/30/2001 16:53'!volume: aNumber	"Set my volume to the given number between 0.0 and 1.0."	volume _ aNumber.	self createMixer.! !!StreamingMonoSound methodsFor: 'playing' stamp: 'jm 11/27/2001 09:19'!millisecondsSinceStart	"Answer the number of milliseconds of this sound started playing."	| mSecs |	(stream isNil or: [stream closed]) ifTrue: [^ 0].	mSecs _ self currentSampleIndex * 1000 // streamSamplingRate.	(self isPlaying and: [lastBufferMSecs > 0]) ifTrue: [		"adjust mSecs by the milliseconds since the last buffer"		mutex critical: [			mSecs _ self currentSampleIndex * 1000 // streamSamplingRate.			mSecs _ mSecs + ((Time millisecondClockValue - lastBufferMSecs) max: 0)]].	^ mSecs + 350 - (2 * SoundPlayer bufferMSecs)! !!StreamingMonoSound methodsFor: 'playing' stamp: 'jm 11/27/2001 07:58'!playSampleCount: n into: aSoundBuffer startingAt: startIndex	"Mix the next n samples of this sound into the given buffer starting at the given index"	self repeat ifTrue: [  "loop if necessary"		(totalSamples - self currentSampleIndex) < n ifTrue: [self startOver]].	mutex critical: [		lastBufferMSecs _ Time millisecondClockValue.		self loadBuffersForSampleCount: (n * streamSamplingRate) // SoundPlayer samplingRate.		mixer playSampleCount: n into: aSoundBuffer startingAt: startIndex].! !!StreamingMonoSound methodsFor: 'playing' stamp: 'jm 10/21/2001 09:45'!reset	super reset.	self startOver.	self createMixer.! !!StreamingMonoSound methodsFor: 'playing' stamp: 'jm 11/8/2001 09:09'!samplesRemaining	"Answer the number of samples remaining to be played."	| result |	(stream isNil or: [stream closed]) ifTrue: [^ 0].	self repeat ifTrue: [^ 1000000].	result _ (totalSamples - self currentSampleIndex) max: 0.	result <= 0 ifTrue: [self closeFile].	^ result! !!StreamingMonoSound methodsFor: 'other' stamp: 'jm 12/14/2001 11:01'!closeFile	"Close my stream, if it responds to close."	stream ifNotNil: [		(stream respondsTo: #close) ifTrue: [stream close]].	mixer _ nil.	codec _ nil.! !!StreamingMonoSound methodsFor: 'other' stamp: 'jm 11/21/2001 08:05'!extractFrom: startSecs to: endSecs	"Extract a portion of this sound between the given start and end times. The current implementation only works if the sound is uncompressed."	| emptySound first last sampleCount byteStream sndBuf |	codec ifNotNil: [^ self error: 'only works on uncompressed sounds'].	emptySound _ SampledSound samples: SoundBuffer new samplingRate: streamSamplingRate.	first _ (startSecs * streamSamplingRate) truncated max: 0.	last _ ((endSecs * streamSamplingRate) truncated min: totalSamples) - 1.	first >= last ifTrue: [^ emptySound].	codec ifNotNil: [self error: 'extracting from compressed sounds is not supported'].	sampleCount _ last + 1 - first.	stream position: audioDataStart + (2 * first).	byteStream _ ReadStream on: (stream next: 2 * sampleCount).	sndBuf _ SoundBuffer newMonoSampleCount: sampleCount.	1 to: sampleCount do: [:i | sndBuf at: i put: byteStream int16].	^ SampledSound samples: sndBuf samplingRate: streamSamplingRate! !!StreamingMonoSound methodsFor: 'private' stamp: 'jm 10/18/2001 15:51'!createMixer	"Create a mixed sound consisting of sampled sounds with one sound buffer's worth of samples."	| snd |	mixer _ MixedSound new.	snd _ SampledSound		samples: (SoundBuffer newMonoSampleCount: 2)  "buffer size will be adjusted dynamically"		samplingRate: streamSamplingRate.	mixer add: snd pan: 0.5 volume: volume.! !!StreamingMonoSound methodsFor: 'private' stamp: 'jm 11/21/2001 09:05'!currentSampleIndex	"Answer the index of the current sample."	| bytePosition frameIndex |	bytePosition _ stream position - audioDataStart.	codec		ifNil: [^ bytePosition // 2]		ifNotNil: [			frameIndex _ bytePosition // codec bytesPerEncodedFrame.			^ (frameIndex * codec samplesPerFrame) - leftoverSamples monoSampleCount].! !!StreamingMonoSound methodsFor: 'private' stamp: 'jm 11/21/2001 11:37'!loadBuffer: aSoundBuffer compressedSampleCount: sampleCount	"Load the given sound buffer from the compressed sample stream."	"Details: Most codecs decode in multi-sample units called 'frames'. Since the requested sampleCount is typically not an even multiple of the frame size, we need to deal with partial frames. The unused samples from a partial frame are retained until the next call to this method."	| n samplesNeeded frameCount encodedBytes r decodedCount buf j |	"first, use any leftover samples"	n _ self loadFromLeftovers: aSoundBuffer sampleCount: sampleCount.	samplesNeeded _ sampleCount - n.	samplesNeeded <= 0 ifTrue: [^ self].	"decode an integral number of full compression frames"	frameCount _ samplesNeeded // codec samplesPerFrame.	encodedBytes _ stream next: (frameCount * codec bytesPerEncodedFrame).	r _ codec decodeFrames: frameCount from: encodedBytes at: 1 into: aSoundBuffer at: n + 1.	decodedCount _ r last.	decodedCount >= samplesNeeded ifTrue: [^ self].	"decode one last compression frame to finish filling the buffer"	buf _ SoundBuffer newMonoSampleCount: codec samplesPerFrame.	encodedBytes _ stream next: codec bytesPerEncodedFrame.	codec decodeFrames: 1 from: encodedBytes at: 1 into: buf at: 1.	j _ 0.	(n + decodedCount + 1) to: sampleCount do: [:i |		aSoundBuffer at: i put: (buf at: (j _ j + 1))].	"save the leftover samples"	leftoverSamples _ buf copyFrom: (j + 1) to: buf monoSampleCount.! !!StreamingMonoSound methodsFor: 'private' stamp: 'jm 12/3/2003 13:08'!loadBuffer: aSoundBuffer uncompressedSampleCount: sampleCount	"Load the given sound buffer from the uncompressed sample stream."	"read directly into the sample buffer; count is in 32-bit words"	stream next: sampleCount // 2 into: aSoundBuffer startingAt: 1.	Smalltalk isBigEndian ifFalse: [aSoundBuffer reverseEndiannessStereo: false].	"read the final sample if sampleCount is odd:"	sampleCount odd ifTrue: [aSoundBuffer at: sampleCount put: stream int16].! !!StreamingMonoSound methodsFor: 'private' stamp: 'jm 12/22/2002 09:55'!loadBuffersForSampleCount: count	"Load the sound buffers from the stream. Answer the buffer."	| snd buf sampleCount |	snd _ mixer sounds first.	buf _ snd samples.	buf monoSampleCount = count ifFalse: [		buf _ SoundBuffer newMonoSampleCount: count.		snd setSamples: buf samplingRate: streamSamplingRate].	sampleCount _ count min: (totalSamples - self currentSampleIndex).	sampleCount < count ifTrue: [buf primFill: 0].	codec		ifNil: [self loadBuffer: buf uncompressedSampleCount: sampleCount]		ifNotNil: [self loadBuffer: buf compressedSampleCount: sampleCount].	mixer reset.	^ buf! !!StreamingMonoSound methodsFor: 'private' stamp: 'jm 11/21/2001 09:09'!loadFromLeftovers: aSoundBuffer sampleCount: sampleCount	"Load the given sound buffer from the samples leftover from the last frame. Answer the number of samples loaded, which typically is less than sampleCount."	| leftoverCount n |	leftoverCount _ leftoverSamples monoSampleCount.	leftoverCount = 0 ifTrue: [^ 0].	n _ leftoverCount min: sampleCount.	1 to: n do: [:i | aSoundBuffer at: i put: (leftoverSamples at: i)].	n < sampleCount		ifTrue: [leftoverSamples _ SoundBuffer new]		ifFalse: [leftoverSamples _ leftoverSamples copyFrom: n + 1 to: leftoverSamples size].	^ n! !!StreamingMonoSound methodsFor: 'private' stamp: 'jm 12/14/2001 14:57'!positionCodecTo: desiredSampleIndex	"Position to the closest frame before the given sample index when using a codec. If using the ADPCM codec, try to ensure that it is in sync with the compressed sample stream."	| desiredFrameIndex desiredPosition tmpStream tmpCodec byteBuf bufFrames sampleBuf frameCount n startOffset |	(codec isKindOf: ADPCMCodec) ifFalse: [		"stateless codecs (or relatively stateless ones, like GSM: just jump to frame boundary"		desiredFrameIndex _ desiredSampleIndex // codec samplesPerFrame.		stream position: audioDataStart + (desiredFrameIndex * codec bytesPerEncodedFrame).		codec reset.		^ self].	"compute the desired stream position"	desiredFrameIndex _ desiredSampleIndex // codec samplesPerFrame.	desiredPosition _ audioDataStart + (desiredFrameIndex * codec bytesPerEncodedFrame).	"copy stream and codec"	(stream isKindOf: FileStream)		ifTrue: [tmpStream _ (FileStream readOnlyFileNamed: stream name) binary]		ifFalse: [tmpStream _ stream deepCopy].	tmpCodec _ codec copy reset.	"reset the codec and start back about 30 seconds to try to get codec in sync"	startOffset _ ((desiredFrameIndex - 80000) max: 0) * codec bytesPerEncodedFrame.	tmpStream position: audioDataStart + startOffset.	"decode forward to the desired position"	byteBuf _ ByteArray new: (32000 roundTo: codec bytesPerEncodedFrame).	bufFrames _ byteBuf size // codec bytesPerEncodedFrame.	sampleBuf _ SoundBuffer newMonoSampleCount: bufFrames * codec samplesPerFrame.	frameCount _ (desiredPosition - tmpStream position) // codec bytesPerEncodedFrame.	[frameCount > 0] whileTrue: [		n _ bufFrames min: frameCount.		tmpStream next: n * codec bytesPerEncodedFrame into: byteBuf startingAt: 1.		tmpCodec decodeFrames: n from: byteBuf at: 1 into: sampleBuf at: 1.		frameCount _ frameCount - n].	codec _ tmpCodec.	stream position: tmpStream position.	(tmpStream isKindOf: FileStream) ifTrue: [tmpStream close].! !!StreamingMonoSound methodsFor: 'private' stamp: 'jm 11/16/2001 10:23'!readAIFFHeader	"Read an AIFF file header from stream."	| aiffReader |	aiffReader _ AIFFFileReader new.	aiffReader readFromStream: stream mergeIfStereo: false skipDataChunk: true.	aiffReader channelCount = 1 ifFalse: [self error: 'not monophonic'].	aiffReader bitsPerSample = 16 ifFalse: [self error: 'not 16-bit'].	audioDataStart _ headerStart + aiffReader channelDataOffset.	streamSamplingRate _ aiffReader samplingRate.	totalSamples _ aiffReader frameCount min: (stream size - audioDataStart) // 2.	codec _ nil.! !!StreamingMonoSound methodsFor: 'private' stamp: 'jm 11/16/2001 10:32'!readHeader	"Read the sound file header from my stream."	| id |	stream position: headerStart.	id _ (stream next: 4) asString.	stream position: headerStart.	id = '.snd' ifTrue: [^ self readSunAudioHeader].	id = 'FORM' ifTrue: [^ self readAIFFHeader].	self error: 'unrecognized sound file format'.! !!StreamingMonoSound methodsFor: 'private' stamp: 'jm 11/21/2001 13:02'!readSunAudioHeader	"Read a Sun audio file header from my stream."	| id headerBytes dataBytes format channelCount |	id _ (stream next: 4) asString.	headerBytes _ stream uint32.  "header bytes"	dataBytes _ stream uint32.	format _ stream uint32.	streamSamplingRate _ stream uint32.	channelCount _ stream uint32.	id = '.snd' ifFalse: [self error: 'not Sun audio format'].	dataBytes _ dataBytes min: (stream size - headerBytes).	channelCount = 1 ifFalse: [self error: 'not monophonic'].	audioDataStart _ headerStart + headerBytes.	codec _ nil.	format = 1 ifTrue: [  "8-bit u-LAW"		codec _ MuLawCodec new.		totalSamples _ dataBytes.		^ self].	format = 3 ifTrue: [  "16-bit linear"		totalSamples _ dataBytes // 2.		^ self].	format = 23 ifTrue: [  "ADPCM-4 bit (CCITT G.721)"		codec _ ADPCMCodec new			initializeForBitsPerSample: 4 samplesPerFrame: 0.		totalSamples _ (dataBytes // 4) * 8.		^ self].	format = 25 ifTrue: [  "ADPCM-3 bit (CCITT G.723)"		codec _ ADPCMCodec new			initializeForBitsPerSample: 3 samplesPerFrame: 0.		totalSamples _ (dataBytes // 3) * 8.		^ self].	format = 26 ifTrue: [  "ADPCM-5 bit (CCITT G.723)"		codec _ ADPCMCodec new			initializeForBitsPerSample: 5 samplesPerFrame: 0.		totalSamples _ (dataBytes // 5) * 8.		^ self].	format = 610 ifTrue: [  "GSM 06.10 (this format was added by Squeak)"		codec _ GSMCodec new.		totalSamples _ (dataBytes // 33) * 160.		^ self].	self error: 'unsupported Sun audio format ', format printString! !!StreamingMonoSound methodsFor: 'private' stamp: 'jm 11/27/2001 07:36'!startOver	"Jump back to the first sample."	stream reopen; binary.	self readHeader.	stream position: audioDataStart.	leftoverSamples _ SoundBuffer new.	lastBufferMSecs _ 0.	mutex _ Semaphore forMutualExclusion.! !!StreamingMonoSound methodsFor: 'converting' stamp: 'jm 12/13/2001 20:08'!saveAsFileNamed: newFileName compressionType: compressionTypeString	"Store this sound in a new file with the given name using the given compression type. Useful for converting between compression formats."	| outFile |	outFile _ (FileStream newFileNamed: newFileName) binary.	self storeSunAudioOn: outFile compressionType: compressionTypeString.	outFile close.! !!StreamingMonoSound methodsFor: 'converting' stamp: 'jm 11/21/2003 17:40'!storeSunAudioOn: aBinaryStream compressionType: compressionName	"Store myself on the given stream as a monophonic sound compressed with the given type of compression. The sampling rate is reduced to 22050 samples/second if it is higher."	| fmt inBufSize samplesPerFrame outCodec compressed outSamplingRate doDownSampling audioWriter samplesRemaining inBuf outBuf counts byteCount |	self pause; reset.  "stop playing and return to beginning"	fmt _ SunAudioFileWriter formatCodeForCompressionType: compressionName.	inBufSize _ 64000.	samplesPerFrame _ 1.	outCodec _ SunAudioFileWriter codecForFormatCode: fmt.	outCodec ifNotNil: [		samplesPerFrame _ outCodec samplesPerFrame.		inBufSize _ inBufSize roundUpTo: (2 * samplesPerFrame).		compressed _ ByteArray new:			(inBufSize // samplesPerFrame) * outCodec bytesPerEncodedFrame].	outSamplingRate _ streamSamplingRate.	doDownSampling _ false.	streamSamplingRate = 44100 ifTrue: [		doDownSampling _ true.		outSamplingRate _ 22050].	"write audio header"	audioWriter _ SunAudioFileWriter onStream: aBinaryStream.	audioWriter writeHeaderSamplingRate: outSamplingRate format: fmt.	"convert and write sound data"	'Storing audio...' displayProgressAt: Sensor cursorPoint		from: 0 to: totalSamples during: [:bar |			samplesRemaining _ totalSamples.			[samplesRemaining > 0] whileTrue: [				bar value: totalSamples - samplesRemaining.				self loadBuffersForSampleCount: (inBufSize min: samplesRemaining).				inBuf _ mixer sounds first samples.				doDownSampling					ifTrue: [outBuf _ inBuf downSampledLowPassFiltering: true]					ifFalse: [outBuf _ inBuf].				outCodec					ifNil: [audioWriter appendSamples: outBuf]					ifNotNil: [						counts _ outCodec							encodeFrames: (outBuf size // samplesPerFrame)							from: outBuf at: 1							into: compressed at: 1.						byteCount _ counts last.						byteCount = compressed size							ifTrue: [audioWriter appendBytes: compressed]							ifFalse: [audioWriter appendBytes: (compressed copyFrom: 1 to: byteCount)]].				samplesRemaining _ samplesRemaining - inBuf monoSampleCount]].	"update audio header"	audioWriter updateHeaderDataSize.! !!StreamingMonoSound class methodsFor: 'instance creation' stamp: 'jm 11/16/2001 16:57'!onFileNamed: fileName	"Answer an instance of me for playing the file with the given name."	| f |	f _ FileDirectory default readOnlyFileNamed: fileName.	f ifNil: [^ self error: 'could not open ', fileName].	^ self new initStream: f headerStart: 0! !!StreamingMonoSound class methodsFor: 'instance creation' stamp: 'jm 11/16/2001 10:25'!onFileNamed: fileName headerStart: anInteger	"Answer an instance of me for playing audio data starting at the given position in the file with the given name."	| f |	f _ FileDirectory default readOnlyFileNamed: fileName.	f ifNil: [^ self error: 'could not open ', fileName].	^ self new initStream: f headerStart: anInteger! !I represent a compact encoding of a set of Forms corresponding to characters in the ASCII character set. All the forms are placed side by side in a large form whose height is the font height, and whose width is the sum of all the character widths. The xTable variable gives the left-x coordinates of the subforms corresponding to the glyphs. Characters are mapped to glyphs by using the characterToGyphMap.Subclasses can have non-trivial mapping rules as well as different representations for glyphs sizes (e.g., not using an xTable). If so, these classes should return nil when queried for xTable and/or the characterToGlyphMap. This will cause the CharacterScanner primitive to fail and query the font for the width of a character (so that a more programatical approach can be implemented).For display, fonts need to implement two messages:	#installOn: aDisplayContext foregroundColor: foregroundColor backgroundColor: backgroundColorThis method installs the receiver (a font) on the given DisplayContext (which may be an instance of BitBlt or Canvas (or any of it's subclasses). The font should take the appropriate action to initialize the display context so that further display operations can be optimized.	#displayString: aString on: aDisplayContext from: startIndex to: stopIndex at: aPoint kern: kernDeltaThis method is called for each subsequent run of characters in aString which is to be displayed with the (previously installed) settings.!!StrikeFont methodsFor: 'accessing' stamp: 'jm 5/12/2003 16:36'!characterToGlyphMap	"Return the character to glyph mapping table. If the table is not provided the character scanner will query the font directly for the width of each individual character."	^ characterToGlyphMap ifNil: [		characterToGlyphMap _ self createCharacterToGlyphMap].! !!StrikeFont methodsFor: 'accessing' stamp: 'jm 5/12/2003 17:39'!characterToGlyphMap: anArray	characterToGlyphMap _ anArray.! !!StrikeFont methodsFor: 'accessing' stamp: 'jm 5/12/2003 17:57'!familyName	^ self name withoutTrailingDigits! !!StrikeFont methodsFor: 'accessing' stamp: 'sw 1/18/2000 20:54'!pointSize	^ pointSize! !!StrikeFont methodsFor: 'accessing' stamp: 'jm 6/9/2003 22:19'!textStyle	"Answer the first TextStyle that contains me."	| aDict |	aDict _ TextConstants select: [:thang | thang isKindOf: TextStyle].	aDict removeKey: #DefaultTextStyle.	^ aDict detect: [:aStyle | aStyle fontArray includes: self] ifNone: [nil]! !!StrikeFont methodsFor: 'accessing' stamp: 'di 3/27/2000 14:49'!widthOf: aCharacter 	"Answer the width of the argument as a character in the receiver."	| ascii |	ascii _ aCharacter asciiValue.	(ascii between: minAscii and: maxAscii) ifFalse: [ascii _ maxAscii + 1].	^ (xTable at: ascii + 2) - (xTable at: ascii + 1)! !!StrikeFont methodsFor: 'displaying' stamp: 'ar 5/19/2000 15:09'!displayString: aString on: aBitBlt from: startIndex to: stopIndex at: aPoint kern: kernDelta	"Draw the given string from startIndex to stopIndex 	at aPoint on the (already prepared) BitBlt."	aBitBlt displayString: aString 			from: startIndex 			to: stopIndex 			at: aPoint 			strikeFont: self			kern: kernDelta.! !!StrikeFont methodsFor: 'displaying' stamp: 'jm 5/12/2003 16:34'!installOn: aDisplayContext foregroundColor: foregroundColor backgroundColor: backgroundColor	"Install the receiver on the given display context for further drawing operations."	^ aDisplayContext 		installStrikeFont: self		foregroundColor: foregroundColor 		backgroundColor: backgroundColor! !!StrikeFont methodsFor: 'emphasis' stamp: 'jm 5/29/2003 18:04'!bonk: glyphForm with: bonkForm	"Bonking means to run through the glyphs clearing out black pixels	between characters to prevent them from straying into an adjacent	character as a result of, eg, bolding or italicizing"	"Uses the bonkForm to erase at every character boundary in glyphs."	| bb offset |	offset _ bonkForm offset x.	bb _ BitBlt toForm: glyphForm.	bb sourceForm: bonkForm; sourceRect: bonkForm boundingBox;		combinationRule: Form erase; destY: 0.	1 to: xTable size-1 do: [:i | bb destX: (xTable at: i) + offset; copyBits].! !!StrikeFont methodsFor: 'emphasis' stamp: 'sma 12/30/1999 15:02'!reset	"Reset the cache of derivative emphasized fonts"	| style font |	derivativeFonts _ Array new: 32.	#('B' 'I' 'BI') doWithIndex:		[:tag :index | 		(style _ TextStyle named: self familyName) ifNotNil:			[(font _ style fontArray				detect: [:each | each name = (self name , tag)]				ifNone: [nil]) ifNotNil: [derivativeFonts at: index put: font]]]! !!StrikeFont methodsFor: 'file in/out' stamp: 'jm 1/1/2004 19:01'!readFromOldStrikeFile: fileName	"Build an instance from the old ST-80 strike font file name. The '.strike' extension is optional."	"Note: this is an old format; use strike2 format instead."	| f rasterWidth |	f _ (FileStream readOnlyFileNamed: fileName) binary.	name _ fileName copyUpTo: $..	minAscii		_		f uint16.	maxAscii		_		f uint16.	maxWidth		_		f uint16.	"strikeLength	_"		f uint16.	ascent			_		f uint16.	descent			_		f uint16.	"xOffset			_"		f uint16. 		rasterWidth		_		f uint16 * 16.		emphasis		_		0.	glyphs			_		Form extent: rasterWidth @ self height.	f next: glyphs bits size into: glyphs bits startingAt: 1.	characterToGlyphMap _ nil.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	minAscii + 1 to: maxAscii + 3 do: [:i | xTable at: i put: f uint16].	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	f close.! !!StrikeFont methodsFor: 'file in/out' stamp: 'jm 5/23/2003 11:06'!readFromStrike2: fileName	"Build an instance from the strike font stored in strike2 format."	"StrikeFont new readFromStrike2: 'Palatino14.sf2'"	| file |	('*.sf2' match: fileName) ifFalse: [self halt.  "likely incompatible"].	name _ fileName copyUpTo: $. .  "get family name"	file _ (FileStream readOnlyFileNamed: fileName) binary.	self readFromStrike2Stream: file.	file close.! !!StrikeFont methodsFor: 'file in/out' stamp: 'jm 1/1/2004 18:52'!readFromStrike2Stream: file 	"Build an instance from the supplied binary stream on data in strike2 format"	| fType |	fType _ file int32.	fType = 2 ifFalse: [file close. self error: 'not strike2 format'].	minAscii _ file int32.	maxAscii _ file int32.	maxWidth _ file int32.	ascent _ file int32.	descent _ file int32.	pointSize _ file int32.	emphasis _ file int32.	xTable _ (Array new: maxAscii + 3) atAllPut: 0.	(minAscii + 1 to: maxAscii + 3) do:		[:index | xTable at: index put: file int32].	glyphs _ Form new readFrom: file.	"Set up space character"	((xTable at: (Space asciiValue + 2))  = 0 or:			[(xTable at: (Space asciiValue + 2)) = (xTable at: (Space asciiValue + 1))])		ifTrue:	[(Space asciiValue + 2) to: xTable size do:					[:index | xTable at: index put: ((xTable at: index) + DefaultSpace)]].	characterToGlyphMap _ nil.! !!StrikeFont methodsFor: 'file in/out' stamp: 'jm 1/1/2004 18:54'!writeAsStrike2On: aStream	"Write me onto the given binary stream in strike2 format."	aStream int32: 2.	aStream int32: minAscii.	aStream int32: maxAscii.	aStream int32: maxWidth.	aStream int32: ascent.	aStream int32: descent.	aStream int32: pointSize.	aStream int32: emphasis.	(minAscii + 1 to: maxAscii + 3) do: [:i | aStream int32: (xTable at: i)].	glyphs writeOn: aStream.! !!StrikeFont methodsFor: 'file in/out' stamp: 'jm 5/12/2003 17:49'!writeAsStrike2named: fileName	"Write me onto a file in strike2 format. By convention, the file name should be of the form: <family name><pointSize>.sf2"	| file |	file _ (FileStream newFileNamed: fileName) binary.	self writeAsStrike2On: file.	file close.! !!StrikeFont methodsFor: 'utilities' stamp: 'di 3/27/2000 14:25'!characterFormAt: character 	"Answer a Form copied out of the glyphs for the argument, character."	| ascii leftX rightX |	ascii _ character asciiValue.	(ascii between: minAscii and: maxAscii) ifFalse: [ascii _ maxAscii + 1].	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	^ glyphs copy: (leftX @ 0 corner: rightX @ self height)! !!StrikeFont methodsFor: 'utilities' stamp: 'di 3/27/2000 16:15'!characterFormAt: character put: characterForm	"Copy characterForm over the glyph for the argument, character."	| ascii leftX rightX widthDif newGlyphs |	ascii _ character asciiValue.	ascii < minAscii ifTrue: [^ self error: 'Cant store characters below min ascii'].	ascii > maxAscii ifTrue:		[(self confirm:'This font does not accomodate ascii values higher than ' , maxAscii printString , '.Do you wish to extend it permanently to handle values up to ' , ascii printString)			ifTrue: [self extendMaxAsciiTo: ascii]			ifFalse: [^ self error: 'No change made']].	leftX _ xTable at: ascii + 1.	rightX _ xTable at: ascii + 2.	widthDif _ characterForm width - (rightX - leftX).	widthDif ~= 0 ifTrue:		["Make new glyphs with more or less space for this char"		newGlyphs _ Form extent: (glyphs width + widthDif) @ glyphs height.		newGlyphs copy: (0@0 corner: leftX@glyphs height)			from: 0@0 in: glyphs rule: Form over.		newGlyphs copy: ((rightX+widthDif)@0 corner: newGlyphs width@glyphs height)			from: rightX@0 in: glyphs rule: Form over.		glyphs _ newGlyphs.		"adjust further entries on xTable"		ascii+2 to: xTable size			do: [:i | xTable at: i put: (xTable at: i) + widthDif]].	glyphs copy: (leftX @ 0 extent: characterForm extent)		from: 0@0 in: characterForm rule: Form over"| f |  f _ TextStyle defaultFont.f characterFormAt: $  put: (Form extent: (f widthOf: $ )+10@f height)"! !!StrikeFont methodsFor: 'utilities' stamp: 'sma 3/11/2000 11:28'!edit: character		"(TextStyle default fontAt: 1) edit: $_"	"Open a Bit Editor on the given character.  Note that you must do an accept	(in the option menu of the bit editor) if you want this work.	Accepted edits will not take effect in the font until you leave or close the bit editor.	Also note that unaccepted edits will be lost when you leave or close."	| charForm editRect scaleFactor bitEditor savedForm r |	charForm _ self characterFormAt: character.	editRect _ BitEditor locateMagnifiedView: charForm	                                        scale: (scaleFactor _ 8@8).	bitEditor _ BitEditor bitEdit: charForm at: editRect topLeft			scale: scaleFactor remoteView: nil.	savedForm _ Form fromDisplay: (r _ bitEditor displayBox expandBy: (0@23 corner: 0@0)).	bitEditor controller startUp.	bitEditor release.	savedForm displayOn: Display at: r topLeft.	self characterFormAt: character put: charForm! !!StrikeFont methodsFor: 'utilities' stamp: 'di 4/28/2000 16:10'!fixOneWideChars 	"This fixes all 1-wide characters to be 2 wide with blank on the right	so as not to cause artifacts in neighboring characters in bold or italic."	| twoWide |	minAscii to: maxAscii do:		[:i | (self widthOf: (Character value: i)) = 1 ifTrue:			[twoWide _ Form extent: 2@glyphs height.			(self characterFormAt: (Character value: i)) displayOn: twoWide at: 0@0.			self characterFormAt: (Character value: i) put: twoWide]]."StrikeFont allInstancesDo: [:f | f fixOneWideChars].StrikeFont shutDown.  'Flush synthetic fonts'."! !!StrikeFont methodsFor: 'utilities' stamp: 'sma 2/10/2000 22:56'!fontDisplay	"TextStyle default defaultFont fontDisplay."	Display restoreAfter:		[(Form extent: 440@400) displayAt: 90@90.		 0 to: 15 do:			[:i |			i hex displayAt: 100 @ (20 * i + 100).			0 to: 15 do:				[:j |				((16*i+j) between: 1 and: (self xTable size - 2)) ifTrue:					[(self characterFormAt: (16 * i + j) asCharacter)						displayAt: (20 * j + 150) @ (20 * i + 100)]]].			'Click to continue...' asDisplayText displayAt: 100@450]! !!StrikeFont methodsFor: 'utilities' stamp: 'jm 5/12/2003 17:48'!widthOfString: aString	"Answer the width of the given string in this font."	"TextStyle default defaultFont widthOfString: 'hello!!'"	^ self composeWord: (1 to: aString size) in: aString beginningAt: 0! !!StrikeFont methodsFor: 'printing' stamp: 'jm 5/12/2003 17:56'!printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self name;		space;		print: self height;		nextPut: $).! !!StrikeFont methodsFor: 'private' stamp: 'jm 5/29/2003 18:04'!characters: anInterval in: sourceString displayAt: aPoint 	clippedBy: clippingRectangle rule: ruleInteger fillColor: aForm 	"Simple, slow, primitive method for displaying a line of characters.	No wrap-around is provided."	| ascii destPoint bb leftX rightX sourceRect |	destPoint _ aPoint.	bb _ BitBlt toForm: Display.	anInterval do: 		[:i | 		ascii _ (sourceString at: i) asciiValue.		(ascii < minAscii or: [ascii > maxAscii])			ifTrue: [ascii _ maxAscii].		leftX _ xTable at: ascii + 1.		rightX _ xTable at: ascii + 2.		sourceRect _ leftX@0 extent: (rightX-leftX) @ self height.		bb copyFrom: sourceRect in: glyphs to: destPoint.		destPoint _ destPoint + ((rightX-leftX)@0)].	^ destPoint! !!StrikeFont methodsFor: 'private' stamp: 'jm 5/12/2003 16:40'!composeWord: aTextLineInterval in: aString beginningAt: startX 	"Non-primitive composition of a word--add the widths of all the characters in the given interval to startX and answer the total. Similar to the scanning primitive, but does not process any stop conditions."	| result |	result _ startX.	aTextLineInterval do: [:i | 		result _ result + (self widthOf: (aString at: i))].	^ result! !!StrikeFont methodsFor: 'private' stamp: 'ar 5/18/2000 18:13'!createCharacterToGlyphMap	"Private. Create the character to glyph mapping for a font that didn't have any before. This is basically equivalent to what the former setStopCondition did, only based on indexes."	| map |	map _ Array new: 256.	0 to: minAscii - 1 do:[:i| map at: i + 1 put: maxAscii + 1].	minAscii to: maxAscii do:[:i| map at: i + 1 put: i].	maxAscii + 1 to: 255 do:[:i| map at: i + 1 put: maxAscii + 1].	^map! !!StrikeFont methodsFor: 'private' stamp: 'ar 5/23/2000 12:48'!extendMaxAsciiTo: newMax	"Extend the range of this font so that it can display glyphs up to newMax."	(newMax+3) <= xTable size ifTrue: [^ self].  "No need to extend."	xTable size = (maxAscii+3) ifFalse:		[^ self error: 'This font is not well-formed.'].	"Insert a bunch of zero-width characters..."	xTable _ (xTable copyFrom: 1 to: maxAscii+2) ,			((maxAscii+1 to: newMax) collect: [:i | xTable at: maxAscii+2]) ,			{ xTable at: maxAscii+3 }.	maxAscii _ newMax.	self fillZeroWidthSlots.	characterToGlyphMap _ nil.! !!StrikeFont methodsFor: 'private' stamp: 'jm 5/24/2003 16:29'!fillZeroWidthSlots	"Note: this is slow because it copies the font once for every replacement."	| nullGlyph |	nullGlyph _ (Form extent: 1@glyphs height) fillColor: Color gray.	"Fill the empty slots with narrow box characters."	minAscii to: maxAscii do:		[:i | (self widthOf: (Character value: i)) = 0 ifTrue:			[self characterFormAt: (Character value: i) put: nullGlyph]].! !!StrikeFont class methodsFor: 'instance creation' stamp: 'tk 1/28/1999 11:31'!familyName: aName size: aSize emphasized: emphasisCode	"Create the font with this emphasis"	^ (self familyName: aName size: aSize) emphasized: emphasisCode! !!StrikeFont class methodsFor: 'instance creation' stamp: 'bolot 11/2/1999 02:53'!passwordFontSize: aSize	| aFont newXTable newGlyphs |	aFont _ (StrikeFont familyName: #NewYork10 size: aSize) copy.	newXTable _ aFont xTable copy.	newGlyphs _ aFont glyphs copy.	aFont instVarNamed: 'xTable' put: newXTable.	aFont instVarNamed: 'glyphs' put: newGlyphs.	aFont minAscii to: aFont maxAscii do: [:ascii |		aFont characterFormAt: ascii asCharacter put: (aFont characterFormAt: $*)].	^aFont! !!StrikeFont class methodsFor: 'examples' stamp: 'jm 5/12/2003 17:44'!example	"Displays a line of text on the display screen at the location of the cursor."	"StrikeFont example"	TextStyle default defaultFont		displayLine: 'A line of text in the default font.'		at: 10@10! !!StrikeFont class methodsFor: 'derivative font caching' stamp: 'jm 1/1/2004 11:14'!shutDown	"Release all synthetically derived versions of base fonts to save space in snapshots. They can be derived again when they are needed."	"StrikeFont shutDown"	self allSubInstancesDo: [:sf | sf reset].! !!StrikeFont class methodsFor: 'accessing' stamp: 'jm 6/15/2003 23:31'!familyName: aName size: aSize	"Answer a font (or the default font if the name is unknown) in the specified size."	"StrikeFont familyName: 'ComicBold' size: 12"	| fonts fStyle |	fonts _ StrikeFont allInstances select: [:f | f name = aName].	fStyle _ fonts size = 0		ifTrue: [TextStyle default]		ifFalse: [TextStyle fontArray: fonts].	^ fStyle fontOfSize: aSize! !!StrikeFont class methodsFor: 'accessing' stamp: 'jm 6/15/2003 23:28'!familyNames	"StrikeFont familyNames"	^ (TextConstants select: [:each | each isKindOf: TextStyle]) keys asSortedCollection! !!StrikeFont class methodsFor: 'accessing' stamp: 'jm 6/9/2003 21:46'!sizesForFamilyName: fontName	"Answer a collection of sizes for the font with the given name. If there are no fonts of the given name answer an empty collection."	"StrikeFont sizesForFamilyName: 'NewYork'"	^ ((TextStyle named: fontName asSymbol) ifNil: [^ #()])		fontArray collect: [:f | f height]! !!String methodsFor: 'accessing' stamp: 'wod 6/16/1998 15:24'!at: index put: aCharacter 	"Primitive. Store the Character in the field of the receiver indicated by	the index. Fail if the index is not an Integer or is out of bounds, or if	the argument is not a Character. Essential. See Object documentation	whatIsAPrimitive."	<primitive: 64>	(aCharacter isKindOf: Character)		ifTrue: [				index isInteger				ifTrue: [self errorSubscriptBounds: index]				ifFalse: [self errorNonIntegerIndex]]		ifFalse: [self error: 'Strings only store Characters']! !!String methodsFor: 'accessing' stamp: 'ar 12/27/1999 13:44'!byteAt: index	<primitive: 60>	^(self at: index) asciiValue! !!String methodsFor: 'accessing' stamp: 'ar 12/27/1999 13:44'!byteAt: index put: value	<primitive: 61>	self at: index put: value asCharacter.	^value! !!String methodsFor: 'accessing' stamp: 'ls 3/19/2000 16:43'!findCloseParenthesisFor: startIndex	"assume (self at: startIndex) is $(.  Find the matching $), allowing parentheses to nest."	" '(1+(2-3))-3.14159' findCloseParenthesisFor: 1 "	" '(1+(2-3))-3.14159' findCloseParenthesisFor: 4 "	| pos nestLevel |	pos := startIndex+1.	nestLevel := 1.	[ pos <= self size ] whileTrue: [		(self at: pos) = $( ifTrue: [ nestLevel := nestLevel + 1 ].		(self at: pos) = $) ifTrue: [ nestLevel := nestLevel - 1 ].		nestLevel = 0 ifTrue: [ ^pos ].		pos := pos + 1.	].	^self size + 1! !!String methodsFor: 'accessing' stamp: 'ar 4/11/1999 22:15'!findString: subString	"Answer the index of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0."	^self findString: subString startingAt: 1.! !!String methodsFor: 'accessing' stamp: 'di 11/15/1998 16:43'!findString: subString startingAt: start 	"Answer the index of subString within the receiver, starting at start. If 	the receiver does not contain subString, answer 0."	^ self findSubstring: subString in: self startingAt: start matchTable: CaseSensitiveOrder! !!String methodsFor: 'accessing' stamp: 'di 11/15/1998 16:45'!findString: key startingAt: start caseSensitive: caseSensitive	"Answer the index in this String at which the substring key first occurs, at or beyond start.  The match can be case-sensitive or not.  If no match is found, zero will be returned."	caseSensitive	ifTrue: [^ self findSubstring: key in: self startingAt: start matchTable: CaseSensitiveOrder]	ifFalse: [^ self findSubstring: key in: self startingAt: start matchTable: CaseInsensitiveOrder]! !!String methodsFor: 'accessing' stamp: 'di 11/15/1998 16:53'!includesSubstring: aString caseSensitive: caseSensitive		^ (self findString: aString startingAt: 1 caseSensitive: caseSensitive) > 0! !!String methodsFor: 'accessing' stamp: 'di 9/1/1999 18:28'!indexOf: aCharacter	(aCharacter class == Character) ifFalse: [^ 0].	^ String indexOfAscii: aCharacter asciiValue inString: self startingAt: 1! !!String methodsFor: 'accessing' stamp: 'di 9/1/1999 18:28'!indexOf: aCharacter  startingAt: start	(aCharacter class == Character) ifFalse: [^ 0].	^ String indexOfAscii: aCharacter asciiValue inString: self startingAt: start! !!String methodsFor: 'accessing' stamp: 'di 9/1/1999 18:28'!indexOf: aCharacter  startingAt: start  ifAbsent: aBlock	| ans |	(aCharacter class == Character) ifFalse: [ ^ aBlock value ].	ans _ String indexOfAscii: aCharacter asciiValue inString: self  startingAt: start.	ans = 0		ifTrue: [ ^ aBlock value ]		ifFalse: [ ^ ans ]! !!String methodsFor: 'accessing' stamp: 'ls 8/20/1998 05:19'!indexOfAnyOf: aCharacterSet  ifAbsent: aBlock	"returns the index of the first character in the given set.  Returns the evaluation of aBlock if none are found"	^self indexOfAnyOf: aCharacterSet  startingAt: 1  ifAbsent: aBlock! !!String methodsFor: 'accessing' stamp: 'ls 8/20/1998 05:19'!indexOfAnyOf: aCharacterSet  startingAt: start	"returns the index of the first character in the given set, starting from start.  Returns 0 if none are found"	^self indexOfAnyOf: aCharacterSet  startingAt: start  ifAbsent: [ 0 ]! !!String methodsFor: 'accessing' stamp: 'ls 8/18/1998 00:27'!indexOfAnyOf: aCharacterSet  startingAt: start ifAbsent: aBlock	"returns the index of the first character in the given set, starting from start"	| ans |	ans _ String findFirstInString: self  inSet: aCharacterSet byteArrayMap startingAt: start.	ans = 0 		ifTrue: [ ^aBlock value ]		ifFalse: [ ^ans ]! !!String methodsFor: 'accessing' stamp: 'di 11/15/1998 17:02'!indexOfSubCollection: sub startingAt: start ifAbsent: exceptionBlock	| index |	index _ self findSubstring: sub in: self startingAt: start matchTable: CaseSensitiveOrder.	index = 0 ifTrue: [^ exceptionBlock value].	^ index! !!String methodsFor: 'accessing' stamp: 'jm 5/24/2003 13:35'!lines	"Answer a collection of lines for this string. Lines are terminated by a CR or LF character or possibly both. The termination character(s) are not included in the line."	| cr lf sz result start i ch end |	cr _ Character cr.	lf _ Character lf.	sz _ self size.	result _ OrderedCollection new: 100.	start _ i _ 1.	[true] whileTrue: [		[ch _ self at: i.		 i < sz and: [(ch ~~ cr) & (ch ~~ lf)]] whileTrue: [			i _ i + 1].  "scan for line end"		end _ (ch == cr) | (ch == lf) ifTrue: [i - 1] ifFalse: [i].		result addLast: (self copyFrom: start to: end).		(i _ i + 1) <= sz ifTrue: [			(ch = cr and: [(self at: i) = lf]) ifTrue: [i _ i + 1].  "CR-LF"			(ch = lf and: [(self at: i) = cr]) ifTrue: [i _ i + 1]].  "LF-CR"		i > sz ifTrue: [^ result asArray].		start _ i].! !!String methodsFor: 'accessing' stamp: 'BJP 6/12/2000 18:53'!skipAnySubStr: delimiters startingAt: start 	"Answer the index of the last character within the receiver, starting at start, that does NOT match one of the delimiters. delimiters is a Array of substrings (Characters also allowed).  If the receiver is all delimiters, answer size + 1."	| any this ind ii |	ii _ start-1.	[(ii _ ii + 1) <= self size] whileTrue: [ "look for char that does not match"		any _ false.		delimiters do: [:delim |			delim class == Character 				ifTrue: [(self at: ii) == delim ifTrue: [any _ true]]				ifFalse: ["a substring"					delim size > (self size - ii + 1) ifFalse: "Here's where the one-off error was."						[ind _ 0.						this _ true.						delim do: [:dd | 							dd == (self at: ii+ind) ifFalse: [this _ false].							ind _ ind + 1].						this ifTrue: [ii _ ii + delim size - 1.  any _ true]]							ifTrue: [any _ false] "if the delim is too big, it can't match"]].		any ifFalse: [^ ii]].	^ self size + 1! !!String methodsFor: 'comparing' stamp: 'di 9/14/1998 16:29'!= aString 	"Answer whether the receiver sorts equally as aString.	The collation order is simple ascii (with case differences)."	aString species == String ifFalse: [^ false].	^ (self compare: self with: aString collated: AsciiOrder) = 2! !!String methodsFor: 'comparing' stamp: 'di 11/15/1998 17:25'!beginsWith: prefix	"Answer whether the receiver begins with the given prefix string.	The comparison is case-sensitive."	self size < prefix size ifTrue: [^ false].	^ (self findSubstring: prefix in: self startingAt: 1			matchTable: CaseSensitiveOrder) = 1! !!String methodsFor: 'comparing' stamp: 'sw 4/19/1999 12:11'!caseInsensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case insensitive."	^ (self compare: self with: aString collated: CaseInsensitiveOrder) <= 2! !!String methodsFor: 'comparing' stamp: 'di 9/20/1998 14:33'!caseSensitiveLessOrEqual: aString 	"Answer whether the receiver sorts before or equal to aString.	The collation order is case sensitive."	^ (self compare: self with: aString collated: CaseSensitiveOrder) <= 2! !!String methodsFor: 'comparing' stamp: 'di 11/15/1998 17:25'!endsWith: suffix	"Answer whether the tail end of the receiver is the same as suffix.	The comparison is case-sensitive."	| extra |	(extra _ self size - suffix size) < 0 ifTrue: [^ false].	^ (self findSubstring: suffix in: self startingAt: extra + 1			matchTable: CaseSensitiveOrder) > 0"  'Elvis' endsWith: 'vis'"! !!String methodsFor: 'comparing' stamp: 'di 11/19/1998 13:37'!match: text	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."	^ self startingAt: 1 match: text startingAt: 1"	'*'			match: 'zort' true	'*baz'		match: 'mobaz' true	'*baz'		match: 'mobazo' false	'*baz*'		match: 'mobazo' true	'*baz*'		match: 'mozo' false	'foo*'		match: 'foozo' true	'foo*'		match: 'bozo' false	'foo*baz'	match: 'foo23baz' true	'foo*baz'	match: 'foobaz' true	'foo*baz'	match: 'foo23bazo' false	'foo'		match: 'Foo' true	'foo*baz*zort' match: 'foobazort' false	'foo*baz*zort' match: 'foobazzort' false	'*foo#zort'	match: 'afoo3zortthenfoo3zort' true	'*foo*zort'	match: 'afoodezortorfoo3zort' true"! !!String methodsFor: 'comparing' stamp: 'di 11/19/1998 13:28'!startingAt: keyStart match: text startingAt: textStart	"Answer whether text matches the pattern in this string.	Matching ignores upper/lower case differences.	Where this string contains #, text may contain any character.	Where this string contains *, text may contain any sequence of characters."	| anyMatch matchStart matchEnd i matchStr j ii jj |	i _ keyStart.	j _ textStart.	"Check for any #'s"	[i > self size ifTrue: [^ j > text size "Empty key matches only empty string"].	(self at: i) = $#] whileTrue:		["# consumes one char of key and one char of text"		j > text size ifTrue: [^ false "no more text"].		i _ i+1.  j _ j+1].	"Then check for *"	(self at: i) = $*		ifTrue: [i = self size ifTrue:					[^ true "Terminal * matches all"].				"* means next match string can occur anywhere"				anyMatch _ true.				matchStart _ i + 1]		ifFalse: ["Otherwise match string must occur immediately"				anyMatch _ false.				matchStart _ i].	"Now determine the match string"	matchEnd _ self size.	(ii _ self indexOf: $* startingAt: matchStart) > 0 ifTrue:		[ii = 1 ifTrue: [self error: '** not valid -- use * instead'].		matchEnd _ ii-1].	(ii _ self indexOf: $# startingAt: matchStart) > 0 ifTrue:		[ii = 1 ifTrue: [self error: '*# not valid -- use #* instead'].		matchEnd _ matchEnd min: ii-1].	matchStr _ self copyFrom: matchStart to: matchEnd.	"Now look for the match string"	[jj _ text findString: matchStr startingAt: j caseSensitive: false.	anyMatch ifTrue: [jj > 0] ifFalse: [jj = j]]		whileTrue:		["Found matchStr at jj.  See if the rest matches..."		(self startingAt: matchEnd+1 match: text startingAt: jj + matchStr size) ifTrue:			[^ true "the rest matches -- success"].		"The rest did not match."		anyMatch ifFalse: [^ false].		"Preceded by * -- try for a later match"		j _ j+1].	^ false "Failed to find the match string"! !!String methodsFor: 'converting' stamp: 'di 11/9/1998 12:17'!adaptToNumber: rcvr andSend: selector	"If I am involved in arithmetic with a number, convert me to a number."	^ rcvr perform: selector with: self asNumber! !!String methodsFor: 'converting' stamp: 'di 11/6/1998 13:49'!adaptToPoint: rcvr andSend: selector	"If I am involved in arithmetic with a point, convert me to a number."	^ rcvr perform: selector with: self asNumber! !!String methodsFor: 'converting' stamp: 'sma 3/11/2000 17:25'!asHtml	"Do the basic character conversion for HTML.  Leave all original return 	and tabs in place, so can conver back by simply removing bracked 	things. 4/4/96 tk"	| temp |	temp _ self copyReplaceAll: '&' with: '&amp;'.	HtmlEntities keysAndValuesDo:		[:entity :char |		char = $& ifFalse:			[temp _ temp copyReplaceAll: char asString with: '&' , entity , ';']].	temp _ temp copyReplaceAll: '	' with: '	<IMG SRC="tab.gif" ALT="    ">'.	temp _ temp copyReplaceAll: '' with: '<BR>'.	^ temp"	'A<&>B' asHtml"! !!String methodsFor: 'converting' stamp: 'sma 6/12/2000 11:40'!asLowercase	"Answer a String made up from the receiver whose characters are all 	lowercase."	^ self copy asString translateToLowercase! !!String methodsFor: 'converting' stamp: 'jm 10/14/2002 19:04'!asNumber 	"Answer the Number created by interpreting the receiver as the string  representation of a number."	^ Number readFrom: (ReadStream on: self)! !!String methodsFor: 'converting' stamp: 'sma 6/12/2000 11:41'!asUppercase	"Answer a String made up from the receiver whose characters are all 	uppercase."	^ self collect: [:each | each asUppercase]! !!String methodsFor: 'converting' stamp: 'ls 9/10/1998 08:48'!capitalized	"Return a copy with the first letter capitalized"	| cap |	self isEmpty ifTrue: [ ^self copy ].	cap _ self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap! !!String methodsFor: 'converting' stamp: 'jm 5/29/2003 18:55'!correctAgainst: wordList continuedFrom: oldCollection	"Like correctAgainst:.  Use when you want to correct against several lists, give nil as the first oldCollection, and nil as the last wordList."	^ wordList isNil		ifTrue: [self correctAgainstEnumerator: nil continuedFrom: oldCollection]		ifFalse: [			self correctAgainstEnumerator: [:action |					wordList do: [:w | w ifNotNil: [action value: w]]]				continuedFrom: oldCollection]! !!String methodsFor: 'converting' stamp: 'ls 8/12/1998 23:31'!encodeForHTTP	"change dangerous characters to their %XX form, for use in HTTP transactions"	| encodedStream |	encodedStream _ WriteStream on: (String new).		self do: [ :c |		c isSafeForHTTP ifTrue: [ encodedStream nextPut: c ] ifFalse: [			encodedStream nextPut: $%.			encodedStream nextPut: (c asciiValue // 16) asHexDigit.			encodedStream nextPut: (c asciiValue \\ 16) asHexDigit.		]	].	^encodedStream contents. ! !!String methodsFor: 'converting' stamp: 'bf 10/13/1999 09:26'!findSelector	"Dan's code for hunting down selectors with keyword parts; while this doesn't give a true parse, in most cases it does what we want, in where it doesn't, we're none the worse for it."	| sel possibleParens level n |	sel _ self withBlanksTrimmed.	(sel includes: $:) ifTrue:		[possibleParens _ sel findTokens: Character separators.		sel _ String streamContents:			[:s | level _ 0.			possibleParens do:				[:token |				(level = 0 and: [token endsWith: ':'])					ifTrue: [s nextPutAll: token]					ifFalse: [(n _ token occurrencesOf: $( ) > 0 ifTrue: [level _ level + n].							(n _ token occurrencesOf: $[ ) > 0 ifTrue: [level _ level + n].							(n _ token occurrencesOf: $] ) > 0 ifTrue: [level _ level - n].							(n _ token occurrencesOf: $) ) > 0 ifTrue: [level _ level - n]]]]].	sel isEmpty ifTrue: [^ nil].	Symbol hasInterned: sel ifTrue:		[:aSymbol | ^ aSymbol].	^ nil! !!String methodsFor: 'converting' stamp: 'sw 8/20/1999 10:23'!initialIntegerOrNil	"Answer the integer represented by the leading digits of the receiver, or nil if the receiver does not begin with a digit"	| firstNonDigit |	(self size == 0 or: [self first isDigit not]) ifTrue: [^ nil].	firstNonDigit _ (self findFirst: [:m | m isDigit not]).	firstNonDigit = 0 ifTrue: [firstNonDigit _ self size + 1].	^ (self copyFrom: 1  to: (firstNonDigit - 1)) asNumber"'234Whoopie' initialIntegerOrNil'wimpy' initialIntegerOrNil'234' initialIntegerOrNil'2N' initialIntegerOrNil'2' initialIntegerOrNil'  89Ten ' initialIntegerOrNil'78 92' initialIntegerOrNil"! !!String methodsFor: 'converting' stamp: 'sma 4/22/2000 17:17'!keywords	"Answer an array of the keywords that compose the receiver."	| answer size last |	answer _ OrderedCollection new.	size _ self size.	last _ 0.	1 to: size do:		[:index |		(self at: index) == $: ifTrue:			[answer add: (self copyFrom: last + 1 to: index).			last _ index]].	last = size ifFalse: [answer add: (self copyFrom: last + 1 to: size)].	^ answer asArray! !!String methodsFor: 'converting' stamp: 'di 9/24/1999 12:31'!splitInteger	"Answer an array that is a splitting of self into a string and an integer.	'43Sam' ==> #(43 'Sam').  'Try90' ==> #('Try' 90)	BUT NOTE: 'Sam' ==> #('Sam' 0), and '90' ==> #('' 90)  ie, (<string> <integer>)."	| pos |	(pos _ self findFirst: [:d | d isDigit not]) == 0 ifTrue: [^ Array with: '' with: self asNumber].	self first isDigit ifTrue: [		^ Array with: (self copyFrom: 1 to: pos - 1) asNumber 				with: (self copyFrom: pos to: self size)].	(pos _ self findFirst: [:d | d isDigit]) == 0 ifTrue: [^ Array with: self with: 0].	^ Array with: (self copyFrom: 1 to: pos - 1)			with: (self copyFrom: pos to: self size) asNumber! !!String methodsFor: 'converting' stamp: 'ls 1/3/1999 13:36'!substrings	"Answer an array of the substrings that compose the receiver."	| result end beginning |	result _ WriteStream on: (Array new: 10).	end _ 0.	"find one substring each time through this loop"	[ 		"find the beginning of the next substring"		beginning _ self indexOfAnyOf: CSNonSeparators startingAt: end+1 ifAbsent: [ nil ].		beginning ~~ nil ] 	whileTrue: [		"find the end"		end _ self indexOfAnyOf: CSSeparators startingAt: beginning ifAbsent: [ self size + 1 ].		end _ end - 1.		result nextPut: (self copyFrom: beginning to: end).	].	^result contents! !!String methodsFor: 'converting' stamp: 'ls 8/15/1998 10:31'!translateFrom: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	String translate: self  from: start to: stop table: table! !!String methodsFor: 'converting' stamp: 'ls 8/18/1998 07:44'!translateToLowercase	"Translate all characters to lowercase, in place"	self translateWith: LowercasingTable! !!String methodsFor: 'converting' stamp: 'ls 8/15/1998 08:30'!translateWith: table	"translate the characters in the string by the given table, in place"	^self translateFrom: 1 to: self size table: table! !!String methodsFor: 'converting' stamp: 'sw 9/2/1998 17:09'!truncateWithElipsisTo: maxLength	"Return myself or a copy suitably shortened but with elipsis added"	^ self size <= maxLength		ifTrue:			[self]		ifFalse:			[(self copyFrom: 1 to: (maxLength - 3)), '...']	"'truncateWithElipsisTo:' truncateWithElipsisTo: 20"! !!String methodsFor: 'converting' stamp: 'bolot 11/3/1999 17:35'!withBlanksCondensed	"Return a copy of the receiver with leading/trailing blanks removed	 and consecutive white spaces condensed."	| trimmed lastBlank |	trimmed _ self withBlanksTrimmed.	^String streamContents: [:stream |		lastBlank _ false.		trimmed do: [:c | (c isSeparator and: [lastBlank]) ifFalse: [stream nextPut: c].			lastBlank _ c isSeparator]].	" ' abc  d   ' withBlanksCondensed"! !!String methodsFor: 'converting' stamp: 'tk 3/28/1999 22:44'!withNoLineLongerThan: aNumber	"Answer a string with the same content as receiver, but rewrapped so that no line has more characters than the given number"	| listOfLines currentLast currentStart resultString putativeLast putativeLine crPosition |	aNumber isNumber not | (aNumber < 1) ifTrue: [self error: 'too narrow'].	listOfLines _ OrderedCollection new.	currentLast _ 0.	[currentLast < self size] whileTrue:		[currentStart _ currentLast + 1.		putativeLast _ (currentStart + aNumber - 1) min: self size.		putativeLine _ self copyFrom: currentStart to: putativeLast.		(crPosition _ putativeLine indexOf: Character cr) > 0 ifTrue:			[putativeLast _ currentStart + crPosition - 1.			putativeLine _ self copyFrom: currentStart to: putativeLast].		currentLast _ putativeLast == self size			ifTrue:				[putativeLast]			ifFalse:				[currentStart + putativeLine lastSpacePosition - 1].		currentLast <= currentStart ifTrue:			["line has NO spaces; baleout!!"			currentLast _ putativeLast].		listOfLines add: (self copyFrom: currentStart to: currentLast) withBlanksTrimmed].	listOfLines size > 0 ifFalse: [^ ''].	resultString _ listOfLines first.	2 to: listOfLines size do:		[:i | resultString _ resultString, String cr, (listOfLines at: i)].	^ resultString"#(5 7 20) collect:	[:i | 'Fred the bear went down to the brook to read his book in silence' withNoLineLongerThan: i]"! !!String methodsFor: 'converting' stamp: 'ls 8/20/1998 10:43'!withSeparatorsCompacted	"replace each sequences of whitespace by a single space character"	| out pos textEnd |	self isEmpty ifTrue: [ ^self ].	out _ WriteStream on: (String new: self size).	pos _ 1.   "current position in a scan through aString"	"handle the case of initial separators"	self first isSeparator ifTrue: [		out nextPut: Character space.		pos _ self indexOfAnyOf: CSNonSeparators ifAbsent: [ self size + 1 ] ].	"central loop: handle a segment of text, followed possibly by a segment of whitespace"	[ pos <= self size ] whileTrue: [ 		"handle a segment of text..."		textEnd _ self 			indexOfAnyOf: CSSeparators			startingAt: pos 			ifAbsent: [ self size + 1 ].		textEnd _ textEnd - 1.		out nextPutAll: (self copyFrom: pos to: textEnd).		pos _ textEnd + 1.		pos <= self size ifTrue: [			pos _ self 				indexOfAnyOf: CSNonSeparators				startingAt: pos				ifAbsent: [ self size + 1 ].			out nextPut: Character space  ] ].	^out contents! !!String methodsFor: 'converting' stamp: 'sw 1/8/1999 14:45'!withoutLeadingDigits	"Answer the portion of the receiver that follows any leading series of digits and blanks.  If the receiver consists entirely of digits and blanks, return an empty string"	| firstNonDigit |	firstNonDigit _ (self findFirst: [:m | m isDigit not and: [m ~~ $ ]]).	^ firstNonDigit > 0		ifTrue:			[self copyFrom: firstNonDigit  to: self size]		ifFalse:			['']"'234Whoopie' withoutLeadingDigits' 4321 BlastOff!!' withoutLeadingDigits'wimpy' withoutLeadingDigits'  89Ten ' withoutLeadingDigits'78 92' withoutLeadingDigits"! !!String methodsFor: 'converting' stamp: 'bf 11/24/1998 19:58'!withoutTrailingBlanks	"Return a copy of the receiver from which trailing blanks have been trimmed."	| last |	last _ self findLast: [:c | c isSeparator not].	last = 0 ifTrue: [^ ''].  "no non-separator character"	^ self copyFrom: 1 to: last	" ' abc  d   ' withoutTrailingBlanks"! !!String methodsFor: 'converting'!withoutTrailingDigits	"Answer the portion of the receiver that precedes any trailing series of digits and blanks.  If the receiver consists entirely of digits and blanks, return an empty string"	| firstDigit |	firstDigit _ (self findFirst: [:m | m isDigit or: [m == $ ]]).	^ firstDigit > 0		ifTrue:			[self copyFrom: 1   to: firstDigit-1]		ifFalse:			[self]"'Whoopie234' withoutTrailingDigits' 4321 BlastOff!!' withoutLeadingDigits'wimpy' withoutLeadingDigits'  89Ten ' withoutLeadingDigits'78 92' withoutLeadingDigits"! !!String methodsFor: 'displaying' stamp: 'jm 5/30/2003 13:17'!display	"Display the receiver on the Display."	self displayOn: Display at: 0@0.! !!String methodsFor: 'displaying' stamp: 'jm 5/25/2003 11:58'!displayAt: aPoint 	"Display the receiver at the given point."	self displayOn: Display at: aPoint.! !!String methodsFor: 'displaying' stamp: 'jm 5/25/2003 11:57'!displayOn: aForm	"Display the receiver on the given Form."	self displayOn: aForm at: 0@0.! !!String methodsFor: 'displaying' stamp: 'jm 5/25/2003 12:00'!displayOn: aForm at: aPoint 	"Display myself at the given point on the given Form."	(self asDisplayText		foregroundColor: Color black		backgroundColor: Color white)			displayOn: aForm at: aPoint.! !!String methodsFor: 'displaying' stamp: 'jm 5/24/2003 16:29'!displayProgressAt: aPoint from: minVal to: maxVal during: workBlock 	"Display this string as a caption over a progress bar while workBlock is evaluated.EXAMPLE (Select next 6 lines and Do It)'Now here''s some Real Progress'	displayProgressAt: Sensor cursorPoint	from: 0 to: 10	during: [:bar |	1 to: 10 do: [:x | bar value: x.			(Delay forMilliseconds: 500) wait]].HOW IT WORKS (Try this in any other language :-)Since your code (the last 2 lines in the above example) is in a block,this method gets control to display its heading before, and clean up the screen after, its execution.The key, though, is that the block is supplied with an argument,named 'bar' in the example, which will update the bar image every it is sent the message value: x, where x is in the from:to: range."	| delta savedArea captionText textFrame barFrame outerFrame result range lastW w |	barFrame _ aPoint - (75@10) corner: aPoint + (75@10).	captionText _ DisplayText text: self asText allBold.	captionText		foregroundColor: Color black		backgroundColor: Color white.	textFrame _ captionText boundingBox insetBy: -4.	textFrame _ textFrame align: textFrame bottomCenter					with: barFrame topCenter + (0@2).	outerFrame _ barFrame merge: textFrame.	delta _ outerFrame amountToTranslateWithin: Display boundingBox.	barFrame _ barFrame translateBy: delta.	textFrame _ textFrame translateBy: delta.	outerFrame _ outerFrame translateBy: delta.	savedArea _ Form fromDisplay: outerFrame.	Display fillBlack: barFrame; fillWhite: (barFrame insetBy: 2).	Display fillBlack: textFrame; fillWhite: (textFrame insetBy: 2).	captionText displayOn: Display at: textFrame topLeft + (4@4).	range _ maxVal = minVal ifTrue: [1] ifFalse: [maxVal - minVal].  "Avoid div by 0"	lastW _ 0.	result _ workBlock value:  "Supply the bar-update block for evaluation in the work block"		[:barVal |		w _ ((barFrame width-4) asFloat * ((barVal-minVal) asFloat / range min: 1.0)) asInteger.		w ~= lastW ifTrue: [			Display fill: (barFrame topLeft + (2@2) extent: w@16) fillColor: Color gray.			lastW _ w]].	savedArea displayOn: Display at: outerFrame topLeft.	^ result! !!String methodsFor: 'printing' stamp: 'sma 6/1/2000 09:48'!printOn: aStream 	"Print inside string quotes, doubling inbedded quotes."	self storeOn: aStream! !!String methodsFor: 'internet' stamp: 'sma 3/11/2000 20:40'!isoToSqueak	^ self collect: [:each | each isoToSqueak]! !!String methodsFor: 'internet' stamp: 'ls 10/27/1998 00:52'!withSqueakLineEndings	"assume the string is textual, and that CR, LF, and CRLF are all 	valid line endings.  Replace each occurence with a single CR"	| cr lf input c crlf inPos outPos outString lineEndPos newOutPos |	cr _ Character cr.	lf _ Character linefeed.	crlf _ CharacterSet new.	crlf add: cr; add: lf.	inPos _ 1.	outPos _ 1.	outString _ String new: self size.	[ lineEndPos _ self indexOfAnyOf: crlf startingAt: inPos ifAbsent: [0].		lineEndPos ~= 0 ] whileTrue: [			newOutPos _ outPos + (lineEndPos - inPos + 1).			outString replaceFrom: outPos to: newOutPos - 2 with: self startingAt: inPos.			outString at: newOutPos-1 put: cr.			outPos _ newOutPos.			((self at: lineEndPos) = cr and: [ lineEndPos < self size and: [ (self at: lineEndPos+1) = lf ] ]) ifTrue: [				"CRLF ending"				inPos _ lineEndPos + 2 ]			ifFalse: [ 				"CR or LF ending"				inPos _ lineEndPos + 1 ]. ].	"no more line endings.  copy the rest"	newOutPos _ outPos + (self size - inPos + 1).	outString replaceFrom: outPos to: newOutPos-1 with: self startingAt: inPos.	^outString copyFrom: 1 to: newOutPos-1	! !!String methodsFor: 'testing' stamp: 'ls 7/4/1998 19:17'!isAllSeparators	"whether the receiver is composed entirely of separators"	self do: [ :c | c isSeparator ifFalse: [ ^false ] ].	^true! !!String methodsFor: 'testing' stamp: 'sw 11/5/1998 17:41'!lastSpacePosition	"Answer the character position of the final space or other separator character in the receiver, and 0 if none"	self size to: 1 by: -1 do:		[:i | ((self at: i) isSeparator) ifTrue: [^ i]].	^ 0"'fred the bear' lastSpacePosition'ziggie' lastSpacePosition'elvis ' lastSpacePosition'wimpy  ' lastSpacePosition'' lastSpacePosition"! !!String methodsFor: 'paragraph support' stamp: 'RAA 8/30/1998 15:20'!indentationIfBlank: aBlock	"Answer the number of leading tabs in the receiver.  If there are	 no visible characters, pass the number of tabs to aBlock and return its value."	| reader leadingTabs lastSeparator cr tab ch |	cr _ Character cr.	tab _ Character tab.	reader _ ReadStream on: self.	leadingTabs _ 0.	[reader atEnd not and: [(ch _ reader next) == tab]]		whileTrue: [leadingTabs _ leadingTabs + 1].	lastSeparator _ leadingTabs + 1.	[reader atEnd not and: [ch isSeparator and: [ch ~~ cr]]]		whileTrue: [lastSeparator _ lastSeparator + 1. ch _ reader next].	lastSeparator = self size | (ch == cr)		ifTrue: [^aBlock value: leadingTabs].	^leadingTabs! !!String methodsFor: 'Dakota' stamp: 'RAA 7/22/2000 08:52'!getInteger32: location	| integer |	<primitive: 'getInteger' module: 'IntegerPokerPlugin'>	"^IntegerPokerPlugin doPrimitive: #getInteger"	"the following is about 7x faster than interpreting the plugin if not compiled"	integer := 		((self byteAt: location) bitShift: 24) +		((self byteAt: location+1) bitShift: 16) +		((self byteAt: location+2) bitShift: 8) +		(self byteAt: location+3).	integer > 1073741824 ifTrue: [		^1073741824 - integer ].	^integer! !!String methodsFor: 'Dakota' stamp: 'RAA 7/31/2000 16:06'!putInteger32: anInteger at: location	| integer |	<primitive: 'putInteger' module: 'IntegerPokerPlugin'>	"IntegerPokerPlugin doPrimitive: #putInteger"	"the following is close to 20x faster than the above if the primitive is not compiled"	"PUTCOUNTER _ PUTCOUNTER + 1."	integer _ anInteger.	integer < 0 ifTrue: [integer :=  1073741824 - integer. ].	self byteAt: location+3 put: (integer \\ 256).	self byteAt: location+2 put: (integer bitShift: -8) \\ 256.	self byteAt: location+1 put: (integer bitShift: -16) \\ 256.	self byteAt: location put: (integer bitShift: -24) \\ 256."Smalltalk at: #PUTCOUNTER put: 0"! !!String methodsFor: 'system primitives' stamp: 'di 11/15/1998 16:27'!findSubstring: key in: body startingAt: start matchTable: matchTable	"Answer the index in the string body at which the substring key first occurs, at or beyond start.  The match is determined using matchTable, which can be used to effect, eg, case-insensitive matches.  If no match is found, zero will be returned.	The algorithm below is not optimum -- it is intended to be translated to C which will go so fast that it wont matter."	| index |	<primitive: 246>	self var: #key declareC: 'unsigned char *key'.	self var: #body declareC: 'unsigned char *body'.	self var: #matchTable declareC: 'unsigned char *matchTable'.	key size = 0 ifTrue: [^ 0].	start to: body size - key size + 1 do:		[:startIndex |		index _ 1.			[(matchTable at: (body at: startIndex+index-1) asciiValue + 1)				= (matchTable at: (key at: index) asciiValue + 1)]				whileTrue:				[index = key size ifTrue: [^ startIndex].				index _ index+1]].	^ 0"' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 1 matchTable: CaseSensitiveOrder 1' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 2 matchTable: CaseSensitiveOrder 7' ' findSubstring: 'abc' in: 'abcdefabcd' startingAt: 8 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseSensitiveOrder 0' ' findSubstring: 'abc' in: 'abcdefABcd' startingAt: 2 matchTable: CaseInsensitiveOrder 7"! !!String methodsFor: 'system primitives' stamp: 'di 4/3/1999 00:37'!numArgs	"Answer either the number of arguments that the receiver would take if considered a selector.  Answer -1 if it couldn't be a selector.  Note that currently this will answer -1 for anything begining with an uppercase letter even though the system will accept such symbols as selectors.  It is intended mostly for the assistance of spelling correction."	| firstChar numColons |	firstChar _ self at: 1.	firstChar isLetter ifTrue:		[ firstChar isUppercase ifTrue: [ ^ -1 ].		numColons _ 0. 		self do: [ :ch |			ch tokenish ifFalse: [ ^ -1 ].			(ch = $:) ifTrue: [numColons _ numColons + 1] ].		^ (self last = $:)			ifTrue: [ numColons > 0 ifTrue: [ numColons ] ifFalse: [ -1 ] ]			ifFalse: [ numColons > 0 ifTrue: [ -1 ] ifFalse: [ 0 ] ] ].	firstChar isSpecial ifTrue:		[self size = 1 ifTrue: [^ 1].		2 to: self size do: [:i | (self at: i) isSpecial ifFalse: [^ -1]].		^ 1].	^ -1.! !!String class methodsFor: 'instance creation' stamp: 'ls 9/10/1998 22:29'!crlf	"Answer a string containing a carriage return and a linefeed."	^ self with: Character cr with: Character lf! !!String class methodsFor: 'instance creation' stamp: 'sw 6/15/1999 22:59'!tab	"Answer a string containing a single tab character."	^ self with: Character tab! !!String class methodsFor: 'initialization' stamp: 'di 9/20/1998 14:09'!initialize  "String initialize"	| order |	AsciiOrder _ (0 to: 255) as: ByteArray.	CaseInsensitiveOrder _ AsciiOrder copy.	($a to: $z) do:		[:c | CaseInsensitiveOrder at: c asciiValue + 1				put: (CaseInsensitiveOrder at: c asUppercase asciiValue +1)].	"Case-sensitive compare sorts space, digits, letters, all the rest..."	CaseSensitiveOrder _ ByteArray new: 256 withAll: 255.	order _ -1.	' 0123456789' do:  "0..10"		[:c | CaseSensitiveOrder at: c asciiValue + 1 put: (order _ order+1)].	($a to: $z) do:     "11-64"		[:c | CaseSensitiveOrder at: c asUppercase asciiValue + 1 put: (order _ order+1).		CaseSensitiveOrder at: c asciiValue + 1 put: (order _ order+1)].	1 to: CaseSensitiveOrder size do:		[:i | (CaseSensitiveOrder at: i) = 255 ifTrue:			[CaseSensitiveOrder at: i put: (order _ order+1)]].	order = 255 ifFalse: [self error: 'order problem'].	"a table for translating to lower case"	LowercasingTable _ String new: 256.	Character allCharacters do: [ :c |		LowercasingTable at: (c asciiValue+1) put: c asLowercase ].		"CR and LF--characters that terminate a line"	CSLineEnders _ CharacterSet empty.	CSLineEnders add: Character cr.	CSLineEnders add: Character lf. 	"separators and non-separators"	CSSeparators _ CharacterSet separators.	CSNonSeparators _ CSSeparators complement.! !!String class methodsFor: 'initialization' stamp: 'jm 5/24/2003 13:52'!initializeHtmlEntities	"String initializeHtmlEntities"	HtmlEntities _ (Dictionary new: 128)		at: 'amp'	put: $&;		at: 'lt'		put: $<;		at: 'gt'		put: $>;		at: 'quot'	put: $";		at: 'euro'	put: (Character value: 219);		yourself.	#('nbsp' 'iexcl' 'cent' 'pound' 'curren' 'yen' 'brvbar' 'sect' 'uml' 'copy' 'ordf' 'laquo' 'not' 'shy' 'reg' 'hibar' 'deg' 'plusmn' 'sup2' 'sup3' 'acute' 'micro' 'para' 'middot' 'cedil' 'sup1' 'ordm' 'raquo' 'frac14' 'frac12' 'frac34' 'iquest' 'Agrave' 'Aacute' 'Acirc' 'Atilde' 'Auml' 'Aring' 'AElig' 'Ccedil' 'Egrave' 'Eacute' 'Ecirc' 'Euml' 'Igrave' 'Iacute' 'Icirc' 'Iuml' 'ETH' 'Ntilde' 'Ograve' 'Oacute' 'Ocirc' 'Otilde' 'Ouml' 'times' 'Oslash' 'Ugrave' 'Uacute' 'Ucirc' 'Uuml' 'Yacute' 'THORN' 'szlig' 'agrave' 'aacute' 'acirc' 'atilde' 'auml' 'aring' 'aelig' 'ccedil' 'egrave' 'eacute' 'ecirc' 'euml' 'igrave' 'iacute' 'icirc' 'iuml' 'eth' 'ntilde' 'ograve' 'oacute' 'ocirc' 'otilde' 'ouml' 'divide' 'oslash' 'ugrave' 'uacute' 'ucirc' 'uuml' 'yacute' 'thorn' 'yuml' ) withIndexDo: [:each :index | HtmlEntities at: each put: (index + 159) asCharacter isoToSqueak]! !!String class methodsFor: 'primitives' stamp: 'ls 9/14/1998 07:50'!findFirstInString: aString  inSet: inclusionMap  startingAt: start	| i stringSize |	<primitive: 244>	self var: #aString declareC: 'unsigned char *aString'.	self var: #inclusionMap  declareC: 'char *inclusionMap'.	inclusionMap size ~= 256 ifTrue: [ ^0 ].	i _ start.	stringSize _ aString size.	[ i <= stringSize and: [ (inclusionMap at: (aString at: i) asciiValue+1) = 0 ] ] whileTrue: [ 		i _ i + 1 ].	i > stringSize ifTrue: [ ^0 ].	^i! !!String class methodsFor: 'primitives' stamp: 'jm 10/12/1998 18:21'!indexOfAscii: anInteger inString: aString startingAt: start	| stringSize |	<primitive: 245>	self var: #aCharacter declareC: 'int anInteger'.	self var: #aString declareC: 'unsigned char *aString'.	stringSize _ aString size.	start to: stringSize do: [:pos |		(aString at: pos) asciiValue = anInteger ifTrue: [^ pos]].	^ 0! !!String class methodsFor: 'primitives' stamp: 'ls 8/15/1998 12:15'!translate: aString from: start  to: stop  table: table	"translate the characters in the string by the given table, in place"	<primitive: 243>	self var: #table  declareC: 'unsigned char *table'.	self var: #aString  declareC: 'unsigned char *aString'.	start to: stop do: [ :i |		aString at: i put: (table at: (aString at: i) asciiValue+1) ]! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 10/16/1998 11:36'!embeddedInMorphicWindowLabeled: labelString	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: #contents accept: #acceptContents:			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	^ window! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 10/16/1998 11:37'!openAsMorphLabel: labelString 	"Workspace new openAsMorphLabel: 'Workspace'"	(self embeddedInMorphicWindowLabeled: labelString) openInWorld! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 8/4/1998 18:21'!openAsMorphLabel: labelString  inWorld: aWorld	"Workspace new openAsMorphLabel: 'Workspace'"	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: #contents accept: #acceptContents:			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	window openInWorld: aWorld! !!StringHolder methodsFor: 'initialize-release' stamp: 'sw 12/22/1998 00:16'!openLabel: aString 	"Create a standard system view of the model, me, a StringHolder and open it.  If in mvc, terminate the active controller so that the new window will immediately be activated."	self openLabel: aString andTerminate: true! !!StringHolder methodsFor: 'initialize-release' stamp: 'sma 4/30/2000 10:15'!openLabel: aString andTerminate: terminateBoolean	"Create a standard system view of the model, me, a StringHolder and open it.; do not terminate the active process if in mvc"	| topView codeView |	Smalltalk isMorphic ifTrue: [^ self openAsMorphLabel: aString].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.	topView label: aString.	topView minimumSize: 100 @ 50.	codeView _ PluggableTextView on: self 			text: #contents accept: #acceptContents:			readSelection: #contentsSelection menu: #codePaneMenu:shifted:.	codeView window: (0@0 extent: 200@200).	topView addSubView: codeView.	"self contents size > 0 ifTrue: [			codeView hasUnacceptedEdits: true].  Is it already saved or not??"	terminateBoolean		ifTrue:			[topView controller open]		ifFalse:			[topView controller openNoTerminate]! !!StringHolder methodsFor: 'accessing' stamp: 'sw 1/12/1999 11:47'!contents: textOrString 	"Set textOrString to be the contents of the receiver."	contents _ textOrString "asString"! !!StringHolder methodsFor: 'accessing' stamp: 'sw 9/27/1999 14:16'!contentsChanged	self changed: #contents! !!StringHolder methodsFor: 'accessing' stamp: 'di 11/23/1998 15:21'!textContents: aStringOrText 	"Set aStringOrText to be the contents of the receiver."	contents _ aStringOrText! !!StringHolder methodsFor: 'code pane menu' stamp: 'sw 11/8/1999 17:56'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items in a text pane"	| donorMenu |	donorMenu _ shifted		ifTrue:			[ParagraphEditor shiftedYellowButtonMenu]		ifFalse:			[ParagraphEditor yellowButtonMenu].	^ aMenu labels: donorMenu labelString lines: donorMenu lineArray selections: donorMenu selections! !!StringHolder methodsFor: 'code pane menu' stamp: 'wod 5/29/1998 16:35'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!StringHolder methodsFor: 'code pane menu' stamp: 'di 9/7/1999 11:27'!spawn: contentsString	(Workspace new contents: contentsString) openLabel: 'Workspace'! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 10/12/1999 17:42'!browseVersions	"Create and schedule a message set browser on all versions of the 	currently selected message selector."	| class selector |	(selector _ self selectedMessageName) ifNotNil:		[class _ self selectedClassOrMetaClass.		VersionsBrowser			browseVersionsOf: (class compiledMethodAt: selector)			class: self selectedClass			meta: class isMeta			category: self selectedMessageCategoryName			selector: selector]! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 5/8/2000 02:16'!classListKey: aChar from: view 	"Respond to a Command key.  I am a model with a list of classes and a 	code pane, and I also have a listView that has a list of methods.  The 	view knows how to get the list and selection."	aChar == $f ifTrue: [^ self findMethod].	aChar == $r ifTrue: [^ self recent].	aChar == $h ifTrue: [^ self spawnHierarchy].	aChar == $x ifTrue: [^ self removeClass].	^ self messageListKey: aChar from: view! !!StringHolder methodsFor: 'message list menu' stamp: 'di 4/28/1999 11:34'!copyName	"Copy the current selector to the clipboard"	| selector |	(selector _ self selectedMessageName) ifNotNil:		[ParagraphEditor clipboardTextPut: selector asString asText]! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 5/8/2000 02:59'!messageListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also	have a listView that has a list of methods.  The view knows how to get	the list and selection."	| sel class |	(class _ self selectedClassOrMetaClass) ifNil: [^ self arrowKey: aChar from: view].	sel _ self selectedMessageName.	aChar == $b ifTrue: [^ Browser fullOnClass: class selector: sel].	aChar == $N ifTrue: [^ self browseClassRefs].	aChar == $i ifTrue: [^ self methodHierarchy].	aChar == $h ifTrue: [^ self classHierarchy].	sel ifNotNil: 		[aChar == $m ifTrue: [^ Smalltalk browseAllImplementorsOf: sel].		aChar == $n ifTrue: [^ Smalltalk browseAllCallsOn: sel].		aChar == $v ifTrue: [^ self browseVersions].		aChar == $O ifTrue: [^ self openSingleMessageBrowser].		aChar == $x ifTrue: [^ self removeMessage]].	^ self arrowKey: aChar from: view! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 1/13/2000 12:19'!messageListSelectorTitle	| selector aString aStamp |	Preferences timeStampsInMenuTitles		ifFalse:			[^ nil].	(selector _ self selectedMessageName) ifNotNil:		[aString _ selector truncateWithElipsisTo: 28.		^ (aStamp _ self timeStamp) size > 0			ifTrue:				[aString, String cr, aStamp]			ifFalse:				[aString]].	^ nil! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 9/21/1999 11:35'!openSingleMessageBrowser	| msgName title |	"Create and schedule a message list browser populated only by the currently selected message"	(msgName _ self selectedMessageName) ifNil: [^ self].	Smalltalk browseMessageList: (Array with: (title _ self selectedClassOrMetaClass name, ' ', msgName))		name: title autoSelect: nil! !!StringHolder methodsFor: 'message list menu' stamp: 'RAA 12/10/1999 09:36'!packageListKey: aChar from: view	"Respond to a Command key in the package pane in the PackageBrowser"	aChar == $f ifTrue: [^ self findClass].	^ self classListKey: aChar from: view! !!StringHolder methodsFor: 'message list menu' stamp: 'di 6/17/1998 10:58'!removeFromCurrentChanges	"Tell the changes mgr to forget that the current msg was changed."	Smalltalk changes removeSelectorChanges: self selectedMessageName 			class: self selectedClassOrMetaClass.! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 1/28/1999 12:34'!revertAndForget	"Revert to the previous version of the current method, and tell the changes mgr to forget that it was ever changed.  Danger!!  Use only if you really know what you're doing!!"	self okToChange ifFalse: [^ self].	self revertToPreviousVersion.	self removeFromCurrentChanges.	self contentsChanged! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 10/10/1999 22:05'!revertToPreviousVersion	"Revert to the previous version of the current method"	| aClass aSelector  changeRecords |	self okToChange ifFalse: [^ self].	aClass _ self selectedClassOrMetaClass.	aClass ifNil: [^ self changed: #flash].	aSelector _ self selectedMessageName.	changeRecords _ aClass changeRecordsAt: aSelector.	(changeRecords == nil or: [changeRecords size <= 1]) ifTrue: [self changed: #flash.  ^ self beep].	changeRecords second fileIn.	self contentsChanged! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 5/4/2000 13:32'!selectMessageAndEvaluate: aBlock	"Allow the user to choose one selector, chosen from the currently selected message's selector, as well as those of all messages sent by it, and evaluate aBlock on behalf of chosen selector.  If there is only one possible choice, simply make it; if there are multiple choices, put up a menu, and evaluate aBlock on behalf of the the chosen selector, doing nothing if the user declines to choose any"	| selector method messages |	(selector _ self selectedMessageName) ifNil: [^ self].	method _ self selectedClassOrMetaClass 		compiledMethodAt: selector		ifAbsent: [].	(method isNil or: [(messages _ method messages) size == 0])		 ifTrue: [^ aBlock value: selector].	(messages size == 1 and: [messages includes: selector])		ifTrue:			[^ aBlock value: selector].  "If only one item, there is no choice"	Smalltalk 		showMenuOf: messages		withFirstItem: selector		ifChosenDo: [:sel | aBlock value: sel]! !!StringHolder methodsFor: 'message list menu' stamp: 'sw 1/26/1999 09:18'!systemCatListKey: aChar from: view	"Respond to a Command key.  I am a model with a code pane, and I also have a listView that has a list of methods.  The view knows how to get the list and selection."	aChar == $f ifTrue: [^ self findClass].	^ self classListKey: aChar from: view! !!StringHolder methodsFor: 'message list menu' stamp: 'di 4/2/1999 15:54'!timeStamp 	|  selector  aMethod |	(selector _ self selectedMessageName) ifNotNil:		[aMethod _ self selectedClassOrMetaClass compiledMethodAt: selector ifAbsent: [nil].		aMethod ifNotNil: [^ Utilities timeStampForMethod: aMethod]].	^ String new! !!StringHolder methodsFor: 'as yet unclassified' stamp: 'sw 9/27/1999 14:10'!showDiffs	"For backward compatibility during transition only, lest browsers be unusable for a spell"	^ false! !I represent a ParagraphEditor for a single paragraph of text, omitting alignment commands. I provide items in the yellow button menu so that the text selection can be evaluated and so that the contents of the model can be stored or restored.	doIt	evaluate the text selection as an expression	printIt	same as doIt but insert a description of the result after the selection	accept	store the contents of the StringHolder into the model	cancel	store the contents of the model into the StringHolder!!StringHolderController methodsFor: 'edit flag' stamp: 'di 10/9/1998 15:41'!hasUnacceptedEdits: aBoolean	^ view hasUnacceptedEdits: aBoolean! !I am a View of a String that is an aspect of a more structured object. This String should not be changed by any editing unless the user issues the accept command. Thus my instances provide a working copy of the String. This copy is edited. When the user issues the accept command, the String is copied from the working version; or if the user issues the cancel command, the working version is restored from the String. StringHolderController is my default controller. It is initialized specially by passing the string viewed which is then converted to a Paragraph for editing.!!StringHolderView methodsFor: 'updating' stamp: 'ar 5/25/2000 19:52'!promptForCancel	"Ask if it is OK to cancel changes to text"	| okToCancel stripes |	self topView isCollapsed ifTrue:		[(self confirm: 'Changes have not been saved.Is it OK to cancel those changes?') ifTrue: [model clearUserEditFlag].		^ self].	stripes _ (Form extent: 16@16 fromStipple: 16r36C9) bits.	Display border: self insetDisplayBox width: 4			rule: Form reverse fillColor: stripes.	okToCancel _ self confirm: 'Changes have not been saved.Is it OK to cancel those changes?'.	Display border: self insetDisplayBox width: 4			rule: Form reverse fillColor: stripes.	okToCancel ifTrue:		[self updateDisplayContents.		model clearUserEditFlag].! !!StringHolderView methodsFor: 'model access' stamp: 'sma 5/28/2000 23:25'!getMenu: shiftKeyState	^ nil! !!StringHolderView class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 10:15'!open: aStringHolder label: labelString 	"NOTE this should be in the model class, and all senders so redirected,	in order that the view class can be discarded in a morphic world."	"Create a standard system view of the model, aStringHolder, as viewed by 	an instance of me. The label of the view is aString."	| aStringHolderView topView |	Smalltalk isMorphic ifTrue: [^ aStringHolder openAsMorphLabel: labelString].	aStringHolderView _ self container: aStringHolder.	topView _ StandardSystemView new.	topView model: aStringHolderView model.	topView addSubView: aStringHolderView.	topView label: labelString.	topView minimumSize: 100 @ 50.	topView controller open! !I am a simple, one-line string that displays all characters in a single font. See TextMorph if you need multiple fonts or styles in the same string or multiple lines.!!StringMorph methodsFor: 'initialization' stamp: 'jm 6/23/2003 09:09'!initWithContents: aString font: aFont emphasis: emphasisCode	self initialize.	font _ aFont.	emphasis _ emphasisCode.	self contents: aString.! !!StringMorph methodsFor: 'initialization' stamp: 'jm 6/23/2003 09:09'!initialize	super initialize.	color _ Color black.	font _ nil.	emphasis _ 0.	hasFocus _ false.	"self contents: is slow, so initialize it this way:"	contents _ 'StringMorph'.	self extent: 72@12.  "determined empirically; depends on conents and font"! !!StringMorph methodsFor: 'accessing' stamp: 'sw 9/17/1999 16:29'!contents: newContents	newContents isText		ifTrue: [emphasis _ newContents emphasisAt: 1.				contents _ newContents string]		ifFalse: [contents = newContents ifTrue: [^ self].  "no substantive change"				contents _ newContents].	self fitContents.	self changed! !!StringMorph methodsFor: 'accessing' stamp: 'jm 6/15/2003 23:11'!emphasis: emphasisCode	emphasis _ emphasisCode.	self fitContents.! !!StringMorph methodsFor: 'accessing' stamp: 'ar 5/18/2000 18:34'!fitContents	| scanner |	scanner _ DisplayScanner quickPrintOn: Display box: Display boundingBox font: self fontToUse.	self extent: (((scanner stringWidth: contents) max: self minimumWidth)  @ scanner lineHeight).	self changed! !!StringMorph methodsFor: 'accessing' stamp: 'di 4/2/1999 16:12'!font: aFont	^ self font: aFont emphasis: 0! !!StringMorph methodsFor: 'accessing' stamp: 'di 4/2/1999 16:11'!font: aFont emphasis: emphasisCode	font _ aFont.	emphasis _ emphasisCode.	self fitContents."in inspector say,	 self font: (TextStyle default fontAt: 2) emphasis: 1"! !!StringMorph methodsFor: 'accessing' stamp: 'sw 12/6/1999 13:15'!fontToUse	| fontToUse |	fontToUse _ font == nil		ifTrue: [TextStyle defaultFont]		ifFalse: [font].	(emphasis == nil or: [emphasis = 0])		ifTrue: [^ fontToUse]		ifFalse: [^ fontToUse emphasized: emphasis]! !!StringMorph methodsFor: 'accessing' stamp: 'sw 9/8/1999 11:26'!hasFocus	^ hasFocus! !!StringMorph methodsFor: 'accessing' stamp: 'sw 9/8/1999 11:10'!interimContents: aString	"The receiver is under edit and aString represents the string the user sees as she edits, which typically will not have been accepted and indeed may be abandoned"	self contents: aString! !!StringMorph methodsFor: 'accessing' stamp: 'jm 3/15/2003 20:23'!minimumWidth	"Answer the minimum width that the receiver can have. A nonzero value here keeps the receiver from degenerating into something that cannot ever be seen or touched again!! Obeyed by fitContents."	^ 5! !!StringMorph methodsFor: 'accessing' stamp: 'sw 12/6/1999 13:16'!setWidth: width	self extent: width @ (font ifNil: [TextStyle defaultFont]) height! !!StringMorph methodsFor: 'drawing' stamp: 'di 9/6/1999 22:43'!drawOn: aCanvas	aCanvas text: contents bounds: bounds font: self fontToUse color: color.! !!StringMorph methodsFor: 'editing' stamp: 'jm 11/1/2002 10:43'!acceptContents	"The message is sent when the user hits enter or cmd-S. Accept the current contents and end editing. This default implementation does nothing."! !!StringMorph methodsFor: 'editing' stamp: 'sw 9/17/1999 13:27'!cancelEdits	self doneWithEdits! !!StringMorph methodsFor: 'editing' stamp: 'di 9/6/1999 22:44'!doneWithEdits	hasFocus _ false! !!StringMorph methodsFor: 'editing' stamp: 'jm 10/15/2002 17:23'!handlesMouseDown: evt	^ (evt shiftPressed and: [self wantsKeyboardFocusOnShiftClick])		ifTrue: [self uncoveredAt: evt cursorPoint]		ifFalse: [super handlesMouseDown: evt].! !!StringMorph methodsFor: 'editing' stamp: 'sw 9/7/1999 16:13'!launchMiniEditor: evt	| textMorph |	hasFocus _ true.  "Really only means edit in progress for this morph"	textMorph _ StringMorphEditor new contentsAsIs: contents.	textMorph beAllFont: self fontToUse.	textMorph bounds: (self bounds expandBy: 0@2).	self addMorphFront: textMorph.	evt hand newMouseFocus: textMorph.	evt hand newKeyboardFocus: textMorph.	textMorph editor selectFrom: 1 to: textMorph paragraph text string size! !!StringMorph methodsFor: 'editing' stamp: 'jm 3/15/2003 21:04'!lostFocusWithoutAccepting	"The message is sent when the user, having been in an editing episode on the receiver, changes the keyboard focus without having accepted the current edits. In This case, we just accept the edits."	self acceptContents.! !!StringMorph methodsFor: 'editing' stamp: 'di 9/5/1999 17:25'!mouseDown: evt	"If the shift key is pressed, make this string the keyboard input focus."	(evt shiftPressed and: [self wantsKeyboardFocusOnShiftClick])		ifTrue: [self launchMiniEditor: evt]		ifFalse: [super mouseDown: evt].! !!StringMorph methodsFor: 'editing' stamp: 'jm 10/15/2002 17:22'!wantsKeyboardFocusOnShiftClick	^ owner wantsKeyboardFocusFor: self! !!StringMorph methodsFor: 'menu' stamp: 'jm 6/15/2003 23:03'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu addLine.	aCustomMenu add: 'set font' action: #fontMenu.	aCustomMenu add: 'set font style' action: #emphasisMenu.! !!StringMorph methodsFor: 'menu' stamp: 'jm 6/15/2003 23:30'!emphasisMenu	| menu bit |	menu _ CustomMenu new.	#(bold italic underlined narrow 'struck out')		with: #(1 2 4 8 16)		do: [:label :mask | menu add: 'toggle ', label action: mask].	(bit _ menu startUp) ifNil: [^ self].	emphasis ifNil: [emphasis _ 0].	self emphasis: (emphasis bitXor: bit).! !!StringMorph methodsFor: 'menu' stamp: 'jm 6/15/2003 23:16'!fontMenu	| menu fName fSize |	menu _ CustomMenu new.	(StrikeFont familyNames copyWithout: 'DefaultTextStyle') do: [:fn |		menu add: fn action: fn].	(fName _ menu startUp) ifNil: [^ self].	menu _ CustomMenu new.	(StrikeFont sizesForFamilyName: fName) do: [:sz | menu add: sz printString action: sz].	(fSize _ menu startUp) ifNil: [^ self].	self font: (StrikeFont familyName: fName size: fSize).! !!StringMorph methodsFor: 'printing' stamp: 'jm 11/1/2002 10:42'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: '['''.	aStream nextPutAll: (contents copyFrom: 1 to: (contents size min: 10)).	contents size > 10 ifTrue: [aStream nextPutAll: '...'].	aStream nextPutAll: ''']'.! !!StringMorph methodsFor: 'object i/o' stamp: 'jm 10/10/2003 09:40'!closeEditor	"Be sure that any StringMorphEditors on me have been removed."	self doneWithEdits.	submorphs size = 0 ifTrue: [^ self].	submorphs copy do: [:m |		(m isKindOf: StringMorphEditor) ifTrue: [m delete]].! !!StringMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:38'!fieldsVersion	^ 1! !!StringMorph methodsFor: 'object i/o' stamp: 'jm 10/21/2003 10:36'!initFieldsFrom: anObjStream version: classVersion	| fontSpec |	super initFieldsFrom: anObjStream version: classVersion.	fontSpec _ anObjStream nextField.fontSpec = #badObjRef ifTrue: [fontSpec _ nil].	fontSpec ifNotNil: [		font _ (StrikeFont familyName: fontSpec first size: fontSpec second)].	self initFieldsNamed: #(		emphasis		contents	) from: anObjStream.! !!StringMorph methodsFor: 'object i/o' stamp: 'jm 10/10/2003 09:27'!storeFieldsOn: anObjStream	self closeEditor.	super storeFieldsOn: anObjStream.	font		ifNil: [anObjStream putField: nil]		ifNotNil: [anObjStream putField: (Array with: font familyName with: font height)].	self storeFieldsNamed: #(		emphasis		contents	) on: anObjStream.! !!StringMorph class methodsFor: 'instance creation' stamp: 'jm 6/23/2003 09:16'!contents: aString	"Create an instance of me with the given contents."	^ self basicNew initWithContents: aString font: nil emphasis: 0! !!StringMorph class methodsFor: 'instance creation' stamp: 'jm 6/23/2003 09:16'!contents: aString font: aFont	"Create an instance of me with the given contents and font."	^ self basicNew initWithContents: aString font: aFont emphasis: 0! !!StringMorph class methodsFor: 'instance creation' stamp: 'jm 6/23/2003 09:15'!contents: aString font: aFont emphasis: emphasisCode	"Create an instance of me with the given contents, font, and emphasis."	^ self basicNew initWithContents: aString font: aFont emphasis: emphasisCode! !!StringMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:03'!includeInNewMorphMenu	^ true! !!StringMorph class methodsFor: 'testing' stamp: 'jm 6/15/2003 10:35'!test2	"Return a morph with lots of strings for testing display speed."	"StringMorph test2 openInWorld"	| c r |	c _ AlignmentMorph newColumn.	SystemOrganization categories do:		[:cat | c addMorphBack: (StringMorph new contents: cat)].	r _ BorderedMorph new extent: c fullBounds extent.	r color: Color white.	c submorphsDo: [:m | r addMorph: m].	^ r! !I am a textMorph used as a pop-up editor for StringMorphs. I present a yellow background and I go away when a CR is typed or when the user clicks elsewhere.!!StringMorphEditor methodsFor: 'all' stamp: 'sw 9/7/1999 16:22'!drawOn: aCanvas	aCanvas fillRectangle: self bounds color: Color yellow muchLighter.	^ super drawOn: aCanvas! !!StringMorphEditor methodsFor: 'all' stamp: 'di 5/15/2000 16:33'!keyStroke: evt	"This is hugely inefficient, but it seems to work, and it's unlikely it will ever need	to be any more efficient -- it's only intended to edit single-line strings."	| char priorEditor oldSel newSel |	(((char _ evt keyCharacter) = Character enter) or: [(char = Character cr)			or: [char = $s and: [evt commandKeyPressed]]])				ifTrue: [owner acceptContents; doneWithEdits.						evt hand newKeyboardFocus: nil.						^ self delete].		(char = $l and: [evt commandKeyPressed]) ifTrue:   "cancel"		[owner cancelEdits.		evt hand newKeyboardFocus: nil.		^ self delete].	oldSel _ self editor selectionInterval.	super keyStroke: evt.	owner interimContents: self contents asString.	newSel _ self editor selectionInterval.	priorEditor _ self editor.  "Save editor state"	self releaseParagraph.  "Release paragraph so it will grow with selection."	self paragraph.      "Re-instantiate to set new bounds"	self installEditorToReplace: priorEditor.  "restore editor state"	oldSel = newSel ifTrue:		["There is a bug that causes characters to be misplaced when the second		character typed is wider than the first.  This fixes it (ugh)."		self editor selectFrom: newSel first + 1 to: newSel last + 1].! !!StringMorphEditor methodsFor: 'all' stamp: 'jm 10/10/2003 09:36'!keyboardFocusChange: aBoolean	| hadFocus |	hadFocus _ owner ifNil: [false] ifNotNil: [owner hasFocus].	super keyboardFocusChange: aBoolean.	aBoolean ifFalse: [		hadFocus ifTrue: [			owner lostFocusWithoutAccepting; doneWithEdits].		self delete].! !I am a strip chart graph that records data from multiple channels using multiple virtual pens. You can set the pen count and pen colors will be chosen automatically or you can manually set the pen colors. You can also set the value range for the data.The data recording message is "plotData:". It takes an array of values the same size as the number of pens.Example of use:m _ StripChartMorph new openInWorld.m penCount: 2.m minVal: -1 maxVal: 1.m clear.0 to: 360 by: 2 do: [:d |	data _ Array with: d degreesToRadians sin with: d degreesToRadians cos.	m plotData: data.	World doOneCycle].  "this is just for testing so you can see the values as they are added"!!StripChartMorph methodsFor: 'as yet unclassified' stamp: 'jm 6/20/2003 23:24'!clear	"Clear the graphs."	form fill: form boundingBox fillColor: self color.	lastYs _ nil.	self changed.! !!StripChartMorph methodsFor: 'as yet unclassified' stamp: 'jm 6/20/2003 23:52'!extent: aPoint	self form: (Form extent: aPoint depth: 8).	self clear.! !!StripChartMorph methodsFor: 'as yet unclassified' stamp: 'jm 6/20/2003 19:36'!initialize	super initialize.	color _ Color white.	self form: (Form extent: 200@200 depth: 8).	form fillWhite.	self minVal: 0 maxVal: 1024.	self penCount: 8.! !!StripChartMorph methodsFor: 'as yet unclassified' stamp: 'jm 6/20/2003 14:29'!minVal: minValue maxVal: maxValue	"Record the minimum and maximum values of my range."	minVal _ minValue.	maxVal _ maxValue.! !!StripChartMorph methodsFor: 'as yet unclassified' stamp: 'jm 6/20/2003 19:46'!penColors: anArrayOfColors	"Use the given set set of pen colors to plot data. There should be as many pens as the values to be plotted."	penColors _ anArrayOfColors asArray.! !!StripChartMorph methodsFor: 'as yet unclassified' stamp: 'jm 6/20/2003 19:44'!penCount: anInteger	"Create a set of colors for the given number of value plots."	self penColors: ((Color h: 0 s: 0.8 v: 0.8) wheel: anInteger).! !!StripChartMorph methodsFor: 'as yet unclassified' stamp: 'jm 6/20/2003 19:51'!plotData: anArrayOfNumbers	| baseY yScale yValues blt minY maxY r |	baseY _ self height - 1.	yScale _ baseY asFloat / (maxVal - minVal).	yValues _ anArrayOfNumbers collect: [:n |		baseY - (yScale * (n - minVal)) rounded].	(lastYs isNil or: [lastYs size ~= yValues size]) ifTrue: [lastYs _ yValues].	blt _ BitBlt toForm: form.	blt copy: (0@0 extent: (form width - 1)@form height) from: 1@0 in: form.	form fill: (((form width - 1)@0) extent: 1@form height) fillColor: color.	1 to: (yValues size min: penColors size) do: [:i |		minY _ (yValues at: i) min: (lastYs at: i).		maxY _ (yValues at: i) max: (lastYs at: i).		minY = maxY ifTrue: [maxY _ minY + 1].		r _ ((form width - 1)@minY) corner: (form width@maxY).		form fill: r fillColor: (penColors at: i)].	lastYs _ yValues.	self changed.				! !I encode monophonic sampled sounds in Sun audio (.au) file format. Sun audio files have a very simple format but can store both compressed and uncompressed sample data. I can write this format either directly into a file or onto any writable binary stream.!!SunAudioFileWriter methodsFor: 'initialization' stamp: 'jm 11/16/2001 17:51'!setStream: aBinaryStream	"Initialize myself for writing on the given stream."	stream _ aBinaryStream.	headerStart _ aBinaryStream position.! !!SunAudioFileWriter methodsFor: 'other' stamp: 'jm 11/16/2001 18:02'!appendBytes: aByteArray	"Append the given sample data to my stream."	stream nextPutAll: aByteArray.! !!SunAudioFileWriter methodsFor: 'other' stamp: 'jm 12/3/2003 13:08'!appendSamples: aSoundBuffer	"Append the given SoundBuffer to my stream."	| swapBytes s |	(stream isKindOf: StandardFileStream) ifTrue: [		"optimization: write sound buffer directly to file"		swapBytes _ Smalltalk isBigEndian not.		swapBytes ifTrue: [aSoundBuffer reverseEndiannessStereo: false].  "make big endian"		stream next: (aSoundBuffer size // 2) putAll: aSoundBuffer startingAt: 1.  "size in words"		swapBytes ifTrue: [aSoundBuffer reverseEndiannessStereo: false].  "revert to little endian"		^ self].	"for non-file streams:"	s _ WriteStream on: (ByteArray new: 2 * aSoundBuffer monoSampleCount).	1 to: aSoundBuffer monoSampleCount do: [:i | s int16: (aSoundBuffer at: i)].	self appendBytes: s contents.! !!SunAudioFileWriter methodsFor: 'other' stamp: 'jm 11/16/2001 22:09'!closeFile	"Update the Sun audio file header to reflect the final size of the sound data. If my stream is a file stream, close it and, on a Macintosh, set the file type and creator to that used by SoundApp for Sun Audio files. (This does nothing on other platforms.)"	self ensureOpen.	self updateHeaderDataSize.	(stream isKindOf: StandardFileStream) ifTrue: [		stream close.		FileDirectory default setMacFileNamed: stream name type: 'ULAW' creator: 'SCPL'].! !!SunAudioFileWriter methodsFor: 'other' stamp: 'jm 11/16/2001 18:28'!ensureOpen	"Ensure that my stream is open."	(stream respondsTo: #closed) ifFalse: [^ self].	stream closed ifTrue: [stream reopen; binary].! !!SunAudioFileWriter methodsFor: 'other' stamp: 'jm 12/18/2001 12:02'!storeSampledSound: aSampledSound compressionType: aString	"Store the given sampled sound using the given type of compression. See formatCodeForCompressionType: for the list of compression types."	| fmt codec compressed |	fmt _ self class formatCodeForCompressionType: aString.	codec _ self class codecForFormatCode: fmt.	self writeHeaderSamplingRate: aSampledSound originalSamplingRate format: fmt.	codec		ifNil: [self appendSamples: aSampledSound samples]		ifNotNil: [			compressed _ codec encodeSoundBuffer: aSampledSound samples.			self appendBytes: compressed].	self updateHeaderDataSize.! !!SunAudioFileWriter methodsFor: 'other' stamp: 'jm 12/18/2001 12:14'!updateHeaderDataSize	"Update the Sun audio file header to reflect the final size of the sound data. Leave the stream positioned at the end of the sample data."	| finalPosition byteCount |	finalPosition _ stream position.	byteCount _ finalPosition - (headerStart + 24).	stream position: headerStart + 8.	stream uint32: byteCount.	stream position: finalPosition.! !!SunAudioFileWriter methodsFor: 'other' stamp: 'jm 11/16/2001 22:10'!writeHeaderSamplingRate: samplingRate format: audioFormat	"Write a Sun audio file header for the given sampling rate and format. Currently, only monophonic files are supported."	self ensureOpen.	stream position: headerStart.	stream nextPutAll: '.snd' asByteArray.	stream uint32: 24.	"header size in bytes"	stream uint32: 0.	"sample data size in bytes; fill in later"	stream uint32: audioFormat.	stream uint32: samplingRate truncated.	stream uint32: 1.	"channel count"! !!SunAudioFileWriter class methodsFor: 'instance creation' stamp: 'jm 11/16/2001 17:49'!onFileNamed: fileName	"Answer an instance of me on a newly created file with the given name."	| file |	file _ (FileStream newFileNamed: fileName) binary.	^ self new setStream: file! !!SunAudioFileWriter class methodsFor: 'instance creation' stamp: 'jm 11/16/2001 17:50'!onStream: aBinaryStream	"Answer an instance of me on the given binary stream."	^ self new setStream: aBinaryStream! !!SunAudioFileWriter class methodsFor: 'sound storing' stamp: 'jm 11/21/2001 15:42'!codecForFormatCode: formatCode	"Answer the codec for the given Sun audio file format number."	formatCode = 1 ifTrue: [^ MuLawCodec new].	formatCode = 3 ifTrue: [^ nil].  "uncompressed"	formatCode = 23 ifTrue: [^ ADPCMCodec newBitsPerSample: 4].	formatCode = 25 ifTrue: [^ ADPCMCodec newBitsPerSample: 3].	formatCode = 26 ifTrue: [^ ADPCMCodec newBitsPerSample: 5].	formatCode = 610 ifTrue: [^ GSMCodec new].	self error: 'unsupported Sun audio format'! !!SunAudioFileWriter class methodsFor: 'sound storing' stamp: 'jm 11/21/2001 15:42'!formatCodeForCompressionType: aString	"Answer the Sun audio file format number for the given compression type name."	| lowercase |	lowercase _ aString asLowercase.	'mulaw' = lowercase ifTrue: [^ 1].	'none' = lowercase ifTrue: [^ 3].	'adpcm3' = lowercase ifTrue: [^ 25].	'adpcm4' = lowercase ifTrue: [^ 23].	'adpcm5' = lowercase ifTrue: [^ 26].	'gsm' = lowercase ifTrue: [^ 610].	self error: 'unknown compression style'! !!SunAudioFileWriter class methodsFor: 'sound storing' stamp: 'jm 11/19/2003 12:37'!storeSampledSound: aSampledSound compressionType: aString on: aBinaryStream	"Store the samples of the given sampled sound on the given stream using the given type of compression. See formatCodeForCompressionType: for the list of compression types."	(self onStream: aBinaryStream)		storeSampledSound: aSampledSound compressionType: aString.! !!SunAudioFileWriter class methodsFor: 'sound storing' stamp: 'jm 11/19/2003 12:37'!storeSampledSound: aSampledSound compressionType: aString onFileNamed: fileName	"Store the samples of the given sampled sound on a file with the given name using the given type of compression. See formatCodeForCompressionType: for the list of compression types."	| writer |	writer _ self onFileNamed: fileName.	writer storeSampledSound: aSampledSound compressionType: aString.	writer closeFile.! !I represent a selection setting and actions to take depending on a change in the setting. An instance has three attributes: state, which is either on or off; on action; and off action. The on and off actions are blocks of code that execute whenever the instance changes state. I am typically used as a menu item in conjunction with a SwitchView and a SwitchController.1/24/96 sw: made this a subclass of Model, for faster dependents handling!I represent Strings that are created uniquely. Thus, someString asSymbol == someString asSymbol.!!Symbol methodsFor: 'accessing' stamp: 'sma 2/5/2000 12:32'!precedence	"Answer the receiver's precedence, assuming it is a valid Smalltalk	message selector or 0 otherwise.  The numbers are 1 for unary,	2 for binary and 3 for keyword selectors."	self size = 0 ifTrue: [^ 0].	self first isLetter ifFalse: [^ 2].	self last = $: ifTrue: [^ 3].	^ 1! !!Symbol methodsFor: 'comparing' stamp: 'di 4/11/2000 16:18'!= another	"Use == between two symbols..."	self == another ifTrue: [^ true].  "Was == "	another class == Symbol ifTrue: [^ false].  "Was not == "	"Otherwise use string =..."	^ super = another! !!Symbol methodsFor: 'copying' stamp: 'tk 6/26/1998 11:35'!clone	"Answer with the receiver, because Symbols are unique."! !!Symbol methodsFor: 'printing' stamp: 'di 4/25/2000 12:32'!storeOn: aStream 	aStream nextPut: $#.	(Scanner isLiteralSymbol: self)		ifTrue: [aStream nextPutAll: self]		ifFalse: [super storeOn: aStream]! !!Symbol methodsFor: 'system primitives' stamp: 'di 1/2/1999 17:00'!flushCache	"Tell the interpreter to remove all entries with this symbol as a selector from its method lookup cache, if it has one.  This primitive must be called whenever a method is defined or removed.	NOTE:  Only one of the two selective flush methods needs to be used.	Squeak 2.3 and later uses 116 (See CompiledMethod flushCache)."	<primitive: 119>! !!Symbol methodsFor: 'testing' stamp: 'sma 2/5/2000 12:32'!isInfix	"Answer whether the receiver is an infix message selector."	^ self precedence == 2! !!Symbol methodsFor: 'testing' stamp: 'sma 2/5/2000 12:34'!isKeyword	"Answer whether the receiver is a message keyword."	^ self precedence == 3! !!Symbol methodsFor: 'testing' stamp: 'di 4/25/2000 12:32'!isLiteral	"Answer whether the receiver is a valid Smalltalk literal."	^ true! !!Symbol methodsFor: 'testing' stamp: 'sma 2/5/2000 12:13'!isPvtSelector	"Answer whether the receiver is a private message selector, that is,	begins with 'pvt' followed by an uppercase letter, e.g. pvtStringhash."	^ (self beginsWith: 'pvt') and: [self size >= 4 and: [(self at: 4) isUppercase]]! !!Symbol methodsFor: 'testing' stamp: 'sma 2/5/2000 12:34'!isUnary	"Answer whether the receiver is an unary message selector."	^ self precedence == 1! !!Symbol class methodsFor: 'instance creation' stamp: 'sma 2/26/2000 20:17'!intern: aString 	"Answer a unique Symbol whose characters are those of aString."	| ascii table mainTable index sym numArgs symbol lastNilIndex |	aString size = 0		ifTrue: [ascii _ 0]		ifFalse:			[ascii _ (aString at: 1) asciiValue.			aString size = 1 ifTrue: [ascii < 128 ifTrue: 				[^ SingleCharSymbols at: ascii + 1]]].	table _ ((ascii >= "$a asciiValue" 97) and:		[(ascii <= "$z asciiValue" 122) and:		[(numArgs _ aString numArgs) >= 0]])			ifTrue: [(mainTable _ SelectorTables									at: (numArgs + 1 min: SelectorTables size))						at: (index _ ascii - "($a asciiValue - 1)" 96)]			ifFalse: [(mainTable _ OtherTable)						at: (index _ aString stringhash \\ OtherTable size + 1)].	1 to: table size do: [:i |		symbol _ table at: i.		symbol isNil 			ifTrue:[lastNilIndex _ i]			ifFalse:[(aString size = symbol size and:[aString = symbol])						ifTrue:[^symbol]]	].	sym _ (aString isMemberOf: Symbol)		ifTrue: [aString]	"putting old symbol in new table"		ifFalse: [(Symbol new: aString size) string: aString]. "create a new one"	lastNilIndex isNil		ifTrue:[mainTable at: index put: (table copyWith: sym)]		ifFalse:[table at: lastNilIndex put: sym].	^sym! !!Symbol class methodsFor: 'instance creation' stamp: 'di 10/11/1999 00:02'!readFrom: strm  "Symbol readFromString: '#abc'"	strm peek = $# ifFalse: [self error: 'Symbols must be introduced by #'].	^ (Scanner new scan: strm) advance  "Just do what the code scanner does"! !!Symbol class methodsFor: 'instance creation' stamp: 'jm 5/24/2003 13:59'!rehash	"Rebuild the hash table, reclaiming unreferenced Symbols."	"Symbol rehash"	| count oldCount |	SelectorTables _ (1 to: 6) collect: [:i | (1 to: 26) collect: [:j | Array new: 0]].	OtherTable _ (1 to: 51) collect: [:i | Array new: 0].	oldCount _ Symbol instanceCount.	count _ 0.	'Rebuilding Symbol Tables...'		displayProgressAt: Sensor cursorPoint		from: 0 to: oldCount		during: [:bar |			Smalltalk garbageCollect.			Symbol allInstancesDo: [:sym |				self intern: sym.				bar value: (count _ count + 1)]].	^ (oldCount - count) printString, ' reclaimed'! !!Symbol class methodsFor: 'private' stamp: 'ar 5/1/1999 04:56'!hasInterned: aString ifTrue: symBlock 	"Answer with false if aString hasnt been interned (into a Symbol), 	otherwise supply the symbol to symBlock and return true."	| table ascii numArgs symbol |	ascii _ (aString at: 1) asciiValue.	aString size = 1 ifTrue: [ascii < 128 ifTrue: 		[symBlock value: (SingleCharSymbols at: ascii + 1).		^true]].	table _ ((ascii >= "$a asciiValue" 97) and:		[(ascii <= "$z asciiValue" 122) and:		[(numArgs _ aString numArgs) >= 0]])			ifTrue: [(SelectorTables at: (numArgs + 1 min: SelectorTables size))						at: ascii - "($a asciiValue - 1)" 96]			ifFalse: [OtherTable at: aString stringhash \\ OtherTable size + 1].	1 to: table size do: [:i | 		symbol _ table at: i.		(symbol notNil and:[aString size = symbol size and: [aString = symbol]]) ifTrue: [			symBlock value: symbol.			^true]	].	^false! !!Symbol class methodsFor: 'access' stamp: 'tk 2/11/2000 21:16'!otherThatStarts: leadingCharacters skipping: skipSym	"Answer a selector symbol with leadingCharacters that 		starts with an uppercase letter. Ignore case in aKeyword.	If skipSym is not nil, it is a previous answer; start searching after it.	If no symbols are found, answer nil.	Used by Alt-q (Command-q) routines."	| key size table candidate ii skip |	key _ leadingCharacters asLowercase.	size _ key size.	skip _ skipSym ~~ nil.	(1 to: OtherTable size) do:		[:jj |		table _ OtherTable at: jj.		1 to: table size do: 			[:tt | 			((candidate _ table at: tt) == nil or:					[skip and: [skip _ candidate ~~ skipSym. true]]) ifFalse:				[candidate size >= size ifTrue:					[ii _ size. "test last character first"					 [ii > 0 and: [(candidate at: ii) asLowercase == (key at: ii)]]						whileTrue: [ii _ ii - 1].					 ii = 0 ifTrue: [^candidate]]]]].	^nil"Symbol otherThatStarts: 'morph' skipping: nil""Symbol otherThatStarts: 'morph' skipping: #'Morphic-Support'""Symbol otherThatStarts: 'rect' skipping: #'rectangle functions'"! !!Symbol class methodsFor: 'access' stamp: 'tk 8/11/1998 22:12'!possibleSelectorsFor: misspelled	"Answer an ordered collection of possible corrections for the misspelled selector in order of likelyhood."	| numArgs table lookupString list binary |	lookupString _ misspelled asLowercase. "correct uppercase selectors to lowercase"	numArgs _ lookupString numArgs.	numArgs < 0 ifTrue: [ ^ OrderedCollection new: 0 ].	table _ (SelectorTables at: (numArgs + 1 min: SelectorTables size))				at: (lookupString at: 1) asciiValue - "($a asciiValue - 1)" 96.	list _ lookupString correctAgainst: table.	((misspelled last ~~ $:) and: [misspelled size > 1]) ifTrue: [		binary _ misspelled, ':'.		"try for missing colon"		Symbol hasInterned: binary ifTrue: [:him | list addFirst: him]].	^ list! !!Symbol class methodsFor: 'access' stamp: 'bf 10/13/1999 09:57'!selectorsContaining: aString	"Answer a list of selectors that contain aString within them.  Case-insensitive."	| size table candidate selectorList selectorTable ascii |	selectorList _ OrderedCollection new.	(size _ aString size) = 0 ifTrue: [^ selectorList].	aString size = 1 ifTrue:		[ascii _ aString first asciiValue.		ascii < 128 ifTrue:			[selectorList add: (SingleCharSymbols at: ascii + 1)]].	aString first isLetter ifFalse: [		aString size == 2 ifTrue: 			[Symbol hasInterned: aString ifTrue: [:s | selectorList add: s]].		^ selectorList].	(SelectorTables size to: 1 by: -1) do:		[:j | selectorTable _ SelectorTables at: j.		1 to: 26 do: [:index |		table _ selectorTable at: index.		1 to: table size do: 			[:t | 			((candidate _ table at: t) == nil) ifFalse:				[candidate size >= size ifTrue:					[((candidate findString: aString startingAt: 1 caseSensitive: false) > 0) ifTrue:							[selectorList add: candidate]]]]]].	^ selectorList"Symbol selectorsContaining: 'scon' "! !!Symbol class methodsFor: 'access' stamp: 'tk 2/11/2000 21:30'!thatStarts: leadingCharacters skipping: skipSym	"Answer a selector symbol that starts with leadingCharacters.	Symbols beginning with a lower-case letter handled directly here.	Ignore case after first char.	If skipSym is not nil, it is a previous answer; start searching after it.	If no symbols are found, answer nil.	Used by Alt-q (Command-q) routines."	| key size index table candidate i skip firstTable |	key _ leadingCharacters asLowercase.	index _ key first asciiValue - "($a asciiValue - 1)" 96.	((index >= 1) and:		[(index <= 26) and:		[leadingCharacters numArgs >= 0]])			ifFalse: [^ self otherThatStarts: leadingCharacters skipping: skipSym].	size _ key size.	skip _ skipSym ~~ nil.	firstTable _ skip		ifTrue: [skipSym numArgs + 1 min: SelectorTables size] "can't be in a later table"		ifFalse: [SelectorTables size]. "could be in any table; favor longer identifiers"	(firstTable to: 1 by: -1) do:		[:j |		table _ (SelectorTables at: j) at: index.		1 to: table size do: 			[:t | 			((candidate _ table at: t) == nil or:					[skip and: [skip _ candidate ~~ skipSym. true]]) ifFalse:				[candidate size >= size ifTrue:					[i _ size. "test last character first"					 [i > 1 and: [(candidate at: i) asLowercase == (key at: i)]]						whileTrue: [i _ i - 1].					 i = 1 ifTrue: "don't need to compare first character"						[^candidate]]]]].	^nil"Symbol thatStarts: 'sf' skipping: nil""Symbol thatStarts: 'sf' skipping: #sfpGetFile:with:with:with:with:with:with:with:with:""Symbol thatStarts: 'candidate' skipping: nil"! !Represents a color and possibly a style attribute to be applied to a syntactic element for pretty-printing.  The attributeList inst var is a cache.!!SyntaxAttribute methodsFor: 'accessing' stamp: 'sw 11/17/1999 15:04'!attributeList	"Answer a list of text attributes that characterize the receiver"	attributeList ifNil:		[attributeList _ OrderedCollection new: 2.		color ifNotNil: [attributeList add: (TextColor color: color)].		emphasis ifNotNil: [attributeList add: (TextEmphasis perform: emphasis)]].	^ attributeList! !!SyntaxAttribute methodsFor: 'accessing' stamp: 'djp 11/7/1999 14:52'!color	^ color! !!SyntaxAttribute methodsFor: 'accessing' stamp: 'sw 11/16/1999 16:21'!color: aTextColor	color _ aTextColor.	attributeList _ nil! !!SyntaxAttribute methodsFor: 'accessing' stamp: 'djp 11/7/1999 14:52'!emphasis	^ emphasis! !!SyntaxAttribute methodsFor: 'accessing' stamp: 'sw 11/16/1999 16:22'!emphasis: aTextEmphasis	emphasis _ aTextEmphasis.	attributeList _ nil! !!SyntaxAttribute class methodsFor: 'as yet unclassified' stamp: 'sw 11/16/1999 12:01'!color: aColor emphasis: anEmphasis	^ self new color: aColor; emphasis: anEmphasis; yourself! !!SyntaxError methodsFor: 'initialization' stamp: 'tk 5/6/1999 13:28'!setClass: aClass code: aString debugger: aDebugger doitFlag: flag	| types printables badChar |	class _ aClass.	debugger _ aDebugger.	selector _ aClass parserClass new parseSelector: aString.	types _ Scanner classPool at: #TypeTable.	"dictionary"	printables _ '!!@#$%&*-_=+<>{}?/\,`~`' asSet.	badChar _ aString detect: [:aChar | (types at: aChar asciiValue) == #xBinary and: [			(printables includes: aChar) not]] ifNone: [nil].	contents _ badChar 		ifNil: [aString]		ifNotNil: ['<<<This string contains a character (ascii value ', 			badChar asciiValue printString,			') that is not normally used in code>>> ', aString].	category ifNil: [category _ aClass organization categoryOfElement: selector].	category ifNil: [category _ ClassOrganizer default].	doitFlag _ flag! !!SyntaxError methodsFor: 'message list' stamp: 'tk 4/19/1999 08:08'!list	"Answer an array of one element made up of the class name, message category, and message selector in which the syntax error was found. This is the single item in the message list of a view/browser on the receiver."	selector ifNil: [^ Array with: (class name, '  ', category, '  ', '<none>')].	^ Array with: (class name, '  ', category, '  ', selector)! !!SyntaxError methodsFor: 'other' stamp: 'di 10/9/1998 16:36'!contents: aString notifying: aController	"Compile the code in aString and notify aController of any errors. If there are no errors, then automatically proceed."	doitFlag	ifTrue: [Compiler new evaluate: aString in: nil to: nil						notifying: aController ifFail: [^ false]]	ifFalse: [(class compile: aString classified: category						notifying: aController) ifNil: [^ false]].	aController hasUnacceptedEdits: false.	self proceed! !!SyntaxError methodsFor: 'other' stamp: 'di 10/9/1998 16:51'!notify: error at: location in: source	"Open a syntax error view, inserting the given error message into the given source at the given location. This message is sent to the 'requestor' when the parser or compiler finds a syntax error."	| aClass aString |	aClass _ thisContext sender receiver encoder classEncoding.	aString _		source contents			copyReplaceFrom: location			to: location - 1			with: error.	self setClass: aClass		code: aString		debugger: (Debugger context: thisContext)		doitFlag: false.	self class open: self.! !!SyntaxError class methodsFor: 'instance creation' stamp: 'di 8/17/1998 10:22'!buildMorphicViewOn: aSyntaxError	"Answer an Morphic view on the given SyntaxError."	| window |	window _ (SystemWindow labelled: 'Syntax Error') model: aSyntaxError.	window addMorph: (PluggableListMorph on: aSyntaxError list: #list			selected: #listIndex changeSelected: nil menu: #listMenu:)		frame: (0@0 corner: 1@0.15).	window addMorph: (PluggableTextMorph on: aSyntaxError text: #contents			accept: #contents:notifying: readSelection: #contentsSelection			menu: #codePaneMenu:shifted:)		frame: (0@0.15 corner: 1@1).	^ window openInWorldExtent: 380@220! !!SyntaxError class methodsFor: 'instance creation' stamp: 'di 10/9/1998 16:18'!errorInClass: aClass withCode: codeString doitFlag: doit	"Open a view whose model is a syntax error. The error occurred when trying to add the given method code to the given class."	self open:		(self new setClass: aClass			code: codeString			debugger: (Debugger context: thisContext)			doitFlag: doit).! !!SyntaxError class methodsFor: 'instance creation' stamp: 'sma 4/30/2000 10:15'!open: aSyntaxError	"Answer a standard system view whose model is an instance of me."	| topView |	<primitive: 19> "Simulation guard"	Smalltalk isMorphic		ifTrue:			[self buildMorphicViewOn: aSyntaxError.			Project current spawnNewProcessIfThisIsUI: Processor activeProcess.			^ Processor activeProcess suspend].	topView _ self buildMVCViewOn: aSyntaxError.	topView controller openNoTerminateDisplayAt: Display extent // 2.	Cursor normal show.	Processor activeProcess suspend.! !I represent a special dictionary that supports protocol for asking questions about the structure of the system. Other than class names, I contain (print this)...	Smalltalk keys select: [:k | ((Smalltalk at: k) isKindOf: Class) not]			thenCollect: [:k | k -> (Smalltalk at: k) class]!!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 12/6/1999 12:42'!associationAtOrAbove: varName ifAbsent: absentBlock 	"Compatibility with environment protocol."	^ self associationAt: varName ifAbsent: absentBlock! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 12/21/1999 12:00'!atOrAbove: key ifAbsent: absentBlock	"Compatibility with environment protocol."	^ self at: key ifAbsent: absentBlock! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 12/6/1999 13:43'!atOrBelow: key ifAbsent: absentBlock	"Compatibility with environment protocol."	^ self at: key ifAbsent: absentBlock! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 12/6/1999 20:36'!environmentForCategory: catName	"Default response for non-partitioned systems"	^ Smalltalk! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 12/21/1999 12:00'!includesKeyOrAbove: key	"Compatibility with environment protocol."	self atOrAbove: key ifAbsent: [^ false].	^ true! !!SystemDictionary methodsFor: 'dictionary access' stamp: 'di 12/19/1999 21:17'!scopeFor: varName from: lower envtAndPathIfFound: envtAndPathBlock	"Null compatibility with partitioning into environments."	(self includesKey: varName)		ifTrue: [^ envtAndPathBlock value: self value: String new]		ifFalse: [^ nil]! !!SystemDictionary methodsFor: 'browsing' stamp: 'di 5/4/1999 13:52'!browseAllObjectReferencesTo: anObject except: objectsToExclude ifNone: aBlock	"Bring up a list inspector on the objects that point to anObject.	If there are none, then evaluate aBlock on anObject.  "	| aList shortName |	aList _ Smalltalk pointersTo: anObject except: objectsToExclude.	aList size > 0 ifFalse: [^ aBlock value: anObject].	shortName _ (anObject name ifNil: [anObject printString]) contractTo: 20.	OrderedCollectionInspector openOn: aList withEvalPane: false		withLabel: 'Objects pointing to ', shortName.! !!SystemDictionary methodsFor: 'browsing' stamp: 'sw 9/21/1999 11:38'!browseMessageList: messageList name: labelString autoSelect: autoSelectString	| title aSize |	"Create and schedule a MessageSet browser on the message list."	messageList size = 0 ifTrue: 		[^ (PopUpMenu labels: ' OK ')				startUpWithCaption: 'There are no' , labelString].	title _ (aSize _ messageList size) > 1		ifFalse:	[labelString]		ifTrue:	[ labelString, ' [', aSize printString, ']'].	MessageSet openMessageList: messageList name: title autoSelect: autoSelectString! !!SystemDictionary methodsFor: 'browsing' stamp: 'di 11/23/1998 12:05'!browseMethodsWithSourceString: aString	"Smalltalk browseMethodsWithSourceString: 'SourceString' "	"Launch a browser on all methods whose source code contains aString as a substring."	| caseSensitive suffix |	(caseSensitive _ Sensor shiftPressed)		ifTrue: [suffix _ ' (case-sensitive)']		ifFalse: [suffix _ ' (use shift for case-sensitive)'].	^ self browseMessageList: (self allMethodsWithSourceString: aString									matchCase: caseSensitive)		name: 'Methods containing ' , aString printString , suffix autoSelect: aString! !!SystemDictionary methodsFor: 'browsing' stamp: 'di 11/23/1998 12:05'!browseMethodsWithString: aString	"Launch a browser on all methods that contain string literals with aString as a substring. The search is case-insensitive, unless the shift key is pressed, in which case the search is case-sensitive."	| caseSensitive suffix |	(caseSensitive _ Sensor shiftPressed)		ifTrue: [suffix _ ' (case-sensitive)']		ifFalse: [suffix _ ' (use shift for case-sensitive)'].	self browseAllSelect:			[:method |				method  hasLiteralSuchThat: [:lit |					lit class == String and:					[lit includesSubstring: aString caseSensitive: caseSensitive]]]		name:  'Methods with string ', aString printString, suffix		autoSelect: aString.! !!SystemDictionary methodsFor: 'browsing' stamp: 'tk 6/24/1999 11:28'!browseObsoleteReferences   "Smalltalk browseObsoleteReferences"	| references |	references _ OrderedCollection new.	(Association allSubInstances select:		[:x | ((x value isKindOf: Behavior) and: ['AnOb*' match: x value name]) or:		['AnOb*' match: x value class name]]) 		do: [:x | references addAll: (Smalltalk allCallsOn: x)].	Smalltalk browseMessageList: references name: 'References to Obsolete Classes'! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jm 5/18/2003 15:03'!allBehaviorsDo: aBlock 	"Evaluate the argument, aBlock, for each kind of Behavior in the system (that is, Object and its subclasses)."	"ar 7/15/1999: The code below will not enumerate any obsolete or anonymous behaviors for which the following can be executed:		Smalltalk allObjectsDo: [:obj | obj isBehavior ifTrue: [aBlock value: obj]].	but what follows is way faster than enumerating all objects."	aBlock value: Object.	Object allSubclassesDo: aBlock.	"Classes outside the Object hierarchy"	Class subclassesDo: [:aClass |		false & aClass isMeta ifTrue: [			"Enumerate the non-meta class and its subclasses"			aBlock value: aClass soleInstance.			aClass soleInstance allSubclassesDo: aBlock]].! !!SystemDictionary methodsFor: 'retrieving' stamp: 'ls 10/10/1999 13:22'!allCallsOn: aLiteral   "Smalltalk browseAllCallsOn: #open:label:."	"Answer a Collection of all the methods that call on aLiteral."	| aCollection special thorough aList byte |	#(23 48 'fred' (new open:label:)) size.		"Example above should find #open:label:, though it is deeply embeddedhere."	aCollection _ OrderedCollection new.	special _ self hasSpecialSelector: aLiteral ifTrueSetByte: [:b | byte _b ].	thorough _ (aLiteral isMemberOf: Symbol)				and: ["Possibly search for symbols imbedded in literal arrays"					Preferences thoroughSenders].	Cursor wait showWhile: 		[self allBehaviorsDo: 			[:class |				aList _ thorough					ifTrue:			 			[(class thoroughWhichSelectorsReferTo: aLiteral special: specialbyte: byte)]					ifFalse:						[class whichSelectorsReferTo: aLiteral special: special byte:byte].				aList do: 					[:sel | sel ~~ #DoIt						ifTrue: [aCollection add: class name , ' ' , sel]]]].	^ aCollection! !!SystemDictionary methodsFor: 'retrieving' stamp: 'bf 9/22/1999 16:56'!allImplementedMessages	"Answer a Set of all the messages that are sent by a method in the system 	but are not implemented."	| aSet |	aSet _ IdentitySet new: Symbol instanceCount.	Cursor wait showWhile: 		[self allBehaviorsDo: [:cl | cl selectorsDo: [:aSelector | aSet add: aSelector]]].	^aSet! !!SystemDictionary methodsFor: 'retrieving' stamp: 'di 11/23/1998 12:02'!allMethodsWithSourceString: aString matchCase: caseSensitive	"Answer a SortedCollection of all the methods that contain, in source code, aString as a substring.  The search is case-insensitive."	| list classCount |	list _ Set new.'Searching all source code...'displayProgressAt: Sensor cursorPointfrom: 0 to: Smalltalk classNames sizeduring:	[:bar | classCount _ 0.	Smalltalk allClassesDo:		[:class | bar value: (classCount _ classCount + 1).		(Array with: class with: class class) do:			[:cl | cl selectorsDo:				[:sel | 				((cl sourceCodeAt: sel) findString: aString startingAt: 1 caseSensitive: caseSensitive) > 0					ifTrue:					[sel == #DoIt ifFalse: [list add: cl name , ' ' , sel]]]]]].	^ list asSortedCollection! !!SystemDictionary methodsFor: 'retrieving' stamp: 'bf 9/22/1999 16:39'!allSentMessages	"Answer the set of selectors which are sent somewhere in the system."	| sent |	sent _ IdentitySet new: CompiledMethod instanceCount.	Cursor execute showWhile: 		[self allBehaviorsDo: 			[:cl | cl selectorsDo: 				[:sel | "Include all sels, but not if sent by self"			(cl compiledMethodAt: sel) literals do: 				[:m | 				(m isMemberOf: Symbol) ifTrue:  "might be sent"					[m == sel ifFalse: [sent add: m]].				(m isMemberOf: Array) ifTrue:  "might be performed"					[m do: [:x | (x isMemberOf: Symbol) ifTrue:						[x == sel ifFalse: [sent add: x]]]]]]].		"The following may be sent without being in any literal frame"		1 to: self specialSelectorSize do: 			[:index | 			sent add: (self specialSelectorAt: index)]].	^ sent! !!SystemDictionary methodsFor: 'retrieving' stamp: 'di 12/15/1998 21:47'!allUnSentMessagesIn: selectorSet	"Answer the subset of selectorSet which are not sent anywhere in the system.	Factored out from#allUnSentMessages "	|  all |	all _ selectorSet copy.	Cursor execute showWhile: 		[self allBehaviorsDo: 			[:cl | cl selectorsDo: 				[:sel | 				(cl compiledMethodAt: sel) literals do: 					[:lit |					(lit isMemberOf: Symbol)  "might be sent"						ifTrue: [all remove: lit ifAbsent: []].					(lit isMemberOf: Array)  "might be performed"						ifTrue: [lit do:								[:elt |								(elt isMemberOf: Array)									ifTrue: [elt do: [:e | all remove: e ifAbsent: []]]									ifFalse: [all remove: elt ifAbsent: []]]].					]]].		"The following may be sent without being in any literal frame"		1 to: self specialSelectorSize do: 			[:index | 			all remove: (self specialSelectorAt: index) ifAbsent: []]].	^ all! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jm 5/16/2003 10:01'!pointersTo: anObject except: objectsToExclude	"Find all occurrences in the system of pointers to the argument anObject. Remove objects in the exclusion list from the results."	| results anObj |	Smalltalk garbageCollect.	"big collection shouldn't grow, so it's contents array is always the same"	results _ OrderedCollection new: 1000.	"allObjectsDo: is expanded inline to keep spurious	 method and block contexts out of the results"	anObj _ self someObject.	[0 == anObj] whileFalse: [		(anObj pointsTo: anObject) ifTrue: [			"exclude the results collector and contexts in call chain"			((anObj ~~ results collector) and:			 [(anObj ~~ objectsToExclude) and:			 [(anObj ~~ thisContext) and:			 [(anObj ~~ thisContext sender) and:			 [anObj ~~ thisContext sender sender]]]])				 ifTrue: [results add: anObj]].		anObj _ anObj nextObject].	objectsToExclude do: [:obj | results removeAllSuchThat: [:el | el == obj]].	^ results asArray! !!SystemDictionary methodsFor: 'retrieving' stamp: 'jm 10/31/2002 10:43'!unimplemented	"Answer an Array of each message that is sent by an expression in a method but is not implemented by any object in the system."	| all unimplemented entry |	all _ IdentitySet new: Symbol instanceCount * 2.	Cursor wait showWhile: 		[self allBehaviorsDo: [:cl | cl selectorsDo: [:aSelector | all add: aSelector]]].	unimplemented _ IdentityDictionary new.	Cursor execute showWhile: [		self allBehaviorsDo: [:cl |			 cl selectorsDo: [:sel |				(cl compiledMethodAt: sel) messages do: [:m |					(all includes: m) ifFalse: [						entry _ unimplemented at: m ifAbsent: [Array new].						entry _ entry copyWith: (cl name, '>', sel).						unimplemented at: m put: entry]]]]].	"remove some clutter from the results:"	#(DoItIn: primitiveFail uniformWindowColors macOptionKeyAllowed)		do: [:sel | unimplemented removeKey: sel ifAbsent: []].	^ unimplemented! !!SystemDictionary methodsFor: 'class names' stamp: 'di 3/26/2000 09:06'!classNamed: className 	"className is either a class name or a class name followed by ' class'.	Answer the class or metaclass it names"	| meta baseName baseClass |	(className endsWith: ' class')		ifTrue: [meta _ true.				baseName _ className copyFrom: 1 to: className size - 6]		ifFalse: [meta _ false.				baseName _ className].	baseClass _ Smalltalk at: baseName asSymbol ifAbsent: [^ nil].	meta		ifTrue: [^ baseClass class]		ifFalse: [^ baseClass]! !!SystemDictionary methodsFor: 'class names' stamp: 'jm 5/16/2003 09:58'!classNames	"Answer a SortedCollection of all class names."	| names |	cachedClassNames ifNil: [		names _ OrderedCollection new: self size.		self do: [:cl |			((cl isKindOf: Class) and:			 [(cl name beginsWith: 'AnObsolete') not])				ifTrue: [names add: cl name]].		cachedClassNames _ names asSortedCollection].	^ cachedClassNames! !!SystemDictionary methodsFor: 'class names' stamp: 'di 2/16/2000 10:28'!flushClassNameCache	"Smalltalk flushClassNameCache"	"Forse recomputation of the cached list of class names."	cachedClassNames _ nil! !!SystemDictionary methodsFor: 'class names' stamp: 'di 2/3/1999 22:21'!removeClassFromSystem: aClass	"Delete the class, aClass, from the system."	aClass wantsChangeSetLogging ifTrue:		[SystemChanges noteRemovalOf: aClass].	aClass acceptsLoggingOfCompilation ifTrue:		[Smalltalk logChange:  'Smalltalk removeClassNamed: #', aClass name].	self removeClassFromSystemUnlogged: aClass! !!SystemDictionary methodsFor: 'class names' stamp: 'jm 1/1/2004 10:09'!removeClassFromSystemUnlogged: aClass	"Delete the class, aClass, from the system, but log the removal neither to the current change set nor to the changes log"	SystemOrganization removeElement: aClass name.	self removeKey: aClass name ifAbsent: [].	self flushClassNameCache.! !!SystemDictionary methodsFor: 'class names' stamp: 'jm 1/1/2004 10:56'!renameClass: aClass as: newName 	"Rename the class, aClass, to have the title newName."	| oldref |	SystemOrganization classify: newName under: aClass category.	SystemOrganization removeElement: aClass name.	SystemChanges renameClass: aClass as: newName.	oldref _ self associationAt: aClass name.	self removeKey: aClass name.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	self flushClassNameCache.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'wod 11/3/1998 15:41'!abandonSources    "Smalltalk abandonSources"	"Replaces every method by a copy with the 4-byte source pointer 	replaced by a string of all arg and temp names, followed by its length.	These names can then be used to inform the decompiler.  See stats below"	"wod 11/3/1998: zap the organization before rather than after condensing changes."	 | oldCodeString argsAndTemps bTotal bCount oldMethods newMethods m |	(self confirm:  '-- CAUTION --If you have backed up your system andare prepared to face the consequences ofabandoning source code files, hit Yes.If you have any doubts, hit No,to back out with no harm done.')		==  true ifFalse: [^ self inform: 'Okay - no harm done'].	Smalltalk forgetDoIts.	oldMethods _ OrderedCollection new: CompiledMethod instanceCount.	newMethods _ OrderedCollection new: CompiledMethod instanceCount.	bTotal _ 0.  bCount _ 0.	Smalltalk allBehaviorsDo: [: b | bTotal _ bTotal + 1].'Saving temp names for better decompilation...'	displayProgressAt: Sensor cursorPoint	from: 0 to: bTotal	during: [:bar |	Smalltalk allBehaviorsDo:    "for test:  (Array with: Arc with: Arc class) do: "		[:cl |  bar value: (bCount _ bCount + 1).		cl selectors do:			[:selector |			m _ cl compiledMethodAt: selector.			m fileIndex > 0 ifTrue:			[oldCodeString _ cl sourceCodeAt: selector.			argsAndTemps _ (cl compilerClass new				parse: oldCodeString in: cl notifying: nil)				tempNames.			oldMethods addLast: m.			newMethods addLast: (m copyWithTempNames: argsAndTemps)]]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	Smalltalk allBehaviorsDo: [: b | b zapOrganization].	Smalltalk condenseChanges.	Preferences disable: #warnIfNoSourcesFile."In a system with 7780 methods, we got 83k of temp names, or around 100k with spaces between.  The order of letter frequency was eatrnoislcmdgpSub, with about 60k falling in the first 11.  This suggests that we could encode in 4 bits, with 0-11 beng most common chars, and 12-15 contributing 2 bits to the next nibble for 6 bits, enough to cover all alphaNumeric with upper and lower case.  If we get 3/4 in 4 bits and 1/4 in 8, then we get 5 bits per char, or about 38% savings (=38k in this case).Summary: about 13 bytes of temp names per method, or 8 with simple compression, plus 1 for the size.  This would be 5 bytes more than the current 4-byte trailer."! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 11/1/1998 08:31'!abandonTempNames	"Replaces every method by a copy with no source pointer or encoded temp names."	"Smalltalk abandonTempNames"	 | continue oldMethods newMethods n m |	continue _ (self confirm:  '-- CAUTION --If you have backed up your system andare prepared to face the consequences ofabandoning all source code, hit Yes.If you have any doubts, hit No,to back out with no harm done.').	continue ifFalse: [^ self inform: 'Okay - no harm done'].	Smalltalk forgetDoIts; garbageCollect.	oldMethods _ OrderedCollection new.	newMethods _ OrderedCollection new.	n _ 0.	'Removing temp names to save space...'		displayProgressAt: Sensor cursorPoint		from: 0 to: CompiledMethod instanceCount		during: [:bar |			Smalltalk allBehaviorsDo: [:cl |				cl selectors do: [:sel |					bar value: (n _ n + 1).					m _ cl compiledMethodAt: sel.					oldMethods addLast: m.					newMethods addLast: (m copyWithTrailerBytes: #(0))]]].	oldMethods asArray elementsExchangeIdentityWith: newMethods asArray.	Smalltalk closeSourceFiles.	Preferences disable: #warnIfNoChangesFile.	Preferences disable: #warnIfNoSourcesFile.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'TPR 8/5/2000 00:56'!discard3D	"Discard 3D Support.Updated for 2.8 TPR"	Smalltalk removeKey: #WonderlandConstants ifAbsent: [].	Smalltalk removeKey: #AliceConstants ifAbsent: [].	Smalltalk removeKey: #B3DEngineConstants ifAbsent: [].	SystemOrganization removeCategoriesMatching: 'Morphic-Balloon3D'.	SystemOrganization removeCategoriesMatching: 'Balloon3D-*'.	SystemOrganization removeCategoriesMatching: 'Pooh-*'! !!SystemDictionary methodsFor: 'shrinking' stamp: 'TPR 8/5/2000 01:32'!discardFlash	"Discard Flash support."	SystemOrganization removeCategoriesMatching: 'Balloon-MMFlash*'! !!SystemDictionary methodsFor: 'shrinking' stamp: 'TPR 8/3/2000 23:36'!discardMVC   "Smalltalk discardMVC"	| keepers |	Smalltalk isMorphic ifFalse:		[PopUpMenu notify: 'You must be in a Morphic project to discard MVC.'.		^ self].	"Check that there are no MVC Projects"	(Project allInstances inject: true into: [:ok :proj | ok & proj isMorphic]) ifFalse:		[(self confirm: 'Would you like a chance to remove yourMVC projects in an orderly manner?')					ifTrue: [^ self].		(self confirm: 'If you wish, I can remove all MVC projects,make this project be the top project, and placeall orphaned sub-projects of MVC parents here.Would you like be to do thisand proceed to discard all MVC classes?')					ifTrue: [self zapMVCprojects]					ifFalse: [^ self]].	Smalltalk reclaimDependents.	"Remove old Paragraph classes and View classes."	(ChangeSet superclassOrder: Paragraph withAllSubclasses asArray) reverseDo: 		[:c | c removeFromSystem].	(ChangeSet superclassOrder: View withAllSubclasses asArray) reverseDo: 		[:c | c removeFromSystem].	"Get rid of ParagraphEditor's ScrollController dependence"	#(markerDelta viewDelta scrollAmount scrollBar computeMarkerRegion) do:			[:sel | ParagraphEditor removeSelector: sel].	ParagraphEditor compile: 'updateMarker'.	ParagraphEditor superclass: MouseMenuController .	"Get rid of all Controller classes not needed by ParagraphEditor and ScreenController"	keepers _ TextMorphEditor withAllSuperclasses copyWith: ScreenController.	(ChangeSet superclassOrder: Controller withAllSubclasses asArray) reverseDo: 		[:c | (keepers includes: c) ifFalse: [c removeFromSystem]].	SystemOrganization removeCategoriesMatching: 'ST80-Paths'.	SystemOrganization removeCategoriesMatching: 'ST80-Pluggable Views'.	Smalltalk removeClassNamed: 'FormButtonCache'.	Smalltalk removeClassNamed: 'WindowingTransformation'.	Smalltalk removeClassNamed: 'ControlManager'.	Smalltalk removeClassNamed: 'DisplayTextView'.	ScheduledControllers _ nil.	Undeclared removeUnreferencedKeys.	SystemOrganization removeEmptyCategories.	Symbol rehash.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 10/5/2002 07:12'!discardMorphic   "Smalltalk discardMorphic"	"Discard Morphic.Updated for 2.8 TPR"	| subs |	"Check that we are in an MVC Project and that there are no Morphic Projects		or WorldMorphViews."	Smalltalk discardFlash.	Smalltalk discardTrueType.	subs _ OrderedCollection new.	Morph allSubclassesWithLevelDo: [:c :i | subs addFirst: c]		startingLevel: 0.	subs do: [:c | c removeFromSystem].	Smalltalk removeClassNamed: #CornerRounder.	Smalltalk removeKey: #BalloonEngineConstants ifAbsent: [].	SystemOrganization removeCategoriesMatching: 'Balloon-*'.	SystemOrganization removeCategoriesMatching: 'Morphic-*'.	SystemOrganization removeSystemCategory: 'Graphics-Transformations'.	SystemOrganization removeSystemCategory: 'ST80-Morphic'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'TPR 8/3/2000 19:48'!discardNetworking	"Discard the support for TCP/IP networking."	Smalltalk discardPluggableWebServer.	SystemOrganization removeCategoriesMatching: 'Network-*'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 6/15/2003 20:17'!discardOddsAndEnds	"This method throws out lots of classes that are not frequently used."	"Smalltalk discardOddsAndEnds"	SystemOrganization removeSystemCategory: 'System-Serial Port'.	SystemOrganization removeSystemCategory: 'ST80-Symbols'.	SystemOrganization removeSystemCategory: 'Tools-File Contents Browser'.	SystemOrganization removeSystemCategory: 'System-Compression'.	SystemOrganization removeSystemCategory: 'Tools-Explorer'.	SystemOrganization removeSystemCategory: 'System-Digital Signatures'.	Smalltalk at: #FormView ifPresent:		[:c | c compile: 'defaultControllerClass  ^ NoController'			classified: 'controller access'].	Smalltalk removeClassNamed: #FormEditorView.	Smalltalk removeClassNamed: #FormEditor.	SystemOrganization removeSystemCategory: 'ST80-Paths'.	"bit editor (remove Form editor first):"	Form removeSelector: #bitEdit.	Form removeSelector: #bitEditAt:scale:.	StrikeFont removeSelector: #edit:.	Smalltalk removeClassNamed: #FormButtonCache.	Smalltalk removeClassNamed: #FormMenuController.	Smalltalk removeClassNamed: #FormMenuView.	Smalltalk removeClassNamed: #BitEditor.	"inspector for Dictionaries of Forms"	Dictionary removeSelector: #inspectFormsWithLabel:.	SystemDictionary removeSelector: #viewImageImports.	ScreenController removeSelector: #viewImageImports.	Smalltalk removeClassNamed: #FormHolderView.	Smalltalk removeClassNamed: #FormInspectView.	"experimental hand-drawn character recoginizer:"	ParagraphEditor removeSelector: #recognizeCharacters.	ParagraphEditor removeSelector: #recognizer:.	ParagraphEditor removeSelector: #recognizeCharactersWhileMouseIn:.	Smalltalk removeClassNamed: #CharRecog.	"experimental updating object viewer:"	Object removeSelector: #evaluate:wheneverChangeIn:.	Smalltalk removeClassNamed: #ObjectViewer.	Smalltalk removeClassNamed: #ObjectTracer.	"miscellaneous classes:"	Smalltalk removeClassNamed: #Array2D.	Smalltalk removeClassNamed: #DriveACar.	Smalltalk removeClassNamed: #EventRecorder.	Smalltalk removeClassNamed: #FindTheLight.	Smalltalk removeClassNamed: #PluggableTest.	Smalltalk removeClassNamed: #SystemMonitor.	Smalltalk removeClassNamed: #DocLibrary.	Smalltalk removeClassNamed: #ProtocolBrowser.	Smalltalk removeClassNamed: #ObjectExplorerWrapper.	Smalltalk removeClassNamed: #HierarchyBrowser.	Smalltalk removeClassNamed: #LinkedMessageSet.	Smalltalk removeClassNamed: #ObjectExplorer.	Smalltalk removeClassNamed: #PackageBrowser.	Smalltalk removeClassNamed: #AbstractHierarchicalList.	Smalltalk removeClassNamed: #ChangeList.	Smalltalk removeClassNamed: #VersionsBrowser.	Smalltalk removeClassNamed: #ChangeRecord.	Smalltalk removeClassNamed: #SelectorBrowser.	Smalltalk removeClassNamed: #HtmlFileStream.	Smalltalk removeClassNamed: #CrLfFileStream.	Smalltalk removeClassNamed: #FXGrafPort.	Smalltalk removeClassNamed: #FXBlt.	Smalltalk at: #SampledSound ifPresent: [:c |c initialize].	#(Helvetica Palatino Courier ComicBold ComicPlain) do:		[:k | TextConstants removeKey: k ifAbsent: []].Preferences setButtonFontTo:	(StrikeFont familyName: #NewYork size: 12).#(GZipConstants ZipConstants KlattResonatorIndices ) do:	[:k | Smalltalk removeKey: k ifAbsent: []].! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 6/7/2001 15:48'!discardPluggableWebServer	"Discard the Pluggable Web Server."	SystemOrganization removeCategoriesMatching: 'Network-Pluggable Web Server'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'TPR 8/3/2000 19:21'!discardSoundSynthesis	"Discard the sound synthesis facilities, and the methods and classes that use it. This also discards MIDI."	Smalltalk discardMIDI.	Smalltalk discardSpeech.	SystemOrganization removeCategoriesMatching: 'Sound-Interface'.	Smalltalk at: #GraphMorph ifPresent: [:graphMorph |		#(playOnce readDataFromFile)			do: [:sel | graphMorph removeSelector: sel]].	Smalltalk at: #TrashCanMorph ifPresent: [:trashMorph |		trashMorph class removeSelector: #samplesForDelete.		trashMorph class removeSelector: #samplesForMouseEnter.		trashMorph class removeSelector: #samplesForMouseLeave].	SystemOrganization removeCategoriesMatching: 'Sound-Synthesis'.	SystemOrganization removeCategoriesMatching: 'Sound-Scores'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'TPR 8/3/2000 19:21'!discardSpeech	"Discard support for speech synthesis"	SystemOrganization removeCategoriesMatching: 'Speech*'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'TPR 8/5/2000 01:32'!discardTrueType	"Discard TrueType support."	SystemOrganization removeCategoriesMatching: 'Balloon-TrueType*'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 1/12/2000 13:05'!lastRemoval  "Smalltalk lastRemoval" 	#(abandonSources browseAllSelect: printSpaceAnalysis browseObsoleteReferences  lastRemoval) do:		[:sel | SystemDictionary removeSelector: sel].	[self removeAllUnSentMessages > 0] whileTrue.	Set withAllSubclassesDo:		[:cls | cls allInstances do: [:s | s rehash]].	Smalltalk allClassesDo: [:c | c zapOrganization].	Smalltalk changes initialize.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'jm 10/30/2002 20:44'!majorShrink    "Smalltalk majorShrink; abandonSources; lastRemoval"	"This method throws out lots of the system that is not needed for, eg, operation in a hand-held PC.  majorShrink produces a 999k image in Squeak 2.8"	Smalltalk isMorphic ifTrue: [^ self error: 'You can only run majorShrink in MVC'].	Project current isTopProject ifFalse: [^ self error: 'You can only run majorShrink in the top project'].	(Smalltalk confirm: 'All sub-projects will be deleted from this image.You should already have made a backup copy,or you must save with a different name after shrinking.Shall we proceed to discard most of the content in this image?')		ifFalse: [^ PopUpMenu notify: 'No changes have been made.'].	"Remove all projects but the current one.  - saves 522k"	ProjectView allInstancesDo: [:pv | pv controller closeAndUnscheduleNoTerminate].	Project current setParent: Project current.	MorphWorldView allInstancesDo: [:pv | pv topView controller closeAndUnscheduleNoTerminate].	Utilities classPool at: #ScrapsBook put: nil.	Smalltalk discardSoundSynthesis.  "544k"	Smalltalk discardOddsAndEnds.  "227k"	Smalltalk discardNetworking.  "234k"	Smalltalk discard3D.  "407k"	Smalltalk discardMorphic.  "1372k"	Symbol rehash.  "40k"	"Above by itself saves about 4,238k"	"Remove references to a few classes to be deleted, so that they won't leave obsolete versions around."	FileList removeSelector: #fileIntoNewChangeSet.	ChangeSet class compile: 'defaultName		^ ''Changes'' ' classified: 'initialization'.	ScreenController removeSelector: #openChangeManager.	ScreenController removeSelector: #exitProject.	ScreenController removeSelector: #openProject.	ScreenController removeSelector: #viewImageImports.	"Now delete various other classes.."	SystemOrganization removeSystemCategory: 'Graphics-Files'.	SystemOrganization removeSystemCategory: 'System-Object Storage'.	Smalltalk removeClassNamed: #ProjectController.	Smalltalk removeClassNamed: #ProjectView.	"Smalltalk removeClassNamed: #Project."	Smalltalk removeClassNamed: #Environment.	Smalltalk removeClassNamed: #Component1.	Smalltalk removeClassNamed: #FormSetFont.	Smalltalk removeClassNamed: #FontSet.	Smalltalk removeClassNamed: #InstructionPrinter.	Smalltalk removeClassNamed: #ChangeSorter.	Smalltalk removeClassNamed: #DualChangeSorter.	Smalltalk removeClassNamed: #EmphasizedMenu.	Smalltalk removeClassNamed: #MessageTally.	StringHolder class removeSelector: #originalWorkspaceContents.	CompiledMethod removeSelector: #symbolic.	RemoteString removeSelector: #makeNewTextAttVersion.	Utilities class removeSelector: #absorbUpdatesFromServer.	Smalltalk removeClassNamed: #PenPointRecorder.	Smalltalk removeClassNamed: #Path.	Smalltalk removeClassNamed: #Base64MimeConverter.	Smalltalk removeClassNamed: #RWBinaryOrTextStream.	Smalltalk removeClassNamed: #AttributedTextStream.	Smalltalk removeClassNamed: #WordNet.	Smalltalk removeClassNamed: #SelectorBrowser.	TextStyle allSubInstancesDo:		[:ts | ts newFontArray: (ts fontArray copyFrom: 1 to: (2 min: ts fontArray size))].	ListParagraph initialize.	PopUpMenu initialize.	StandardSystemView initialize.	Smalltalk noChanges.	ChangeSorter classPool at: #AllChangeSets 		put: (OrderedCollection with: Smalltalk changes).	SystemDictionary removeSelector: #majorShrink.	[Smalltalk removeAllUnSentMessages > 0]		whileTrue:		[Smalltalk unusedClasses do: [:c | (Smalltalk at: c) removeFromSystem]].	SystemOrganization removeEmptyCategories.	Smalltalk allClassesDo: [:c | c zapOrganization].	MethodDictionary allInstances do: [:d | d rehash].	Smalltalk changes initialize.	Symbol rehash.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:33'!printSpaceAnalysis	"Smalltalk printSpaceAnalysis"	^ Smalltalk printSpaceAnalysis: 0 on: 'STspace.text'! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/26/1999 11:32'!printSpaceAnalysis: threshold on: fileName	"Smalltalk printSpaceAnalysis: 1000 on: 'STspace.text0'"	"If threshold > 0, then only those classes with more than that number	of instances will be shown, and they will be sorted by total instance space.	If threshold = 0, then all classes will appear, sorted by name."	| f codeSpace instCount instSpace totalCodeSpace totalInstCount totalInstSpace eltSize n stats totalPercent percent |	Smalltalk garbageCollect.	totalCodeSpace _ totalInstCount _ totalInstSpace _ n _ 0.	stats _ OrderedCollection new.'Taking statistics...'	displayProgressAt: Sensor cursorPoint	from: 0 to: self classNames size	during: [:bar |	self allClassesDo:		[:cl | codeSpace _ cl spaceUsed.		bar value: (n _ n+1).		Smalltalk garbageCollectMost.		instCount _ cl instanceCount.		instSpace _ (cl indexIfCompact > 0 ifTrue: [4] ifFalse: [8])*instCount. "Object headers"		cl isVariable			ifTrue: [eltSize _ cl isBytes ifTrue: [1] ifFalse: [4].					cl allInstancesDo: [:x | instSpace _ instSpace + (x basicSize*eltSize)]]			ifFalse: [instSpace _ instSpace + (cl instSize*instCount*4)].		stats add: (Array with: cl name with: codeSpace) , (Array with: instCount with: instSpace).		totalCodeSpace _ totalCodeSpace + codeSpace.		totalInstCount _ totalInstCount + instCount.		totalInstSpace _ totalInstSpace + instSpace]].	totalPercent _ 0.0.	f _ FileStream newFileNamed: fileName.	f timeStamp.	f nextPutAll: ('Class' padded: #right to: 30 with: $ );			nextPutAll: ('code space' padded: #left to: 12 with: $ );			nextPutAll: ('# instances' padded: #left to: 12 with: $ );			nextPutAll: ('inst space' padded: #left to: 12 with: $ );			nextPutAll: ('percent' padded: #left to: 8 with: $ ); cr.	threshold > 0 ifTrue:		["If inst count threshold > 0, then sort by space"		stats _ (stats select: [:s | s third >= threshold or: [s fourth > (totalInstSpace // 500)]])				asSortedCollection: [:s :s2 | s fourth > s2 fourth]].	stats do:		[:s | f nextPutAll: (s first padded: #right to: 30 with: $ );			nextPutAll: (s second printString padded: #left to: 12 with: $ );			nextPutAll: (s third printString padded: #left to: 12 with: $ );			nextPutAll: (s fourth printString padded: #left to: 14 with: $ ).		percent _ s fourth*100.0/totalInstSpace roundTo: 0.1.		totalPercent _ totalPercent + percent.		percent >= 0.1 ifTrue:			[f nextPutAll: (percent printString padded: #left to: 8 with: $ )].		f cr].	f cr; nextPutAll: ('Total' padded: #right to: 30 with: $ );		nextPutAll: (totalCodeSpace printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstCount printString padded: #left to: 12 with: $ );		nextPutAll: (totalInstSpace printString padded: #left to: 14 with: $ );		nextPutAll: ((totalPercent roundTo: 0.1) printString padded: #left to: 8 with: $ ).	f close! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 6/20/1998 12:37'!printSpaceDifferenceFrom: fileName1 to: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk printSpaceDifferenceFrom: 'STspace.text1' to: 'STspace.text2'"	| f coll1 coll2 item |	f _ FileStream oldFileNamed: fileName1.	coll1 _ OrderedCollection new.	[f atEnd] whileFalse: [coll1 add: (f upTo: Character cr)].	f close.	f _ FileStream oldFileNamed: fileName2.	coll2 _ OrderedCollection new.	[f atEnd] whileFalse:		[item _ (f upTo: Character cr).		((coll1 includes: item) and: [(item endsWith: 'percent') not])			ifTrue: [coll1 remove: item]			ifFalse: [coll2 add: item]].	f close.	(StringHolder new contents: (String streamContents: 			[:s | 			s nextPutAll: fileName1; cr.			coll1 do: [:x | s nextPutAll: x; cr].			s cr; cr.			s nextPutAll: fileName2; cr.			coll2 do: [:x | s nextPutAll: x; cr]]))		openLabel: 'Differential Space Analysis'.! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 8/16/2000 14:20'!removeAllUnSentMessages   "Smalltalk removeAllUnSentMessages"	"[Smalltalk unusedClasses do: [:c | (Smalltalk at: c) removeFromSystem].		Smalltalk removeAllUnSentMessages > 0] whileTrue." 	"Remove all implementations of unsent messages."	| sels n |	sels _ self allUnSentMessages.	"The following should be preserved for doIts, etc"	#(browseAllSelect: printSpaceAnalysis lastRemoval		scrollBarValue: scrollBarMenuButtonPressed: 		withSelectionFrom:  to: removeClassNamed:		dragon: hilberts: mandala: web test3 factorial tinyBenchmarks benchFib		newDepth: restoreAfter: forgetDoIts zapAllMethods obsoleteClasses		removeAllUnSentMessages abandonSources removeUnreferencedKeys		reclaimDependents zapOrganization condenseChanges browseObsoleteReferences		subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:		methodsFor:stamp: methodsFor:stamp:prior: instanceVariableNames:		startTimerInterruptWatcher unusedClasses) do:		[:sel | sels remove: sel ifAbsent: []].	"The following may be sent by perform: in dispatchOnChar..."	(ParagraphEditor classPool at: #CmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	(ParagraphEditor classPool at: #ShiftCmdActions) asSet do:		[:sel | sels remove: sel ifAbsent: []].	sels size = 0 ifTrue: [^ 0].	n _ 0. Smalltalk allBehaviorsDo: [:x | n _ n+1].	'Removing ', sels size printString , ' messages . . .'		displayProgressAt: Sensor cursorPoint		from: 0 to: n		during:		[:bar |		n _ 0.		self allBehaviorsDo:			[:class | bar value: (n _ n+1).			sels do:				[:sel | class removeSelectorSimply: sel]]].	^ sels size! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 4/20/1999 12:24'!unusedClasses	"Warning: Slow!! Enumerates all classes in the system and returns a list of those that are apparently unused. A class is considered in use if it (a) has subclasses (b) has instances or (c) is referred to by some method. Obsolete classes are not included in this list."	"Smalltalk unusedClasses"	| unused c n |	unused _ SortedCollection new.'Scanning for unused classes...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Metaclass instanceCount	during: [:bar | n _ 0.	Metaclass allInstancesDo: [:meta | bar value: (n _ n+1).		c _ meta soleInstance.		((c ~~ nil) and:		 [('AnOb*' match: c name asString) not]) ifTrue: [			((c subclasses size = 0) and:			 [(c inheritsFrom: FileDirectory) not & (c instanceCount = 0) and:			 [(Smalltalk includesKey: c name) and: [(Smalltalk allCallsOn: (Smalltalk associationAt: c name)) size = 0]]])				ifTrue: [unused add: c name]]]].	^ unused asArray! !!SystemDictionary methodsFor: 'shrinking' stamp: 'di 9/26/1999 21:44'!zapMVCprojects   "Smalltalk zapMVCprojects"	| window |	Smalltalk garbageCollect.  "So allInstances is precise"	Project allSubInstancesDo:		[:proj |		proj isTopProject		ifTrue: [proj isMorphic ifFalse:					["Root project is MVC -- we must become the root"					Project current setParent: Project current]]		ifFalse: [proj parent isMorphic				ifFalse: [proj isMorphic ifTrue:							["Remove Morphic projects from MVC views"							"... and add them back here."							window _ (SystemWindow labelled: proj name) model: proj.							window addMorph: (ProjectViewMorph on: proj)									frame: (0@0 corner: 1.0@1.0).							window openInWorld.							proj setParent: Project current]].				proj isMorphic					ifFalse: ["Remove MVC projects from Morphic views"							Project allInstancesDo: [:p | p deletingProject: proj].							ProjectViewMorph allInstancesDo: [:p | p deletingProject: proj]]]		]! !!SystemDictionary methodsFor: 'memory space' stamp: 'jm 10/14/2002 18:53'!lowSpaceThreshold 	"Return the low space threshold. When the amount of free memory (after garbage collection) falls below this limit, the system is in serious danger of completely exhausting memory and crashing. This limit should be made high enough to allow the user open a debugger to diagnose a problem or to save the image."	^ 250000! !!SystemDictionary methodsFor: 'memory space' stamp: 'jm 10/4/2002 11:00'!lowSpaceWatcher	"Wait until the low space semaphore is signalled, then take appropriate actions."	self garbageCollectMost <= self lowSpaceThreshold ifTrue: [		self garbageCollect <= self lowSpaceThreshold ifTrue: [			"free space must be above threshold before starting low space watcher"			^ self beep]].	LowSpaceSemaphore _ Semaphore new.	self primLowSpaceSemaphore: LowSpaceSemaphore.	self primSignalAtBytesLeft: self lowSpaceThreshold.  "enable low space interrupts"	LowSpaceSemaphore wait.  "wait for a low space condition..."	self primSignalAtBytesLeft: 0.  "disable low space interrupts"	self primLowSpaceSemaphore: nil.	LowSpaceProcess _ nil.	"Note: user is now unprotected until the low space watcher is re-installed"	Smalltalk isMorphic		ifTrue: [Project current interruptName: 'Space is low']		ifFalse: [ScheduledControllers interruptName: 'Space is low'].! !!SystemDictionary methodsFor: 'memory space' stamp: 'di 8/18/2000 21:15'!useUpMemoryWithArrays 	"For testing the low space handler..."	"Smalltalk installLowSpaceWatcher; useUpMemoryWithArrays"	| b |  "First use up most of memory."	b _ String new: self bytesLeft - self lowSpaceThreshold - 100000.	b _ b.  "Avoid unused value warning"	(1 to: 10000) collect: [:i | Array new: 10000]! !!SystemDictionary methodsFor: 'memory space' stamp: 'di 8/18/2000 16:49'!useUpMemoryWithContexts 	"For testing the low space handler..."	"Smalltalk installLowSpaceWatcher; useUpMemoryWithContexts"	self useUpMemoryWithContexts! !!SystemDictionary methodsFor: 'memory space' stamp: 'di 8/18/2000 16:50'!useUpMemoryWithTinyObjects 	"For testing the low space handler..."	"Smalltalk installLowSpaceWatcher; useUpMemoryWithTinyObjects"	| b |  "First use up most of memory."	b _ String new: self bytesLeft - self lowSpaceThreshold - 100000.	b _ b.  "Avoid unused value warning"	(1 to: 10000) collect: [:i | BitBlt new]! !!SystemDictionary methodsFor: 'special objects' stamp: 'JMM 6/6/2000 20:36'!clearExternalObjects	"Clear the array of objects that have been registered for use in non-Smalltalk code."	"Smalltalk clearExternalObjects"	ExternalSemaphoreTable clearExternalObjects! !!SystemDictionary methodsFor: 'special objects' stamp: 'JMM 6/6/2000 21:01'!externalObjects	"Return an array of objects that have been registered for use in non-Smalltalk code. Smalltalk objects should be referrenced by external code only via indirection through this array, thus allowing the objects to move during compaction. This array can be cleared when the VM re-starts, since variables in external code do not survive snapshots. Note that external code should not attempt to access a Smalltalk object, even via this mechanism, while garbage collection is in progress."	"Smalltalk externalObjects"	^ ExternalSemaphoreTable externalObjects! !!SystemDictionary methodsFor: 'special objects' stamp: 'jm 10/7/2002 05:33'!recreateSpecialObjectsArray    "Smalltalk recreateSpecialObjectsArray"	"The Special Objects Array is an array of object pointers used by the Smalltalk virtual machine.  Its contents are critical and unchecked, so don't even think of playing here unless you know what you are doing."	| newArray |	newArray _ Array new: 48.	"Nil false and true get used throughout the interpreter"	newArray at: 1 put: nil.	newArray at: 2 put: false.	newArray at: 3 put: true.	"This association holds the active process (a ProcessScheduler)"	newArray at: 4 put: (Smalltalk associationAt: #Processor).	"Numerous classes below used for type checking and instantiation"	newArray at: 5 put: Bitmap.	newArray at: 6 put: SmallInteger.	newArray at: 7 put: String.	newArray at: 8 put: Array.	newArray at: 9 put: Smalltalk. 	newArray at: 10 put: Float.	newArray at: 11 put: MethodContext.	newArray at: 12 put: BlockContext.	newArray at: 13 put: Point.	newArray at: 14 put: LargePositiveInteger.	newArray at: 15 put: Display.	newArray at: 16 put: Message.	newArray at: 17 put: CompiledMethod.	newArray at: 18 put: (self specialObjectsArray at: 18)  "(low space Semaphore)".	newArray at: 19 put: Semaphore.	newArray at: 20 put: Character.	newArray at: 21 put: #doesNotUnderstand:.	newArray at: 22 put: #cannotReturn:.	newArray at: 23 put: nil.  "*unused*"	"An array of the 32 selectors that are compiled as special bytecodes,	paired alternately with the number of arguments each takes."	newArray at: 24 put: #(+ 1 - 1 < 1 > 1 <= 1 >= 1 = 1 ~= 1 * 1 / 1 \\ 1 @ 1 bitShift: 1 // 1 bitAnd: 1 bitOr: 1 at: 1 at:put: 2 size 0 next 0 nextPut: 1 atEnd 0 == 1 class 0 blockCopy: 1 value 0 value: 1 do: 1 new 0 new: 1 x 0 y 0 ).	"An array of the 255 Characters in ascii order."	newArray at: 25 put: ((0 to: 255) collect: [:ascii | Character value: ascii]).	newArray at: 26 put: #mustBeBoolean.	newArray at: 27 put: ByteArray.	newArray at: 28 put: Process.	"An array of up to 31 classes whose instances will have compact headers"	newArray at: 29 put: self compactClassesArray.	newArray at: 30 put: (self specialObjectsArray at: 30)   "(delay Semaphore)".	newArray at: 31 put: (self specialObjectsArray at: 31)   "(user input Semaphore)".	"Prototype instances that can be copied for fast initialization"	newArray at: 32 put: (Float new: 2).	newArray at: 33 put: (LargePositiveInteger new: 4).	newArray at: 34 put: Point new.	newArray at: 35 put: #cannotInterpret:.	"Note: This must be fixed once we start using context prototypes"	newArray at: 36 put: (self specialObjectsArray at: 36). 						"(MethodContext new: CompiledMethod fullFrameSize)."	newArray at: 37 put: nil.	newArray at: 38 put: (self specialObjectsArray at: 38). 						"(BlockContext new: CompiledMethod fullFrameSize)."	newArray at: 39 put: Array new.  "array of objects referred to by external code"	newArray at: 40 put: nil.  "was PseudoContext"	newArray at: 41 put: nil.  "was TranslatedMethod"	"finalization Semaphore"	newArray at: 42 put: ((self specialObjectsArray at: 42) ifNil:[Semaphore new]).	newArray at: 43 put: LargeNegativeInteger.	"External objects for callout.	Note: Written so that one can actually completely remove the FFI."	newArray at: 44 put: (Smalltalk at: #ExternalAddress ifAbsent:[nil]).	newArray at: 45 put: (Smalltalk at: #ExternalStructure ifAbsent:[nil]).	newArray at: 46 put: (Smalltalk at: #ExternalData ifAbsent:[nil]).	newArray at: 47 put: (Smalltalk at: #ExternalFunction ifAbsent:[nil]).	newArray at: 48 put: (Smalltalk at: #ExternalLibrary ifAbsent:[nil]).	"Now replace the interpreter's reference in one atomic operation"	self specialObjectsArray become: newArray! !!SystemDictionary methodsFor: 'special objects' stamp: 'JMM 6/6/2000 20:39'!registerExternalObject: anObject	"Register the given object in the external objects array and return its index. If it is already there, just return its index."	^ExternalSemaphoreTable registerExternalObject: anObject! !!SystemDictionary methodsFor: 'special objects' stamp: 'JMM 6/6/2000 20:40'!unregisterExternalObject: anObject	"Unregister the given object in the external objects array. Do nothing if it isn't registered."	ExternalSemaphoreTable unregisterExternalObject: anObject! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'jm 5/31/2003 17:08'!aboutThisSystem 	"Identify software version"	^ self inform: self systemInformationString! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'di 2/11/2000 17:23'!assureStartupStampLogged	"If there is a startup stamp not yet actually logged to disk, do it now."	| changesFile |	StartupStamp ifNil: [^ self].	(SourceFiles isNil or: [(changesFile _ SourceFiles at: 2) == nil]) ifTrue: [^ self].	changesFile setToEnd; cr; cr.	changesFile nextChunkPut: StartupStamp asString; cr.	StartupStamp _ nil.	self forceChangesToDisk.! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'sw 2/15/1999 16:32'!currentChangeSetString	"Smalltalk currentChangeSetString"	^ 'Current Change Set: ', self changes name! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'JMM 8/10/2000 15:15'!externalizeSources   	"Write the sources and changes streams onto external files." 	"Smalltalk externalizeSources"	| sourcesName changesName aFile |	sourcesName _ self sourcesName.	(FileDirectory default fileExists: sourcesName)		ifTrue: [^ self inform:'Sorry, you must first move or remove thefile named ', sourcesName].	changesName _ self changesName.	(FileDirectory default fileExists: changesName)		ifTrue: [^ self inform:'Sorry, you must first move or remove thefile named ', changesName].	aFile _  FileStream newFileNamed: sourcesName.	aFile nextPutAll: SourceFiles first originalContents.	aFile close.	"On Mac, set the file type and creator (noop on other platforms)"	FileDirectory default		setMacFileNamed: sourcesName		type: 'STch'		creator: 'FAST'.	SourceFiles at: 1 put: (FileStream readOnlyFileNamed: sourcesName).	aFile _ FileStream newFileNamed: self changesName.	aFile nextPutAll: SourceFiles last contents.	aFile close.	"On Mac, set the file type and creator (noop on other platforms)"	FileDirectory default		setMacFileNamed: self changesName		type: 'STch'		creator: 'FAST'.	SourceFiles at: 2 put: (FileStream oldFileNamed: changesName).	self inform: 'Sources successfully externalized'.! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'jm 12/3/2003 11:12'!isBigEndian	"Answer true if the underlying processor is 'big-endian.' A big-endian processor stores the most significant byte of a 32-bit integer first when accessing memory as a sequence of bytes. A little-endian processor stores the least-significant byte first."	"Details: Use BitBlt to copy the integer '1' from a Bitmap (i.e., a 32-bit word array) into a ByteArray. On a big-endian machine, the 1 will be in the first byte of the ByteArray. On a little-endian machine, it will be in the last byte."	"Smalltalk isBigEndian"	| src dstBytes dst |	src _ Form extent: 4@1 depth: 8.	src bits at: 1 put: 1.	dstBytes _ ByteArray withAll: #(0 0 0 0).	dst _ Form new hackBits: dstBytes.	(BitBlt toForm: dst) copyForm: src to: 0@0 rule: Form over.	^ dstBytes last = 1! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'sma 2/12/2000 12:42'!lastUpdateString	"Smalltalk lastUpdateString"	| aNumber |	aNumber _ (Smalltalk		at: #ChangeSorter		ifAbsent: [^ 'Update # unknown']) highestNumberedChangeSet.	^ (aNumber notNil and: [aNumber > 0])		ifTrue: ['latest update: #' , aNumber printString]		ifFalse: ['No updates present.']! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'sw 2/12/1999 17:18'!logChange: aStringOrText 	"Write the argument, aString, onto the changes file."	| aString changesFile |	(SourceFiles isNil or: [(SourceFiles at: 2) == nil]) ifTrue: [^ self].	self assureStartupStampLogged.	aStringOrText isText		ifTrue: [aString _ aStringOrText string]		ifFalse: [aString _ aStringOrText].	(aString isMemberOf: String)		ifFalse: [self error: 'can''t log this change'].	(aString findFirst: [:char | char isSeparator not]) = 0		ifTrue: [^ self].  "null doits confuse replay"	(changesFile _ SourceFiles at: 2) setToEnd; cr; cr.	changesFile nextChunkPut: aString.		"If want style changes in DoIt, use nextChunkPutWithStyle:, and allow Texts to get here"	self forceChangesToDisk.! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'jm 10/7/2002 06:34'!newChanges: aChangeSet 	"Set the system ChangeSet to be the argument, aChangeSet. Tell the current project that aChangeSet is now its change set. When called from Project enter:, the setChangeSet: call is redundant but harmless; when called from code that changes the current change set from within a project, it's vital"	SystemChanges _ aChangeSet.	"following code still works after removal of Projects:"	Smalltalk at: #Project ifPresent:		[:projClass | projClass current setChangeSet: aChangeSet].! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'di 4/28/2000 13:01'!openSourceFiles	self imageName = LastImageName ifFalse:		["Reset the author initials to blank when the image gets moved"		LastImageName _ self imageName.		Utilities setAuthorInitials: ''].	FileDirectory		openSources: self sourcesName		andChanges: self changesName		forImage: LastImageName.	StandardSourceFileArray install! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'jm 5/31/2003 17:08'!systemInformationString	"Identify the Squeak image version."	"Smalltalk systemInformationString"	^ self version, String cr, self currentChangeSetString! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'sw 9/27/1999 10:41'!timeStamp: aStream 	"Writes system version and current time on stream aStream."	| dateTime |	dateTime _ Time dateAndTimeNow.	aStream nextPutAll: 'From ', Smalltalk version, ' [', Smalltalk lastUpdateString, '] on ', (dateTime at: 1) printString,						' at ', (dateTime at: 2) printString! !!SystemDictionary methodsFor: 'sources, change log' stamp: 'jm 5/31/2003 17:07'!version	"Answer the version of this release."	"VersionString _ 'MIT Squeak 0.9.4 (June 1, 2003)'"	^ VersionString! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'sma 4/30/2000 09:17'!isMorphic	"Answer true if the user interface is running in Morphic rathern than 	MVC.  By convention the gloabl variable World is set to nil when MVC is 	running.  ScheduledControllers could be set to nil when Morphic is 	running, but this symmetry is not yet in effect."	^ World ~~ nil! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jm 1/1/2004 10:22'!processShutDownList	"Send #shutDown to each class that needs to do something when starting up."	#(		SoundPlayer		Delay		FileDirectory		Color		StrikeFont		ControlManager		Form		DisplayScreen	) do: [:cName |		Smalltalk at: cName ifPresent: [:cl | cl shutDown]].! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jm 1/1/2004 10:17'!processStartUpList	"Send #startUp to each class that needs to do something when starting up."	#(		DisplayScreen		Cursor		InputSensor		ProcessorScheduler		Delay		FileDirectory		CrLfFileStream		ControlManager		PasteUpMorph	) do: [:cName |		Smalltalk at: cName ifPresent: [:cl | cl startUp]].! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jm 5/31/2003 16:09'!readDocumentFile	"Hook for starting up an application by double-clicking."	StartupStamp _ '----STARTUP----', Time dateAndTimeNow printString, ' as ', Smalltalk imageName.! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jm 11/14/2003 10:47'!saveAs	| dir newName newImageName newChangesName |	dir _ FileDirectory default.	newName _ FillInTheBlank		request: 'New File Name?'		initialAnswer: (FileDirectory localNameFor: self imageName).	newName = '' ifTrue: [^self].	newName _ FileDirectory baseNameFor: newName asFileName.	newImageName _ newName, '.image'.	newChangesName _ newName, '.changes'.	((dir includesKey: newImageName) or:	 [dir includesKey: newChangesName]) ifTrue: [		^ self notify: newName, ' is already in use.Please choose another name.'].	dir copyFileNamed: self changesName toFileNamed: newChangesName.		"On Mac, set the file type and creator (noop on other platforms)"	FileDirectory default		setMacFileNamed: newChangesName		type: 'STch'		creator: 'FAST'.	self logChange: '----SAVEAS ', newName, '----', Date dateAndTimeNow printString.	self imageName: (dir fullNameFor: newImageName).	LastImageName _ self imageName.	self closeSourceFiles; openSourceFiles.  "so SNAPSHOT appears in new changes file"	self snapshot: true andQuit: false.! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jm 6/7/1999 21:33'!setGCParameters	"Adjust the VM's default GC parameters to avoid premature tenuring."	Smalltalk vmParameterAt: 5 put: 4000.  "do an incremental GC after this many allocations"	Smalltalk vmParameterAt: 6 put: 2000.  "tenure when more than this many objects survive the GC"! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'jm 1/1/2004 10:27'!snapshot: save andQuit: quit	"Mark the changes file and close all files. If save is true, save the current state of this Smalltalk in the image file. If quit is true, then exit to the outer shell. The latter part of this method runs when resuming a previously saved image. The resume logic checks for a document file to process when starting up."	| resuming msg sourceLink |	save & (SourceFiles at: 2) notNil ifTrue:		[msg _  (quit			ifTrue: ['----QUIT----']			ifFalse: ['----SNAPSHOT----'])			, Date dateAndTimeNow printString.		sourceLink _ ' priorSource: ' , LastQuitLogPosition printString.		self assureStartupStampLogged.		LastQuitLogPosition _ (SourceFiles at: 2) setToEnd; position.		self logChange: msg , sourceLink.		Transcript cr; show: msg].	self processShutDownList.	Cursor write show.	save		ifTrue: [resuming _ self snapshotPrimitive]  "<-- PC frozen here on image file"		ifFalse: [resuming _ false].	quit & resuming not ifTrue: [self quitPrimitive].	Cursor normal show.	self setGCParameters.	resuming ifTrue: [self clearExternalObjects].	self processStartUpList.	resuming ifTrue: [self readDocumentFile].	Smalltalk isMorphic ifTrue: [SystemWindow wakeUpTopWindowUponStartup].	^ resuming! !!SystemDictionary methodsFor: 'snapshot and quit' stamp: 'ar 3/26/2000 16:12'!unbindExternalPrimitives	"Primitive. Force all external primitives to be looked up again afterwards. Since external primitives that have not found are bound for fast failure this method will force the lookup of all primitives again so that after adding some plugin the primitives may be found."	<primitive: 570>	"Do nothing if the primitive fails for compatibility with older VMs"! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 8/16/2000 10:08'!condenseChanges		"Smalltalk condenseChanges"	"Move all the changes onto a compacted sources file."	| f oldChanges classCount |	f _ FileStream fileNamed: 'ST80.temp'.	f header; timeStamp.'Condensing Changes File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class moveChangesTo: f.			class class moveChangesTo: f]].	LastQuitLogPosition _ f position.	f trailer; close.	oldChanges _ SourceFiles at: 2.	oldChanges close.	FileDirectory default deleteFileNamed: oldChanges name , '.old'.	FileDirectory default rename: oldChanges name						toBe: oldChanges name , '.old'.	FileDirectory default rename: f name						toBe: oldChanges name.	FileDirectory default setMacFileNamed: oldChanges name						type: 'STch' creator: 'FAST'.	SourceFiles at: 2			put: (StandardFileStream oldFileNamed: oldChanges name).! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'JMM 8/10/2000 15:13'!condenseSources		"Smalltalk condenseSources"	"Move all the changes onto a compacted sources file."	| f classCount dir |	dir _ FileDirectory default.	"Write all sources with fileIndex 1"	f _ FileStream newFileNamed: self sourcesName , '.temp'.	f header; timeStamp.'Condensing Sources File...'	displayProgressAt: Sensor cursorPoint	from: 0 to: Smalltalk classNames size	during:		[:bar | classCount _ 0.		Smalltalk allClassesDo:			[:class | bar value: (classCount _ classCount + 1).			class fileOutOn: f moveSource: true toFile: 1]].	f trailer; close.	"Make a new empty changes file"	self closeSourceFiles.	dir rename: self changesName		toBe: self changesName , '.old'.	(FileStream newFileNamed: self changesName)		header; timeStamp; close.	LastQuitLogPosition _ 0.	dir rename: self sourcesName		toBe: self sourcesName , '.old'.	dir rename: self sourcesName , '.temp'		toBe: self sourcesName.	"On Mac, set the file type and creator (noop on other platforms)"	FileDirectory default		setMacFileNamed: self changesName		type: 'STch'		creator: 'FAST'.	FileDirectory default		setMacFileNamed:  self sourcesName		type: 'STch'		creator: 'FAST'.	self openSourceFiles.	SelectionMenu notify: 'Source files have been rewritten!!Check that all is well,and then save/quit.'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'ar 7/19/1999 23:00'!forgetDoIts	"Smalltalk forgetDoIts"	Smalltalk allBehaviorsDo: "get rid of old DoIt methods"		[:cl | cl forgetDoIts]! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'ar 7/15/1999 16:05'!obsoleteBehaviors   "Smalltalk obsoleteBehaviors inspect"	"Find all obsolete behaviors including meta classes"	| obs |	obs _ OrderedCollection new.	Smalltalk garbageCollect.	self allObjectsDo:[:cl|		(cl isBehavior and:[cl isObsolete]) ifTrue:[obs add: cl]].	^ obs asArray! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'tk 6/24/1999 11:47'!reclaimDependents		"Smalltalk reclaimDependents"	"Reclaim unused entries in DependentsFields (DF)..."	"NOTE:  if <object>addDependent: is ever used to add something		other than a view, this process will fail to reinstate that		thing after clearing out DependentsFields.  DF was only		intended to be used as part of the MVC architecture."	Object classPool at: #DependentsFields  "Remove all entries from DF"				put: IdentityDictionary new.	Smalltalk garbageCollect.  "If that was the only reference, they will go away"	"Now if any views of non-models remain,		they should be reinstated as dependent views..."	View allSubInstancesDo:		[:v | (v model==nil or: [v model isKindOf: Model])				ifFalse: [v model addDependent: v]].	SystemWindow allSubInstancesDo:		[:v | (v model==nil or: [v model isKindOf: Model])				ifFalse: [v model addDependent: v]].! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 4/24/2000 14:02'!recompileAllFrom: firstName 	"Recompile all classes, starting with given name."	Smalltalk forgetDoIts.	self allClassesDo: 		[:class | class name >= firstName			ifTrue: 				[Transcript show: class name; cr.				class compileAll]]	"Smalltalk recompileAllFrom: 'AAABodyShop'."! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 10/16/1999 20:31'!removeAllLineFeeds    "Smalltalk removeAllLineFeeds"	"Scan all methods for source code with lineFeeds.	Replaces all occurrences of <CR><LF> by <CR>, noted by beep.	Halts with a message if any other LFs are found."	 | oldCodeString n crlf cr newCodeString oldStamp oldCategory m |	crlf _ String with: Character cr with: Character lf.	cr _ String with: Character cr.	Smalltalk forgetDoIts.'Scanning sources for LineFeeds.This will take a few minutes...'displayProgressAt: Sensor cursorPointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0. m _ 0.	Smalltalk allBehaviorsDo:		[:cls | 		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			oldCodeString _ (cls sourceCodeAt: selector) asString.			(oldCodeString indexOf: Character lf startingAt: 1) > 0 ifTrue:				[self beep.				newCodeString _ oldCodeString copyReplaceAll: crlf with: cr asTokens: false.				(newCodeString indexOf: Character lf startingAt: 1) > 0					ifTrue: [(self confirm: cls name , ' ' , (selector contractTo: 30) , 'has an isolated LineFeed (not part of CRLF).Shall I replace it?') ifFalse: [self halt]].				oldStamp _ Utilities timeStampForMethod: (cls compiledMethodAt: selector).				oldCategory _ cls whichCategoryIncludesSelector: selector.				cls compile: newCodeString classified: oldCategory withStamp: oldStamp notifying: nil.				m _ m + 1]]].].	Transcript cr; show: m printString , ' methods stripped of LFs.'.! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 6/8/1999 15:47'!removeEmptyMessageCategories	"Smalltalk removeEmptyMessageCategories"	Smalltalk garbageCollect.	(ClassOrganizer allInstances copyWith: SystemOrganization) do:		[:org | org removeEmptyCategories]! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'di 8/23/1998 14:35'!testDecompiler    "Smalltalk testDecompiler"	"Decompiles the source for every method in the system, and then compiles that source and verifies that it generates (and decompiles to) identical code.  This currently fails in a number of places because some different patterns (esp involving conditionals where the first branch returns) decompile the same."	 | methodNode oldMethod newMethod badOnes oldCodeString n |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.'Decompiling all classes...'displayProgressAt: Sensor cursorPointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0.	Smalltalk allBehaviorsDo:		[:cls | 		"Transcript cr; show: cls name."		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			oldMethod _ cls compiledMethodAt: selector.			oldCodeString _ (cls decompilerClass new								decompile: selector in: cls method: oldMethod)							decompileString.			methodNode _ cls compilerClass new						compile: oldCodeString						in: cls notifying: nil ifFail: [].			newMethod _ methodNode generate: #(0 0 0 0).			oldCodeString = (cls decompilerClass new								decompile: selector in: cls method: newMethod)							decompileString ifFalse: [Transcript cr; show: '***' , cls name , ' ' , selector.											badOnes add: cls name , ' ' , selector]]].].	Smalltalk browseMessageList: badOnes asSortedCollection name: 'Decompiler Discrepancies'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'sw 11/9/1999 17:56'!testFormatter    "Smalltalk testFormatter"	"Reformats the source for every method in the system, and then compiles that source and verifies that it generates identical code.   The formatting used will be either classic monochrome or fancy polychrome, depending on the setting of the preference #colorWhenPrettyPrinting."	 | newCodeString methodNode oldMethod newMethod badOnes n |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.'Formatting all classes...'displayProgressAt: Sensor cursorPointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0.	Smalltalk allBehaviorsDo:		[:cls | 		"Transcript cr; show: cls name."		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			newCodeString _ (cls compilerClass new)				format: (cls sourceCodeAt: selector)				in: cls notifying: nil decorated: Preferences colorWhenPrettyPrinting.			methodNode _ cls compilerClass new						compile: newCodeString						in: cls notifying: nil ifFail: [].			newMethod _ methodNode generate: #(0 0 0 0).			oldMethod _ cls compiledMethodAt: selector.			oldMethod = newMethod ifFalse: [Transcript cr; show: '***' , cls name , ' ' , selector.											badOnes add: cls name , ' ' , selector]]].].	Smalltalk browseMessageList: badOnes asSortedCollection name: 'Formatter Discrepancies'! !!SystemDictionary methodsFor: 'housekeeping' stamp: 'sw 11/9/1999 17:56'!testFormatter2    "Smalltalk testFormatter2"	"Reformats the source for every method in the system, and then verifies that the order of source tokens is unchanged.  The formatting used will be either classic monochrome or fancy polychrome, depending on the setting of the preference #colorWhenPrettyPrinting."	 | newCodeString badOnes n oldCodeString oldTokens newTokens |	badOnes _ OrderedCollection new.	Smalltalk forgetDoIts.'Formatting all classes...'displayProgressAt: Sensor cursorPointfrom: 0 to: CompiledMethod instanceCountduring: [:bar | n _ 0.	Smalltalk allBehaviorsDo:		[:cls | 		"Transcript cr; show: cls name."		cls selectors do:			[:selector | (n _ n+1) \\ 100 = 0 ifTrue: [bar value: n].			oldCodeString _ (cls sourceCodeAt: selector) asString.			newCodeString _ (cls compilerClass new)				format: oldCodeString				in: cls notifying: nil decorated: Preferences colorWhenPrettyPrinting.			oldTokens _ oldCodeString findTokens: Character separators.			newTokens _ newCodeString findTokens: Character separators.			oldTokens = newTokens ifFalse:					[Transcript cr; show: '***' , cls name , ' ' , selector.					badOnes add: cls name , ' ' , selector]]].].	Smalltalk browseMessageList: badOnes asSortedCollection name: 'Formatter Discrepancies'! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jm 7/10/1999 08:26'!extraVMMemory: extraBytesToReserve	"Request that the given amount of extra memory be reserved for use by the virtual machine to leave extra C heap space available for things like plugins, network and file buffers, and so on. This request is stored when the image is saved and honored when the image is next started up. Answer the previous value of this parameter."	extraBytesToReserve < 0		ifTrue: [self error: 'VM memory reservation must be non-negative'].	^ Smalltalk vmParameterAt: 23 put: extraBytesToReserve! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'di 9/23/1998 16:11'!handleUserInterrupt	Preferences cmdDotEnabled ifTrue:		[Smalltalk isMorphic			ifTrue: [[Project current interruptName: 'User Interrupt'] fork]			ifFalse: [[ScheduledControllers interruptName: 'User Interrupt'] fork]]! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'di 7/19/1999 15:44'!hasMorphic	"Answer whether the Morphic classes are available in the system (they may have been stripped, such as by a call to Smalltalk removeMorphic"	^ ((Smalltalk at: #Morph ifAbsent: [nil]) isKindOf: Class)! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'tao 10/26/97 23:23'!jpegReaderClass	"Answer, if present, a class to handle the importing of JPEG files from disk. If none, return nil.   9/18/96 sw"	| aClass |	^ ((aClass _ self at: #JPEGReadWriter ifAbsent: [nil]) isKindOf: Class)		ifTrue:			[aClass]		ifFalse:			[nil]! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ar 5/16/2000 00:54'!listBuiltinModule: index	"Return the name of the n-th builtin module.	This list is not sorted!!"	<primitive: 572>	^self primitiveFailed! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ar 6/5/2000 18:44'!listBuiltinModules	"Smalltalk listBuiltinModules"	"Return a list of all builtin modules (e.g., plugins). Builtin plugins are those that are compiled with the VM directly, as opposed to plugins residing in an external shared library. The list will include all builtin plugins regardless of whether they are currently loaded or not. Note that the list returned is not sorted!!"	| modules index name |	modules _ WriteStream on: Array new.	index _ 1.	[true] whileTrue:[		name _ self listBuiltinModule: index.		name ifNil:[^modules contents].		modules nextPut: name.		index _ index + 1.	].! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'TPR 5/16/2000 16:56'!listLoadedModule: index	"Return the name of the n-th loaded module.	This list is not sorted!!"	<primitive: 573>	^self primitiveFailed! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ar 6/5/2000 18:43'!listLoadedModules	"Smalltalk listLoadedModules"	"Return a list of all currently loaded modules (e.g., plugins). Loaded modules are those that currently in use (e.g., active). The list returned will contain all currently active modules regardless of whether they're builtin (that is compiled with the VM) or external (e.g., residing in some external shared library). Note that the returned list is not sorted!!"	| modules index name |	modules _ WriteStream on: Array new.	index _ 1.	[true] whileTrue:[		name _ self listLoadedModule: index.		name ifNil:[^modules contents].		modules nextPut: name.		index _ index + 1.	].! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'di 12/6/1999 19:54'!logError: errMsg inContext: aContext to: aFilename	"Log the error message and a stack trace to the given file."	| ff ctx |	FileDirectory default deleteFileNamed: aFilename ifAbsent: [].	(ff _ FileStream fileNamed: aFilename) ifNil: [^ self "avoid recursive errors"].  	ff print: Date today; space; print: Time now; cr.  	ff nextPutAll: errMsg; cr.	"Note: The following is an open-coded version of ContextPart>>stackOfSize:	since this method may be called during a low space condition and we might	run out of space for allocating the full stack."	ctx _ aContext.	[ctx == nil] whileFalse:[		ff print: ctx; cr.		ctx _ ctx sender].	ff close.! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jm 11/1/1998 11:38'!spaceForInstancesOf: aClass	"Answer the number of bytes consumed by all instances of the given class, including thier object headers."	| instCount isCompact instVarBytes bytesPerElement contentBytes headerBytes total |	instCount _ aClass instanceCount.	instCount = 0 ifTrue: [^ 0].	isCompact _ aClass indexIfCompact > 0.	instVarBytes _ aClass instSize * 4.	aClass isVariable		ifTrue: [			bytesPerElement _ aClass isBytes ifTrue: [1] ifFalse: [4].			total _ 0.			aClass allInstancesDo: [:inst |				contentBytes _ instVarBytes + (inst size * bytesPerElement).				headerBytes _					contentBytes > 255						ifTrue: [12]						ifFalse: [isCompact ifTrue: [4] ifFalse: [8]].				total _ total + headerBytes + contentBytes].			^ total]		ifFalse: [			headerBytes _				instVarBytes > 255					ifTrue: [12]					ifFalse: [isCompact ifTrue: [4] ifFalse: [8]].			^ instCount * (headerBytes + instVarBytes)].! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'jm 11/1/1998 11:45'!spaceTally	"Answer a collection of tuples representing the memory space (in bytes) consumed by the code and instances of each class in the system. The tuples have the form:	<class> <code size> <instance count> <space for instances>Code sizes do not currently report memory consumed by class variables. The arrays used to record these results consume a relatively insignificant amount of space."	"(Smalltalk spaceTally asSortedCollection: [:a :b | a last > b last]) asArray"	| results entry c |	"pre-allocate array of entries for results"	results _ OrderedCollection new: self size.	self do: [:cl |		(cl isKindOf: Class) ifTrue: [			entry _ Array new: 4.			entry at: 1 put: cl.			results add: entry]].	results _ results asArray.	Smalltalk garbageCollect.	1 to: results size do: [:i |		entry _ results at: i.		c _ entry at: 1.		entry at: 2 put: c spaceUsed.		entry at: 3 put: c instanceCount.		entry at: 4 put: (self spaceForInstancesOf: c).		Smalltalk garbageCollectMost].	^ results! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'ar 3/10/2000 17:32'!unloadModule: aString	"Primitive. Unload the given module.	This primitive is intended for development only since some	platform do not implement unloading of DLL's accordingly.	Also, the mechanism for unloading may not be supported	on all platforms."	<primitive: 571>	^self primitiveFailed! !!SystemDictionary methodsFor: 'miscellaneous' stamp: 'sw 9/21/1998 11:03'!verifyMorphicAvailability	"If Morphic is available, return true; if not, put up an informer and return false"	self hasMorphic ifFalse:		[self beep.		self inform: 'Sorry, Morphic mustbe present to use this feature'.		^ false].	^ true! !!SystemDictionary methodsFor: 'accessing' stamp: 'ar 7/11/1999 21:56'!organization	"Return the organizer for the receiver"	^SystemOrganization! !!SystemDictionary methodsFor: 'printing' stamp: 'sma 6/1/2000 09:53'!printElementsOn: aStream	aStream nextPutAll:'(lots of globals)'! !My instances provide an organization for the classes in the system, just as a ClassOrganizer organizes the messages within a class. The only difference is the methods for fileIn/Out.!!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'di 8/16/2000 10:03'!fileOut  "SystemOrganization fileOut"	(FileStream newFileNamed:		(FileDirectory default nextNameFor: 'SystemOrganization' extension: 'st'))		nextPutAll: 'SystemOrganization changeFromCategorySpecs: #('; cr;		print: SystemOrganization;  "ends with a cr"		nextPutAll: ')!!'; cr;		close.! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'ar 12/22/1999 17:33'!fileOutCategory: category asHtml: useHtml	"FileOut all the classes in the named system category."	| fileStream |	fileStream _ useHtml		ifTrue: [(FileStream newFileNamed: category , '.html') asHtml]		ifFalse: [FileStream newFileNamed: category , '.st'].	self fileOutCategory: category on: fileStream initializing: true.	fileStream close! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'ar 12/22/1999 17:28'!fileOutCategory: category on: aFileStream 	"Store on the file associated with aFileStream, all the classes associated 	with the category and any requested shared pools."	^self fileOutCategory: category on: aFileStream initializing: true! !!SystemOrganizer methodsFor: 'fileIn/Out' stamp: 'ar 12/22/1999 17:28'!fileOutCategory: category on: aFileStream initializing: aBool	"Store on the file associated with aFileStream, all the classes associated 	with the category and any requested shared pools."	| first poolSet tempClass classes |	classes _ (self superclassOrder: category).	poolSet _ Set new.	classes do: 		[:class | class sharedPools do: [:eachPool | poolSet add: eachPool]].	poolSet size > 0 ifTrue:		[tempClass _ Class new.		tempClass shouldFileOutPools ifTrue:			[poolSet _ poolSet select: [:aPool | tempClass shouldFileOutPool: (Smalltalk keyAtIdentityValue: aPool)].			poolSet do: [:aPool | tempClass fileOutPool: aPool onFileStream: aFileStream]]].	first _ true.	classes do: 		[:class | 		first			ifTrue: [first _ false]			ifFalse: [aFileStream cr; nextPut: Character newPage; cr].		class			fileOutOn: aFileStream			moveSource: false			toFile: 0			initializing: false].	aBool ifTrue:[classes do:[:cls| cls fileOutInitializerOn: aFileStream]].! !!SystemOrganizer methodsFor: 'remove' stamp: 'di 9/10/1999 09:37'!removeSystemCategory: category	"remove all the classes associated with the category"	(self superclassOrder: category) reverseDo: [:class | class removeFromSystem].	self removeEmptyCategories! !!SystemWindow methodsFor: 'initialization' stamp: 'kfr 4/27/2000 20:56'!addCloseBox	self addMorph: (closeBox _ SimpleButtonMorph new borderWidth: 0;			label: 'X' font: Preferences standardButtonFont; color: Color transparent;			actionSelector: #delete; target: self; extent: 14@14)! !!SystemWindow methodsFor: 'initialization' stamp: 'jm 10/16/2002 06:57'!addMenuControl	self addMorph: (menuBox _ IconicButton new borderWidth: 0;			labelGraphic: self menuButtonIcon;			color: Color transparent; 			actWhen: #buttonDown;			actionSelector: #offerWindowMenu; target: self;			setBalloonText: 'window menu')"NB: for the moment, we always supply balloon help for this control, until people get used to it; eventually, we mays switch to showing this balloon help only in novice mode, as we do for the other standard window controls."! !!SystemWindow methodsFor: 'initialization' stamp: 'jm 6/15/2003 16:56'!initialize	| aFont |	super initialize.	allowReframeHandles := true.	labelString ifNil: [labelString _ 'Untitled Window'].	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	paneRects _ Array new.	borderColor _ #raised.	borderWidth _ 1.	color _ Color black.	aFont _ Preferences standardButtonFont.	stripes _ Array		with: (BorderedMorph newBounds: bounds color: Color gray)  "see extent:"		with: (BorderedMorph newBounds: bounds color: Color gray).	self addMorph: (stripes first borderWidth: 1).	self addMorph: (stripes second borderWidth: 2).	self addMorph: (label _ StringMorph new contents: labelString;			font: Preferences windowTitleFont emphasis: 1).	self setLabelWidgetAllowance.	self addCloseBox.	self addMenuControl.	self addMorph: (collapseBox _ SimpleButtonMorph new borderWidth: 0;			label: 'O' font: aFont; color: Color transparent;			actionSelector: #collapseOrExpand; target: self; extent: 14@14).	Preferences noviceMode ifTrue:		[closeBox ifNotNil: [closeBox setBalloonText: 'close window'].		menuBox ifNotNil: [menuBox setBalloonText: 'window menu'].		collapseBox ifNotNil: [collapseBox setBalloonText: 'collapse/expand window']].	self extent: 300@200.	mustNotClose _ false.	updatablePanes _ Array new.! !!SystemWindow methodsFor: 'initialization' stamp: 'jm 11/25/2002 15:51'!menuButtonIcon	MenuButtonIcon ifNil: [		MenuButtonIcon _ (Form			extent: 8@9			depth: 1			fromArray: #(4278190080 2164260864 3170893824 2164260864 3170893824 2164260864 3170893824 2164260864 4278190080)			offset: 0@0)].	^ MenuButtonIcon! !!SystemWindow methodsFor: 'accessing' stamp: 'jm 10/3/2002 17:54'!model	^ model! !!SystemWindow methodsFor: 'accessing' stamp: 'jm 10/3/2002 17:55'!model: anObject	model _ anObject.! !!SystemWindow methodsFor: 'geometry' stamp: 'sr 1/14/2000 03:59'!extent: newExtent 	| inner labelRect |	isCollapsed		ifTrue: [super extent: newExtent x @ (self labelHeight + 2)]		ifFalse: [super extent: newExtent].	inner _ self innerBounds.	labelRect _ self labelRect.	stripes first bounds: (labelRect insetBy: 1).	stripes second bounds: (labelRect insetBy: 3).	self setStripeColorsFrom: self paneColorToUse.	closeBox ifNotNil: [closeBox align: closeBox topLeft with: inner topLeft + (4 @ 1)].	menuBox ifNotNil: [menuBox align: menuBox topLeft with: inner topLeft + (19 @ 1)].	collapseBox align: collapseBox topRight with: inner topRight - (4 @ -1).	label fitContents; setWidth: (label width min: bounds width - self labelWidgetAllowance).	label align: label bounds topCenter with: inner topCenter.	isCollapsed		ifTrue: [collapsedFrame _ self bounds]		ifFalse: [self setBoundsOfPaneMorphs. fullFrame _ self bounds]! !!SystemWindow methodsFor: 'geometry' stamp: 'di 6/16/1998 07:56'!labelRect	^ self innerBounds withHeight: self labelHeight.! !!SystemWindow methodsFor: 'geometry' stamp: 'sw 2/16/1999 15:23'!paneMorphs	"Nominally private but a need for obtaining this from the outside arose"	^ paneMorphs copy! !!SystemWindow methodsFor: 'geometry' stamp: 'sma 2/5/2000 14:09'!panelRect	"Answer the area below the title bar which is devoted to panes."	^ self innerBounds insetBy: (0 @ self labelHeight corner: 0 @ 0)! !!SystemWindow methodsFor: 'geometry' stamp: 'sw 10/8/1998 13:41'!setBoundsOfPaneMorphs	| panelRect |	panelRect _ self panelRect.	paneMorphs with: paneRects do:		[:m :frame |  "m color: paneColor."		m bounds: (((frame scaleBy: panelRect extent) translateBy: panelRect topLeft)) truncated]! !!SystemWindow methodsFor: 'geometry' stamp: 'di 10/23/1998 09:39'!setPaneRectsFromBounds	"Reset proportional specs from actual bounds, eg, after reframing panes"	| panelRect |	panelRect _ self panelRect.	paneRects _ paneMorphs collect:		[:m | 		(m bounds translateBy: panelRect topLeft negated)			scaleBy: (1.0 asPoint / panelRect extent)]! !!SystemWindow methodsFor: 'label' stamp: 'sr 1/14/2000 02:39'!getRawLabel	^ label! !!SystemWindow methodsFor: 'label' stamp: 'jm 10/15/2002 18:07'!labelDisplayBox	"For compatability with StandardSystemView."	^ self position extent: 200@30! !!SystemWindow methodsFor: 'label' stamp: 'sw 9/28/1999 13:39'!labelHeight	^ label height + 1 max: collapseBox height! !!SystemWindow methodsFor: 'label' stamp: 'jm 10/10/2002 20:17'!labelText	"For compatability with StandardSystemView."	^ labelString asParagraph! !!SystemWindow methodsFor: 'label' stamp: 'sw 9/29/1999 07:22'!labelWidgetAllowance	^ labelWidgetAllowance ifNil: [self setLabelWidgetAllowance]! !!SystemWindow methodsFor: 'label' stamp: 'di 11/4/1999 13:24'!relabel	| newLabel |	newLabel _ FillInTheBlank 		request: 'New title for this window'		initialAnswer: labelString.	newLabel isEmpty ifTrue: [^self].	(model windowReqNewLabel: newLabel)		ifTrue: [self setLabel: newLabel]! !!SystemWindow methodsFor: 'label' stamp: 'sw 9/29/1999 07:25'!setLabel: aString	labelString _ aString.	label ifNil: [^ self].	label contents: aString.	self labelWidgetAllowance.  "Sets it if not already"	self isCollapsed		ifTrue: [self extent: (label width + labelWidgetAllowance) @ (self labelHeight + 2)]		ifFalse: [label fitContents; setWidth: (label width min: bounds width - labelWidgetAllowance).				label align: label bounds topCenter with: bounds topCenter + (0@borderWidth).				collapsedFrame ifNotNil:					[collapsedFrame _ collapsedFrame withWidth: label width + labelWidgetAllowance]]! !!SystemWindow methodsFor: 'label' stamp: 'sw 9/29/1999 07:22'!setLabelWidgetAllowance	^ labelWidgetAllowance _ 75! !!SystemWindow methodsFor: 'label' stamp: 'ar 5/18/2000 18:35'!widthOfFullLabelText	^ (DisplayScanner quickPrintOn: Display box: Display boundingBox font: (Preferences windowTitleFont emphasized: 1)) stringWidth: labelString! !!SystemWindow methodsFor: 'open/close' stamp: 'jm 10/15/2002 15:24'!delete	| thisWorld  |	self mustNotClose ifTrue: [^ self].	model okToChange ifFalse: [^ self].	thisWorld _ self world.	super delete.	model windowIsClosing; release.	model _ nil.	SystemWindow noteTopWindowIn: thisWorld.! !!SystemWindow methodsFor: 'open/close' stamp: 'sw 9/28/1999 13:32'!mustNotClose	^ mustNotClose == true! !!SystemWindow methodsFor: 'open/close' stamp: 'sw 8/12/1998 14:40'!openInWorld: aWorld	"This msg and its callees result in the window being activeOnlyOnTop"	self bounds: (RealEstateAgent initialFrameFor: self).	aWorld addMorph: self.	self activate.	aWorld startSteppingSubmorphsOf: self! !!SystemWindow methodsFor: 'open/close' stamp: 'di 5/8/2000 10:02'!openInWorld: aWorld extent: extent	"This msg and its callees result in the window being activeOnlyOnTop"	self position: (RealEstateAgent initialFrameFor: self) topLeft; extent: extent.	aWorld addMorph: self.	self activate.	aWorld startSteppingSubmorphsOf: self.! !!SystemWindow methodsFor: 'open/close' stamp: 'di 5/8/2000 10:02'!openInWorldExtent: extent	"This msg and its callees result in the window being activeOnlyOnTop"	Smalltalk isMorphic ifFalse: [^ self openInMVCExtent: extent].	self openInWorld: World extent: extent! !!SystemWindow methodsFor: 'open/close' stamp: 'sw 10/15/1998 11:13'!positionSubmorphs	"Feels like overkill, but effect needed"	super positionSubmorphs.	self submorphsDo:		[:aMorph | aMorph positionSubmorphs]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'ar 2/10/1999 04:19'!collapse	self isCollapsed ifFalse:[self collapseOrExpand]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'jm 10/15/2002 15:26'!collapseOrExpand	isCollapsed		ifTrue: 			["Expand -- restore panes to morphics structure"			isCollapsed _ false.			collapsedFrame _ self bounds.			"First save latest collapsedFrame"			self bounds: fullFrame.			paneMorphs				reverseDo: 					[:m | 					self addMorph: m.					self world startSteppingSubmorphsOf: m].			self activate "-- mainly for findWindow"]		ifFalse: 			["Collapse -- remove panes from morphics structure"			isCollapsed _ true.			fullFrame _ self bounds.			"First save latest fullFrame"			paneMorphs do: [:m | m delete; releaseCachedState].			model modelSleep.			collapsedFrame _ (RealEstateAgent assignCollapseFrameFor: self).									self bounds: collapsedFrame].	self layoutChanged! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'jlb 3/27/2000 09:05'!doFastWindowReframe: ptName	| newBounds |	"For fast display, only higlight the rectangle during loop"	newBounds _ self bounds newRectFrom: [:f | 		f 			withSideOrCorner: ptName			setToPoint: (self pointFromWorld: Sensor cursorPoint)			minExtent: self minimumExtent].	self bounds: newBounds! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'ar 2/10/1999 04:20'!expand	self isCollapsed ifTrue:[self collapseOrExpand]! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'jm 10/15/2002 15:24'!fastFramingOn	^ Preferences fastDragWindowForMorphic! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/21/1998 16:12'!paneWithLongestSide: sideBlock near: aPoint 	| thePane theSide theLen box |	theLen _ 0.	paneMorphs do:		[:pane | box _ pane bounds.		box forPoint: aPoint closestSideDistLen:			[:side :dist :len |			(dist <= 5 and: [len > theLen]) ifTrue:				[thePane _ pane.				theSide _ side.				theLen _ len]]].	sideBlock value: theSide.	^ thePane! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'di 10/22/1998 22:55'!reframePanesAdjoining: growingPane along: side to: aDisplayBox 	| delta newRect minDim theMin horiz |	growingPane ifNil: [^ self].  "As from click outside"	newRect _ aDisplayBox.	horiz _ #(left right) includes: side.	theMin _ horiz ifTrue: [40] ifFalse: [20].	"First check that this won't make any pane smaller than theMin screen dots"	minDim _ (((paneMorphs select: [:pane | pane bounds bordersOn: growingPane bounds along: side])		collect: [:pane | pane bounds adjustTo: newRect along: side]) copyWith: aDisplayBox)			inject: 999 into:				[:was :rect | was min: (horiz ifTrue: [rect width] ifFalse: [rect height])].	"If so, amend newRect as required"	minDim > theMin ifFalse:		[delta _ minDim - theMin.		newRect _ newRect withSide: side setTo: 				((newRect perform: side) > (growingPane bounds perform: side)					ifTrue: [(newRect perform: side) + delta]					ifFalse: [(newRect perform: side) - delta])].	"Now adjust all adjoining panes for real"	paneMorphs do:		[:pane | (pane bounds bordersOn: growingPane bounds along: side) ifTrue:			[pane bounds: (pane bounds adjustTo: newRect along: side)]].	"And adjust the growing pane itself"	growingPane bounds: newRect.	"Finally force a recomposition of the whole window"	self setPaneRectsFromBounds.	self extent: self extent! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'bf 1/5/2000 19:38'!spawnPaneFrameHandle: event	| resizer localPt side growingPane newBounds adjoiningPanes limit |	(self world firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[ ^ self  "Prevent multiple handles"].	((self innerBounds withHeight: self labelHeight+4) containsPoint: event cursorPoint)		ifTrue: [^ self "in label or top of top pane"].	growingPane _ self paneWithLongestSide: [:s | side _ s] near: event cursorPoint.	growingPane ifNil: [^ self].	adjoiningPanes _ paneMorphs select: [:pane | pane bounds bordersOn: growingPane bounds along: side].	limit _ adjoiningPanes isEmpty		ifFalse: [ (adjoiningPanes collect: [:pane | pane bounds perform: side])			perform: ((#(top left) includes: side) ifTrue: [#max] ifFalse: [#min])]		ifTrue: [self bounds perform: side].	resizer _ NewHandleMorph new		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ growingPane bounds withSideOrCorner: side setToPoint: localPt minExtent: 40@20 limit: limit.			self fastFramingOn 			ifTrue:				["For fast display, only higlight the rectangle during loop"				newBounds _ growingPane bounds					 newRectFrom:					[:f | growingPane bounds withSideOrCorner: side							setToPoint: (self pointFromWorld: Sensor cursorPoint)							minExtent: 40@20 limit: limit].					self reframePanesAdjoining: growingPane along: side						to: newBounds]			ifFalse:				[self reframePanesAdjoining: growingPane along: side to: newBounds]]		lastPointDo: [:p | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'resize/collapse' stamp: 'jlb 3/27/2000 09:05'!spawnReframeHandle: event	"The mouse has crossed a pane border.  Spawn a reframe handle."	| resizer localPt pt ptName newBounds |	allowReframeHandles ifFalse: [^ self].	owner ifNil: [^ self  "Spurious mouseLeave due to delete"].	(self isActive not or: [self isCollapsed]) ifTrue:  [^ self].	((self world ifNil: [^ self]) firstSubmorph isKindOf: NewHandleMorph) ifTrue:		[^ self  "Prevent multiple handles"].	paneMorphs do: [:p | ((p fullBounds insetBy: 1) containsPoint: event cursorPoint)			ifTrue: [^ self  "Don't activate resizer if in a scrollbar"]].	pt _ event cursorPoint.	self bounds forPoint: pt closestSideDistLen:		[:side :dist :len |  "Check for window side adjust"		dist <= 2  ifTrue: [ptName _ side]].	ptName ifNil:		["Check for pane border adjust"		^ self spawnPaneFrameHandle: event].	#(topLeft bottomRight bottomLeft topRight) do:		[:corner |  "Check for window corner adjust"		(pt dist: (self bounds perform: corner)) < 20 ifTrue: [ptName _ corner]].	resizer _ NewHandleMorph new		followHand: event hand		forEachPointDo:			[:p | localPt _ self pointFromWorld: p.			newBounds _ self bounds				withSideOrCorner: ptName				setToPoint: localPt				minExtent: self minimumExtent.			self fastFramingOn 			ifTrue:				[self doFastWindowReframe: ptName]			ifFalse:				[self bounds: newBounds.				(Preferences roundedWindowCorners					and: [#(bottom right bottomRight) includes: ptName])					ifTrue:					["Complete kluge: causes rounded corners to get painted correctly,					in spite of not working with top-down displayWorld."					ptName = #bottom ifFalse:						[self invalidRect: (self bounds topRight - (6@0) extent: 7@7)].					ptName = #right ifFalse:						[self invalidRect: (self bounds bottomLeft - (0@6) extent: 7@7)].					self invalidRect: (self bounds bottomRight - (6@6) extent: 7@7)]]]		lastPointDo:			[:p | ].	event hand world addMorph: resizer.	resizer startStepping! !!SystemWindow methodsFor: 'top window' stamp: 'jm 7/19/2003 15:32'!activate	"Bring me to the front and make me able to respond to mouse and keyboard."	| oldTop |	self owner ifNil: [^ self "avoid spurious activate when dropped into trash"].	oldTop _ TopWindow.	TopWindow _ self.	oldTop ifNotNil: [oldTop passivate].	self owner firstSubmorph == self ifFalse: [		"bring me to the front if not already"		self owner addMorphFront: self].	self submorphsDo: [:m | m isLocked: false].	self setStripeColorsFrom: self paneColorToUse.	self isCollapsed ifFalse: [		model modelWakeUpIn: self.		self positionSubmorphs].! !!SystemWindow methodsFor: 'top window' stamp: 'sw 5/10/1999 15:42'!activateAndForceLabelToShow	self activate.	bounds top < 0 ifTrue:		[self position: (self position x @ 0)]! !!SystemWindow methodsFor: 'top window' stamp: 'sw 10/25/1999 23:51'!passivate	"Make me unable to respond to mouse and keyboard"	self setStripeColorsFrom: self paneColorToUse.	model modelSleep.	self submorphsDo:		[:m | (m == closeBox or: [m == collapseBox])				ifTrue: ["Control boxes remain active, except in novice mode"						Preferences noviceMode ifTrue: [m lock]]				ifFalse: [m lock]].	self world ifNotNil:  "clean damage now, so dont merge this rect with new top window"		[self world == World ifTrue: [self world displayWorld]]! !!SystemWindow methodsFor: 'panes' stamp: 'di 10/13/1999 22:03'!addMorph: aMorph frame: relFrame	| panelRect |	self addMorph: aMorph.	paneMorphs _ paneMorphs copyReplaceFrom: 1 to: 0 with: (Array with: aMorph).	paneRects _ paneRects copyReplaceFrom: 1 to: 0 with: (Array with: relFrame).	panelRect _ self panelRect.	(aMorph isKindOf: BorderedMorph) ifTrue: [aMorph borderWidth: 1].	aMorph color: self paneColor;		bounds: ((relFrame scaleBy: panelRect extent) translateBy: panelRect topLeft) truncated.! !!SystemWindow methodsFor: 'panes' stamp: 'jm 6/15/2003 17:07'!existingPaneColor	"Answer the existing pane color for the window, obtaining it from the first paneMorph if any/ Fall back on using the second stripe color if necessary."	| aColor |	paneMorphs isEmptyOrNil ifFalse: [		((aColor _ paneMorphs first color) isKindOf: Color) ifTrue: [^ aColor]].	^ stripes second color! !!SystemWindow methodsFor: 'panes' stamp: 'jm 5/16/2003 09:33'!paneColor	Display depth > 2 ifTrue: [		model ifNotNil: [^ Color colorFrom: model defaultBackgroundColor].		paneMorphs isEmptyOrNil ifFalse: [^ paneMorphs first color]].	^ Color white! !!SystemWindow methodsFor: 'panes' stamp: 'jm 6/15/2003 17:09'!paneColorToUse	^ Display depth <= 2		ifTrue: [Color white]		ifFalse: [self existingPaneColor ifNil: [self paneColor]]! !!SystemWindow methodsFor: 'panes' stamp: 'sw 10/19/1999 09:44'!paneMorphSatisfying: aBlock	^ paneMorphs detect: [:aPane | aBlock value: aPane] ifNone: [nil]! !!SystemWindow methodsFor: 'panes' stamp: 'sw 10/26/1999 00:36'!restoreDefaultPaneColor	"Useful when changing from monochrome to color display"	self setStripeColorsFrom: self paneColor.	paneMorphs do: [:p | p color: self paneColor].! !!SystemWindow methodsFor: 'panes' stamp: 'sw 10/19/1999 09:50'!setUpdatablePanesFrom: getSelectors	| aList aPane |	"Set my updatablePanes inst var to the list of panes which are list panes with the given get-list selectors.  Order is important here!!  Note that the method is robust in the face of panes not found, but a warning is printed in the transcript in each such case"	aList _ OrderedCollection new.	getSelectors do:		[:sel | aPane _ self paneMorphSatisfying:				[:pane | (pane isKindOf: PluggableListMorph) and: [pane getListSelector == sel]].			aPane				ifNotNil:					[aList add: aPane]				ifNil:					[Transcript cr; show: 'Warning: pane ', sel, ' not found.']].	updatablePanes _ aList asArray! !!SystemWindow methodsFor: 'panes' stamp: 'sw 10/19/1999 09:53'!updatablePanes	"Answer the list of panes, in order, which should be sent the #verifyContents message"	^ updatablePanes ifNil: [updatablePanes _ #()]! !!SystemWindow methodsFor: 'panes' stamp: 'sw 10/25/1999 23:52'!updatePaneColors	"Useful when changing from monochrome to color display"	self setStripeColorsFrom: self paneColorToUse.	paneMorphs do: [:p | p color: self paneColorToUse].! !!SystemWindow methodsFor: 'events' stamp: 'jm 7/19/2003 15:43'!doFastFrameDrag	"Drag me to a new position and make sure I'm in front."	| offset newBounds |	offset _ self position - Sensor cursorPoint.	newBounds _ self bounds newRectFrom: [:f | 		Sensor cursorPoint + offset extent: self extent].	self position: newBounds topLeft.	self owner firstSubmorph == self ifFalse: [		"bring me to the front if not already"		self owner addMorphFront: self].! !!SystemWindow methodsFor: 'events' stamp: 'di 10/28/1999 13:22'!handlesMouseDown: evt	"If I am not the topWindow, then I will only respond to dragging by the title bar.	Any other click will only bring me to the top"	(self fastFramingOn 		and: [self labelRect containsPoint: evt cursorPoint])		ifTrue: [^ true].	^ self activeOnlyOnTop and: [self ~~ TopWindow]! !!SystemWindow methodsFor: 'events' stamp: 'jm 10/10/2002 15:53'!handlesMouseOver: evt	^ true! !!SystemWindow methodsFor: 'events' stamp: 'jm 10/15/2002 17:26'!mouseDown: evt	| cp |	TopWindow == self ifFalse: [self activate].	(Sensor redButtonPressed  and:	 [self labelRect containsPoint: evt cursorPoint]) ifTrue: [   "if mouse still down after activate:"		^ self isSticky ifFalse: [			self fastFramingOn 				ifTrue: [self doFastFrameDrag]				ifFalse: [evt hand grabMorph: self]]].	model windowActiveOnFirstClick ifTrue: [		"Normally, window keeps control of first click. Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseDown: evt]]]! !!SystemWindow methodsFor: 'events' stamp: 'jm 10/10/2002 15:54'!mouseEnter: evt	self spawnReframeHandle: evt.! !!SystemWindow methodsFor: 'events' stamp: 'jm 10/10/2002 15:54'!mouseLeave: evt	self spawnReframeHandle: evt.! !!SystemWindow methodsFor: 'events' stamp: 'di 6/10/1998 14:41'!mouseMove: evt	| cp |	model windowActiveOnFirstClick ifTrue:		["Normally window takes control on first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseMove: evt]]]! !!SystemWindow methodsFor: 'events' stamp: 'di 6/10/1998 14:41'!mouseUp: evt	| cp |	model windowActiveOnFirstClick ifTrue:		["Normally window takes control on first click.		Need explicit transmission for first-click activity."		cp _ evt cursorPoint.		submorphs do: [:m | (m containsPoint: cp) ifTrue: [m mouseUp: evt]]]! !!SystemWindow methodsFor: 'events' stamp: 'di 10/23/1998 09:22'!paneTransition: event	"Mouse has entered or left a pane"	^ self spawnReframeHandle: event! !!SystemWindow methodsFor: 'events' stamp: 'sw 12/22/1999 18:31'!wantsHalo	^ false! !!SystemWindow methodsFor: 'events' stamp: 'sw 4/18/2000 09:06'!wantsHaloFromClick	^ true! !!SystemWindow methodsFor: 'events' stamp: 'sw 5/9/2000 02:33'!willingToBeEmbeddedUponLanding	^ Preferences systemWindowEmbedOK! !!SystemWindow methodsFor: 'stepping' stamp: 'sw 10/19/1999 09:30'!amendSteppingStatus	"Circumstances having changed, find out whether stepping is wanted and assure that the new policy is carried out"	self wantsSteps		ifTrue:			[self arrangeToStartStepping]		ifFalse:			[self stopStepping]! !!SystemWindow methodsFor: 'stepping' stamp: 'sw 10/19/1999 08:16'!step	model ifNotNil: [model stepIn: self]! !!SystemWindow methodsFor: 'stepping' stamp: 'sw 10/20/1999 15:48'!stepAt: millisecondClockValue	model ifNotNil: [model stepAt: millisecondClockValue in: self]! !!SystemWindow methodsFor: 'stepping' stamp: 'sw 10/19/1999 08:22'!stepTime	^ model		ifNotNil:			[model stepTimeIn: self]		ifNil:			[200] "milliseconds"! !!SystemWindow methodsFor: 'stepping' stamp: 'jm 10/7/2002 07:54'!wantsSteps	"Return true if the model wants its view to be stepped."	self isPartsDonor ifTrue: [^ false].	^ model wantsStepsIn: self! !!SystemWindow methodsFor: 'drawing' stamp: 'di 8/16/1998 01:14'!areasRemainingToFill: aRectangle	| areas |	(areas _ super areasRemainingToFill: aRectangle) isEmpty		ifTrue: [^ areas "good news -- complete occlusion"].	"Check for special case that this is scrollbar damage"	((bounds topLeft - (14@0) corner: bounds bottomRight) containsRect: aRectangle) ifTrue:		[paneMorphs do: [:p | ((p isKindOf: ScrollPane) and: [p scrollBarFills: aRectangle])							ifTrue: [^ Array new]]].	^ areas! !!SystemWindow methodsFor: 'drawing' stamp: 'sw 11/29/1999 18:01'!fullDrawOn: aCanvas	Preferences roundedWindowCorners		ifTrue: [CornerRounder roundCornersOf: self on: aCanvas					displayBlock:						[aCanvas drawMorph: self.						self basicFullDrawOn: aCanvas]					borderWidth: 2]		ifFalse: [super fullDrawOn: aCanvas]! !!SystemWindow methodsFor: 'drawing' stamp: 'mir 5/30/2000 17:20'!makeMeVisible 	self world extent > (0@0) ifFalse: [^ self].	((self world bounds insetBy: (0@0 corner: self labelHeight asPoint))		containsPoint: self position) ifTrue: [^ self "OK -- at least my top left is visible"].	"window not on screen (probably due to reframe) -- move it now"	self isCollapsed		ifTrue: [self position: (RealEstateAgent assignCollapsePointFor: self)]		ifFalse: [self position: (RealEstateAgent initialFrameFor: self initialExtent: self extent) topLeft].! !!SystemWindow methodsFor: 'drawing' stamp: 'di 3/25/2000 10:55'!wantsRoundedCorners	^ Preferences roundedWindowCorners or: [super wantsRoundedCorners]! !!SystemWindow methodsFor: 'menu' stamp: 'di 5/10/1999 23:37'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph."template..."	aCustomMenu addLine.	aCustomMenu add: 'edit label...' action: #relabel..! !!SystemWindow methodsFor: 'menu' stamp: 'jm 10/11/2002 07:08'!buildWindowMenu	| aMenu |	aMenu _ MenuMorph new defaultTarget: self.	aMenu add: 'change title...' action: #relabel.	aMenu addLine.	aMenu add: 'send to back' action: #sendToBack.	aMenu addLine.	self mustNotClose		ifFalse:			[aMenu add: 'make unclosable' action: #makeUnclosable]		ifTrue:			[aMenu add: 'make closable' action: #makeClosable].	aMenu add: (self isSticky ifTrue: ['make draggable'] ifFalse: ['make undraggable']) 		action: #toggleStickiness.	aMenu addLine.	aMenu add: 'full screen' action: #fullScreen.	self isCollapsed ifFalse: [aMenu add: 'window color...' action: #setWindowColor].	^aMenu! !!SystemWindow methodsFor: 'menu' stamp: 'jm 10/5/2002 07:20'!fullScreen	self bounds: self world bounds.! !!SystemWindow methodsFor: 'menu' stamp: 'sw 9/28/1999 13:53'!makeClosable	mustNotClose _ false.	closeBox ifNil:		[self addCloseBox.		self extent: self extent]! !!SystemWindow methodsFor: 'menu' stamp: 'sw 9/28/1999 13:52'!makeUnclosable	mustNotClose _ true.	closeBox ifNotNil:		[closeBox delete.		closeBox _ nil]! !!SystemWindow methodsFor: 'menu' stamp: 'sma 6/5/2000 13:34'!offerWindowMenu	| aMenu |	aMenu _ self buildWindowMenu.	model ifNotNil:		[model addModelItemsToWindowMenu: aMenu].	aMenu popUpEvent: self currentEvent! !!SystemWindow methodsFor: 'menu' stamp: 'jm 10/11/2002 07:08'!sendToBack	| aWorld nextWindow |	aWorld _ self world.	nextWindow _ aWorld submorphs detect:		[:m | (m isKindOf: SystemWindow) and:  [m ~~ self]] ifNone: [^ self].	nextWindow activate.	aWorld addMorphBack: self.! !!SystemWindow methodsFor: 'menu' stamp: 'sw 10/26/1999 00:00'!setWindowColor	ColorPickerMorph new		sourceHand: self activeHand;		target: self;		selector: #setWindowColor:;		originalColor: self paneColorToUse;		addToWorld: self world			near: self fullBounds! !!SystemWindow methodsFor: 'menu' stamp: 'sw 10/27/1999 11:28'!setWindowColor: incomingColor	| existingColor aColor |	incomingColor ifNil: [^ self].  "it happens"	aColor _ incomingColor asNontranslucentColor.	(aColor = ColorPickerMorph perniciousBorderColor 		or: [aColor = Color black]) ifTrue: [^ self].	existingColor _ self paneColorToUse.	existingColor ifNil: [^ self beep].	(self allMorphs copyWithout: self) do:		[:aMorph |			((aMorph isKindOf: PluggableButtonMorph) and: [aMorph offColor = existingColor])				ifTrue:					[aMorph onColor: aColor darker offColor: aColor].			aMorph color = existingColor				ifTrue:					[aMorph color: aColor]].	self setStripeColorsFrom: aColor		! !!SystemWindow methodsFor: '-- all --' stamp: 'jm 7/19/2003 15:41'!justDroppedInto: aMorph event: anEvent	isCollapsed		ifTrue: [			self position: ((self position max: 0@0) grid: 8@8).			collapsedFrame _ self bounds]		ifFalse: [			fullFrame _ self bounds.			TopWindow ~~ self ifTrue: [self activate]].! !!SystemWindow class methodsFor: 'top window' stamp: 'jm 10/11/2002 08:20'!clearTopWindow	TopWindow _ nil.! !!SystemWindow class methodsFor: 'top window' stamp: 'di 9/26/1999 22:48'!noteTopWindowIn: aWorld	| newTop |	"TopWindow must be nil or point to the top window in this project."	TopWindow _ nil.	aWorld ifNil: [^ self].	newTop _ nil.	aWorld submorphsDo:		[:m | (m isKindOf: SystemWindow) ifTrue:			[(newTop == nil and: [m activeOnlyOnTop])				ifTrue: [newTop _ m].			(m model isKindOf: Project)				ifTrue: ["This really belongs in a special ProjWindow class"						m label ~= m model name ifTrue: [m setLabel: m model name]]]].	newTop == nil ifFalse: [newTop activate]! !!SystemWindow class methodsFor: 'top window' stamp: 'sw 1/4/2000 15:22'!wakeUpTopWindowUponStartup	TopWindow ifNotNil:		[TopWindow isCollapsed ifFalse:			[TopWindow model ifNotNil:				[TopWindow model modelWakeUpIn: TopWindow]]]! !!SystemWindow class methodsFor: 'top window' stamp: 'jm 10/15/2002 15:30'!windowsIn: aWorld satisfying: windowBlock	| windows |	windows _ OrderedCollection new.	aWorld submorphs do: [:m |		((m isKindOf: SystemWindow) and: [windowBlock value: m])			ifTrue: [windows addLast: m]].	^ windows! !This is an assembler for the Texas Instruments 430x1xx series of microprocessors. The input in Logo list format, where a top-level word is a label and instructions and assembler directives are sublists. The output is an array of 16-bit words.The TI 430x1xx processor is a 16-bit CPU with 16 registers. Instructions are one, two, or three words and take one to six cycles. The instruction set is small (only 27 instruction types) and quite regular. There are only three instruction formats: two-operand instructions, zero-or-one-operand instructions, and jumps. See the 430x1xx User Manual (http://www-s.ti.com/sc/psheets/slau049b/slau049b.pdf) for details.The assembly process is three stages:  1. pass zero: parse the input stream and build a sequence of labels and instruction records  2. pass one: generate dummy code while incrementing the pc and recording label values  3. pass two: generate the final code using the recorded label valuesPasses one and two are similar, but pass two raises an error when an undefined label is encountered.!!TI430Assembler methodsFor: 'initialization' stamp: 'jm 12/18/2002 07:15'!initialize	registers _ Dictionary new.	symbolTable _ Dictionary new.	finalPass _ false.	pc _ 0.	instructions _ OrderedCollection new.	code _ OrderedCollection new.	self defineRegisters.! !!TI430Assembler methodsFor: 'assembling' stamp: 'jm 12/18/2002 08:14'!codeFor: instr	"Answer an Array of code words for the given instruction record. Assembler directives that don't generate code simply return an empty Array."	| actionRec sel |	actionRec _ Actions at: instr first.	sel _ actionRec first.	sel numArgs = 1 ifTrue: [^ self perform: sel with: instr].	sel numArgs = 2 ifTrue: [^ self perform: sel with: instr with: actionRec last].	self error: 'bad selector'.! !!TI430Assembler methodsFor: 'assembling' stamp: 'jm 12/18/2002 08:46'!pass1	"Make a pass over my instructions, counting generated words and recording label addresses. Don't warn the user about undefined symbols."	| wordCount |	symbolTable _ Dictionary new: 100.	pc _ 0.	finalPass _ false.	instructions do: [:instrOrLabel |		(instrOrLabel isKindOf: String)			ifTrue: [symbolTable at: instrOrLabel put: pc]			ifFalse: [				wordCount _ (self codeFor: instrOrLabel) size.				pc _ pc + (2 * wordCount)]].! !!TI430Assembler methodsFor: 'assembling' stamp: 'jm 12/18/2002 23:06'!pass2	"Make a second pass over my instructions, collecting the generated code. On this pass, all labels and symbolic values should be defined, so give an error if an undefined symbol is encountered."	| words |	pc _ 0.	finalPass _ true.	code _ OrderedCollection new.	listing _ WriteStream on: (String new: 5000).	instructions do: [:instrOrLabel |		(instrOrLabel isKindOf: String)			ifTrue: [				listing nextPutAll: instrOrLabel; cr.				(symbolTable at: instrOrLabel) = pc					ifFalse: [self error: 'multiply-defined label']]			ifFalse: [				words _ self codeFor: instrOrLabel.				self appendToListing: instrOrLabel words: words.				code addAllLast: words.				pc _ pc + (2 * words size)]].	listing_ listing contents.! !!TI430Assembler methodsFor: 'assembling' stamp: 'jm 12/17/2002 21:13'!readFileNamed: fileName	"Read my instructions from the file with the given name."	| f |	f _ FileStream oldFileNamed: fileName.	self readFrom: f.	f close.! !!TI430Assembler methodsFor: 'assembling' stamp: 'jm 12/17/2002 21:19'!readFrom: aStream	"Read my instruction list from the given stream."	| token |	instructions _ OrderedCollection new: 100.	[(token _ self readToken: aStream) notNil]		whileTrue: [instructions addLast: token].! !!TI430Assembler methodsFor: 'private-instructions' stamp: 'jm 12/18/2002 08:56'!emulatedBr: instr	^ self codeFor: (Array with: 'mov' with: instr last with: 'pc')! !!TI430Assembler methodsFor: 'private-instructions' stamp: 'jm 12/18/2002 08:56'!emulatedPop: instr	^ self codeFor: (Array with: 'mov' with: '@sp+' with: instr last)! !!TI430Assembler methodsFor: 'private-instructions' stamp: 'jm 12/18/2002 08:56'!emulatedRet: instr	^ self codeFor: (Array with: 'mov' with: '@sp+' with: 'pc')! !!TI430Assembler methodsFor: 'private-instructions' stamp: 'jm 12/18/2002 22:03'!format1: instr opcode: opcode	"Generate code for a format-1 instruction with the given opcode."	| result src dst |	src _ self registerSpecFor: (instr at: 2).	dst _ self registerSpecFor: (instr at: 3).	(#(register indexed) includes: dst first) ifFalse: [		self error: 'destination mode must be register or indexed'].	result _ Array with: opcode + (self srcRegBitsFor: src) + (self dstRegBitsFor: dst).	(src first = #indexed or: [src first = #immediate]) ifTrue: [		result _ result copyWith: (self valueOf: src last)].	dst first = #indexed ifTrue: [		result _ result copyWith: (self valueOf: dst last)].	^ result! !!TI430Assembler methodsFor: 'private-instructions' stamp: 'jm 12/18/2002 22:32'!format2: instr opcode: opcode	"Generate code for a format-2 instruction with the given opcode."	| offset targetAddr |	offset _ 0.	finalPass ifTrue: [		targetAddr _ self valueOf: (instr at: 2).		targetAddr isNumber ifFalse: [self error: 'undefined symbol'].		offset _ (targetAddr - (pc + 2)) // 2.		(offset > 511) | (offset < -512) ifTrue: [			self error: 'jump target address out of range']].	^ Array with: opcode + (offset bitAnd: 16r3FF)! !!TI430Assembler methodsFor: 'private-instructions' stamp: 'jm 12/18/2002 22:22'!format3: instr opcode: opcode	"Generate code for a format-2 instruction with the given opcode."	| arg regBits result |	"register field is in bottom 4-bits for format-3 instruction"	arg _ self registerSpecFor: (instr at: 2).	regBits _ self srcRegBitsFor: arg.	regBits _ (regBits bitAnd: 16r30) + ((regBits >> 8) bitAnd: 16rF).	result _ Array with: opcode + regBits.	(arg first = #indexed or: [arg first = #immediate]) ifTrue: [		result _ result copyWith: (self valueOf: arg last)].	^ result! !!TI430Assembler methodsFor: 'private-assembler directives' stamp: 'jm 12/18/2002 07:53'!const: instr	"Define a constant."	instr size = 3 ifFalse: [self error: 'bad const format'].	symbolTable at: (instr at: 2) put: (instr at: 3).	^ #()! !!TI430Assembler methodsFor: 'private-assembler directives' stamp: 'jm 12/18/2002 07:50'!dcw: instr	"Generate a table of words."	^ (instr copyFrom: 2 to: instr size) collect: [:each | self valueOf: each]! !!TI430Assembler methodsFor: 'private-assembler directives' stamp: 'jm 12/18/2002 07:51'!namereg: instr	"Assign a name to a register."	instr size = 3 ifFalse: [self error: 'bad namereg format'].	registers at: (instr at: 3) put: (instr at: 2).	^ #()! !!TI430Assembler methodsFor: 'private-assembler directives' stamp: 'jm 12/18/2002 08:47'!org: instr	"Set the target pc for the following code or data."	instr size = 2 ifFalse: [self error: 'bad org format'].	pc _ instr at: 2.	^ #()! !!TI430Assembler methodsFor: 'private-parsing' stamp: 'jm 12/18/2002 07:39'!isDelimiter: aCharacter	"Answer true if the given character is a Logo delimiter."	aCharacter <= Character space ifTrue: [^ true].  "white space"	^ '()[]' includes: aCharacter! !!TI430Assembler methodsFor: 'private-parsing' stamp: 'jm 12/19/2002 09:04'!numberFor: s base: base	"Answer the positive number represented by the given string, or nil if the string contains characters other than 0 through the last digit for the given base. Base can be 2-36."	| result digit |	result _ 0.	s do: [:ch |		(digit _ ch asUppercase digitValue) < 0 ifTrue: [^ nil].		digit > (base - 1) ifTrue: [^ nil].		result _ (base * result) + digit].	^ result! !!TI430Assembler methodsFor: 'private-parsing' stamp: 'jm 12/19/2002 09:02'!numberOrToken: s	"If the given string represents a number, answer that number. Otherwise, answer the string."	| n |	(s size > 2 and: [s beginsWith: '0x']) ifTrue: [  "example: 0xFF"		n _ self numberFor: (s copyFrom: 3 to: s size) base: 16.		n ifNotNil: [^ n]].	(s size > 1 and: [s first = $$]) ifTrue: [  "example: $FF"		n _ self numberFor: (s copyFrom: 2 to: s size) base: 16.		n ifNotNil: [^ n]].	s first isDigit ifTrue: [  "example: 17"		(n _ self numberFor: s base: 10) ifNotNil: [^ n]].	(s size > 1 and: [s first = $-]) ifTrue: [  "example: -17"		n _ self numberFor: (s copyFrom: 2 to: s size) base: 10.		n ifNotNil: [^ n negated]].	^ s! !!TI430Assembler methodsFor: 'private-parsing' stamp: 'jm 12/17/2002 18:34'!readList: aStream	"Read and answer list from the given stream. Lists are represented as Arrays, and may contain nested lists."	| result token |	result _ OrderedCollection new.	[aStream atEnd not and:	 [(token _ self readToken: aStream) notNil]]		whileTrue: [			token = ']' ifTrue: [^ result asArray].			result addLast: token].	self error: 'missing ]'.! !!TI430Assembler methodsFor: 'private-parsing' stamp: 'jm 12/17/2002 09:38'!readRawToken: aStream	"Read and answer the next raw Logo token from the given stream. The result is a string containing the next delimiter, word, or number. Answer nil if the stream is at the end."	| result ch |	self skipSpace: aStream.	aStream atEnd ifTrue: [^ nil].	(self isDelimiter: aStream peek) ifTrue: [^ aStream next asString].	result _ WriteStream on: (String new: 20).	[true] whileTrue: [		ch _ aStream peek.		aStream atEnd ifTrue: [^ result contents].		(self isDelimiter: ch) ifTrue: [^ result contents].		result nextPut: aStream next].! !!TI430Assembler methodsFor: 'private-parsing' stamp: 'jm 12/18/2002 07:31'!readToken: aStream	"Read and answer the next Logo token from the given stream. Answer nil if at the end of stream."	| token |	token _ self readRawToken: aStream.	token ifNil: [^ nil].  "end of stream"	token = '[' ifTrue: [^ self readList: aStream].	^ self numberOrToken: token! !!TI430Assembler methodsFor: 'private-parsing' stamp: 'jm 12/17/2002 09:31'!skipSpace: aStream	"Advance the given stream past all white space and comments."	| ch |	[aStream atEnd not and:	 [((ch _ aStream peek) <= Character space) or: [ch = $;]]] whileTrue: [		aStream next.		ch = $; ifTrue: [  "comment; skip to end of line"			[aStream atEnd not and: [aStream peek ~= Character cr]]				whileTrue: [aStream next]]].! !!TI430Assembler methodsFor: 'private-other' stamp: 'jm 12/18/2002 23:15'!appendToListing: instrOrLabel words: words	| lineStart s |	'org' = instrOrLabel first ifTrue: [listing cr].  "blank lines before org"	lineStart _ listing position.	listing tab; nextPutAll: (self hexString: pc); space; tab.	words do: [:w | listing nextPutAll: (self hexString: w); space].	[(listing position - lineStart) < 28] whileTrue: [listing space].	s _ instrOrLabel printString select: [:ch | (ch ~= $') & (ch ~= $#)].	s _ s copyFrom: 2 to: s size - 1.	listing tab; nextPutAll: s; cr.! !!TI430Assembler methodsFor: 'private-other' stamp: 'jm 12/18/2002 09:20'!defineRegisters	"Record the pre-defined register names pc (r0), sp (r1), sr (r2), and r2-r15. A register can have multiple names, such as 'sr' and 'cg1'. Registers r2 and r3 have special behavior; registers r4-r15 are general purpose."	registers at: 'pc' put: 0.	registers at: 'sp' put: 1.	registers at: 'sr' put: 2.	registers at: 'cg1' put: 2.	registers at: 'cg2' put: 3.	4 to: 15 do: [:i | registers at: 'r', i printString put: i].! !!TI430Assembler methodsFor: 'private-other' stamp: 'jm 12/18/2002 21:53'!dstRegBitsFor: registerSpec	"Answer an interger containing the bit fields that encode the destination register and mode for the given register specification. The result of this method can simply be added to an instruction word that has zero bits in these fields."	| mode reg i |	mode _ registerSpec first.	reg _ registerSpec at: 2.	i _ #(register indexed) indexOf: mode.	i < 0 ifTrue: [self error: 'illegal mode for destination register'].	^ ((i - 1) << 7) + reg! !!TI430Assembler methodsFor: 'private-other' stamp: 'jm 12/18/2002 23:00'!hexString: anInteger	"Answer a 4-digit hexadecimal string for the given positive integer."	| s |	s _ anInteger printStringBase: 16.	s _ s copyFrom: 4 to: s size.	[s size < 4] whileTrue: [s _ '0', s].	^ s! !!TI430Assembler methodsFor: 'private-other' stamp: 'jm 12/19/2002 14:58'!registerSpecFor: aStringOrArray	"Answer a register specification for the given string."	| reg arg mode n r |	"indexed mode: register spec is an Array"	(aStringOrArray isKindOf: Array) ifTrue: [		reg _ aStringOrArray first.		reg first = $@			ifTrue: [reg _ reg copyFrom: 2 to: reg size]			ifFalse: [self error: 'bad indexed mode format'].		aStringOrArray size > 2 ifTrue: [self error: 'expressions not yet supported'].		^ Array with: #indexed with: (registers at: reg) with: aStringOrArray second].	arg _ aStringOrArray asLowercase.	arg first = $@ ifTrue: [		arg last = $+			ifTrue: [				arg _ arg copyFrom: 2 to: arg size - 1.				mode _ #autoIncrement]			ifFalse: [				arg _ arg copyFrom: 2 to: arg size.				mode _ #indirect].		^ Array with: mode with: (registers at: arg)].	"immediate"	arg first = $# ifTrue: [		arg _ arg copyFrom: 2 to: arg size.		n _ self numberOrToken: arg.		n isNumber ifTrue: [			(#(16rFFFF -1 0 1 2 4 8) includes: n)				ifTrue: [^ Array with: #constant with: n]				ifFalse: [^ Array with: #immediate with: n]].		n _ self valueOf: arg.		^ Array with: #immediate with: n].	"register"	r _ registers at: arg ifAbsent: [nil].	r ifNotNil: [^ Array with: #register with: r].	"absolute"	^ Array with: #indexed with: 2 with: (self valueOf: arg)! !!TI430Assembler methodsFor: 'private-other' stamp: 'jm 12/19/2002 14:58'!srcRegBitsFor: registerSpec	"Answer an interger containing the bit fields that encode the source register and mode for the given register specification. The result of this method can simply be added to an instruction word that has zero bits in these fields."	| mode const reg i |	mode _ registerSpec first.	mode = #immediate ifTrue: [^ 0 + (3 << 4)].  "@pc+"	mode = #constant ifTrue: [		const _ registerSpec at: 2.		const = 0 ifTrue: [^ (3 << 8) + (0 << 4)].		const = 1 ifTrue: [^ (3 << 8) + (1 << 4)].		const = 2 ifTrue: [^ (3 << 8) + (2 << 4)].		(const = -1) | (const = 16rFFFF) ifTrue: [^ (3 << 8) + (3 << 4)].		const = 4 ifTrue: [^ (2 << 8) + (2 << 4)].		const = 8 ifTrue: [^ (2 << 8) + (3 << 4)]].	reg _ registerSpec at: 2.	i _ #(register indexed indirect autoIncrement) indexOf: mode.	i < 0 ifTrue: [self error: 'unimplemented mode'].	^ (reg << 8) + ((i - 1) << 4)! !!TI430Assembler methodsFor: 'private-other' stamp: 'jm 12/18/2002 22:01'!valueOf: aNumberOrString	"If the argument is a number, answer its value. If the argument is a string, look it up in the symbol table. If this is the final pass, give an error if the string is not found, otherwise answer the string itself."	(aNumberOrString isKindOf: Number) ifTrue: [^ aNumberOrString].	^ symbolTable at: aNumberOrString ifAbsent: [		finalPass ifTrue: [self error: 'undefined: ', aNumberOrString].		aNumberOrString]! !!TI430Assembler methodsFor: 'private-other' stamp: 'jm 12/19/2002 09:08'!writeListingToFileNamed: fileName	"Save my listing to the give file."	| f |	f _ FileStream newFileNamed: 'listing.txt'.	f nextPutAll: listing.	f close.! !!TI430Assembler class methodsFor: 'class initialization' stamp: 'jm 12/19/2002 13:47'!defineInstructions	"Add entries for all instructions to the Actions dictionary."	"self initialize"	| opcode byteBit op |	"format 1 instructions"	opcode _ 16r4000.	byteBit _ 64.	#(mov add addc subc sub cmp dadd bit bic bis xor and) do: [:sym |		op _ sym asString.		Actions at: op put: (Array with: #format1:opcode: with: opcode).		Actions at: op, '.b' put: (Array with: #format1:opcode: with: opcode + byteBit).		opcode _ opcode + 16r1000].	"format 2 instructions"	opcode _ 16r2000.	#(jne jeq jnc jc jn jge jl jmp) do: [:sym |		op _ sym asString.		Actions at: op put: (Array with: #format2:opcode: with: opcode).		opcode _ opcode + 16r400].	"format 3 instructions"	opcode _ 16r1000.	#(rrc 'rrc.b' swpb - rra 'rra.b' sxt - push 'push.b' call - reti - - -) do: [:sym |		sym ~= #- ifTrue: [			op _ sym asString.			Actions at: op put: (Array with: #format3:opcode: with: opcode)].		opcode _ opcode + 16r40].! !!TI430Assembler class methodsFor: 'class initialization' stamp: 'jm 12/18/2002 07:54'!initialize	"Initialize my Actions dictionary."	"self initialize"	| op |	Actions _ Dictionary new.	self defineInstructions.  "normal instructions"	"emulated instructions"	#(br pop ret) do: [:sym |		op _ sym asString. 		Actions at: op put: (Array with: ('emulated', op capitalized, ':') asSymbol)].	"assembler directives"	#(const dcw namereg org) do: [:sym |		op _ sym asString. 		Actions at: op put: (Array with: (op, ':') asSymbol)].! !I am a parse tree leaf representing a temporary variable!!TempVariableNode methodsFor: 'printing' stamp: 'sw 11/16/1999 16:37'!printOn: aStream indent: level 	aStream withAttributes: (Preferences syntaxAttributesFor: #temporaryVariable)			do: [aStream nextPutAll: name]! !!TempoEvent methodsFor: 'as yet unclassified' stamp: 'jm 9/10/1998 08:37'!printOn: aStream	aStream nextPut: $(.	time printOn: aStream.	aStream nextPutAll: ': tempo '.	((120.0 * (500000.0 / tempo)) roundTo: 0.01) printOn: aStream.	aStream nextPut: $).! !This is a port of JTetris.java 1.0.0.How to start:choose new morph.../Games/TetrisHow to play:1) using buttons2) using keyboard:	drop - spacebar	move to left - left arrow	move to right - right arrow	rotate clockwise - up arrow	rotate anticlockwise - down arrowNOTE: mouse must be over Tetris!!Tetris methodsFor: 'initialization' stamp: 'RAA 1/8/2000 14:38'!buildButtonTarget: aTarget label: aLabel selector: aSelector help: aString	^self rowForButtons		addMorph: (			SimpleButtonMorph new 				target: aTarget;				label: aLabel;				actionSelector: aSelector;				borderColor: #raised;				borderWidth: 2;				color: color		)! !!Tetris methodsFor: 'initialization' stamp: 'RAA 1/7/2000 22:43'!initialize	super initialize.	board _ TetrisBoard new game: self.	color _ Color lightGray.	orientation _ #vertical.	centering _ #center.	vResizing _ #shrinkWrap.	hResizing _ #spaceFill.	inset _ 3.	self 		addMorphBack: self makeGameControls;		addMorphBack: self makeMovementControls;		addMorphBack: self showScoreDisplay;		addMorphBack: board.	board newGame.! !!Tetris methodsFor: 'initialization' stamp: 'RAA 1/7/2000 22:51'!makeGameControls	^self rowForButtons		addMorph:			(self				buildButtonTarget: self				label: 'Quit'				selector: #delete				help: 'quit');		addMorph:			(self				buildButtonTarget: board				label: 'Pause'				selector: #pause				help: 'pause');		addMorph:			(self				buildButtonTarget: board				label: 'New game'				selector: #newGame				help: 'new game')! !!Tetris methodsFor: 'initialization' stamp: 'RAA 1/8/2000 14:03'!makeMovementControls	^self rowForButtons		addMorph:			(self				buildButtonTarget: board				label: '->'				selector: #moveRight				help: 'move to the right');		addMorph:			(self				buildButtonTarget: board				label: ' ) '				selector: #rotateClockWise				help: 'rotate clockwise');		addMorph:			(self				buildButtonTarget: board				label: ' | '				selector: #dropAllTheWay				help: 'drop');		addMorph:			(self				buildButtonTarget: board				label: ' ( '				selector: #rotateAntiClockWise				help: 'rotate anticlockwise');		addMorph:			(self				buildButtonTarget: board				label: '<-'				selector: #moveLeft				help: 'move to the left')! !!Tetris methodsFor: 'initialization' stamp: 'RAA 1/7/2000 21:48'!rowForButtons	^AlignmentMorph newRow		color: color;		borderWidth: 0;		inset: 3;		vResizing: #shrinkWrap;		centering: #center! !!Tetris methodsFor: 'initialization' stamp: 'di 1/19/2000 22:53'!showScoreDisplay	^self rowForButtons		hResizing: #rigid;		addMorph: (			self 				wrapPanel: (					(scoreDisplay _ LedMorph new) digits: 5; extent: (4*10@15)				) 				label: 'Score:'		)! !!Tetris methodsFor: 'initialization' stamp: 'RAA 1/8/2000 14:38'!wrapPanel: anLedPanel label: aLabel	"wrap an LED panel in an alignmentMorph with a label to its left"	^self rowForButtons		color: color lighter;		addMorph: anLedPanel;		addMorph: (StringMorph contents: aLabel)! !!Tetris methodsFor: 'events' stamp: 'am 8/28/1999 14:22'!handlesMouseOver: evt	^ true! !!Tetris methodsFor: 'events' stamp: 'RAA 1/8/2000 15:42'!keyStroke: evt	| charValue |	charValue _ evt keyCharacter asciiValue.	charValue = 28 ifTrue: [board moveLeft].	charValue = 29 ifTrue: [board moveRight].	charValue = 30 ifTrue: [board rotateClockWise].	charValue = 31 ifTrue: [board rotateAntiClockWise].	charValue = 32 ifTrue: [board dropAllTheWay].! !!Tetris methodsFor: 'events' stamp: 'am 8/28/1999 14:22'!mouseEnter: evt        evt hand newKeyboardFocus: self! !!Tetris methodsFor: 'events' stamp: 'RAA 1/7/2000 22:37'!score: anInteger	scoreDisplay value: anInteger! !!Tetris class methodsFor: 'as yet unclassified' stamp: 'RAA 1/7/2000 23:19'!colors	^{		Color r: 0.5 g: 0 b: 0.		Color r: 0 g: 0.5 b: 0.		Color r: 0 g: 0 b: 0.5.		Color r: 0.5 g: 0.5 b: 0.		Color r: 0.5 g: 0 b: 0.5.		Color r: 0 g: 0.5 b: 0.5	}! !!Tetris class methodsFor: 'as yet unclassified' stamp: 'jm 6/1/2003 21:05'!includeInNewMorphMenu	^ true! !I am a falling block used in the Tetris game.!!TetrisBlock methodsFor: 'initialization' stamp: 'jm 6/15/2003 10:30'!board: theBoard	board _ theBoard.	4 timesRepeat: [		self addMorph: (			BorderedMorph new				color: color;				extent: board cellSize;				borderRaised)].	self positionCellMorphs.! !!TetrisBlock methodsFor: 'initialization' stamp: 'RAA 1/8/2000 15:33'!initialize	super initialize.	bounds _ (2@2) negated extent: 1@1.	"keep this puppy out of sight"	shapeInfo _ self class shapeChoices atRandom.	baseCellNumber _ (4 atRandom + 2) @ 1.	angle _ 4 atRandom.	color _ Tetris colors atRandom.! !!TetrisBlock methodsFor: 'other' stamp: 'RAA 1/8/2000 12:37'!dropByOne 	^self moveDeltaX: 0 deltaY: 1 deltaAngle: 0! !!TetrisBlock methodsFor: 'other' stamp: 'RAA 1/8/2000 13:56'!moveDeltaX: deltaX deltaY: deltaY deltaAngle: deltaAngle 	| delta |	delta _ deltaX @ deltaY.	(shapeInfo atWrap: angle + deltaAngle) do: [ :offsetThisCell | 		(board emptyAt: baseCellNumber + offsetThisCell + delta) ifFalse: [^ false]	].	baseCellNumber _ baseCellNumber + delta.	angle _ angle + deltaAngle - 1 \\ 4 + 1.	self positionCellMorphs.	^ true ! !!TetrisBlock methodsFor: 'other' stamp: 'RAA 1/8/2000 13:41'!positionCellMorphs	(shapeInfo atWrap: angle) withIndexDo: [ :each :index |		(submorphs at: index)			position: (board originForCell: baseCellNumber + each)	].	fullBounds _ nil.	self changed.	 ! !!TetrisBlock class methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 15:29'!flipShapes: anArray	^OrderedCollection new 		add: anArray;		add: (anArray collect: [ :each | each y negated @ each x]);		add: (anArray collect: [ :each | each x negated @ each y negated]);		add: (anArray collect: [ :each | each y @ each x negated]);		yourself	! !!TetrisBlock class methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 11:55'!includeInNewMorphMenu	^false! !!TetrisBlock class methodsFor: 'as yet unclassified' stamp: 'RAA 1/8/2000 15:32'!shapeChoices	^ ShapeChoices ifNil: [		ShapeChoices _ {			{ {  0 @ 0 .  1 @ 0 .  0 @ 1 .  1 @ 1  } }.	"square - one is sufficient here"			self flipShapes: {  0 @  0 . -1 @  0 .  1 @  0 .  0 @ -1  }.	"T"			{ 				{  0 @ 0 . -1 @ 0 .  1 @ 0 .  2 @ 0  }.				{  0 @ 0 .  0 @-1 .  0 @ 1 .  0 @ 2  } 	"long - two are sufficient here"			}.			self flipShapes: { 0 @ 0 .  0 @ -1 .  0 @  1 .  1 @  1  }.	"L"			self flipShapes: { 0 @ 0 .  0 @ -1 .  0 @  1 . -1 @  1  }.	"inverted L"			self flipShapes: { 0 @ 0 . -1 @  0 .  0 @ -1 .  1 @ -1  }.	"S"			self flipShapes: {  0 @ 0 .  1 @ 0 .  0 @ -1 . -1 @ -1  } "Z"		}.	]! !I am the board for the Tetris game.!!TetrisBoard methodsFor: 'initialization' stamp: 'RAA 1/8/2000 13:26'!initialize	super initialize.	resizeToFit _ false.	bounds _ 0@0 extent: (self numColumns @ self numRows) * self cellSize + (1@1).	color _ Color r: 0.8 g: 1.0 b: 1.0.! !!TetrisBoard methodsFor: 'accessing' stamp: 'RAA 1/7/2000 22:34'!game: aTetris	game _ aTetris! !!TetrisBoard methodsFor: 'accessing' stamp: 'RAA 8/28/1999 22:31'!running	^currentBlock notNil and: [paused not]! !!TetrisBoard methodsFor: 'accessing' stamp: 'RAA 1/7/2000 22:38'!score: aNumber	score _ aNumber.	game score: score.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 14:03'!dropAllTheWay	self running ifFalse: [^ self].	[currentBlock dropByOne] whileTrue: [		self score: score + 1	].! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:17'!moveLeft	self running ifFalse: [^ self].	currentBlock moveDeltaX: -1 deltaY: 0 deltaAngle: 0.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:17'!moveRight	self running ifFalse: [^ self].	currentBlock moveDeltaX: 1 deltaY: 0 deltaAngle: 0.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 13:20'!newGame	self removeAllMorphs.	gameOver _ paused _ false.	delay _ 500.	currentBlock _ nil.	self score: 0.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:16'!pause	gameOver ifTrue: [^ self].	paused _ paused not.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:17'!rotateAntiClockWise	self running ifFalse: [^ self].	currentBlock moveDeltaX: 0 deltaY: 0 deltaAngle: -1.! !!TetrisBoard methodsFor: 'button actions' stamp: 'RAA 1/8/2000 11:17'!rotateClockWise	self running ifFalse: [^ self].	currentBlock moveDeltaX: 0 deltaY: 0 deltaAngle: 1.! !!TetrisBoard methodsFor: 'stepping' stamp: 'RAA 1/8/2000 15:59'!step	(self ownerThatIsA: HandMorph) ifNotNil: [^self].	paused ifTrue: [^ self]. 	currentBlock ifNil: [		currentBlock _ TetrisBlock new.		self addMorphFront: currentBlock.		currentBlock board: self.	] ifNotNil: [		currentBlock dropByOne ifFalse: [self storePieceOnBoard]	].! !!TetrisBoard methodsFor: 'stepping' stamp: 'AM 7/26/1999 16:07'!stepTime	^ delay! !!TetrisBoard methodsFor: 'other' stamp: 'RAA 1/7/2000 23:12'!cellSize	^12@12! !!TetrisBoard methodsFor: 'other' stamp: 'jm 6/1/2003 20:57'!emptyAt: aPoint	| cellOrigin |	(aPoint x between: 1 and: self numColumns) ifFalse: [^ false].	(aPoint y < 1) ifTrue: [^ true].	"handle early phases"	(aPoint y <= self numRows) ifFalse: [^ false].	cellOrigin _ self originForCell: aPoint.	^(self submorphs select: [:each | each topLeft = cellOrigin]) isEmpty! !!TetrisBoard methodsFor: 'other' stamp: 'RAA 8/28/1999 23:30'!numRows	^27	! !!TetrisBoard methodsFor: 'other' stamp: 'RAA 1/8/2000 13:11'!originForCell: aPoint	^aPoint - (1@1) * self cellSize + self position! !!TetrisBoard methodsFor: 'private' stamp: 'jm 6/1/2003 20:57'!checkForFullRows	| targetY morphsInRow bonus |	self numRows to: 2 by: -1 do: [ :row |		targetY _ (self originForCell: 1@row) y.		[			morphsInRow _ self submorphs select: [:each | each top = targetY].			morphsInRow size = self numColumns		] whileTrue: [			bonus _ (morphsInRow collect: [:each | each color]) asSet size = 1 				ifTrue: [1000] 				ifFalse: [100].			self score: score + bonus.			submorphs copy do: [ :each |				each top = targetY ifTrue: [					each delete				].				each top < targetY ifTrue: [					each position: each position + (0@self cellSize y)				].			].		].	].! !!TetrisBoard methodsFor: 'private' stamp: 'RAA 8/28/1999 23:29'!numColumns	^10	! !!TetrisBoard methodsFor: 'private' stamp: 'RAA 1/8/2000 13:59'!storePieceOnBoard	currentBlock submorphs do: [ :each |		self addMorph: each.		((each top - self top) // self cellSize y) < 3 ifTrue: [			paused _ gameOver _ true.		].	].	currentBlock delete.	currentBlock _ nil.	self checkForFullRows.	self score: score + 10.	delay _ delay - 2 max: 80.! !!Text methodsFor: 'accessing' stamp: 'ls 7/29/1998 01:17'!embeddedMorphs	"return the list of morphs embedded in me"	| morphs |	morphs _ IdentitySet new.	runs withStartStopAndValueDo: [ :start :stop :attribs | attribs do: [ :attrib |		(attrib isKindOf: TextAnchor) ifTrue: [  morphs add: attrib anchoredMorph ] ] ].	^morphs select: [ :m | m isKindOf: Morph ]! !!Text methodsFor: 'accessing' stamp: 'di 11/23/1998 11:53'!findString: aString startingAt: start caseSensitive: caseSensitive	"Answer the index of subString within the receiver, starting at index 	start. If the receiver does not contain subString, answer 0."	^string findString: aString asString startingAt: start caseSensitive: caseSensitive! !!Text methodsFor: 'accessing' stamp: 'sw 12/7/1999 12:25'!rangeOf: attribute startingAt: index forStyle: aStyle	"This is stupid, slow code, but it works"	| start stop |	start _ index.	[start > 1 and: [(self attributesAt: (start - 1) forStyle: aStyle) includes: attribute]]		whileTrue: [start _ start - 1].	stop _ index-1.	[stop < self size and: [(self attributesAt: (stop + 1) forStyle: aStyle) includes: attribute]]		whileTrue: [stop _ stop + 1].	^ start to: stop! !!Text methodsFor: 'comparing' stamp: 'di 1/29/2000 14:15'!= other	| otherRuns |	^ other isText		ifTrue:	["This is designed to run fast even for megabytes"				otherRuns _ other asText runs.				(string == other string or: [string = other string])					and: [runs == otherRuns or: [runs = otherRuns]]]		ifFalse: [false]! !!Text methodsFor: 'emphasis' stamp: 'sw 12/7/1999 12:30'!attributesAt: characterIndex 	"Answer the code for characters in the run beginning at characterIndex."	"NB: no senders any more (supplanted by #attributesAt:forStyle: but retained for the moment in order not to break user code that may exist somewhere that still calls this"	| attributes |	self size = 0		ifTrue: [^ Array with: (TextFontChange new fontNumber: 1)].  "null text tolerates access"	attributes _ runs at: characterIndex.	^ attributes! !!Text methodsFor: 'emphasis' stamp: 'sw 12/7/1999 11:32'!attributesAt: characterIndex forStyle: aTextStyle	"Answer the code for characters in the run beginning at characterIndex."	| attributes |	self size = 0		ifTrue: [^ Array with: (TextFontChange new fontNumber: aTextStyle defaultFontIndex)].  "null text tolerates access"	attributes _ runs at: characterIndex.	^ attributes! !!Text methodsFor: 'emphasis' stamp: 'di 4/1/1999 15:17'!emphasisAt: characterIndex	"Answer the fontfor characters in the run beginning at characterIndex."	| attributes emph |	self size = 0 ifTrue: [^ 0].	"null text tolerates access"	emph _ 0.	attributes _ runs at: characterIndex.	attributes do: 		[:att | emph _ emph bitOr: att emphasisCode].	^ emph	! !!Text methodsFor: 'emphasis' stamp: 'sw 12/7/1999 10:58'!fontAt: characterIndex withStyle: aTextStyle	"Answer the fontfor characters in the run beginning at characterIndex."	| attributes font |	self size = 0 ifTrue: [^ aTextStyle defaultFont].	"null text tolerates access"	attributes _ runs at: characterIndex.	font _ aTextStyle defaultFont.  "default"	attributes do: 		[:att | att forFontInStyle: aTextStyle do: [:f | font _ f]].	^ font! !!Text methodsFor: 'emphasis' stamp: 'sma 2/5/2000 12:03'!makeSelectorBoldIn: aClass	"For formatting Smalltalk source code, set the emphasis of that portion of 	the receiver's string that parses as a message selector to be bold."	| parser |	string size = 0 ifTrue: [^self].	(parser _ aClass parserClass new) parseSelector: string.	self makeBoldFrom: 1 to: (parser endOfLastToken min: string size)! !!Text methodsFor: 'printing' stamp: 'sma 6/1/2000 09:49'!printOn: aStream	self printNameOn: aStream.	aStream nextPutAll: ' for '; print: string! !!Text methodsFor: 'attributes' stamp: 'sw 11/9/1999 17:24'!askIfAddStyle: priorMethod req: requestor	"Ask the user if we have a complex style (i.e. bold) for the first time"	| tell answ old |	(Preferences browseWithPrettyPrint and: [Preferences colorWhenPrettyPrinting])		ifTrue: [self couldDeriveFromPrettyPrinting ifTrue: [^ self asString]].	self runs coalesce.	self unembellished ifTrue: [^ self asString].	priorMethod ifNotNil: [old _ priorMethod getSourceFromFile].	(old == nil or: [old unembellished])		ifTrue:			[tell _ 'This method contains style (e.g. bold) for the first time.Do you really want to save the style info?'.			answ _ (PopUpMenu labels: 'Save method with styleSave method simply')						startUpWithCaption: tell.			answ = 2 ifTrue: [^ self asString]]! !!Text methodsFor: 'attributes' stamp: 'sw 11/16/1999 22:33'!couldDeriveFromPrettyPrinting	"Return true if the receiver has any TextAttributes that are functional rather than simply appearance-related"	runs values do:		[:emphArray | emphArray do:			[:emph | emph couldDeriveFromPrettyPrinting ifFalse: [^ false]]].	^ true! !!Text methodsFor: 'attributes' stamp: 'sw 12/7/1999 12:31'!unembellished 	"Return true if the only emphases are the default font and bold"	| font1 bold |	font1 _ TextFontChange defaultFontChange.	bold _ TextEmphasis bold.	Preferences ignoreStyleIfOnlyBold ifFalse:		["Ignore font1 only or font1-bold followed by font1-plain"		^ (runs values = (Array with: (Array with: font1)))		or: [runs values = (Array with: (Array with: font1 with: bold) 								with: (Array with: font1))]].	"If preference is set, then ignore any combo of font1 and bold"	runs withStartStopAndValueDo:		[:start :stop :emphArray |		emphArray do:			[:emph | (font1 = emph or: [bold = emph]) ifFalse: [^ false]]].	^ true! !!Text class methodsFor: 'instance creation' stamp: 'sw 12/6/1999 14:14'!fromString: aString 	"Answer an instance of me whose characters are those of the argument, aString."	^ self string: aString attribute: (TextFontChange fontNumber: TextStyle default defaultFontIndex)! !!TextAction methodsFor: 'as yet unclassified' stamp: 'sw 11/9/1999 17:21'!couldDeriveFromPrettyPrinting	^ false! !!TextAction methodsFor: 'as yet unclassified' stamp: 'DSM 3/30/1999 13:15'!info	^ 'no hidden info'! !TextAnchors support anchoring of images in text.  A TextAnchor exists as an attribute of text emphasis, and it gets control like a FontReference, through the emphasizeScanner: message.  Depending on whether its anchoredMorph is a Morph or a Form, it repositions the morph, or displays the form respectively.  The coordination between composition, display and selection can best be understood by browsing the various implementations of placeEmbeddedObject:.In the morphic world, simply embed any morph in text.  In the old world, you can create an image reference using code such as the following.	ParagraphEditor new clipboardTextPut:		(Text string: '*'			attribute: (TextAnchor new anchoredMorph: Form fromUser))In this case you select a piece of the screen, and it gets anchored to a one-character text in the editor's past buffer.  If you then paste into some other text, you will see the image as an embedded image.!!TextAnchor methodsFor: 'as yet unclassified' stamp: 'di 7/1/1998 14:35'!= other 	^ (other class == self class) 		and: [other anchoredMorph == anchoredMorph]! !!TextAnchor methodsFor: 'as yet unclassified' stamp: 'sw 11/9/1999 17:21'!couldDeriveFromPrettyPrinting	^ false! !Tells a piece of text to be a certain way.Select text, press Command-6, choose a attribute.  If selected text is of the form 	Hi There<Smalltalk beep>the part in angle brackets is saved for action, and the Hi There appears in the paragraph.  If selection has no angle brackets, use the whole thing as both the text and the action.TextDoIt  --  eval as a Smalltalk expression (the part in angle brackets)TextLink -- Show a method, class comment, class hierarchy, or class defintion.	<Point extent:>, <Point Comment>, <Point Hierarchy>, or <Point Defintion> are what you type.TextURL -- Show the web page. <www.disney.com>These attributes of text need to be stored on the disk in a regular file-out.  It is done in this form: 	(ascii 2)<!!do Smalltalk beep(ascii 3)>Hi There(ascii 3)<!!>	(ascii 2)<!!li Point extent:(ascii 3)>Click here to see the extent: method(ascii 3)<!!>The brackets are for people to see in fileOuts.  The wierd ascii are for the scanner to pick up easily.  See RunArray class scanFrom: where decoding is done.!]style[(993 24 25)f1,f1LRunArray class scanFrom:;,f1!!TextAttribute methodsFor: 'as yet unclassified' stamp: 'sw 11/9/1999 17:25'!couldDeriveFromPrettyPrinting	"Answer whether the receiver is a kind of attribute that could have been generated by doing polychrome pretty-printing of a method without functional text attributes."	^ true! !!TextAttribute methodsFor: 'as yet unclassified' stamp: 'di 4/1/1999 15:16'!emphasisCode	"Subclasses may override to add bold, italic, etc"	^ 0! !A TextColor encodes a text color change applicable over a given range of text.!!TextColor methodsFor: 'comparing' stamp: 'sma 3/24/2000 10:51'!hash	^ color hash! !!TextColor methodsFor: 'printing' stamp: 'sma 3/24/2000 10:51'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' code: '; print: color! !!TextColor class methodsFor: 'constants' stamp: 'sma 3/24/2000 10:50'!white 	^ self new color: Color white! !!TextColor class methodsFor: 'instance creation' stamp: 'sma 3/24/2000 10:49'!scanFrom: strm	"read a color in the funny format used by Text styles on files. c125000255 or cblue;"	| r g b |	strm peek isDigit		ifTrue:			[r _ (strm next: 3) asNumber.			g _ (strm next: 3) asNumber.			b _ (strm next: 3) asNumber.			^ self color: (Color r: r g: g b: b range: 255)].	"A name of a color"	^ self color: (Color perform: (strm upTo: $;) asSymbol)! !A TextContainer models the shape of an ownerMorph, possibly occluded by one or more occludingMorphs, and scans this shape to provide a list of rectangles suitable for layout of text.  It does this by displaying the shadow of the ownerMorph in black, and any occludingMorphs in white, on its shadowForm.  It then scans horizontal strips of appropriate height to find unbroken intervals of black, greater than minWidth in extent.  Conputation of the rectangles is done on demand, and results are cached so that text can be redisplayed without having to recompute the rectangles.!!TextContainer methodsFor: 'container protocol' stamp: 'di 9/30/1998 23:17'!rectanglesAt: lineY height: lineHeight	"Return a list of rectangles that are at least minWidth wide	in the specified horizontal strip of the shadowForm.	Cache the results for later retrieval if the owner does not change."	| hProfile rects thisWidth thisX count pair outerWidth lineRect lineForm |	pair _ Array with: lineY with: lineHeight.	rects _ rectangleCache at: pair ifAbsent: [nil].	rects ifNotNil: [^ rects].	outerWidth _ minWidth + (2*OuterMargin).	self shadowForm.  "Compute the shape".	lineRect _ 0@(lineY - shadowForm offset y)					extent: shadowForm width@lineHeight.	lineForm _ shadowForm copy: lineRect.	"Check for a full line -- frequent case"	(lineForm tallyPixelValues at: 2) = lineRect area	ifTrue:		[rects _ Array with: (shadowForm offset x@lineY extent: lineRect extent)]	ifFalse:		["No such luck -- scan the horizontal profile for segments of minWidth"		hProfile _ lineForm xTallyPixelValue: 1 orNot: false.		rects _ OrderedCollection new.		thisWidth _ 0.  thisX _ 0.		1 to: hProfile size do:			[:i | count _ hProfile at: i.			count >= lineHeight ifTrue:				[thisWidth _ thisWidth + 1]				ifFalse:				[thisWidth >= outerWidth ifTrue:					[rects addLast: ((thisX + shadowForm offset x)@lineY									extent: thisWidth@lineHeight)].				thisWidth _ 0. thisX _ i]].		thisWidth >= outerWidth ifTrue:				[rects addLast: ((thisX + shadowForm offset x)@lineY									extent: thisWidth@lineHeight)]].	rects _ rects collect: [:r | r insetBy: OuterMargin@0].	rectangleCache at: pair put: rects.	^ rects! !!TextContainer methodsFor: 'private' stamp: 'jm 10/15/2002 16:31'!bounds	| bounds theText |	self fillsOwner ifFalse: [^ textMorph textBounds].	theText _ textMorph.	bounds _ theText owner bounds.	theText owner submorphsBehind: theText do:		[:m | bounds _ bounds merge: m fullBounds].	^ bounds! !!TextContainer methodsFor: 'private' stamp: 'jm 11/24/2002 10:49'!computeShadow	| canvas back bounds theText |	bounds _ self bounds.	theText _ textMorph.	canvas _ (FormCanvas extent: bounds extent depth: 1)			shadowColor: Color black.	canvas translateBy: bounds topLeft negated during:[:tempCanvas|		self fillsOwner			ifTrue: [(theText owner copyWithoutSubmorph: theText) fullDrawOn: tempCanvas]			ifFalse: [tempCanvas fillRectangle: textMorph bounds color: Color black].		self avoidsOcclusions ifTrue:			[back _ tempCanvas form deepCopy.			tempCanvas form fillWhite.			theText owner submorphsInFrontOf: theText do:				[:m | (textMorph isLinkedTo: m)					ifTrue: []					ifFalse: [m fullDrawOn: tempCanvas]].			back displayOn: tempCanvas form at: 0@0 rule: Form reverse].	].	shadowForm _ canvas form offset: bounds topLeft.	vertProfile _ shadowForm  yTallyPixelValue: 1 orNot: false.	rectangleCache _ Dictionary new.	^ shadowForm! !!TextDiffBuilder methodsFor: 'printing' stamp: 'sma 5/6/2000 18:15'!printPatchSequence: seq on: aStream 	seq do: 		[:assoc | 		aStream			withAttribute: (self attributeOf: assoc key)			do: [aStream nextPutAll: assoc value; cr]]! !!TextDiffBuilder methodsFor: 'initialize' stamp: 'ar 11/20/1998 18:17'!destString: aString	realDst := self split: aString asString.	dstLines := OrderedCollection new.	dstMap := OrderedCollection new.	realDst doWithIndex:[:line :realIndex|		"(line contains:[:anyChar| anyChar isSeparator not]) ifTrue:["			dstLines add: line.			dstMap add: realIndex.		"]."	].	dstPos := PluggableDictionary new: dstLines size.	dstPos hashBlock: self stringHashBlock.	dstLines doWithIndex:[:line :index|		(dstPos includesKey: line)			ifTrue:[(dstPos at: line) add: index. multipleMatches := true]			ifFalse:[dstPos at: line put: (OrderedCollection with: index)]].! !!TextDiffBuilder methodsFor: 'initialize'!from: sourceString to: destString	self sourceString: sourceString.	self destString: destString.! !!TextDiffBuilder methodsFor: 'initialize' stamp: 'ar 11/20/1998 18:17'!sourceString: aString	realSrc := self split: aString asString.	srcLines := OrderedCollection new.	srcMap := OrderedCollection new.	realSrc doWithIndex:[:line :realIndex|		"(line contains:[:anyChar| anyChar isSeparator not]) ifTrue:["			srcLines add: line.			srcMap add: realIndex.		"]."	].	srcPos := PluggableDictionary new: srcLines size.	srcPos hashBlock: self stringHashBlock.	srcLines doWithIndex:[:line :index| 		(srcPos includesKey: line)			ifTrue:[(srcPos at: line) add: index. multipleMatches := true]			ifFalse:[srcPos at: line put: (OrderedCollection with: index)]].! !!TextDiffBuilder methodsFor: 'initialize'!split: aString	^self split: aString by: self splitCharacter! !!TextDiffBuilder methodsFor: 'testing'!hasMultipleMatches	^multipleMatches == true! !!TextDiffBuilder methodsFor: 'creating patches'!buildDisplayPatch	^Text streamContents:[:stream|		self printPatchSequence: self buildPatchSequence on: stream.	]! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 16:35'!buildPatchSequence	"@@ TODO: Das funktioniert noch nicht fr n-m matches"	matches := PluggableDictionary new.	matches hashBlock: self pointHashBlock.	self buildReferenceMap.	runs := self processDiagonals.	self validateRuns: runs.	"There may be things which have just been moved around. Find those."	shifted := self detectShiftedRuns.	self processShiftedRuns.	"Now generate a patch sequence"	patchSequence := self generatePatchSequence.	^patchSequence! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 16:57'!buildReferenceMap	dstLines doWithIndex:[:line :index|		(srcPos at: line ifAbsent:[#()]) 			do:[:index2| matches at: index@index2 put: line]	].	srcLines doWithIndex:[:line :index|		(dstPos at: line ifAbsent:[#()]) 			do:[:index2| matches at: index2@index put: line]	].! !!TextDiffBuilder methodsFor: 'creating patches'!collectRunFrom: todo startingWith: startIndex into: run	| next start |	start := startIndex.	self remove: start from: todo.	run add: (matches at: start).	"Search downwards"	next := start.	[next := next + (1@1).	todo includes: next] whileTrue:[		run addLast: (matches at: next).		self remove: next from: todo].	"Search upwards"	next := start.	[next := next - (1@1).	todo includes: next] whileTrue:[		run addFirst: (matches at: next).		self remove: next from: todo.		start := next. "To use the first index"	].	^start! !!TextDiffBuilder methodsFor: 'creating patches'!detectShiftedRuns	| sortedRuns lastY run shiftedRuns |	runs size < 2 ifTrue: [^ nil].	shiftedRuns _ OrderedCollection new.	sortedRuns _ SortedCollection sortBlock: [:a1 :a2 | a1 key x < a2 key x].	runs associationsDo: [:assoc | sortedRuns add: assoc].	lastY _ sortedRuns first key y.	2 to: sortedRuns size do:[:i | 		run _ sortedRuns at: i.		run key y > lastY			ifTrue: [lastY _ run key y]			ifFalse: [shiftedRuns add: run]].	^ shiftedRuns! !!TextDiffBuilder methodsFor: 'creating patches'!generatePatchSequence	| ps |	ps := OrderedCollection new: srcLines size.	srcLines size timesRepeat:[ps add: nil].	self incorporateMatchesInto: ps.	self incorporateRemovalsInto: ps.	self incorporateAddsInto: ps.	^ps! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'di 3/15/1999 14:01'!incorporateAddsInto: aPatchSequence	"Incorporate adds"	| lastMatch lastIndex index |	added ifNil:[^self].	added := added sortBy:[:a1 :a2| a1 key < a2 key].	lastMatch := 1.	lastIndex := 0.	1 to: added size do:[:i|		index := (added at: i) key.		[index > lastMatch] whileTrue:[			[lastIndex := lastIndex + 1.			(aPatchSequence at: lastIndex) key == #match] whileFalse.			lastMatch := lastMatch + 1.		].		aPatchSequence add: #insert->(added at: i) value afterIndex: lastIndex.		lastIndex := lastIndex + 1.		lastMatch := lastMatch + 1.	].! !!TextDiffBuilder methodsFor: 'creating patches'!incorporateMatchesInto: aPatchSequence	"Incorporate matches"	| index |	runs associationsDo:[:assoc|		index := assoc key y.		assoc value do:[:line|			self assert:[(aPatchSequence at: index) isNil].			aPatchSequence at: index put: (#match -> line).			index := index + 1.		].	].! !!TextDiffBuilder methodsFor: 'creating patches'!incorporateRemovalsInto: aPatchSequence	"Incorporate removals"	| index |	removed ifNil:[^self].	removed do:[:assoc|		index := assoc key.		self assert:[(aPatchSequence at: index) isNil].		aPatchSequence at: index put: #remove -> assoc value.	].! !!TextDiffBuilder methodsFor: 'creating patches'!processDiagonals	^self processDiagonalsFrom: matches keys asSet! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 16:34'!processDiagonalsFrom: todoList	| runList start run todo |	todo := todoList copy.	runList := PluggableDictionary new.	runList hashBlock: self pointHashBlock.	[todo isEmpty] whileFalse:[		start := todo detect:[:any| true].		run := OrderedCollection new.		start := self 					collectRunFrom: todo 					startingWith: start 					into: run.		runList at: start put: run.	].	"If we have multiple matches we might have chosen a bad sequence.	There we redo the whole thing recursively"	self hasMultipleMatches  ifFalse:[^runList].	runList size < 2 ifTrue:[^runList].	run := nil.	start := 0.	runList associationsDo:[:assoc|		(run isNil or:[assoc value size > run size]) ifTrue:[			run := assoc value.			start := assoc key]].	"Now found the longest run"	run := OrderedCollection new.	start := self				collectRunFrom: todoList				startingWith: start				into: run.	"Find the diagonals in the remaining set"	runList := self processDiagonalsFrom: todoList.	runList at: start put: run.	^runList! !!TextDiffBuilder methodsFor: 'creating patches'!processShiftedRuns	| key |	shifted isNil ifTrue:[^self].	shifted do:[:assoc|		key := assoc key.		assoc value doWithIndex:[:line :idx|			removed add: (key y + idx - 1) -> line.			added add: (key x + idx - 1) -> line].		runs removeKey: assoc key.	].! !!TextDiffBuilder methodsFor: 'creating patches' stamp: 'ar 11/20/1998 17:26'!validateRuns: runList	| srcPosCopy dstPosCopy lines srcIndex dstIndex |	srcPosCopy _ srcPos copy.	srcPosCopy associationsDo:[:assoc| assoc value: assoc value asSet].	dstPosCopy _ dstPos copy.	dstPosCopy associationsDo:[:assoc| assoc value: assoc value asSet].	runList associationsDo:[:assoc|		srcIndex := assoc key y.		dstIndex := assoc key x.		lines := assoc value.		lines do:[:string|			(srcPosCopy at: string) remove: srcIndex.			(dstPosCopy at: string) remove: dstIndex.			srcIndex := srcIndex + 1.			dstIndex := dstIndex + 1.		].	].	removed := OrderedCollection new.	srcPosCopy associationsDo:[:assoc|		assoc value do:[:index| removed add: (index -> assoc key)].	].	removed := removed sortBy:[:a1 :a2| a1 key < a2 key].	added := OrderedCollection new.	dstPosCopy associationsDo:[:assoc|		assoc value do:[:index| added add: (index -> assoc key)].	].	added := added sortBy:[:a1 :a2| a1 key < a2 key].! !!TextDiffBuilder methodsFor: 'private' stamp: 'sma 5/6/2000 18:13'!attributeOf: type	"Private. Answer a TextAttribute that is used to display text of the given type."	type == #insert ifTrue: [^ TextColor red].	type == #remove ifTrue: [^ TextEmphasis struckOut].	^ TextEmphasis normal! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 16:35'!pointHashBlock	^[:pt| (pt x bitShift: 12) + pt y] fixTemps! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 16:31'!remove: pointKey from: aSet	self hasMultipleMatches ifFalse:[^aSet remove: pointKey].	aSet copy do:[:obj|		obj x = pointKey x ifTrue:[			aSet remove: obj.		] ifFalse:[			obj y = pointKey y ifTrue:[				aSet remove: obj.			].		]	].! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/20/1998 17:26'!split: aString by: splitChar	| lines index nextIndex |	lines := OrderedCollection new.	index _ 1.	[index <= aString size] whileTrue:[		nextIndex _ aString 						indexOf: splitChar 						startingAt: index 						ifAbsent:[aString size+1].		lines add: (aString copyFrom: index to: nextIndex-1).		index _ nextIndex+1].	^lines! !!TextDiffBuilder methodsFor: 'private'!splitCharacter	^Character cr! !!TextDiffBuilder methodsFor: 'private' stamp: 'ar 11/24/1998 13:41'!stringHashBlock	"Return a block for use in string hashing"	| stringSize |	^[:string| 		stringSize _ string size.		stringSize = 0 			ifTrue:[0]			ifFalse:[ stringSize < 3 				ifTrue:[(string at: 1) asInteger +						((string at: string size) asInteger bitShift: 8)]				ifFalse:[	(string at: 1) asInteger +						((string at: stringSize // 3 + 1) asInteger bitShift: 4) +						((string at: stringSize // 2 + 1) asInteger bitShift: 8) +						((string at: stringSize * 2 // 3 + 1) asInteger bitShift: 12) +						((string at: stringSize) asInteger bitShift: 16)]]] fixTemps! !!TextDiffBuilder class methodsFor: 'instance creation'!buildDisplayPatchFrom: srcString to: dstString	^(self from: srcString to: dstString) buildDisplayPatch! !!TextDiffBuilder class methodsFor: 'instance creation'!from: srcString to: dstString	^self new from: srcString to: dstString! !A TextEmphasis, encodes a characteristic applicable to all fonts.  The encoding is as follows:	1	bold	2	itallic	4	underlined	8	narrow	16	struck out!A TextFontChange encodes a font change applicable over a given range of text.  The font number is interpreted relative to the textStyle governing display of this text.!!TextFontChange class methodsFor: 'as yet unclassified' stamp: 'sw 12/6/1999 17:52'!defaultFontChange	"Answer a TextFontChange that represents the default font"	^ self new fontNumber: TextStyle default defaultFontIndex! !A TextFontReference encodes a font change applicable over a given range of text.  The font reference is absolute:  unlike a TextFontChange, it is independent of the textStyle governing display of this text.!!TextFontReference methodsFor: 'as yet unclassified' stamp: 'sw 11/9/1999 17:22'!couldDeriveFromPrettyPrinting	^ false! !!TextFontReference methodsFor: 'as yet unclassified' stamp: 'di 5/10/1999 23:47'!font	^ font! !!TextFontReference methodsFor: 'comparing' stamp: 'mas 5/7/1999 06:20'!= other 	^ (other class == self class) 		and: [other font == font]! !create a hanging indent. !!TextIndent methodsFor: 'access' stamp: 'ls 6/22/1998 17:51'!amount	"number of tab spaces to indent by"	^amount! !!TextIndent methodsFor: 'access' stamp: 'ls 6/22/1998 17:51'!amount: anInteger	"change the number of tabs to indent by"	amount _ anInteger! !!TextIndent methodsFor: 'printing' stamp: 'ls 6/22/1998 18:03'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' amount: '.	amount printOn: aStream! !!TextIndent methodsFor: 'setting indentation' stamp: 'ls 6/22/1998 18:56'!emphasizeScanner: scanner	scanner indentationLevel: amount! !!TextIndent methodsFor: 'condensing' stamp: 'ls 6/22/1998 19:27'!dominates: anAttribute	^(self class == anAttribute class)! !!TextIndent class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 15:55'!amount: amount	"create a TextIndent which will indent by the given amount.  Currently this is a number of tabs, but may change in the futur"	^super new amount: amount! !!TextIndent class methodsFor: 'instance creation' stamp: 'ls 6/27/1998 15:54'!tabs: numTabs	"create an indentation by the given number of tabs"	^self amount: numTabs! !!TextIndent class methodsFor: 'example' stamp: 'jm 7/23/2003 16:15'!example	"Display an example text with some color-coded indentations."	"TextIndent example"	| text pg r |	text _ 'How now brown cow? How much wood would a woodchuck chuck if a woodchuck could chuck wood? He was born with the gift of laughter and a conviction that the world was mad.' asText.	text addAttribute: (TextColor red)  from: 1 to: 18.	text addAttribute: (TextIndent amount: 1) from: 1 to: 18.	text addAttribute: (TextColor blue)  from: 90 to: 127.	text addAttribute: (TextIndent amount: 2) from: 90 to: 127.	"stick it in a paragraph and display it"	pg _ text asParagraph.	r _ 0@0 extent: 150@500.	pg compositionRectangle: r; clippingRectangle: r.	pg displayAt: 0@0.! !!TextIndent class methodsFor: 'example' stamp: 'jm 7/23/2003 16:19'!example2	"Display an example text with some color-coded indentations."	"TextIndent example2"	| text m |	text _ 'How now brown cow? How much wood would a woodchuck chuck if a woodchuck could chuck wood? He was born with the gift of laughter and a conviction that the world was mad.' asText.	text addAttribute: (TextColor red)  from: 1 to: 18.	text addAttribute: (TextIndent amount: 1) from: 1 to: 18.	text addAttribute: (TextColor blue)  from: 90 to: 127.	text addAttribute: (TextIndent amount: 2) from: 90 to: 127.	m _ TextMorph new extent: 150@500.	m contentsWrapped: text.	m openInWorld.! !A TextKern encodes a kerning change applicable over a given range of text.  Positive values of kern spread letters out, negative kern will cause them to overlap more.  Note that kerns other than 0 will display somewhat slower, as kerning is not yet supported in the text scanning primitive. !!TextKern methodsFor: 'as yet unclassified' stamp: 'sw 11/9/1999 17:21'!couldDeriveFromPrettyPrinting	^ false! !!TextKern methodsFor: 'as yet unclassified' stamp: 'tk 9/21/1999 15:57'!writeScanOn: strm	kern > 0 ifTrue: [		1 to: kern do: [:kk | strm nextPut: $+]].	kern < 0 ifTrue: [		1 to: 0-kern do: [:kk | strm nextPut: $-]].! !A TextLine embodies the layout of a line of composed text.	left right top bottom		The full line rectangle	firstIndex lastIndex		Starting and stopping indices in the full text	internalSpaces		Number of spaces to share paddingWidth	paddingWidth		Number of pixels of extra space in full line	baseline				Distance of baseline below the top of the line	leftMargin			Left margin due to paragraph indentationTextLine's rather verbose message protocol is required for compatibility with the old CharacterScanners.!!TextLine methodsFor: 'updating' stamp: 'di 4/28/1999 11:12'!slideIndexBy: delta andMoveTopTo: newTop	"Relocate my character indices and y-values.	Used to slide constant text up or down in the wake of a text replacement."	firstIndex _ firstIndex + delta.	lastIndex _ lastIndex + delta.	bottom _ bottom + (newTop - top).	top _ newTop.! !My instances specify the starting and stopping points in a String of a composed line. The step is always 1.!I support display of (possibly) multiple lines of text that includes a mixture of different fonts and styles. I also support text-editing capabilities, as well as imbedded hot links, and the ability to embed submorphs in the text. When a TextMorph has been embedded into another Morph, one can elect to make the text fill its owner's bounds, in which case the text will be laid out in the shape of the owner's shadow image (including any submorphs other than the TextMorph itself). One can also elect to have the text flow around occlusions, in which case it will avoid the bounds of any sibling morphs that appear in front of it. It may be necessary to update the bounds in order for the text runaround to notice the presence of a new occluding shape.!!TextMorph methodsFor: 'initialization' stamp: 'mir 8/2/1999 10:34'!string: aString fontName: aName size: aSize	self string: aString fontName: aName size: aSize wrap: true! !!TextMorph methodsFor: 'initialization' stamp: 'mir 8/2/1999 10:35'!string: aString fontName: aName size: aSize wrap: shouldWrap	shouldWrap		ifTrue: [self contentsWrapped: aString]		ifFalse: [self contents: aString].	self fontName: aName size: aSize! !!TextMorph methodsFor: 'accessing' stamp: 'di 10/5/1998 13:56'!editor	"Return my current editor, or install a new one."	editor ifNotNil: [^ editor].	^ self installEditorToReplace: nil! !!TextMorph methodsFor: 'accessing' stamp: 'mir 8/2/1999 10:33'!fontName: fontName size: fontSize	| newTextStyle |	newTextStyle _ (TextStyle named: fontName asSymbol) copy.	newTextStyle ifNil: [self halt: 'Error: font ', fontName, ' not found.'].	textStyle _ newTextStyle.	text addAttribute: (TextFontChange fontNumber: (newTextStyle fontIndexOfSize: fontSize)).	paragraph ifNotNil: [paragraph textStyle: newTextStyle]! !!TextMorph methodsFor: 'accessing' stamp: 'dvf 6/16/2000 17:40'!newContents: stringOrText 	"Accept new text contents."	| newText embeddedMorphs |	newText _ stringOrText asText.	text = newText ifTrue: [^ self].	"No substantive change"	text ifNotNil: [(embeddedMorphs _ text embeddedMorphs)			ifNotNil: 				[self removeAllMorphsIn: embeddedMorphs.				embeddedMorphs do: [:m | m delete]]].	text _ newText.	"add all morphs off the visible region; they'll be moved into the right 	place when they become visible. (this can make the scrollable area too 	large, though)"	stringOrText asText embeddedMorphs do: 		[:m | 		self addMorph: m.		m position: -1000 @ 0].	self releaseParagraph.	"update the paragraph cache"	self paragraph.	"re-instantiate to set bounds"	self world ifNotNil: [self world startSteppingSubmorphsOf: self]! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 10:55'!drawBoundsOn: aCanvas	"Shows where line boundaries are"	self paragraph lines do:		[:line | aCanvas frameRectangle: line rectangle color: Color brown]! !!TextMorph methodsFor: 'drawing' stamp: 'di 6/22/1998 10:39'!drawNullTextOn: aCanvas	"make null text frame visible"	aCanvas fillRectangle: bounds color: Color lightRed! !!TextMorph methodsFor: 'drawing'!drawOn: aCanvas	self setDefaultContentsIfNil.	"self drawBoundsOn: aCanvas."  "show line rects for debugging"	self startingIndex > text size		ifTrue: [self drawNullTextOn: aCanvas]		ifFalse: [aCanvas paragraph: self paragraph bounds: bounds color: color].! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55'!chooseAlignment	self editor changeAlignment.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55'!chooseEmphasis	self editor changeEmphasis.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'sw 9/27/1999 12:13'!chooseEmphasisOrAlignment	self editor changeEmphasisOrAlignment.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55'!chooseFont	self editor offerFontMenu.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'di 10/5/1998 13:55'!chooseStyle	self editor changeStyle.	self updateFromParagraph! !!TextMorph methodsFor: 'editing' stamp: 'RAA 6/15/2000 13:43'!handleInteraction: interactionBlock fromEvent: evt        | oldEditor oldParagraph |        "Perform the changes in interactionBlock, noting any change in selection"        "Also couple ParagraphEditor to Morphic keyboard events"        self editor sensor: (KeyboardBuffer new startingEvent: evt).        oldEditor _ editor.        oldParagraph _ paragraph.        self selectionChanged.  "Note old selection"                interactionBlock value.        oldParagraph == paragraph ifTrue: [     "this will not work if the paragraph changed"                editor _ oldEditor.     "since it may have been changed while in block"        ].        self selectionChanged.  "Note new selection"! !!TextMorph methodsFor: 'editing' stamp: 'di 8/11/1998 13:04'!handlesMouseDown: evt	self isPartsDonor ifTrue: [^ false].	^ self uncoveredAt: evt cursorPoint! !!TextMorph methodsFor: 'editing' stamp: 'di 6/7/1999 15:51'!keyboardFocusChange: aBoolean	| w |	aBoolean		ifTrue: ["A hand is wanting to send us characters..."				self hasFocus ifFalse: [self editor "Forces install"]]		ifFalse: ["A hand has clicked elsewhere..."				(w _ self world) == nil ifFalse:					[w handsDo: [:h | h keyboardFocus == self ifTrue: [^ self]].					"Release control unless some hand is still holding on"					self releaseEditor]].! !!TextMorph methodsFor: 'editing' stamp: 'di 6/7/1999 15:56'!passKeyboardFocusTo: otherMorph	| w |	(w _ self world) == nil ifFalse:		[w handsDo:			[:h | h keyboardFocus == self				ifTrue: [h newKeyboardFocus: otherMorph]]].! !!TextMorph methodsFor: 'geometry' stamp: 'di 10/8/1998 23:46'!bounds	container ifNil: [^ bounds].	^ container bounds ifNil: [bounds]! !!TextMorph methodsFor: 'geometry' stamp: 'di 1/28/1999 09:20'!container	"Return the container for composing this text.  There are four cases:	1.  container is specified as, eg, an arbitrary shape,	2.  container is specified as the bound rectangle, because		this morph is linked to others,	3.  container is nil, and wrap is true -- grow downward as necessary,	4.  container is nil, and wrap is false -- grow in 2D as nexessary."	container ifNil:		[successor ifNotNil: [^ self bounds].		wrapFlag ifTrue: [^ self bounds withHeight: 9999999].		^ self position extent: 9999999@9999999].	^ container! !!TextMorph methodsFor: 'geometry' stamp: 'di 1/13/1999 14:11'!containsPoint: aPoint	(super containsPoint: aPoint) ifFalse: [^false].	self startingIndex > text size ifTrue:		["make null text frame visible"		^ super containsPoint: aPoint].	^ self paragraph containsPoint: aPoint! !!TextMorph methodsFor: 'geometry' stamp: 'di 8/14/1998 15:50'!defaultLineHeight	^ textStyle lineGrid! !!TextMorph methodsFor: 'geometry' stamp: 'di 4/27/2000 10:37'!privateMoveBy: delta	editor == nil		ifTrue: [super privateMoveBy: delta.				paragraph ifNotNil: [paragraph moveBy: delta]]		ifFalse: ["When moving text with an active editor, save and restore all state."				super privateMoveBy: delta.				paragraph moveBy: delta.				self installEditorToReplace: editor]! !!TextMorph methodsFor: 'menu' stamp: 'jm 10/19/2002 09:32'!addCustomMenuItems: aCustomMenu hand: aHandMorph	| outer |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'add predecessor' action: #addPredecessor:.	aCustomMenu add: 'add successor' action: #addSuccessor:.	outer _ self owner.	((outer isKindOf: PolygonMorph) and: [outer isOpen]) ifFalse: [		(container == nil or: [container fillsOwner not])			ifTrue: [aCustomMenu add: 'fill owner''s shape' action: #fillingOnOff]			ifFalse: [aCustomMenu add: 'rectangluar bounds' action: #fillingOnOff].		(container == nil or: [container avoidsOcclusions not])			ifTrue: [aCustomMenu add: 'avoid occlusions' action: #occlusionsOnOff]			ifFalse: [aCustomMenu add: 'ignore occlusions' action: #occlusionsOnOff]].! !!TextMorph methodsFor: 'private' stamp: 'di 4/14/98 09:30'!fit	"Adjust bounds to fit the text if not in a rigid container."	| newExtent para |	newExtent _ (self paragraph extent max: 9@textStyle lineGrid) + (0@2).	newExtent ~= bounds extent ifTrue:		[(container == nil and: [successor == nil]) ifTrue:			[para _ paragraph.  "Save para (layoutChanged smashes it)"			super extent: newExtent.			paragraph _ para]].	container ifNotNil:		[self privateBounds: container bounds truncated].	self paragraph positionWhenComposed: self position.	successor ifNotNil:		[successor predecessorChanged].	self changed. "Too conservative: only paragraph composition					should cause invalidation."! !!TextMorph methodsFor: 'private' stamp: 'di 10/5/1998 13:53'!installEditor	"Install an editor for my paragraph.  This constitutes 'hasFocus'."	editor ifNotNil: [^ editor].	^ self installEditorToReplace: nil! !!TextMorph methodsFor: 'private' stamp: 'di 10/5/1998 17:04'!installEditorToReplace: priorEditor	"Install an editor for my paragraph.  This constitutes 'hasFocus'.	If priorEditor is not nil, then initialize the new editor from its state.	We may want to rework this so it actually uses the prior editor."	| stateArray |	priorEditor ifNotNil: [stateArray _ priorEditor stateArray].	editor _ TextMorphEditor new morph: self.	editor changeParagraph: self paragraph.	priorEditor ifNotNil: [editor stateArrayPut: stateArray].	self selectionChanged.	^ editor! !!TextMorph methodsFor: 'private' stamp: 'jm 10/15/2002 16:32'!paragraph	"Paragraph instantiation is lazy -- create it only when needed"	paragraph ifNotNil: [^ paragraph].	self setDefaultContentsIfNil.	"...code here to recreate the paragraph..."	paragraph _ (self paragraphClass new textOwner: self owner)		compose: text style: textStyle copy		from: self startingIndex in: self container.	wrapFlag ifFalse: [		"was given huge container at first... now adjust"		paragraph adjustRightX].	self fit.	^ paragraph! !!TextMorph methodsFor: 'private' stamp: 'di 10/5/1998 16:39'!releaseEditor 	"Release the editor for my paragraph.  This morph no longer 'hasFocus'."	editor ifNotNil:		[self selectionChanged.		self paragraph selectionStart: nil selectionStop: nil.		editor _ nil].! !!TextMorph methodsFor: 'private' stamp: 'di 1/19/2000 15:47'!updateFromParagraph	"A change has taken place in my paragraph, as a result of editing and I must be updated.  If a line break causes recomposition of the current paragraph, or it the selection has entered a different paragraph, then the current editor will be release, and must be reinstalled with the resulting new paragraph, while retaining any editor state, such as selection, undo state, and current typing emphasis."	| newStyle sel oldLast oldEditor |	paragraph ifNil: [^ self].	wrapFlag ifNil: [wrapFlag _ true].	editor ifNotNil: [oldEditor _ editor.					sel _ editor selectionInterval.					editor storeSelectionInParagraph].	text _ paragraph text.	paragraph textStyle = textStyle		ifTrue: [self fit]		ifFalse: ["Broadcast style changes to all morphs"				newStyle _ paragraph textStyle.				(self firstInChain text: text textStyle: newStyle) recomposeChain.				editor ifNotNil: [self installEditorToReplace: editor]].	super layoutChanged.	sel ifNil: [^ self].	"If selection is in top line, then recompose predecessor for possible ripple-back"	predecessor ifNotNil:		[sel first <= (self paragraph lines first last+1) ifTrue:			[oldLast _ predecessor lastCharacterIndex.			predecessor paragraph recomposeFrom: oldLast to: text size delta: 0.			oldLast = predecessor lastCharacterIndex				ifFalse: [predecessor changed. "really only last line"						self predecessorChanged]]].	((predecessor~~nil and: [sel first <= self paragraph firstCharacterIndex])		or: [successor~~nil and: [sel first > (self paragraph lastCharacterIndex+1)]])		ifTrue:		["The selection is no longer inside this paragraph.		Pass focus to the paragraph that should be in control."		self firstInChain withSuccessorsDo:			[:m |  (sel first between: m firstCharacterIndex								and: m lastCharacterIndex+1)					ifTrue: [m installEditorToReplace: editor.							^ self passKeyboardFocusTo: m]].		self error: 'Inconsistency in text editor' "Must be somewhere in the successor chain"].	editor ifNil:		["Reinstate selection after, eg, style change"		self installEditorToReplace: oldEditor]! !!TextMorph methodsFor: 'containment' stamp: 'sw 6/25/1998 10:44'!ownerChanged	super ownerChanged.	container ifNotNil:		[self releaseParagraph]! !!TextMorph methodsFor: 'containment' stamp: 'tk 9/28/1999 16:50'!privateOwner: newOwner	"Nil the container when text gets extracted"	super privateOwner: newOwner.	container ifNotNil: [		newOwner ifNotNil: [			newOwner isWorldOrHandMorph ifTrue: [self setContainer: nil]]]! !!TextMorph methodsFor: 'anchors' stamp: 'tk 6/30/1998 17:06'!acceptDroppingMorph: aMorph event: evt	"This message is sent when a morph is dropped onto me."	self addMorphFront: aMorph fromWorldPosition: aMorph position.		"Make a TextAnchor and install it in a run."! !!TextMorph methodsFor: 'anchors' stamp: 'ar 11/15/1998 23:42'!addMorphFront: aMorph fromWorldPosition: wp 	"Overridden for more specific re-layout and positioning"	| i |	self addMorphFront: aMorph.	i _ (self paragraph characterBlockAtPoint: (self transformFromWorld globalPointToLocal: wp))		stringIndex.	self paragraph replaceFrom: i to: i-1		with: (Text string: '*' attribute: (TextAnchor new anchoredMorph: aMorph))		displaying: false.	self fit! !!TextMorph class methodsFor: 'as yet unclassified' stamp: 'jm 5/31/2003 20:01'!includeInNewMorphMenu	^ true! !I am an editor for TextMorphs.!!TextMorphEditor methodsFor: 'accessing' stamp: 'tk 1/13/1999 07:53'!morph	^ morph! !!TextMorphEditor methodsFor: 'accessing' stamp: 'tk 1/13/1999 07:53'!morph: aMorph	"Install a link back to the morph being edited (esp for text links)"	morph _ aMorph ! !!TextMorphEditor methodsFor: 'events' stamp: 'di 9/8/1999 11:48'!mouseDown: evt 	"An attempt to break up the old processRedButton code into threee phases"	| clickPoint |	oldInterval _ startBlock stringIndex to: stopBlock stringIndex - 1.	clickPoint _ evt cursorPoint.	(paragraph clickAt: clickPoint for: model controller: self) ifTrue: [		evt hand newKeyboardFocus: nil.		^ self].	sensor leftShiftDown		ifFalse:			[self closeTypeIn.			stopBlock _ startBlock _ pivotBlock _				paragraph characterBlockAtPoint: clickPoint]		ifTrue:			[(paragraph characterBlockAtPoint: clickPoint) <= startBlock				ifTrue: [stopBlock _ startBlock.						pivotBlock _ stopBlock]				ifFalse: [startBlock _  stopBlock.						pivotBlock _ startBlock].			self closeTypeIn].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:12'!mouseMove: evt 	"Change the selection in response to moue-down drag"	| dragBlock |	pivotBlock ifNil: [^ self].  "Patched during clickAt: repair"	dragBlock _ paragraph characterBlockAtPoint: (evt cursorPoint).	dragBlock > pivotBlock		ifTrue: [stopBlock _ dragBlock.  startBlock _ pivotBlock]		ifFalse: [startBlock _ dragBlock.  stopBlock _ pivotBlock].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:12'!mouseUp: evt	"An attempt to break up the old processRedButton code into threee phases"	oldInterval ifNil: [^ self].  "Patched during clickAt: repair"	(startBlock = stopBlock 		and: [oldInterval = (startBlock stringIndex to: startBlock stringIndex-1)])		ifTrue: [self selectWord].	self setEmphasisHere.	(self isDisjointFrom: oldInterval) ifTrue:		[otherInterval _ oldInterval].	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'events' stamp: 'di 6/14/1998 13:11'!readKeyboard	super readKeyboard.	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'menu commands' stamp: 'di 10/9/1998 16:55'!cancel	"Cancel the changes made so far to this text"	morph cancelEdits! !!TextMorphEditor methodsFor: 'menu commands' stamp: 'jm 10/13/2002 18:57'!changeEmphasis: characterStream 	"Intercept requests to create a link (Cmd-6). Make them simpler for end-user editing. SystemWidows use ParagraphEditor's complex commands."	| keyCode attribute index colors theSelection labels |	"Test if it's really the droids we're looking for..."	keyCode _ ('0123456789-=' indexOf: sensor keyboardPeek ifAbsent: [1]) - 1.	keyCode ~= 6 ifTrue: [^ super changeEmphasis: characterStream].		"underline, bold, etc."	(morph isKindOf: TextMorphForEditView) ifTrue: [		^ super changeEmphasis: characterStream].	"if in a browser, show all choices"	sensor keyboard.  "Yes, it is Cmd-6;  consume the command character"	theSelection _ self selection.	colors _ #(black magenta red yellow green blue cyan white).	labels _ colors, #(active).	index _ (PopUpMenu labelArray: labels lines: (Array with: colors size)) startUp.	index = 0 ifTrue: [^ true].	index <= colors size ifTrue:		[attribute _ TextColor color: (Color perform: (colors at: index))].	index = (colors size + 1) ifTrue:		[attribute _ TextDoIt new.		theSelection _ attribute analyze: self selection asString].	self replaceSelectionWith: (theSelection asText addAttribute: attribute).	^ true! !!TextMorphEditor methodsFor: 'menu commands' stamp: 'di 10/5/1998 21:48'!find	super find.	morph installEditorToReplace: self! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 6/22/1998 01:32'!againOrSame: bool	super againOrSame: bool.	morph editView selectionInterval: self selectionInterval! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'sbw 10/14/1999 17:06'!selectAndScrollToTop	"Scroll until the selection is in the view and then highlight it."	| lineHeight deltaY rect deltaX |	lineHeight _ paragraph textStyle lineGrid.	rect _ morph owner bounds.	deltaY _ stopBlock top - rect top.	deltaY ~= 0 ifTrue: [		deltaX _ 0.		deltaY _ (deltaY abs + lineHeight - 1 truncateTo: lineHeight) negated.		morph editView scrollBy: deltaX@deltaY]! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'sbw 10/14/1999 16:51'!selectForTopFrom: start to: stop	self selectFrom: start to: stop.	morph editView ifNotNil: [self selectAndScrollToTop]! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'di 6/14/1998 13:12'!selectFrom: start to: stop	"Select the specified characters inclusive."	self selectInvisiblyFrom: start to: stop.	self closeTypeIn.	self storeSelectionInParagraph! !!TextMorphEditor methodsFor: 'mvc compatibility' stamp: 'sw 12/7/1999 12:27'!zapSelectionWith: aText	"**overridden to inhibit old-style display"	| start stop |	self deselect.	start _ startBlock stringIndex.	stop _ stopBlock stringIndex.	(aText isEmpty and: [stop > start]) ifTrue:		["If deleting, then set emphasisHere from 1st character of the deletion"		emphasisHere _ (paragraph text attributesAt: start forStyle: paragraph textStyle)					select: [:att | att mayBeExtended]].	(start = stop and: [aText size = 0]) ifFalse:		[paragraph replaceFrom: start to: stop - 1			with: aText displaying: false.  "** was true in super"		self computeIntervalFrom: start to: start + aText size - 1.		UndoInterval _ otherInterval _ self selectionInterval].	self userHasEdited  " -- note text now dirty"! !!TextMorphEditor methodsFor: 'binding' stamp: 'ls 7/24/1998 21:06'!bindingOf: aString	^model bindingOf: aString! !!TextMorphEditor methodsFor: 'as yet unclassified' stamp: 'sbw 10/13/1999 22:41'!totalTextHeight	^paragraph lines last bottom! !!TextMorphEditor methodsFor: 'as yet unclassified' stamp: 'sbw 10/13/1999 22:43'!visibleHeight	^morph owner bounds height! !!TextMorphEditor class methodsFor: 'instance creation' stamp: 'jm 5/30/2003 10:48'!new	"Initialize, but don't set my paragraph."	^ self basicNew initialize! !I am a TextMorph used for editable texts.!!TextMorphForEditView methodsFor: 'initialization' stamp: 'di 9/11/1998 15:43'!initialize	super initialize.	acceptOnCR _ false! !!TextMorphForEditView methodsFor: 'events' stamp: 'bf 4/14/1999 12:39'!keyStroke: evt	| view |	(editView scrollByKeyboard: evt) ifTrue: [^self].	self editor model: editView model.  "For evaluateSelection"	view _ editView.  "Copy into temp for case of a self-mutating doit"	(acceptOnCR and: [evt keyCharacter = Character cr])		ifTrue: [^ self editor accept].	super keyStroke: evt.	view scrollSelectionIntoView! !!TextMorphForEditView methodsFor: 'events' stamp: 'di 6/30/1998 08:50'!mouseDown: event	event yellowButtonPressed ifTrue: [^ editView yellowButtonActivity: event shiftPressed].	^ super mouseDown: event! !!TextMorphForEditView methodsFor: 'other' stamp: 'di 9/11/1998 15:42'!acceptOnCR: trueOrFalse	acceptOnCR _ trueOrFalse! !!TextMorphForEditView methodsFor: 'other' stamp: 'di 6/22/1998 10:44'!drawNullTextOn: aCanvas	"Just run the normal code to show selection in a window"	aCanvas paragraph: self paragraph bounds: bounds color: color! !!TextMorphForEditView methodsFor: 'other' stamp: 'di 6/22/1998 01:31'!editView	^ editView! !!TextMorphForEditView methodsFor: 'other' stamp: 'di 11/10/1998 10:13'!flash	^ editView flash! !!TextMorphForEditView methodsFor: 'other' stamp: 'di 10/5/1998 14:03'!handleInteraction: interActionBlock fromEvent: evt	"Overridden to pass along a model to the editor for, eg, link resolution, doits, etc"	self editor model: editView model.  "For evaluateSelection, etc"	^ super handleInteraction: interActionBlock fromEvent: evt! !!TextMorphForEditView methodsFor: 'private' stamp: 'dew 2/21/1999 03:09'!updateFromParagraph  	super updateFromParagraph.	editView setScrollDeltas.! !I represent a link to either a SqueakPage in a BookMorph, or a regular url.  See TextMorphEditor changeEmphasis:.  !]style[(81 31 4)f1,f1LTextMorphEditor changeEmphasis:;,f1!!TextSqkPageLink methodsFor: 'as yet unclassified' stamp: 'tk 1/13/1999 08:14'!writeScanOn: strm	strm nextPut: $q; nextPutAll: url; nextPut: $;! !!TextStream methodsFor: 'as yet unclassified' stamp: 'djp 11/6/1999 20:30'!withAttributes: attributes do: streamBlock 	| pos1 val |	pos1 _ self position.	val _ streamBlock value.	attributes do: [:attribute |		collection			addAttribute: attribute			from: pos1 + 1			to: self position].	^ val! !!TextStyle methodsFor: 'accessing' stamp: 'sw 12/6/1999 12:31'!defaultFont	^ fontArray at: self defaultFontIndex! !!TextStyle methodsFor: 'accessing' stamp: 'jm 6/9/2003 21:51'!fontNamesWithHeights	"Answer a collection of strings containing the font name and height for each of my fonts."	"TextStyle default fontNamesWithHeights"	^ fontArray collect: [:x |		x name withoutTrailingDigits, ' ', x height printString]! !!TextStyle methodsFor: 'accessing' stamp: 'sma 12/30/1999 13:57'!printOn: aStream	super printOn: aStream.	aStream space; nextPutAll: self defaultFont name! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'sw 12/8/1999 18:02'!consistOnlyOf: aFont	fontArray _ Array with: aFont.	defaultFontIndex _ 1! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'sw 12/6/1999 13:54'!fontIndexOf: aFont	^ fontArray indexOf: aFont ifAbsent: [nil]! !!TextStyle methodsFor: 'fonts and font indexes' stamp: 'sw 1/18/2000 21:34'!fontOfPointSize: aPointSize	^ fontArray detect: [:aFont | aFont pointSize = aPointSize] ifNone: [nil]! !!TextStyle methodsFor: 'private' stamp: 'di 3/20/1999 22:31'!fontAt: index 	"This is private because no object outside TextStyle should depend on the 	representation of the font family in fontArray."	^ fontArray atPin: index! !!TextStyle methodsFor: 'default font' stamp: 'sw 12/6/1999 12:30'!defaultFontIndex	^ defaultFontIndex ifNil: [defaultFontIndex _ 1]! !!TextStyle methodsFor: 'default font' stamp: 'sw 12/6/1999 13:50'!defaultFontIndex: anIndex	defaultFontIndex _ anIndex! !!TextStyle class methodsFor: 'constants' stamp: 'sw 12/6/1999 12:32'!defaultFont	"Answer the default system font"	^ DefaultTextStyle defaultFont! !!TextURL methodsFor: 'as yet unclassified' stamp: 'jm 10/14/2002 18:52'!actOnClickFor: anObject	"Do what you can with this URL. Later show it in a web browser."	| response |	response _ (PopUpMenu labels: 'View web page as source\Cancel' withCRs)		startUpWithCaption: 'Couldn''t find a web browser. Viewpage as source?'.	response = 1 ifTrue: [HTTPSocket httpShowPage: url].	^ true! !A button morph with separate images for on, off, and pressed with the mouse. When the event actWhen occurs, send actionSelector with 'arguments' to target.  For other events, default to my eventHandler.  The current event is not supplied in the arguments to the actionSelector.  image (a.k.a. onImage) may not be nil.  offImage and pressedImage may be nil.  nil there means be transparent and show the underlying object.  If my getSelector is not nil, I update myself from the state of my target object.Tools for debugging:Display the images momentarily under program control (for positioning) (self is an instance).	self state: #on.  self state: #off.	self state: #pressed.  self state: #off.Display a rectangle where the button is.	Display fillWithColor: bounds + (self world viewBox origin).	self invalidRect: bounds.!!ThreePhaseButtonMorph methodsFor: 'initialization' stamp: 'jm 10/13/2002 17:37'!initialize	super initialize.	state _ #off.	target _ nil.	actionSelector _ #flash.	arguments _ Array empty.	actWhen _ #buttonUp.	"self on: #mouseStillDown send: #dragIfAuthoring: to: self."		"real move should include a call on dragIfAuthoring: "! !!ThreePhaseButtonMorph methodsFor: 'accessing' stamp: 'jm 10/4/2002 08:45'!adaptToWorld: aWorld	super adaptToWorld: aWorld.	target isMorph ifTrue: [		target isWorldMorph ifTrue: [self target: aWorld].		target isHandMorph ifTrue: [self target: aWorld primaryHand]].! !!ThreePhaseButtonMorph methodsFor: 'accessing' stamp: 'jm 6/15/2003 11:46'!getSelector	^ getSelector! !!ThreePhaseButtonMorph methodsFor: 'accessing' stamp: 'jm 6/15/2003 11:46'!getSelector: sel	getSelector _ sel.! !!ThreePhaseButtonMorph methodsFor: 'accessing' stamp: 'sw 3/8/1999 13:56'!isOn	^ state == #on! !!ThreePhaseButtonMorph methodsFor: 'accessing' stamp: 'sw 5/23/2000 17:53'!mouseDown: evt	| now dt |	self state: #pressed.	actWhen == #buttonDown		ifTrue:			[self doButtonAction]		ifFalse:			[now _ Time millisecondClockValue.			super mouseDown: evt.			"Allow on:send:to: to set the response to events other than actWhen"			dt _ Time millisecondClockValue - now max: 0.  "Time it took to do"			dt < 200 ifTrue: [(Delay forMilliseconds: 200-dt) wait]]	! !!ThreePhaseButtonMorph methodsFor: 'accessing' stamp: 'jm 11/13/2002 11:02'!onImage	^ form! !!ThreePhaseButtonMorph methodsFor: 'accessing' stamp: 'jm 11/13/2002 11:01'!onImage: aForm	form _ aForm.	self invalidRect: self bounds.! !!ThreePhaseButtonMorph methodsFor: 'drawing' stamp: 'jm 11/13/2002 11:02'!drawOn: aCanvas	state == #off ifTrue: [		offImage ifNotNil: [aCanvas paintImage: offImage at: bounds origin]].	state == #pressed ifTrue: [		pressedImage ifNotNil: [aCanvas paintImage: pressedImage at: bounds origin]].	state == #on ifTrue: [		form ifNotNil: [aCanvas paintImage: form at: bounds origin]].! !!ThreePhaseButtonMorph methodsFor: 'stepping' stamp: 'jm 6/16/2003 14:24'!step	| newOnState |	getSelector ifNil: [^ self stopStepping].	state == #pressed ifTrue: [^ self].  "do not update while user is pressing me"	newOnState _ target perform: getSelector.	newOnState == self isOn ifFalse: [		self state: (newOnState ifTrue: [#on] ifFalse: [#off])].! !!ThreePhaseButtonMorph methodsFor: 'stepping' stamp: 'jm 6/15/2003 11:50'!stepTime	^ 50! !!ThreePhaseButtonMorph methodsFor: 'printing' stamp: 'sw 11/11/1998 15:01'!printOn: aStream	| string |	aStream nextPutAll: '3PButton'.	arguments size > 0 ifTrue: [string _ arguments at: (2 min: arguments size)].	aStream nextPutAll: '('.	(string ~~ nil and: [string ~~ self])		ifTrue:			[aStream print: string; space]		ifFalse:			[aStream print: actionSelector; space].	aStream print: self identityHash;			nextPutAll: ')'.! !!ThreePhaseButtonMorph class methodsFor: 'class initialization' stamp: 'jm 10/8/2002 09:08'!initialize	"self initialize"	| extent inset f r c |	extent _ 12@12.	inset _ 3.	#(CheckBoxOff CheckBoxOn CheckBoxPressed) do: [:fName |		f _ ColorForm extent: extent depth: 1.		f colors: {Color transparent. Color black}.		f borderWidth: 1.		r _ f boundingBox insetBy: inset.		fName = #CheckBoxPressed ifTrue: [f border: r width: 1].		fName = #CheckBoxOn ifTrue: [f fillBlack: r].		self classPool at: fName put: f].	#(RadioButtonOff RadioButtonOn RadioButtonPressed) do: [:fName |		f _ ColorForm extent: extent depth: 1.		f colors: {Color transparent. Color black}.		r _ f boundingBox.		c _ f getCanvas.		c frameOval: r color: Color black.		r _ r insetBy: inset.		fName = #RadioButtonPressed ifTrue:			[c frameOval: r color: Color black].		fName = #RadioButtonOn ifTrue:			[c fillOval: r color: Color black].		self classPool at: fName put: f].! !!ThreePhaseButtonMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 18:50'!checkBox	"Answer a button pre-initialized with checkbox images."	^ super new		onImage: CheckBoxOn;		pressedImage: CheckBoxPressed;		offImage: CheckBoxOff;		extent: CheckBoxOn extent + (2@0);		yourself! !!ThreePhaseButtonMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 18:50'!radioButton	"Answer a button pre-initialized with radiobutton images."	^ super new		onImage: RadioButtonOn;		pressedImage: RadioButtonPressed;		offImage: RadioButtonOff;		extent: RadioButtonOn extent + (2@0);		yourself! !I represent the time of day.Internally I store the number of seconds since midnight.!!Time methodsFor: 'accessing' stamp: 'BP 5/17/2000 19:48'!hours	"Answer the number of hours the receiver represents."	^seconds // 3600! !!Time methodsFor: 'accessing' stamp: 'BP 5/17/2000 00:48'!minutes	"Answer the number of minutes the receiver represents."	^seconds \\ 3600 // 60! !!Time methodsFor: 'accessing' stamp: 'BP 5/17/2000 00:00'!seconds	"Answer the number of seconds the receiver represents."	^seconds \\ 3600 \\ 60! !!Time methodsFor: 'comparing' stamp: 'BP 5/17/2000 00:00'!< aTime 	"Answer whether aTime is earlier than the receiver."	^seconds < aTime asSeconds! !!Time methodsFor: 'comparing' stamp: 'BP 5/17/2000 00:00'!= aTime 	"Answer whether aTime represents the same second as the receiver."	self species = aTime species		ifTrue: [ ^seconds = aTime asSeconds ]		ifFalse: [ ^false ].! !!Time methodsFor: 'comparing' stamp: 'BP 5/17/2000 00:00'!hash	"Hash must be redefined since = was redefined."	^seconds hash! !!Time methodsFor: 'printing' stamp: 'BP 5/17/2000 19:44'!hhmm24	"Return a string of the form 1123 (for 11:23 am), 2154 (for 9:54 pm), of exactly 4 digits"	^(String streamContents: 		[ :aStream | self print24: true showSeconds: false on: aStream ])			copyWithout: $:! !!Time methodsFor: 'printing' stamp: 'BP 5/17/2000 19:44'!intervalString	"Treat the time as a difference.  Give it in hours and minutes with two digits of accuracy."	| hh mm ss |	hh _ self hours = 0 ifTrue: [''] ifFalse: [' ', self hours printString, ' hours'].	mm _ self minutes = 0 ifTrue: [''] ifFalse: [' ', self minutes printString, ' minutes'].	ss _ self seconds = 0 ifTrue: [''] ifFalse: [' ', self seconds printString, ' seconds'].	hh size > 0 ifTrue: [ss _ ''].	^ hh, mm, ss! !!Time methodsFor: 'printing' stamp: 'BP 5/17/2000 19:43'!print24	"Return as 8-digit string 'hh:mm:ss', with leading zeros if needed"	^String streamContents:		[ :aStream | self print24: true on: aStream ]! !!Time methodsFor: 'printing' stamp: 'BP 5/17/2000 19:41'!print24: hr24 on: aStream 	"Format is 'hh:mm:ss' or 'h:mm:ss am' "	self print24: hr24 showSeconds: true on: aStream ! !!Time methodsFor: 'printing' stamp: 'BP 5/17/2000 19:42'!print24: hr24 showSeconds: showSeconds on: aStream 	"Format is 'hh:mm:ss' or 'h:mm:ss am'  or, if showSeconds is false, 'hh:mm' or 'h:mm am'"	| h m s |	h _ self hours. m _ self minutes. s _ self seconds.	hr24	ifTrue:	[		h < 10 ifTrue: [ aStream nextPutAll: '0' ].		h printOn: aStream	]	ifFalse:	[		h > 12		ifTrue: [ h - 12 printOn: aStream]		ifFalse: 		[			h < 1				ifTrue: [ 12 printOn: aStream ]				ifFalse: [ h printOn: aStream ]		]	].	aStream nextPutAll: (m < 10 ifTrue: [':0'] ifFalse: [':']).	m printOn: aStream.	showSeconds ifTrue:	[		aStream nextPutAll: (s < 10 ifTrue: [':0'] ifFalse: [':']).		s printOn: aStream	].	hr24 ifFalse:	[		aStream nextPutAll: (h < 12 ifTrue: [' am'] ifFalse: [' pm'])	].! !!Time methodsFor: 'converting' stamp: 'BP 5/17/2000 00:00'!asSeconds	"Answer the number of seconds since midnight of the receiver."	^seconds! !!Time methodsFor: 'private' stamp: 'BP 5/17/2000 19:45'!hours: anInteger	self hours: anInteger minutes: 0 seconds: 0.! !!Time methodsFor: 'private' stamp: 'BP 5/17/2000 00:00'!hours: hourInteger minutes: minInteger seconds: secInteger	self setSeconds: (hourInteger * 3600) + (minInteger * 60) + secInteger.! !!Time methodsFor: 'private' stamp: 'BP 5/17/2000 00:00'!setSeconds: secondCount	seconds _ secondCount! !!Time class methodsFor: 'instance creation' stamp: 'BP 5/17/2000 19:53'!fromSeconds: secondCount 	"Answer an instance of me that is secondCount number of seconds since midnight."	^self new 		setSeconds: secondCount;		yourself.! !!Time class methodsFor: 'instance creation' stamp: 'BP 5/17/2000 19:53'!readFrom: aStream	"Read a Time from the stream in the form:		<hour>:<minute>:<second> <am/pm>	<minute>, <second> or <am/pm> may be omitted.  e.g. 1:59:30 pm; 8AM; 15:30"	| hour minute second ampm |	hour _ Integer readFrom: aStream.	minute _ 0.	second _ 0.	(aStream peekFor: $:) ifTrue:	[		minute _ Integer readFrom: aStream.		(aStream peekFor: $:) ifTrue: [ second _ Integer readFrom: aStream ]	].	aStream skipSeparators.	(aStream atEnd not and: [aStream peek isLetter])	ifTrue:	[		ampm _ aStream next asLowercase.		(ampm = $p and: [hour < 12]) ifTrue: [hour _ hour + 12].		(ampm = $a and: [hour = 12]) ifTrue: [hour _ 0].		(aStream peekFor: $m) ifFalse: [aStream peekFor: $M]	].	^self fromSeconds: 60*(60*hour+minute)+second	"Time readFrom: (ReadStream on: '2:23:09 pm')"! !!Time class methodsFor: 'general inquiries' stamp: 'JZH 11/8/1998 13:03'!dateAndTimeFromSeconds: secondCount	^ Array		with: (Date fromSeconds: secondCount)		with: (Time fromSeconds: secondCount \\ 86400)! !!Time class methodsFor: 'general inquiries' stamp: 'ls 7/25/1998 01:16'!dateAndTimeNow	"Answer a two-element Array of (Date today, Time now)."	| secondCount d t |	secondCount _ self primSecondsClock.	d _ Date fromSeconds: secondCount.	t _ Time fromSeconds: secondCount \\ 86400.	^ Array with: d with: t! !!Time class methodsFor: 'general inquiries' stamp: 'mir 10/29/1999 18:27'!milliseconds: currentTime since: lastTime	| delta |	"Answer the elapsed time since last recorded in milliseconds.	Compensate for rollover."	delta _ currentTime - lastTime.	^delta < 0		ifTrue: [SmallInteger maxVal + delta]		ifFalse: [delta]! !!Time class methodsFor: 'general inquiries' stamp: 'mir 10/29/1999 18:24'!millisecondsSince: lastTime	"Answer the elapsed time since last recorded in milliseconds.	Compensate for rollover."	^self milliseconds: self millisecondClockValue since: lastTime! !!Time class methodsFor: 'benchmarks' stamp: 'ar 9/6/1999 17:51'!benchmarkMillisecondClock		"Time benchmarkMillisecondClock"	"Benchmark the time spent in a call to Time>>millisecondClockValue.	On the VM level this tests the efficiency of calls to ioMSecs()."	"PII/400 Windows 98: 0.725 microseconds per call"	| temp1 temp2 temp3 delayTime nLoops time |	delayTime _ 5000. "Time to run benchmark is approx. 2*delayTime"	"Don't run the benchmark if we have an active delay since	we will measure the additional penalty in the primitive dispatch	mechanism (see #benchmarkPrimitiveResponseDelay)."	Delay anyActive ifTrue:[		^self notify:'Some delay is currently active.Running this benchmark will not give any useful result.'].	"Flush the cache for this benchmark so we will have	a clear cache hit for each send to #millisecondClockValue below"	Object flushCache.	temp1 _ 0.	temp2 _ self. "e.g., temp1 == Time"	temp3 _ self millisecondClockValue + delayTime.	"Now check how often we can run the following loop in the given time"	[temp2 millisecondClockValue < temp3]		whileTrue:[temp1 _ temp1 + 1].	nLoops _ temp1. "Remember the loops we have run during delayTime"	"Setup the second loop"	temp1 _ 0.	temp3 _ nLoops.	"Now measure how much time we spend without sending #millisecondClockValue"	time _ Time millisecondClockValue.	[temp1 < temp3]		whileTrue:[temp1 _ temp1 + 1].	time _ Time millisecondClockValue - time.	"And compute the number of microseconds spent per call to #millisecondClockValue"	^((delayTime - time * 1000.0 / nLoops) truncateTo: 0.001) printString,		' microseconds per call to Time>>millisecondClockValue'! !!Time class methodsFor: 'benchmarks' stamp: 'ar 9/6/1999 18:02'!benchmarkPrimitiveResponseDelay	"Time benchmarkPrimitiveResponseDelay"	"Benchmark the overhead for primitive dispatches with an active Delay.	On the VM level, this tests the efficiency of ioLowResMSecs."	"PII/400 Windows98: 0.128 microseconds per prim"	"ar 9/6/1999: This value is *extremely* important for stuff like sockets etc.	I had a bad surprise when Michael pointed this particular problem out:	Using the hardcoded clock() call for ioLowResMSecs on Win32 resulted in an overhead	of 157.4 microseconds per primitive call - meaning you can't get no more than	approx. 6000 primitives per second on my 400Mhz PII system with an active delay!!	BTW, it finally explains why Squeak seemed soooo slow when running PWS or 	other socket stuff. The new version (not using clock() but some Windows function) 	looks a lot better (see above; approx. 8,000,000 prims per sec with an active delay)."	| nLoops bb index baseTime actualTime delayTime |	delayTime _ 5000. "Time to run this test is approx. 3*delayTime"	Delay anyActive ifTrue:[		^self notify:'Some delay is currently active.Running this benchmark will not give any useful result.'].	bb _ Array new: 1. "The object we send the prim message to"	"Compute the # of loops we'll run in a decent amount of time"	[(Delay forMilliseconds: delayTime) wait] 		forkAt: Processor userInterruptPriority.	nLoops _ 0.	[Delay anyActive] whileTrue:[		bb basicSize; basicSize; basicSize; basicSize; basicSize; 			basicSize; basicSize; basicSize; basicSize; basicSize.		nLoops _ nLoops + 1.	].	"Flush the cache and make sure #basicSize is in there"	Object flushCache.	bb basicSize.	"Now run the loop without any active delay	for getting an idea about its actual speed."	baseTime _ self millisecondClockValue.	index _ nLoops.	[index > 0] whileTrue:[		bb basicSize; basicSize; basicSize; basicSize; basicSize; 			basicSize; basicSize; basicSize; basicSize; basicSize.		index _ index - 1.	].	baseTime _ self millisecondClockValue - baseTime.	"Setup the active delay but try to never make it active"	[(Delay forMilliseconds: delayTime + delayTime) wait] 		forkAt: Processor userInterruptPriority.	"And run the loop"	actualTime _ self millisecondClockValue.	index _ nLoops.	[index > 0] whileTrue:[		bb basicSize; basicSize; basicSize; basicSize; basicSize; 			basicSize; basicSize; basicSize; basicSize; basicSize.		index _ index - 1.	].	actualTime _ self millisecondClockValue - actualTime.	"And get us some result"	^((actualTime - baseTime) * 1000 asFloat / (nLoops * 10) truncateTo: 0.001) printString,		' microseconds overhead per primitive call'! !I demonstrate how to create a very simple image editor in Morphic. I am intentially left incomplete so that the basics can be clearly seen.!!TinyPaint methodsFor: 'events' stamp: 'jm 6/15/2003 12:06'!mouseDown: evt	"Start drawing at the event point and report the invalid area."	lastMouse _ evt cursorPoint.	brush drawFrom: lastMouse - bounds origin to: lastMouse - bounds origin.	self invalidRect:		((lastMouse - brush sourceForm extent) corner:		 (lastMouse + brush sourceForm extent)).! !!TinyPaint methodsFor: 'events' stamp: 'jm 6/15/2003 12:05'!mouseMove: evt	"Draw from the last mouse position to the new position and report the invalid area."	| p |	p _ evt cursorPoint.	p = lastMouse ifTrue: [^ self].	brush drawFrom: lastMouse - bounds origin to: p - bounds origin.	self invalidRect: (		((lastMouse min: p) - brush sourceForm extent) corner:		((lastMouse max: p) + brush sourceForm extent)).	lastMouse _ p.! !!TinyPaint methodsFor: 'menu' stamp: 'jm 1/6/2003 16:04'!fill	| fillPt |	Cursor blank show.	Cursor crossHair showWhile:		[fillPt _ Sensor waitButton - self position].	originalForm shapeFill: brushColor interiorPoint: fillPt.	Sensor waitNoButton.	self changed.! !!TinyPaint methodsFor: 'menu' stamp: 'di 9/3/1999 09:43'!setPenColor: evt	evt hand changeColorTarget: self selector: #brushColor: originalColor: brushColor.! !!TinyPaint class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:02'!includeInNewMorphMenu	^ true! !I am a button with two forms. Clicking on me toggles which form is shown and sends my target a message. If my isMomentary flag is true, then I return to my off state after I am pressed.!!ToggleButton methodsFor: 'initialization' stamp: 'jm 12/17/2003 13:02'!initialize	super initialize.	self cornerStyle: #square.	isMomentary _ false.	toggleMode _ true.	isOn _ isOver _ false.! !!ToggleButton methodsFor: 'initialization' stamp: 'jm 12/18/2003 12:08'!onForm: f1 offForm: f2	onForm _ f1.	offForm _ f2.	self on; off.! !!ToggleButton methodsFor: 'initialization' stamp: 'jm 12/18/2003 12:08'!onForm: f1 offForm: f2 overForm: f3	onForm _ f1.	offForm _ f2.	overForm _ f3.	self on; off.! !!ToggleButton methodsFor: 'initialization' stamp: 'jm 12/17/2003 13:07'!setDefaultLabel	"Overridden to do nothing. I have no label by default, although a label can be added."! !!ToggleButton methodsFor: 'accessing' stamp: 'jm 12/17/2003 13:07'!isMomentary: aBoolean	isMomentary _ aBoolean.! !!ToggleButton methodsFor: 'accessing' stamp: 'jm 12/17/2003 13:07'!isOn	^ isOn! !!ToggleButton methodsFor: 'accessing' stamp: 'jm 12/17/2003 13:08'!label: aString font: aFont	"Add the given label in the given font centered in my current extent."	| oldLabel m |	(oldLabel _ self findA: StringMorph) ifNotNil: [oldLabel delete].	m _ StringMorph contents: aString font: (aFont ifNil: [Preferences standardButtonFont]).	m position: self center - (m extent // 2).	self addMorph: m.	m lock.! !!ToggleButton methodsFor: 'accessing' stamp: 'jm 12/18/2003 11:29'!off	"Turn myself off."	isOn ifFalse: [^ self].	isOn _ false.	offForm ifNotNil: [self extent: offForm extent].	self changed.! !!ToggleButton methodsFor: 'accessing' stamp: 'jm 12/18/2003 11:29'!on	"Turn myself on."	isOn ifTrue: [^ self].	isOn _ true.	onForm ifNotNil: [self extent: onForm extent].	self changed.! !!ToggleButton methodsFor: 'accessing' stamp: 'jm 12/17/2003 13:02'!toggleMode: aBoolean	toggleMode _ aBoolean.! !!ToggleButton methodsFor: 'drawing' stamp: 'jm 12/17/2003 13:10'!drawOn: aCanvas	| form |	isOn 		ifTrue: [form _ onForm] 		ifFalse: [form _ offForm].	isOver ifTrue: [form _ overForm].	form		ifNil: [  "default drawing if no form"			aCanvas frameRectangle: self bounds				width: 3				color: (isOn ifTrue: [Color veryVeryLightGray] ifFalse: [Color gray])]		ifNotNil: [aCanvas paintImage: form at: bounds origin].! !!ToggleButton methodsFor: 'event handling' stamp: 'ee 8/6/2003 16:33'!handlesMouseOver: evt	^ true! !!ToggleButton methodsFor: 'event handling' stamp: 'jm 12/18/2003 11:25'!mouseDown: evt	"If I am currently turned on, turn myself off and vice versa. If toggleMode is false, then do nothing if I am already on. If isMomentary, then turn myself off immediately. If I am to act when I'm pressed, then send my target my action selector."	wasOn _ isOn.	actWhen == #buttonDown ifTrue: [		self doButtonAction.		isMomentary ifTrue: [self off]].! !!ToggleButton methodsFor: 'event handling' stamp: 'jm 12/17/2003 13:12'!mouseEnter: evt	overForm ifNotNil: [		self changed.		isOver _ true.		self extent: overForm extent.		self changed].! !!ToggleButton methodsFor: 'event handling' stamp: 'jm 12/17/2003 13:14'!mouseLeave: evt	overForm ifNotNil: [		self changed.		isOver _ false.		isOn ifTrue: [self on] ifFalse: [self off]].! !!ToggleButton methodsFor: 'event handling' stamp: 'jm 12/18/2003 11:24'!mouseMove: evt	"Give feedback depending on whether the mouse is over me. If I was originally on, show my off image if the mouse is over me and my on image if not. Do the opposite if I was originally off."	actWhen == #buttonDown ifTrue: [^ self].	(toggleMode not & wasOn) ifTrue: [^ self].  "already on and not toggling"	(self containsPoint: evt cursorPoint)		ifTrue: [wasOn ifTrue: [self off] ifFalse: [self on]]		ifFalse: [wasOn ifTrue: [self on] ifFalse: [self off]].! !!ToggleButton methodsFor: 'event handling' stamp: 'jm 12/18/2003 11:25'!mouseUp: evt	"If I am a momentary button, then turn off. If I am to act on button up, then send my target my action selector."	isMomentary ifTrue: [self off].	(actWhen == #buttonUp and:	 [self containsPoint: evt cursorPoint])		ifTrue: [self doButtonAction].! !!ToggleButton methodsFor: 'menu' stamp: 'ee 6/24/2003 11:37'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change action selector' action: #setActionSelector.	aCustomMenu add: 'change arguments' action: #setArguments.! !!ToggleButton class methodsFor: 'instance creation' stamp: 'ee 7/1/2003 14:49'!onForm: f1 offForm: f2	"Set the forms used for my on and off states."	^ self new onForm: f1 offForm: f2! !!ToggleButton class methodsFor: 'instance creation' stamp: 'ee 8/6/2003 16:28'!onForm: f1 offForm: f2 overForm: f3	"Set the forms used for my on and off states."	^ self new onForm: f1 offForm: f2 overForm: f3! !This class supports a few simple tests of the Tower sensor layer and Cricket bus.!!TowerTester methodsFor: 'accessing' stamp: 'jm 1/8/2003 14:34'!port	^ port! !!TowerTester methodsFor: 'open-close' stamp: 'jm 1/8/2003 14:49'!closePort	port ifNotNil: [port close].	port _ nil.! !!TowerTester methodsFor: 'open-close' stamp: 'jm 1/23/2003 15:34'!openPort: anInteger	self closePort.	port _ SerialPort new parityType: 1; openPort: anInteger.! !!TowerTester methodsFor: 'inputs' stamp: 'jm 1/23/2003 16:27'!getClapDetector	"Fetch the current value from the clap detector sensor."	"Note: Did not work with the clap detector device we had--no response from the device."	| msg |	msg _ #(255 2 1 104).  "last byte: 104 - red sensor, 105 - blue sensor, 106 - generic sensor"	port flushInputBuffer.	port nextPutAll: msg asByteArray.	^ (port next: 1) first! !!TowerTester methodsFor: 'inputs' stamp: 'jm 1/23/2003 16:14'!getDistanceSensor	"Fetch the current value from the distance sensor."	"Warning: The distance sensor takes about 100 milliseconds to respond, whereas most other sensors respond within 10 milliseconds."	| msg |	msg _ #(255 2 1 85).	port flushInputBuffer.	port nextPutAll: msg asByteArray.	^ (port next: 1) first! !!TowerTester methodsFor: 'inputs' stamp: 'jm 1/23/2003 16:19'!getSensor: n	"Fetch the current value from given input port (1-8) of the sensor layer."	| msg |	msg _ #(100 2 1 0).	msg at: 4 put: n.	port flushInputBuffer.	port nextPutAll: msg asByteArray.	^ (port next: 1) first! !!TowerTester methodsFor: 'outputs' stamp: 'jm 1/23/2003 15:48'!fourDigitLED: anInteger	"Display the given integer in the 4-digit numeric LED display. The range is -999 to 9999."	| msg |	msg _ #(255 4 0 112 0 0).	msg at: 5 put: anInteger // 256.	msg at: 6 put: anInteger \\ 256.	port nextPutAll: msg asByteArray.! !!TowerTester methodsFor: 'outputs' stamp: 'jm 1/23/2003 15:51'!tricolorR: r G: g B: b	"Set the tri-color LED to the given RGB value. The range of each color component is 0 to 255."	| msg |	msg _ #(255 5 0 117 0 0 0).	msg at: 5 put: r.	msg at: 6 put: g.	msg at: 7 put: b.	port nextPutAll: msg asByteArray.! !!TranscriptStream methodsFor: 'initialization' stamp: 'di 5/9/2000 09:11'!closeAllViews  "Transcript closeAllViews"	self dependents do:		[:d |		(d isKindOf: PluggableTextView) ifTrue: [d topView controller closeAndUnscheduleNoTerminate].		(d isKindOf: SystemWindow) ifTrue: [d delete]]! !!TranscriptStream methodsFor: 'initialization' stamp: 'di 5/27/1998 16:36'!openAsMorphLabel: labelString 	"Build a morph viewing this transcriptStream"	| window |	window _ (SystemWindow labelled: labelString) model: self.	window addMorph: (PluggableTextMorph on: self text: nil accept: nil			readSelection: nil menu: #codePaneMenu:shifted:)		frame: (0@0 corner: 1@1).	^ window! !!TranscriptStream methodsFor: 'initialization' stamp: 'sma 4/30/2000 10:16'!openLabel: aString 	"Open a window on this transcriptStream"	| topView codeView |	Smalltalk isMorphic ifTrue: [^ (self openAsMorphLabel: aString) openInWorld].	topView _ (StandardSystemView new) model: self.	topView borderWidth: 1.	topView label: aString.	topView minimumSize: 100 @ 50.	codeView _ PluggableTextView on: self text: nil accept: nil					readSelection: nil menu: #codePaneMenu:shifted:.	codeView window: (0@0 extent: 200@200).	topView addSubView: codeView.	topView controller open! !!TranscriptStream methodsFor: 'access' stamp: 'di 3/16/1999 21:38'!characterLimit	"Tell the views how much to retain on screen"	^ 20000! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'sma 3/15/2000 21:28'!bs	self position > 0 ifTrue: [^ self skip: -1].	self changed: #bs! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'sma 4/22/2000 16:58'!flush	self endEntry! !!TranscriptStream methodsFor: 'stream extensions' stamp: 'sma 2/26/2000 19:31'!show: anObject  "TextCollector compatibility"	self nextPutAll: anObject asString; endEntry! !!TranscriptStream methodsFor: 'model protocol' stamp: 'di 5/27/1998 16:44'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items"	^ StringHolder basicNew codePaneMenu: aMenu shifted: shifted! !!TranscriptStream methodsFor: 'model protocol' stamp: 'di 5/29/1998 17:13'!perform: selector orSendTo: otherTarget	"Selector was just chosen from a menu by a user.  If can respond, thenperform it on myself. If not, send it to otherTarget, presumably theeditPane from which the menu was invoked."	(self respondsTo: selector)		ifTrue: [^ self perform: selector]		ifFalse: [^ otherTarget perform: selector]! !!TranscriptStream methodsFor: 'model protocol' stamp: 'di 5/3/1999 22:49'!release	self dependents do:		[:view | (view isMorph and: [view isInWorld not])					ifTrue: [self removeDependent: view]]! !Transcripter is a dog-simple scrolling stream with display.  It is intended to operate with no support from MVC or color in a minimal, or headless version of Squeak.  No attention has been paid to appearance or performance.!!Transcripter methodsFor: 'initialization' stamp: 'di 8/14/97 12:44'!initInFrame: rect	frame _ rect insetBy: 2.  "Leave room for border"	para _ Paragraph withText: self contents asText				style: TextStyle default				compositionRectangle: ((frame insetBy: 4) withHeight: 9999)				clippingRectangle: frame				foreColor: self black backColor: self white! !!Transcripter methodsFor: 'accessing' stamp: 'di 8/14/97 12:41'!clear	Display fill: (frame insetBy: -2) fillColor: self black;			fill: frame fillColor: self white.	self on: (String new: 100); endEntry! !!Transcripter methodsFor: 'accessing' stamp: 'di 8/14/97 12:44'!endEntry	| c d cb |	c _ self contents.	Display extent ~= DisplayScreen actualScreenSize ifTrue:		["Handle case of user resizing physical window"		DisplayScreen startUp.		frame _ frame intersect: Display boundingBox.		^ self clear; show: c].	para setWithText: c asText		style: TextStyle default		compositionRectangle: ((frame insetBy: 4) withHeight: 9999)		clippingRectangle: frame		foreColor: self black backColor: self white.	d _ para compositionRectangle bottom - frame bottom.	d > 0 ifTrue:		["Scroll up to keep all contents visible"		cb _ para characterBlockAtPoint: para compositionRectangle topLeft											+ (0@(d+para lineGrid)).		self on: (c copyFrom: cb stringIndex to: c size).		readLimit_ position_ collection size.		^ self endEntry].	para display! !!Transcripter methodsFor: 'accessing' stamp: 'sma 2/26/2000 19:35'!show: anObject	self nextPutAll: anObject asString; endEntry! !!Transcripter methodsFor: 'command line' stamp: 'di 8/12/97 22:11'!confirm: queryString 	| choice |	[true]		whileTrue: 			[choice _ self request: queryString , 'Please type yes or no followed by return'.			choice first asUppercase = $Y ifTrue: [^ true].			choice first asUppercase = $N ifTrue: [^ false]]! !!Transcripter methodsFor: 'command line' stamp: 'sma 5/27/2000 17:53'!readEvalPrint	| line |	[#('quit' 'exit' 'done' ) includes: (line _ self request: '>')]		whileFalse: [self cr; show: ([Compiler evaluate: line]			ifError: [:err :ex | err])]! !!Transcripter methodsFor: 'command line' stamp: 'sma 2/26/2000 19:39'!request: prompt	| startPos char contents | 	self cr; show: prompt.	startPos _ position.	[[Sensor keyboardPressed] whileFalse.	(char _ Sensor keyboard) = Character cr]		whileFalse:		[char = Character backspace			ifTrue: [readLimit _ position _ (position - 1 max: startPos)]			ifFalse: [self nextPut: char].		self endEntry].	contents _ self contents.	^ contents copyFrom: startPos + 1 to: contents size! !!Transcripter methodsFor: 'private' stamp: 'di 8/14/97 12:12'!black	Display depth = 1 ifTrue: [^ Bitmap with: 16rFFFFFFFF "Works without color support"].	^ Color black! !!Transcripter methodsFor: 'private' stamp: 'di 8/14/97 12:12'!white	Display depth = 1 ifTrue: [^ Bitmap with: 0 "Works without color support"].	^ Color white! !!Transcripter class methodsFor: 'instance creation' stamp: 'di 8/14/97 12:09'!newInFrame: frame"(Transcripter newInFrame: (0@0 extent: 100@200))	nextPutAll: 'Hello there'; endEntry;	cr; print: 355.0/113; endEntry;	readEvalPrint."	| transcript |	transcript _ self on: (String new: 100).	transcript initInFrame: frame.	^ transcript clear! !!Transcripter class methodsFor: 'instance creation' stamp: 'jm 1/1/2004 10:29'!startTranscriptProcess   "Transcripter startTranscriptProcess"	| activeProcess |	Transcript _ self newInFrame: Display boundingBox.	activeProcess _		[Transcript readEvalPrint.		 Smalltalk processShutDownList; quitPrimitive] newProcess.	activeProcess priority: Processor userSchedulingPriority.	activeProcess resume.	Processor terminateActive.! !!Transcripter class methodsFor: 'utilities' stamp: 'sma 5/27/2000 17:35'!emergencyEvaluator	(Transcripter newInFrame: (0@0 corner: 320@200))		show: 'type ''exit'' to exit the emergency evaluator';		readEvalPrint! !Warning: TransformMorph is currently being phased out. Do not use it for new applications!!A TransformMorph introduces a 2-D transformation between its (global) coordinates and the (local) coordinates of its submorphs, while also clipping all display to its bounds. Specifically, with no offset, angle or scaling, a submorph with coordinates (0@0) will appear exactly at the topLeft of the windowMorph (its position). Rotation and scaling are relative to the local origin, (0@0).TransformMorphs operate with two different display strategies, depending on whether the transformation is a pure translation or not. If so, then they simply use a clipping canvas and display their submorphs with the appropriate offset. If the transformation includes scaling or rotation, then a caching canvas is used, whose active area covers the fullBounds of the submorphs intersected with the source quadrilateral corresponding to the window bounds.!!TransformMorph methodsFor: 'accessing' stamp: 'ar 5/19/1999 18:04'!transform	^transform! !!TransformMorph methodsFor: 'accessing' stamp: 'ar 5/19/1999 18:04'!transform: aTransform	transform _ aTransform.! !!TransformMorph methodsFor: 'submorphs-accessing' stamp: 'ar 11/15/1998 23:42'!morphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point.  Map through my transform.  Must do this recursively because of transforms.  "	| p |	(self containsPoint: aPoint) ifFalse:		["TransformMorph clips to bounds"		^ mList].	p _ transform globalPointToLocal: aPoint.	submorphs do: [:m | m morphsAt: p addTo: mList].	mList addLast: self.	^ mList! !!TransformMorph methodsFor: 'submorphs-accessing' stamp: 'ar 11/15/1998 23:42'!unlockedMorphsAt: aPoint addTo: mList	"Return a collection of all morphs in this morph structure that contain the given point.  Map through my transform.  Must do this recursively because of transforms.  "	| p |	self isLocked ifTrue: [^ mList].	(self containsPoint: aPoint) ifFalse:		["TransformMorph clips to bounds"		^ mList].	p _ transform globalPointToLocal: aPoint.	submorphs do: [:m | m unlockedMorphsAt: p addTo: mList].	mList addLast: self.	^ mList! !!TransformMorph methodsFor: 'drawing' stamp: 'di 10/16/1999 16:03'!drawSubmorphsOn: aCanvas	aCanvas transformBy: transform		clippingTo: self innerBounds		during: [:myCanvas |				submorphs reverseDo:[:m | myCanvas fullDrawMorph: m] ]		smoothing: smoothing! !!TransformMorph methodsFor: 'geometry' stamp: 'ar 11/15/1998 23:42'!containsPoint: aPoint	(bounds containsPoint: aPoint) ifFalse: [^ false].	self hasSubmorphs		ifTrue: [self submorphsDo: 					[:m | (m fullBounds containsPoint: (transform globalPointToLocal: aPoint))							ifTrue: [^ true]].				^ false]		ifFalse: [^ true]! !!TransformMorph methodsFor: 'geometry' stamp: 'sw 12/29/1999 15:51'!wantsHaloFromClick	^ false! !!TransformMorph methodsFor: 'change reporting' stamp: 'ar 3/14/2000 16:06'!invalidRect: damageRect	"Translate damage reports from submorphs by the scrollOffset."	super invalidRect: (((transform localBoundsToGlobal: damageRect) intersect: bounds) expandBy: 1)! !A TranslucentColor behaves just like a normal color, except that it will pack its alpha value into the high byte of a 32-bit pixelValue.  This allows creating forms with translucency for use with the alpha blend function of BitBlt.  An alpha of zero is transparent, and 1.0 is opaque.!!TranslucentColor methodsFor: 'printing' stamp: 'mir 7/21/1999 11:43'!storeArrayValuesOn: aStream	self isTransparent ifTrue: [		^ aStream space].	super storeArrayValuesOn: aStream.	aStream space.	(self alpha roundTo: 0.001) storeOn: aStream.! !!TranslucentColor methodsFor: 'printing' stamp: 'di 1/14/1999 14:31'!storeOn: aStream	self isTransparent ifTrue: [^ aStream nextPutAll: '(Color transparent)'].	super storeOn: aStream.	aStream		skip: -1;	  "get rid of trailing )"		nextPutAll: ' alpha: ';		nextPutAll: self alpha printString;		nextPutAll: ')'.! !!TranslucentColor methodsFor: 'conversions' stamp: 'di 1/15/1999 11:44'!alpha: alphaValue	alphaValue = 1.0 ifTrue:		[^ Color basicNew			setPrivateRed: self privateRed			green: self privateGreen			blue: self privateBlue].	^ super alpha: alphaValue! !!TranslucentColor methodsFor: 'conversions' stamp: 'sw 10/27/1999 10:51'!asNontranslucentColor	^ self alpha: 1.0! !!TranslucentColor methodsFor: 'conversions' stamp: 'di 3/25/2000 17:56'!balancedPatternForDepth: depth	"Return an appropriate bit pattern or stipple.  This will almost never be meaningful for tranlucentColors, except for the degenerate case of tranparency."	alpha = 0 ifTrue: [^ Bitmap with: 0].	^ super balancedPatternForDepth: depth! !!TranslucentColor methodsFor: 'conversions' stamp: 'di 1/14/1999 20:05'!bitPatternForDepth: depth	"Return an appropriate bit pattern or stipple.  This will almost never be meaningful for tranlucentColors, except for the degenerate case of tranparency."	alpha = 0 ifTrue: [^ Bitmap with: 0].	^ super bitPatternForDepth: depth! !!TranslucentColor methodsFor: 'conversions' stamp: 'di 1/6/1999 16:15'!pixelValueForDepth: d	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."	alpha = 0 ifTrue: [^ 0].	^ super pixelValueForDepth: d! !!TranslucentColor methodsFor: 'conversions' stamp: 'di 1/6/1999 16:14'!pixelWordForDepth: depth	"Return the pixel value for this color at the given depth. Translucency only works in RGB; this color will appear either opaque or transparent at all other depths."	| basicPixelWord |	alpha = 0 ifTrue: [^ 0].	basicPixelWord _ super pixelWordForDepth: depth.	depth < 32		ifTrue: [^ basicPixelWord]		ifFalse: [^ (basicPixelWord bitAnd: 16rFFFFFF) bitOr: (alpha bitShift: 24)].! !!TranslucentColor methodsFor: 'conversions' stamp: 'ar 1/14/1999 15:30'!scaledPixelValue32	"Return the alpha scaled pixel value for depth 32"	| pv32 a b g r |	pv32 _ super scaledPixelValue32.	a _ (self alpha * 255.0) rounded.	b _ (pv32 bitAnd: 255) * a // 256.	g _ ((pv32 bitShift: -8) bitAnd: 255) * a // 256.	r _ ((pv32 bitShift: -16) bitAnd: 255) * a // 256.	^b + (g bitShift: 8) + (r bitShift: 16) + (a bitShift: 24)! !!TranslucentColor methodsFor: 'private' stamp: 'jm 9/23/2003 17:27'!setRgb: rgbValue alpha: rawAlpha	"Set the state of this translucent color. Alpha is represented internally by an integer in the range 0..255."	rgb == nil ifFalse: [self attemptToMutateError].	rgb _ rgbValue.	alpha _ (rawAlpha asInteger max: 0) min: 255.! !!TranslucentColor methodsFor: 'queries' stamp: 'di 12/30/1998 14:33'!isTranslucent	^ alpha < 255! !!TranslucentColor methodsFor: 'queries' stamp: 'di 1/3/1999 12:22'!isTranslucentColor	"This means: self isTranslucent, but isTransparent not"	^ alpha > 0! !!TranslucentColor methodsFor: 'queries' stamp: 'di 12/30/1998 14:33'!isTransparent	^ alpha = 0! !I am a client for TransmissionTestServer that can be used to test the data throughput of a connection. First start the server on the target machine (it can be the local machine):  server _ TransmissionTestServer new.  server forkServerProcess.Then execute the following tests in a workspace, one line at a time:  client _ TransmissionTestClient new initialize.  client serverAddress: '127.0.0.1'.  "<- insert the actual server address here"  client openConnection.  client pingTest.  client sendTest.  client receiveTest.  client echoTest.  client closeConnection.When you are done with the server, you can stop it with:  server stopServerHave fun!!!!TransmissionTestClient methodsFor: 'initialization' stamp: 'jm 10/10/2001 13:10'!initialize	serverAddress _ NetNameResolver addressFromString: '127.0.0.1'.	msgSocket _ MessageSocket new.	payloadBytes _ 10000.! !!TransmissionTestClient methodsFor: 'accessing' stamp: 'jm 10/10/2001 13:10'!payloadBytes	^ payloadBytes! !!TransmissionTestClient methodsFor: 'accessing' stamp: 'jm 10/10/2001 14:04'!payloadBytes: aNumber	"Set the number of bytes to send or receive."	payloadBytes _ aNumber asInteger max: 0.! !!TransmissionTestClient methodsFor: 'accessing' stamp: 'jm 10/10/2001 12:32'!serverAddress	^ serverAddress! !!TransmissionTestClient methodsFor: 'accessing' stamp: 'jm 10/10/2001 12:32'!serverAddress: addressOrString	(addressOrString isKindOf: ByteArray)		ifTrue: [serverAddress _ addressOrString]		ifFalse: [serverAddress _ NetNameResolver addressFromString: addressOrString].! !!TransmissionTestClient methodsFor: 'connection' stamp: 'jm 10/10/2001 13:49'!closeConnection	"Close the connection, if any."	msgSocket destroy.! !!TransmissionTestClient methodsFor: 'connection' stamp: 'jm 10/10/2001 13:46'!openConnection	"Open a connection and report how long it took."	| port t |	msgSocket destroy.	port _ TransmissionTestServer portNumber. 	t _ [msgSocket connectTo: serverAddress port: port waitSecs: 10] timeToRun.	msgSocket isConnected		ifTrue: [self inform: 'connected in ', t printString, ' milliseconds']		ifFalse: [			self closeConnection.			^ self inform: 'could not connect to ',				(NetNameResolver stringFromAddress: serverAddress)].! !!TransmissionTestClient methodsFor: 'tests' stamp: 'jm 10/10/2001 14:05'!echoTest	"Report the time to echo some data to the server. The data is sent to the server and back again."	| buf t r |	msgSocket isConnected ifFalse: [^ self inform: 'not connected'].	buf _ ByteArray new: payloadBytes.	buf at: 1 put: 1.  "data echo request"	t _ [r _ msgSocket request: buf] timeToRun.	self inform: r size printString, ' bytes echoed in ', t printString, ' milliseconds'.! !!TransmissionTestClient methodsFor: 'tests' stamp: 'jm 10/10/2001 14:03'!pingTest	"Report the time to ping the server with an empty request."	| t |	msgSocket isConnected ifFalse: [^ self inform: 'not connected'].	t _ [msgSocket request: ''] timeToRun.	self inform: 'ping took ', t printString, ' milliseconds'.! !!TransmissionTestClient methodsFor: 'tests' stamp: 'jm 10/10/2001 13:47'!receiveTest	"Report the time to receive some data from the server. A short request is sent to the server, which replies with the requested number of bytes."	| s t r |	msgSocket isConnected ifFalse: [^ self inform: 'not connected'].	s _ WriteStream on: ByteArray new.	s nextPut: 2.	s uint32: payloadBytes.	t _ [r _ msgSocket request: s contents] timeToRun.	self inform: r size printString, ' bytes received in ', t printString, ' milliseconds'.! !!TransmissionTestClient methodsFor: 'tests' stamp: 'jm 10/10/2001 13:49'!sendTest	"Report the time to send the server some data. The server absorbs the data and sends an empty reply."	| buf t |	msgSocket isConnected ifFalse: [^ self inform: 'not connected'].	buf _ ByteArray new: payloadBytes.	buf at: 1 put: 0.  "data sink request"	t _ [msgSocket request: buf] timeToRun.	self inform: payloadBytes printString, ' bytes sent in ', t printString, ' milliseconds'.! !I am a simple server that can be used to test network transmission. The first byte of the request message determines the response:	1 -- echo the message verbatim	2 -- reply with a message containing N bytes of 0, where N is specified by next 4 bytes	anything else -- reply with a null message (can be used to measure upload speed)!!TransmissionTestServer methodsFor: 'request handling' stamp: 'jm 9/6/2001 17:46'!processMessage: aByteArray	"This server implements three tests that can be used to test network performance. The first byte of the message determines the response:		1 -- server echos the message verbatim		2 -- server answers a message containing N bytes of 0, where N is specified by next 4 bytes		3 (or anything else) -- server answers null message."	| op s n |	aByteArray size = 0 ifTrue: [^ ByteArray new].  "null message generates null respose"	op _ aByteArray first.	op = 1 ifTrue: [^ aByteArray].  "echo request"	((op = 2) and: [aByteArray size = 5]) ifTrue: [  "server transmit request"		s _ ReadStream on: aByteArray.		s skip: 1.		n _ (s uint32 min: (Smalltalk garbageCollectMost - 1000000)) max: 0.		^ ByteArray new: n].	^ ByteArray new  "null message"! !!TransmissionTestServer class methodsFor: 'port number' stamp: 'jm 7/30/2001 20:31'!portNumber	^ 54323! !The TrashBin contains all image and sounds objects dragged and dropped into it.It can also hold objects that want to be placed into it via right mouse clicks.Possible useful expressions for doIt or printIt.Structure: contents		Collection -- contains all morphs in the TrashBin owner	 	     Object -- pointer to the owner of thisIn order to accept implement the correct behavior for Media objects(ImageMorph and SoundMorph)that came from either the StoryLineContents or the Repository, i added a lastLocation variable which the TrashBinuses to decide the appropriate action for each item.  !!TrashBinMorph methodsFor: 'event handling' stamp: 'RG 9/23/2003 14:05'!handlesMouseDown: evt^true.! !!TrashBinMorph methodsFor: 'event handling' stamp: 'RG 11/26/2003 15:53'!mouseDown: evt	evt yellowButtonPressed ifTrue:[	"Transcript show: 'right mouse button pressed';cr."	"menu _ MenuMorph new.	contents do:[:imgOrSound | menu add: imgOrSound title target: self action: #restore.].	menu popUpNearHand. "	self showContents: evt.	].evt redButtonPressed ifTrue:[	].^true.! !!TrashBinMorph methodsFor: 'event handling' stamp: 'RG 11/26/2003 15:53'!showContents: evt|  |view _ TrashBinView createTrashView: (owner repository) for: self.view position: evt cursorPoint. view trashedItems: contents. "adds all current trashed items in TrashWrappers to the TrashCanView"view openInWorld.! !!TrashBinMorph methodsFor: 'dropping/grabbing' stamp: 'jm 12/8/2003 06:49'!acceptDroppingMorph: aMorph event: evt"When morphs are dropped on the TrashBin, it follows two cases(1) if the morph is coming from the Repository then it puts a TrashWrapper around it(to enable selection)	and then removes it from the repository(2) if the morph is from the story line it just deletes it from the screen."| dueno repContents newMorphs morphs aWrapper |dueno _ aMorph owner.repository _ self owner repository.(dueno isKindOf: HandMorph) ifTrue:[	(aMorph lastLocation isKindOf: NarratorRepositoryMorph) ifTrue:[		aWrapper _  TrashWrapper createTrashWrapper: aMorph at: ((contents size) + 1).		contents add: aWrapper.		repContents _ repository contents.		morphs _ (repContents submorphs asOrderedCollection).		newMorphs _  morphs removeAllSuchThat:[:m | m fileName = aMorph fileName ].  	repContents removeAllMorphs.  	repContents addAllMorphs: (newMorphs asArray).	].	(aMorph lastLocation isKindOf: StoryLineContentsMorph)ifTrue:[		aMorph delete.	].].aMorph delete.! !!TrashBinMorph methodsFor: 'dropping/grabbing' stamp: 'RG 9/30/2003 13:44'!wantsDroppedMorph: aMorph event: evt	^ (aMorph isKindOf: NarratorImageMorph) |	  (aMorph isKindOf: NarratorSoundMorph)! !!TrashBinMorph methodsFor: 'initialization' stamp: 'jm 12/8/2003 06:46'!initialize| graphicMorph|super initialize.self extent: 40@50.graphicMorph _ SketchMorph withForm: TrashCanForm.graphicMorph position: self center- (graphicMorph extent //2).graphicMorph extent: 40@50.self addMorph: graphicMorph.contents _ OrderedCollection new.view _ ScrollFrameMorph new.! !!TrashBinMorph methodsFor: 'restoring' stamp: 'RG 10/28/2003 14:17'!untrash: aTrashWrapper"fix equality later"contents _ contents removeAllSuchThat:[:w | 	(w morph) fileName = (aTrashWrapper morph) fileName].! !!TrashBinMorph methodsFor: 'accessing' stamp: 'RG 11/26/2003 15:52'!repository: aRepository.repository _ aRepository.! !!TrashBinMorph class methodsFor: 'as yet unclassified' stamp: 'RG 10/28/2003 13:28'!createTrashBin: aRepository| aTrashBin |aTrashBin _ TrashBinMorph new.aTrashBin repository: aRepository.^ aTrashBin.! !!TrashBinMorph class methodsFor: 'as yet unclassified' stamp: 'RG 11/26/2003 13:23'!initialize| graphicForm graphicMorph |graphicForm _ Form fromFileNamed: 'trash.gif'.graphicMorph _ SketchMorph withForm: graphicForm."graphicMorph position: self center -((graphicMorph extent //2))."graphicMorph extent: 40@40."self addMorph: graphicMorph."graphicMorph lock.! !!TrashBinMorph class methodsFor: 'as yet unclassified' stamp: 'jm 12/8/2003 06:46'!readForm	TrashCanForm _ Form fromFileNamed: 'trash2.jpeg'.! !!TrashBinView methodsFor: 'initialization' stamp: 'RG 11/26/2003 14:14'!initialize| b r myPasteUpMorph center |super initialize.b _ SimpleButtonMorph new target: self; borderColor: #raised;			borderWidth: 2; color: Color lightGray.r _ self makeRow.r addMorphBack: (b label: 'restore'; actionSelector: #restore).self addMorph: r."indicateCursor enables the black outline selection tool"myPasteUpMorph _ self contents.myPasteUpMorph indicateCursor: true."autoLineLayout sorts and aligns the morphs contained in this scrollFrameMorph" myPasteUpMorph autoLineLayout: true. self extent: 500@300.center _ (self right - self left)//2.r position:(center - ((r extent x)//2))@(self bottom - 40).trashedItems _ OrderedCollection new. ! !!TrashBinView methodsFor: 'initialization' stamp: 'RG 11/26/2003 14:14'!makeRow^ AlignmentMorph newRow	 color: Color transparent; borderWidth: 0;	 hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 10@10.! !!TrashBinView methodsFor: 'event handling' stamp: 'RG 10/21/2003 14:15'!handlesMouseDown: evt^true.! !!TrashBinView methodsFor: 'event handling' stamp: 'RG 10/28/2003 14:19'!mouseDown: evt"not working properly right now"| selectedItems myPasteUpMorph |evt redButtonPressed ifTrue:[	"w is short for wrapper, TrashWrapper"	selectedItems _ trashedItems select:[:w| ((evt cursorPoint x) - ((w morph) position x) < 50) 	& (((evt cursorPoint y) -((w morph) position y))< 50).].	selectedItems isEmpty ifFalse: [ selectedItem _ selectedItems first.		myPasteUpMorph _ self contents.		myPasteUpMorph cursor: selectedItem index. 	].			].evt yellowButtonPressed ifTrue: [ 	selectedItem ifNotNil:[self restore.].	"Transcript show: 'right mouse click';cr.	"].	^true.! !!TrashBinView methodsFor: 'event handling' stamp: 'RG 10/28/2003 14:04'!trashedItems: anOrderedCollectionofWrappers| morphs |morphs_ OrderedCollection new. 	(1 to: anOrderedCollectionofWrappers size) do:[:i |  	morphs add: ((anOrderedCollectionofWrappers at: i) morph).	].self contents addAllMorphs: morphs.  "this adds the items in the ordredCollection so that they can be viewed when the view is openedin the world. its specific to aScrollFrameMorph"trashedItems _ anOrderedCollectionofWrappers.  ! !!TrashBinView methodsFor: 'accessing' stamp: 'RG 10/21/2003 13:23'!repository: aRepositoryrepository _ aRepository.! !!TrashBinView methodsFor: 'accessing' stamp: 'RG 10/28/2003 13:43'!trashBin: aTrashBin	"set the TrashBin that I'm a view for"trashBin _ aTrashBin.! !!TrashBinView methodsFor: 'accessing' stamp: 'RG 10/17/2003 14:42'!trashedItems^ trashedItems.! !!TrashBinView methodsFor: 'restoring' stamp: 'RG 11/26/2003 14:05'!restore | wrapper curIndex |selectedItem ifNotNil:[	repository contents addMorph: (selectedItem morph). "unwrap"	"this is buggy" "fix selection"	"now need to decrement all wrappers with index > selectedItem index"		1 to: (trashedItems size) do: [ :i | 		wrapper _ trashedItems at: i.		curIndex _ wrapper index.			(curIndex > selectedItem index) ifTrue:[ wrapper index: (curIndex - 1)].	].	trashBin untrash: selectedItem.].repository changed.! !!TrashBinView methodsFor: 'restoring' stamp: 'RG 10/21/2003 13:16'!selectedItem^selectedItem! !!TrashBinView methodsFor: 'restoring' stamp: 'RG 10/21/2003 13:17'!selectedItem: aMorphselectedItem _ aMorph.! !!TrashBinView class methodsFor: 'instance creation' stamp: 'RG 11/26/2003 14:20'!createTrashView: aRepository | aTrashView aTrashBin |aTrashView _ TrashBinView new.aTrashView repository: aRepository.aTrashView trashBin: aTrashBin.^aTrashView.! !!TrashBinView class methodsFor: 'instance creation' stamp: 'RG 11/26/2003 14:18'!createTrashView: aRepository for: aTrashBin| aTrashView |aTrashView _ TrashBinView new.aTrashView repository: aRepository.aTrashView trashBin: aTrashBin.^aTrashView.! !!TrashWrapper methodsFor: 'accessing' stamp: 'RG 10/28/2003 14:11'!index^index.! !!TrashWrapper methodsFor: 'accessing' stamp: 'RG 10/28/2003 13:48'!index: aNumber"its the order with which i was put into the trash bin"index _ aNumber.! !!TrashWrapper methodsFor: 'accessing' stamp: 'RG 10/28/2003 14:04'!morph^morph! !!TrashWrapper methodsFor: 'accessing' stamp: 'RG 10/28/2003 13:49'!morph: aMorph.morph _ aMorph.! !!TrashWrapper class methodsFor: 'as yet unclassified' stamp: 'RG 10/28/2003 13:51'!createTrashWrapper: aMorph at: anIndex| wrapper |wrapper _ TrashWrapper new.wrapper morph: aMorph.wrapper index: anIndex.^wrapper.! !True defines the behavior of its single instance, true -- logical assertion. Notice how the truth-value checks become direct message sends, without the need for explicit testing.Be aware however that most of these methods are not sent as real messages in normal use. Most are inline coded by the compiler as test and jump bytecodes - avoiding the overhead of the full message sends. So simply redefining these methods here will have no effect.!I describe the behavior of my sole instance, nil. nil represents a prior value for variables that have not been initialized, or for results which are meaningless.!!UndefinedObject methodsFor: 'copying' stamp: 'tk 6/26/1998 11:35'!clone	"Only one instance of UndefinedObject should ever be made, so answer 	with self."! !!UndefinedObject methodsFor: 'testing' stamp: 'sw 4/7/1999 17:44'!isEmptyOrNil	"Answer whether the receiver contains any elements, or is nil.  Useful in numerous situations where one wishes the same reaction to an empty collection or to nil"	^ true! !!UndefinedObject methodsFor: 'testing' stamp: 'sma 6/6/2000 22:53'!isLiteral	^ true! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 7/15/1999 16:49'!addSubclass: aClass	"Ignored -- necessary to support disjoint class hierarchies"! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 7/15/1999 16:57'!environment	"Necessary to support disjoint class hierarchies."	^Smalltalk! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 7/15/1999 18:56'!subclass: nameOfClass  "Define root (superclass = nil) of a class hierarchy"	instanceVariableNames: instVarNames	classVariableNames: classVarNames	poolDictionaries: poolDictnames	category: category	^(ClassBuilder new)		superclass: self		subclass: nameOfClass		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: poolDictnames		category: category! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 8/29/1999 12:49'!subclassDefinerClass	"For disjunct class hierarchies -- how should subclasses of nil be evaluated"	^Compiler! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 7/15/1999 16:55'!subclasses	"Return all the subclasses of nil"	| classList |	classList _ WriteStream on: Array new.	self subclassesDo:[:class| classList nextPut: class].	^classList contents! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'jm 5/16/2003 09:37'!subclassesDo: aBlock	"Evaluate aBlock with all subclasses of nil. Others are not direct subclasses of Class."	^ Class subclassesDo: [:cl |		cl isMeta ifTrue: [aBlock value: cl soleInstance]].! !!UndefinedObject methodsFor: 'class hierarchy' stamp: 'ar 7/13/1999 06:08'!typeOfClass	"Necessary to support disjoint class hierarchies."	^#normal! !!UnixFileDirectory methodsFor: 'file names' stamp: 'bf 3/22/2000 18:24'!fullPathFor: path	"Return the fully-qualified path name for the given file."	path isEmpty ifTrue: [^ pathName].	path first = $/ ifTrue: [^ path].	^ pathName = '/'			"Only root dir ends with a slash"		ifTrue: ['/' , path]		ifFalse: [pathName , '/' , path]! !!UnixFileDirectory methodsFor: 'testing' stamp: 'sr 5/8/2000 12:58'!directoryExists: filenameOrPath	"Handles the special case of testing for the root dir: there isn't a	possibility to express the root dir as full pathname like '/foo'."	^ filenameOrPath = '/' or: [super directoryExists: filenameOrPath]! !!UnixFileDirectory methodsFor: 'testing' stamp: 'sr 5/8/2000 13:03'!fileOrDirectoryExists: filenameOrPath 	"Handles the special case of testing for the root dir: there isn't a 	possibility to express the root dir as full pathname like '/foo'."	^ filenameOrPath = '/' or: [super fileOrDirectoryExists: filenameOrPath]! !!UnixFileDirectory class methodsFor: 'platform specific' stamp: 'yo 2/4/1999 06:40'!maxFileNameLength	^ 255! !Instances of me, which are really just FMSounds, are used placeholders for sounds that have been unloaded from this image but which may be re-loaded later.!!UnloadedSound class methodsFor: 'as yet unclassified' stamp: 'jm 1/14/1999 12:00'!default	"UnloadedSound default play"	| snd p |	snd _ super new modulation: 1 ratio: 1.	p _ OrderedCollection new.	p add: 0@0.0; add: 10@1.0; add: 100@1.0; add: 120@0.0.	snd addEnvelope: (VolumeEnvelope points: p loopStart: 2 loopEnd: 3).	^ snd setPitch: 440.0 dur: 1.0 loudness: 0.5! !A menu item whose textual label and whose enablement are updatable.  The wordingProvider provides the current wording, upon being being sent the wordingSelector.The item can also dynamically update whether or not it should be enabled; to do this, give it an enablementSelector, which is also sent to the wordingProvider..!!UpdatingMenuItemMorph methodsFor: 'as yet unclassified' stamp: 'jm 10/4/2002 08:45'!adaptToWorld: aWorld	super adaptToWorld: aWorld.	wordingProvider isMorph ifTrue: [		wordingProvider isWorldMorph ifTrue: [	wordingProvider _ aWorld].		wordingProvider isHandMorph ifTrue: [wordingProvider _ aWorld primaryHand]].! !!UpdatingMenuItemMorph methodsFor: 'as yet unclassified' stamp: 'sw 6/21/1999 11:28'!enablementSelector: aSelector	enablementSelector _ aSelector! !!UpdatingMenuItemMorph methodsFor: 'as yet unclassified' stamp: 'sw 7/15/1999 07:27'!step	| newString enablement |	super step.	wordingProvider ifNotNil:		[newString _ wordingProvider perform: wordingSelector.		newString = contents ifFalse: [self contents: newString].		enablementSelector ifNotNil:			[enablement _ wordingProvider perform: enablementSelector.			enablement == isEnabled ifFalse:				[self isEnabled: enablement]]]! !!UpdatingMenuItemMorph methodsFor: 'as yet unclassified' stamp: 'sw 6/11/1999 18:31'!stepTime	^ 1200! !!UpdatingMenuItemMorph methodsFor: 'as yet unclassified' stamp: 'sw 6/11/1999 15:12'!wordingProvider: aProvider wordingSelector: aSelector	wordingProvider _ aProvider.	wordingSelector _ aSelector! !I am a rectangle that updates its color by periodically sending a message to my target object. I also optionally allow the color of the target object to be edited.!!UpdatingRectangleMorph methodsFor: 'initialization' stamp: 'sw 9/15/1999 15:31'!initialize	super initialize.	borderColor _ Color lightGray lighter ! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'jm 6/15/2003 12:39'!argument	^ argument! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'jm 6/15/2003 12:39'!argument: arg	argument _ arg.! !!UpdatingRectangleMorph methodsFor: 'accessing' stamp: 'jm 6/15/2003 12:42'!getSelector	^ getSelector! !!UpdatingRectangleMorph methodsFor: 'accessing'!getSelector: aSymbol	getSelector _ aSymbol.! !!UpdatingRectangleMorph methodsFor: 'drawing' stamp: 'sw 10/24/1998 21:23'!drawOn: aCanvas 	"Copied down from BorderedMorph, with the substitution that the color inst var of the receiver here might well be something like #raised or some other symbol, which the frameAndFillRectangle... methods barf on."	| insetColor colorToFill |	colorToFill _ (color isKindOf: Color) ifTrue: [color] ifFalse: [Color gray].	borderWidth = 0 ifTrue: [  "no border"		aCanvas fillRectangle: bounds color: color.		^ self].	borderColor == #raised ifTrue:		[^ aCanvas frameAndFillRectangle: bounds			fillColor: colorToFill			borderWidth: borderWidth			topLeftColor: colorToFill lighter			bottomRightColor: colorToFill darker].	borderColor == #inset ifTrue:		[insetColor _ owner colorForInsets.		^ aCanvas frameAndFillRectangle: bounds			fillColor: colorToFill			borderWidth: borderWidth			topLeftColor: insetColor darker			bottomRightColor: insetColor lighter].	"solid color border"	aCanvas frameAndFillRectangle: bounds		fillColor: colorToFill		borderWidth: borderWidth		borderColor: borderColor.! !!UpdatingRectangleMorph methodsFor: 'events' stamp: 'di 9/3/1999 09:43'!mouseUp: evt	evt hand changeColorTarget: self selector: #setTargetColor: originalColor: color.! !!UpdatingRectangleMorph methodsFor: 'stepping' stamp: 'jm 6/15/2003 12:57'!step	| c |	super step.	c _ self readFromTarget.	c = color ifFalse: [self color: c].! !!UpdatingRectangleMorph methodsFor: 'stepping' stamp: 'jm 6/15/2003 12:40'!stepTime	^ 500! !!UpdatingRectangleMorph methodsFor: 'private' stamp: 'jm 6/15/2003 12:58'!readFromTarget	((target == nil) or: [getSelector == nil]) ifTrue: [^ self color].	argument		ifNil: [^ target perform: getSelector]		ifNotNil: [^ target perform: getSelector with: argument].! !!UpdatingRectangleMorph methodsFor: 'private' stamp: 'jm 6/15/2003 12:58'!setTargetColor: aColor	| args |	putSelector ifNotNil: [		self color: aColor.		args _ argument			ifNil: [Array with: aColor]			ifNotNil: [Array with: argument with: aColor].		target perform: self putSelector withArguments: args].! !I am a StringMorph that periodically polls my target object (by sending it getSelector) and displays the resulting value. If I have a putSelector, then I can be edited and my target object is informed by sending the new value as a parameter of the putSelector message.!!UpdatingStringMorph methodsFor: 'initialization' stamp: 'jm 3/15/2003 20:37'!initialize	super initialize.	format _ #default.  "formats: #string, #default"	target _ getSelector _ lastValue _ putSelector _ parameter _ nil.	floatPrecision _ 1.	growable _ true.	stepTime _ 50.! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jm 3/15/2003 19:43'!floatPrecision	^ floatPrecision! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jm 5/26/1999 16:22'!floatPrecision: aNumber	floatPrecision _ aNumber.! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jm 3/15/2003 20:34'!growable	^ growable! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jm 5/26/1999 16:22'!growable: aBoolean	growable _ aBoolean.! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jm 3/15/2003 20:49'!parameter	^ parameter! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jm 3/15/2003 20:51'!parameter: anObject	"Set a parameter (e.g., an array index) to be sent with both my get selector and my put selector. The default is nil, which means no parameter is used."	parameter _ anObject.! !!UpdatingStringMorph methodsFor: 'accessing' stamp: 'jm 9/26/2003 08:13'!target: anObject	target _ anObject.	lastValue _ nil.! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'sw 7/15/1999 07:28'!step	| s |	super step.	hasFocus ifFalse:		["update contents, but only if user isn't editing this string"		s _ self readFromTarget.		s = contents ifFalse:			[self updateContentsFrom: s]]! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'jm 5/26/1999 16:17'!stepTime	^ stepTime ifNil: [50]! !!UpdatingStringMorph methodsFor: 'stepping' stamp: 'jm 5/26/1999 16:23'!stepTime: mSecsPerStep	stepTime _ mSecsPerStep truncated.! !!UpdatingStringMorph methodsFor: 'menu' stamp: 'jm 3/15/2003 20:33'!addCustomMenuItems: menu hand: aHandMorph	| prefix |	super addCustomMenuItems: menu hand: aHandMorph.	prefix _ growable ifTrue: ['stop'] ifFalse: ['start'].	menu add: prefix, ' being growable' action: #toggleGrowability.	menu add: 'decimal places...' action: #setPrecision.	menu add: 'font size...' action: #setFontSize.	menu add: 'font style...' action: #setFontStyle.! !!UpdatingStringMorph methodsFor: 'menu' stamp: 'jm 6/9/2003 21:52'!setFontSize	| sizes reply family |	family _ font ifNil: [TextStyle default] ifNotNil: [font textStyle].	family ifNil: [family _ TextStyle default].  "safety net -- this line SHOULD be unnecessary now"	sizes _ 	family fontNamesWithHeights.	reply _ (SelectionMenu labelList: sizes selections: sizes) startUp.	reply ifNotNil:		[self font: (family fontAt: (sizes indexOf: reply))]! !!UpdatingStringMorph methodsFor: 'menu' stamp: 'sw 12/7/1999 11:45'!setFontStyle	| aList reply style |	aList _ (TextConstants select: [:anItem | anItem isKindOf: TextStyle])			keys asOrderedCollection.	reply _ (SelectionMenu labelList: aList selections: aList) startUp.	reply ~~ nil ifTrue:		[(style _ TextStyle named: reply) ifNil: [self beep. ^ true].		self font: (style defaultFont)]! !!UpdatingStringMorph methodsFor: 'menu' stamp: 'sw 10/5/1998 15:31'!setPrecision	| aList aMenu reply |	aList _ #('0' '1' '2' '3' '4' '5').	aMenu _ SelectionMenu labels: aList selections: aList.	reply _ aMenu startUpWithCaption: 'How many decimal places?'.	reply ifNotNil:		[self floatPrecision:			(#(1 0.1 0.01 0.001 0.0001 0.00001 0.000001) at: (aList indexOf: reply))]! !!UpdatingStringMorph methodsFor: 'menu' stamp: 'jm 3/15/2003 20:33'!toggleGrowability	growable _ growable not.	self updateContentsFrom: self readFromTarget.	growable ifTrue: [self fitContents].! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'jm 9/29/2003 19:48'!acceptContents	| newValue |	((target ~~ nil) and: [putSelector ~~ nil]) ifTrue: [		"compute the new value"		format = #string			ifTrue: [newValue _ contents]			ifFalse: [				(contents size > 0 and: [contents first = $.]) ifTrue: [contents _ '0', contents].				newValue _ Compiler evaluate: contents].		newValue ifNotNil: [			parameter				ifNil: [target perform: putSelector with: newValue]				ifNotNil: [target perform: putSelector with: parameter with: newValue].			target isMorph ifTrue: [target changed]].		self fitContents].! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'jm 3/15/2003 20:43'!handlesMouseDown: evt	(owner wantsKeyboardFocusFor: self)		ifTrue: [^ self uncoveredAt: evt cursorPoint].	^ super handlesMouseDown: evt! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'jm 3/15/2003 20:36'!lostFocusWithoutAccepting	"The message is sent when the user, having been in an editing episode on the receiver, changes the keyboard focus without having accepted the current edits. In This case, we just accept the edits."	self acceptContents.! !!UpdatingStringMorph methodsFor: 'editing' stamp: 'sw 9/9/1999 10:58'!mouseDown: evt	(owner wantsKeyboardFocusFor: self) ifTrue:		[putSelector ifNotNil: [self launchMiniEditor: evt]]! !!UpdatingStringMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 22:18'!fieldsVersion	^ 1! !!UpdatingStringMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 22:21'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		format		target		getSelector		putSelector		parameter		floatPrecision		growable		stepTime	) from: anObjStream.! !!UpdatingStringMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 22:21'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		format		target		getSelector		putSelector		parameter		floatPrecision		growable		stepTime	) on: anObjStream.! !!UpdatingStringMorph methodsFor: 'private' stamp: 'jm 3/15/2003 20:28'!fitContents	| minWidth maxWidth scanner newExtent |	minWidth _ 5.	maxWidth _ 500.	scanner _ DisplayScanner quickPrintOn: Display box: Display boundingBox font: self fontToUse.	newExtent _		(((scanner stringWidth: contents) max: minWidth) min: maxWidth) @ scanner lineHeight.	self extent = newExtent ifFalse: [		self extent: newExtent.		self changed].! !!UpdatingStringMorph methodsFor: 'private' stamp: 'jm 3/15/2003 21:00'!formatValue: v	format = #string ifTrue: [^ v asString].	(format = #default and: [v isNumber]) ifTrue: [		v isInteger ifTrue: [^ v asInteger printString].		(v isKindOf: Float) ifTrue: [^ (v roundTo: self floatPrecision) printString]].	^ v printString! !!UpdatingStringMorph methodsFor: 'private' stamp: 'jm 3/17/2003 17:01'!readFromTarget	"Answer the formatted string for the value read from my target. If the target or selector are nil, or if the value is the same as the last value read, answer my current contents."	| v |	(v _ self valueFromTargetOrNil) ifNil: [^ contents].	lastValue = v ifTrue: [^ contents].	lastValue _ v.	^ self formatValue: v! !!UpdatingStringMorph methodsFor: 'private' stamp: 'jm 3/15/2003 20:34'!updateContentsFrom: aValue	growable		ifTrue: [self contents: aValue]		ifFalse: [self contentsClipped: aValue].! !!UpdatingStringMorph methodsFor: 'private' stamp: 'jm 3/17/2003 16:59'!valueFromTargetOrNil	"Answer the value read from my target. Answer nil if my target or selector is nil.."	((target == nil) or: [getSelector == nil]) ifTrue: [^ nil].	parameter		ifNil: [^ target perform: getSelector]		ifNotNil: [^ target perform: getSelector with: parameter].! !!UpdatingStringMorph class methodsFor: 'instance creation' stamp: 'jm 3/15/2003 20:49'!on: targetObject selector: aSymbol	^ self new		getSelector: aSymbol;		target: targetObject! !A repository for general and miscellaneous utilities; much of what is here are in effect global methods that don't naturally attach to anything else. All the functionality is implemented as class messages.!!Utilities class methodsFor: 'investigations' stamp: 'jm 5/29/2003 19:10'!inspectGlobals	"Utilities  inspectGlobals"	| dict gNames |	dict _ IdentityDictionary new.	gNames _ (Smalltalk keys select: [:n | (Smalltalk at: n) isBehavior not]) asArray sort.	gNames do: [:n | dict add: (Smalltalk associationAt: n)].	dict inspectWithLabel: 'The Globals'.! !!Utilities class methodsFor: 'identification' stamp: 'sw 7/6/1998 11:49'!authorInitialsPerSe	"Answer the currently-prevailing author initials, such as they, empty or not"	^ AuthorInitials! !!Utilities class methodsFor: 'identification' stamp: 'jm 5/31/2003 16:25'!authorName	AuthorName ifNil: [		AuthorName _ FillInTheBlank 			request: 'Please type your name:'			initialAnswer: 'Your Name'].	^ AuthorName! !!Utilities class methodsFor: 'identification' stamp: 'jm 6/23/2003 09:36'!clearAuthorInfo	AuthorInitials _ ''.	AuthorName _ nil.! !!Utilities class methodsFor: 'identification' stamp: 'sw 11/13/1999 22:45'!dateTimeSuffix	"Answer a string which indicates the date and time, intended for use in building fileout filenames, etc."	"Utilities dateTimeSuffix"	^ Preferences twentyFourHourFileStamps		ifFalse:			[self monthDayTimeStringFrom: Time primSecondsClock]		ifTrue:			[self monthDayTime24StringFrom: Time primSecondsClock]! !!Utilities class methodsFor: 'identification' stamp: 'sw 11/13/1999 23:03'!monthDayTime24StringFrom: aSecondCount	| aDate aTime |	"From the date/time represented by aSecondCount, produce a string which indicates the date and time in the compact form             ddMMMhhmm		where dd is a two-digit day-of-month, MMM is the alpha month abbreviation and hhmm is the time on a 24-hr clock.          Utilities monthDayTime24StringFrom: Time primSecondsClock"	aDate _ Date fromSeconds: aSecondCount.	aTime _ Time fromSeconds: aSecondCount \\ 86400.	^ (aDate dayOfMonth asTwoCharacterString), 		(aDate monthName copyFrom: 1 to: 3), 		(aTime hhmm24)! !!Utilities class methodsFor: 'identification' stamp: 'sw 11/13/1999 23:03'!monthDayTimeStringFrom: aSecondCount	| aDate aTime |	"From the date/time represented by aSecondCount, produce a string which indicates the date and time in the form:		ddMMMhhmmPP	  where:							dd is a two-digit day-of-month,							MMM is the alpha month abbreviation,							hhmm is the time,							PP is either am or pm          Utilities monthDayTimeStringFrom: Time primSecondsClock"	aDate _ Date fromSeconds: aSecondCount.	aTime _ Time fromSeconds: aSecondCount \\ 86400.	^ (aDate dayOfMonth asTwoCharacterString), 		(aDate monthName copyFrom: 1 to: 3), 		((aTime hours \\ 12) asTwoCharacterString), 		(aTime minutes asTwoCharacterString),		(aTime hours > 12 ifTrue: ['pm'] ifFalse: ['am'])! !!Utilities class methodsFor: 'identification' stamp: 'jm 12/5/2002 12:15'!setAuthorInitials	"Put up a dialog allowing the user to specify the author's initials.  "	self setAuthorInitials:		(FillInTheBlank			request: 'Please type your initials: '			initialAnswer: AuthorInitials)! !!Utilities class methodsFor: 'support windows' stamp: 'sma 2/12/2000 20:29'!commandKeyMappings	^ self class firstCommentAt: #commandKeyMappings"Lower-case command keys(use with Cmd key on Mac and Alt key on other platforms)a	Select allb	Browse it (selection is a class name)c	Copy selectiond	Do it (selection is a valid expression)e	Exchange selection with prior selectionf	Findg	Find againh	Set selection as search string for find againi	Inspect it (selection is a valid expression)j	Again oncek	Set fontl	Cancelm	Implementors of it (selection is a message selector)n	Senders of it (selection is a message selector)o	Spawn current methodp	Print it (selection is a valid expression)q	Query symbol (toggle all possible completion for a given prefix)r	Recognizers	Save (i.e. accept)u	Toggle alignmentv	Pastew	Delete preceding wordx	Cut selectiony	Swap charactersz	UndoNote: for Do it, Senders of it, etc., a null selection will be expanded to a word or to the current line in an attempt to do what you want.  Also note that Senders/Implementors of it will find the outermost keyword selector in a large selection, as when you have selected a bracketed expression or an entire line.  Finally note that the same cmd-m and cmd-n (and cmd-v for versions) work in the message pane of most browsers.Upper-case command keys(use with Shift-Cmd, or Ctrl on Mac or Shift-Alt on other platforms; sometimes Ctrl works too)A	Advance argumentB	Browse it in this same browser (in System browsers only)C	Compare argument to clipboardD	DuplicateE	Method strings containing itF	Insert 'ifFalse:'I	Inspect via Object ExplorerJ	Again manyK	Set styleL	Outdent (move selection one tab-stop left)N	References to itO	Open single-message browser (in selector lists)R	Indent (move selection one tab-stap right)S	SearchT	Insert 'ifTrue:'U	Convert linefeeds to carriage returns in selectionV	Paste author's initialsW	Selectors containing itX	Force selection to lowercaseY	Force selection to uppercaseZ	Capitalize all words in selectionOther special keysBackspace	Backward delete characterDel			Forward delete characterShift-Bcksp	Backward delete wordShift-Del	Forward delete wordEsc			Select current type-inCursor keysleft, right,up, ordown		Move cursor left, right, up or downCtrl+Left	Move cursor left one wordCtrl+Right	Move cursor right one wordHome		Move cursor to begin of line or begin of textEnd			Move cursor to end of line or end of textPgUp, orCtrl+Up		Move cursor up one pagePgDown, orCtrl+Down	Move cursor down one pageNote all these keys can be used together with Shift to define or enlarge the selection. You cannot however shrink that selection again, which is, compared to other systems, still a limitation aka bug.Other Cmd-key combinations (does not work on all platforms)Return		Insert return followed by as many tabs as the previous line			(with a further adjustment for additional brackets in that line)Space		Select the current word as with double clickingEnclose the selection in a kind of bracket.  Each is a toggle.(does not work on all platforms)Ctrl-(	Enclose within ( and ), or remove enclosing ( and )Ctrl-[	Enclose within [ and ], or remove enclosing [ and ]Crtl-{	Enclose within { and }, or remove enclosing { and }Ctrl-<	Enclose within < and >, or remove enclosing < and >Ctrl-'	Enclose within ' and ', or remove enclosing ' and 'Ctrl-""	Enclose within "" and "", or remove enclosing "" and ""Note also that you can double-click just inside any of the above delimiters (or at the beginning or end of a line) to select the text enclosed.Text Emphasis...(does not work on all platforms)Cmd-1	10 point fontCmd-2	12 point fontCmd-3	18 point fontCmd-4	24 point fontCmd-5	36 point fontCmd-6	color, action-on-click, link to class comment, link to method, url		Brings up a menu.  To remove these properties, select		more than the active part and then use command-0.Cmd-7	boldCmd-8	italicCmd-9	narrow (same as negative kern)Cmd-0	plain text (resets all emphasis)Cmd--	underlined (toggles it)Cmd-=	struck out (toggles it)Shift-Cmd--	(aka _) negative kern (letters 1 pixel closer)Shift-Cmd-+	positive kern (letters 1 pixel larger spread)"! !!Utilities class methodsFor: 'support windows' stamp: 'di 9/23/1998 01:53'!openCommandKeyHelp	"Open a window giving command key help."	"Utilities openCommandKeyHelp"	(StringHolder new contents: self commandKeyMappings)		openLabel: 'Command Key Actions'! !!Utilities class methodsFor: 'user interface' stamp: 'sma 4/30/2000 10:17'!informUser: aString during: aBlock	"Display a message above (or below if insufficient room) the cursor during execution of the given block."	"Utilities informUser: 'Just a sec!!' during: [(Delay forSeconds: 1) wait]"	Smalltalk isMorphic		ifTrue:			[(MVCMenuMorph from: (SelectionMenu labels: '') title: aString)				displayAt: Sensor cursorPoint during: [aBlock value].			^ self].	(SelectionMenu labels: '')		displayAt: Sensor cursorPoint		withCaption: aString		during: [aBlock value]! !!Utilities class methodsFor: 'user interface' stamp: 'sma 4/30/2000 10:18'!informUserDuring: aBlock	"Display a message above (or below if insufficient room) the cursor during execution of the given block."	"Utilities informUserDuring:[:bar|		#(one two three) do:[:info|			bar value: info.			(Delay forSeconds: 1) wait]]"	Smalltalk isMorphic		ifTrue:			[(MVCMenuMorph from: (SelectionMenu labels: '') title: '						')				informUserAt: Sensor cursorPoint during: aBlock.			^ self].	aBlock value:[:string| Transcript cr; show: string]! !!Utilities class methodsFor: 'miscellaneous' stamp: 'JMM 3/31/2000 20:41'!awaitMouseUpIn: box whileMouseDownDo: doBlock1 whileMouseDownInsideDo: doBlock2 ifSucceed: succBlock	"The mouse has gone down in box; track the mouse, inverting the box while it's within, and if, on mouse up, the cursor was still within the box, execute succBlock.  While waiting for the mouse to come up, repeatedly execute doBlock1, and also, if the cursor is within the box, execute doBlock2.  6/10/96 sw3/31/00 JMM added logic to stop multiple redraws"	| p inside lightForm darkForm isLight |	p _ Sensor cursorPoint.	inside _ box insetBy: 1.	isLight _ true.	lightForm _ Form fromDisplay: inside.	darkForm _ lightForm deepCopy reverse.	[Sensor anyButtonPressed] whileTrue:		[doBlock1 value.		(box containsPoint: (p _ Sensor cursorPoint))			ifTrue: [doBlock2 value.					isLight ifTrue: 						[isLight _ false.						darkForm displayAt: inside origin]]			ifFalse: [isLight ifFalse:						[isLight _ true.						lightForm displayAt: inside origin]]].	(box containsPoint: p)		ifTrue: [lightForm displayAt: inside origin.				^ succBlock value]! !!Utilities class methodsFor: 'miscellaneous' stamp: 'jm 11/25/1998 22:31'!convertCRtoLF: fileName	"Convert the given file to LF line endings. Put the result in a file with the extention '.lf'"	| in out c justPutCR |	in _ (FileStream oldFileNamed: fileName) binary.	out _  (FileStream newFileNamed: fileName, '.lf') binary.	justPutCR _ false.	[in atEnd] whileFalse: [		c _ in next.		c = 10			ifTrue: [				out nextPut: 13.				justPutCR _ true]			ifFalse: [				(justPutCR and: [c = 10]) ifFalse: [out nextPut: c].				justPutCR _ false]].	in close.	out close.! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sma 4/30/2000 10:17'!emergencyCollapse	Smalltalk isMorphic ifTrue: [^ self].	ScheduledControllers screenController emergencyCollapse! !!Utilities class methodsFor: 'miscellaneous' stamp: 'jm 7/20/2003 22:30'!form: partName from: directory	"Answer the form with the given name in the given directory or nil if there isn't one." 	| f |	directory fileNames do: [:fn |		((partName, '.*') match: fn) ifTrue: [			f _ [Form fromFileNamed: (directory fullNameFor: fn)] ifError: [nil].			f ifNotNil: [^ f]]].	^ nil! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 7/22/1998 17:12'!instanceComparisonsBetween: fileName1 and: fileName2	"For differential results, run printSpaceAnalysis twice with different fileNames,	then run this method...		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text1'.			--- do something that uses space here ---		Smalltalk printSpaceAnalysis: 0 on: 'STspace.text2'.		Smalltalk instanceComparisonsBetween: 'STspace.text1' and 'STspace.text2'"	| instCountDict report f aString items className newInstCount oldInstCount newSpace oldPair oldSpace |	instCountDict _ Dictionary new.	report _ ReadWriteStream on: ''.	f _ FileStream oldFileNamed: fileName1.	[f atEnd] whileFalse:		[aString _ f upTo: Character cr.		items _ aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[instCountDict at: items first put: (Array with: items third asNumber with: items fourth asNumber)]].	f close.	f _ FileStream oldFileNamed: fileName2.	[f atEnd] whileFalse:		[aString _ f upTo: Character cr.		items _ aString findTokens: ' '.		(items size == 4 or: [items size == 5]) ifTrue:			[className _ items first.			newInstCount _ items third asNumber.			newSpace _ items fourth asNumber.			oldPair _ instCountDict at: className ifAbsent: [nil].			oldInstCount _ oldPair ifNil: [0] ifNotNil: [oldPair first].			oldSpace _ oldPair ifNil: [0] ifNotNil: [oldPair second].			oldInstCount ~= newInstCount ifTrue:				[report nextPutAll: (newInstCount - oldInstCount) printString; tab; nextPutAll: (newSpace - oldSpace) printString; tab; nextPutAll: className asString; cr]]].	f close.	(StringHolder new contents: report contents)		openLabel: 'Instance count differentials between ', fileName1, ' and ', fileName2! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 1/12/1999 12:24'!methodDiffFor: aString class: aClass selector: aSelector	^ (aClass includesSelector: aSelector)		ifFalse:			[aString copy]		ifTrue:			[TextDiffBuilder buildDisplayPatchFrom: (aClass sourceCodeAt: aSelector) to: aString]! !!Utilities class methodsFor: 'miscellaneous' stamp: 'sw 10/20/1999 13:48'!setClassAndSelectorFrom: messageIDString in: csBlock	"Decode strings of the form <className> [class] <selectorName>.   If <className> does not exist as a class, use nil for the class in the block"	| aStream aClass maybeClass sel |	aStream _ ReadStream on: messageIDString.	aClass _ Smalltalk at: (aStream upTo: $ ) asSymbol ifAbsent: [nil].	maybeClass _ aStream upTo: $ .	sel _ aStream upTo: $ .	((maybeClass = 'class') & (sel size ~= 0))		ifTrue:			[aClass				ifNil:					[csBlock value: nil value: sel asSymbol]				ifNotNil:					[csBlock value: aClass class value: sel asSymbol]]		ifFalse:			[csBlock value: aClass value: maybeClass asSymbol]"Utilities setClassAndSelectorFrom: 'Utilities class oppositeModeTo:' in: [:aClass :aSelector | Transcript cr; show: 'Class = ', aClass name printString, ' selector = ', aSelector printString].Utilities setClassAndSelectorFrom: 'MessageSet setClassAndSelectorIn:' in: [:aClass :aSelector | Transcript cr; show: 'Class = ', aClass name printString, ' selector = ', aSelector printString]."! !!Utilities class methodsFor: 'miscellaneous' stamp: 'jm 4/20/1999 11:29'!timeStampForMethod: method	"Answer the authoring time-stamp for the given method, retrieved from the sources or changes file. Answer the empty string if no time stamp is available."	| position file preamble stamp tokens tokenCount |	method fileIndex == 0 ifTrue: [^ String new].  "no source pointer for this method"	position _ method filePosition.	file _ SourceFiles at: method fileIndex.	file ifNil: [^ String new].  "sources file not available"	file _ file readOnlyCopy.	file position: (0 max: position - 150).  "Skip back to before the preamble"		[file position < (position - 1)]  "then pick it up from the front"			whileTrue: [preamble _ file nextChunk].		stamp _ String new.		tokens _ (preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [Scanner new scanTokens: preamble]			ifFalse: [Array new  "ie cant be back ref"].		(((tokenCount _ tokens size) between: 7 and: 8) and: [(tokens at: tokenCount - 5) = #methodsFor:])			ifTrue:				[(tokens at: tokenCount - 3) = #stamp:					ifTrue: ["New format gives change stamp and unified prior pointer"							stamp _ tokens at: tokenCount - 2]].		((tokenCount between: 5 and: 6) and: [(tokens at: tokenCount - 3) = #methodsFor:])			ifTrue:				[(tokens at: tokenCount  - 1) = #stamp:					ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokenCount]].	file close.	^ stamp! !!Utilities class methodsFor: 'miscellaneous' stamp: 'jm 10/7/2002 05:38'!vmStatisticsReportString	"StringHolderView open: (StringHolder new contents:		Utilities vmStatisticsReportString) label: 'VM Statistics'"	| params oldSpaceEnd youngSpaceEnd memoryEnd fullGCs fullGCTime incrGCs incrGCTime tenureCount upTime |	params _ Smalltalk getVMParameters.	oldSpaceEnd			_ params at: 1.	youngSpaceEnd		_ params at: 2.	memoryEnd			_ params at: 3.	fullGCs				_ params at: 7.	fullGCTime			_ params at: 8.	incrGCs				_ params at: 9.	incrGCTime			_ params at: 10.	tenureCount			_ params at: 11.	upTime _ Time millisecondClockValue.	^ String streamContents: [:str |		str	nextPutAll: 'uptime			';			print: (upTime / 1000 / 60 // 60); nextPut: $h;			print: (upTime / 1000 / 60 \\ 60) asInteger; nextPut: $m;			print: (upTime / 1000 \\ 60) asInteger; nextPut: $s; cr; cr.		str	nextPutAll: 'memory			';			nextPutAll: memoryEnd asStringWithCommas; nextPutAll: ' bytes'; cr.		str	nextPutAll:	'	old			';			nextPutAll: oldSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';			print: ((oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	young		';			nextPutAll: (youngSpaceEnd - oldSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';			print: ((youngSpaceEnd - oldSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	used		';			nextPutAll: youngSpaceEnd asStringWithCommas; nextPutAll: ' bytes (';			print: ((youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr.		str	nextPutAll: '	free		';			nextPutAll: (memoryEnd - youngSpaceEnd) asStringWithCommas; nextPutAll: ' bytes (';			print: ((memoryEnd - youngSpaceEnd / memoryEnd * 100) roundTo: 0.1); nextPutAll: '%)'; cr; cr.		str	nextPutAll: 'GCs				';			nextPutAll: (fullGCs + incrGCs) asStringWithCommas;			nextPutAll: ' ('; print: ((upTime / (fullGCs + incrGCs)) roundTo: 1); nextPutAll: 'ms between GCs)'; cr.		str	nextPutAll: '	full			';			print: fullGCs; nextPutAll: ' in '; nextPutAll: fullGCTime asStringWithCommas; nextPutAll: 'ms (';			print: ((fullGCTime / upTime * 100) roundTo: 1.0);			nextPutAll: '% uptime)'.		fullGCs = 0 ifFalse:			[str	nextPutAll: ', avg '; print: ((fullGCTime / fullGCs) roundTo: 1.0); nextPutAll: 'ms'].		str	cr.		str	nextPutAll: '	incr		';			print: incrGCs; nextPutAll: ' in '; nextPutAll: incrGCTime asStringWithCommas; nextPutAll: 'ms (';			print: ((incrGCTime / upTime * 100) roundTo: 1.0);			nextPutAll: '% uptime), avg '; print: ((incrGCTime / incrGCs) roundTo: 1.0); nextPutAll: 'ms'; cr.		str	nextPutAll: '	tenures		';			nextPutAll: tenureCount asStringWithCommas.		tenureCount = 0 ifFalse:			[str nextPutAll: ' (avg '; print: (incrGCs / tenureCount) asInteger; nextPutAll: ' GCs/tenure)'].		str	cr].! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 10/5/1998 17:58'!chooseFileWithSuffixFromList: aSuffixList withCaption: aCaption	"Pop up a list of all files in the default directory which have a suffix in the list.  Return #none if there are none; return nil if the user backs out of the menu without making a choice."	"Utilities chooseFileWithSuffixFromList: #('.gif' '.jpg')"	| aList aName |	aList _ OrderedCollection new.	aSuffixList do:		[:aSuffix | aList addAll: (FileDirectory default fileNamesMatching: '*', aSuffix)].	^ aList size > 0		ifTrue:			[aName _ (SelectionMenu selections: aList) startUpWithCaption: aCaption.			aName]		ifFalse:			[#none]! !!Utilities class methodsFor: 'summer97 additions' stamp: 'sw 5/4/2000 13:47'!classFromPattern: pattern withCaption: aCaption	"If there is a class whose name exactly given by pattern, return it.	If there is only one class in the system whose name matches pattern, return it.	Otherwise, put up a menu offering the names of all classes that match pattern, and return the class chosen, else nil if nothing chosen"	| toMatch potentialClassNames classNames exactMatch index |	pattern isEmpty ifTrue: [^ nil].	Symbol hasInterned: pattern ifTrue:		[:patternSymbol | Smalltalk at: patternSymbol ifPresent:			[:maybeClass | (maybeClass isKindOf: Class) ifTrue: [^ maybeClass]]].	toMatch _ (pattern copyWithout: $.) asLowercase.	potentialClassNames _ Smalltalk classNames asOrderedCollection.	classNames _ pattern last = $. 		ifTrue: [potentialClassNames select:					[:nm |  nm asLowercase = toMatch]]		ifFalse: [potentialClassNames select: 					[:n | n includesSubstring: toMatch caseSensitive: false]].	classNames isEmpty ifTrue: [^ nil].	exactMatch _ classNames detect: [:each | each asLowercase = toMatch] ifNone: [nil].	index _ classNames size = 1		ifTrue:	[1]		ifFalse:	[exactMatch			ifNil: [(PopUpMenu labelArray: classNames lines: #()) startUpWithCaption: aCaption]			ifNotNil: [classNames addFirst: exactMatch.				(PopUpMenu labelArray: classNames lines: #(1)) startUpWithCaption: aCaption]].	index = 0 ifTrue: [^ nil].	^ Smalltalk at: (classNames at: index) asSymbol"	Utilities classFromPattern: 'CharRecog'	Utilities classFromPattern: 'rRecog'	Utilities classFromPattern: 'znak'	Utilities classFromPattern: 'orph'"! !I act like an argument morph but I actually represent the target variable for an assignment ("set:to:") block. I allow the user to change me to a different variable in the same object via a popup menu.!!VariableArgMorph methodsFor: 'initialization' stamp: 'tis 6/24/2003 11:50'!initialize	super initialize.	self borderWidth: 1.	self borderInset.	self color: (Color r: 0.4 g: 1.0 b: 0.4).	self extent: 20@17.	labelMorph _ StringMorph new.	self addMorph: labelMorph.	self variable: 'x'.! !!VariableArgMorph methodsFor: 'initialization' stamp: 'jm 6/23/2003 00:17'!wantsDroppedMorph: aMorph event: evt	"I don't want any argument morphs to drop into my place because I have a menu of all possible variables."	^ false! !!VariableArgMorph methodsFor: 'accessing' stamp: 'tis 7/2/2003 12:22'!target	^ target! !!VariableArgMorph methodsFor: 'accessing' stamp: 'tis 7/2/2003 12:23'!target: anObject	target _ anObject.! !!VariableArgMorph methodsFor: 'accessing' stamp: 'jm 9/24/2003 18:44'!variable	^ labelMorph contents! !!VariableArgMorph methodsFor: 'accessing' stamp: 'jm 9/24/2003 18:44'!variable: aString	labelMorph contents: aString.	self width: labelMorph width + 6.	labelMorph position: self position + (3@2).! !!VariableArgMorph methodsFor: 'event handling' stamp: 'TIS 6/19/2003 13:09'!handlesMouseDown: evt	^ true! !!VariableArgMorph methodsFor: 'event handling' stamp: 'TIS 7/11/2003 09:01'!mouseDown: evt	| menu choice |	menu _ CustomMenu new.	((self target builtinVars), (self target userVars)) do: [		:sym | menu add: sym action: sym].	(choice _ menu startUp) ifNotNil: [self variable: choice].! !!VariableArgMorph methodsFor: 'evaluation' stamp: 'jm 9/24/2003 18:45'!evaluate	"Returns a string with the name of the argument."	^ self variable! !!VariableArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:41'!fieldsVersion	^ 1! !!VariableArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:45'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		target	) from: anObjStream.! !!VariableArgMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 18:45'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		target	) on: anObjStream.! !I am a parse tree leaf representing a variable. Note that my name and key are different for pool variables: the key is the Object Reference.!!VariableNode methodsFor: 'testing' stamp: 'tk 8/2/1999 18:40'!isSelfPseudoVariable	"Answer if this ParseNode represents the 'self' pseudo-variable."	^ key = 'self'! !!VariableNode methodsFor: 'testing' stamp: 'di 2/3/1999 09:41'!type	"This code attempts to reconstruct the type from its encoding in code.		This allows one to test, for instance, (aNode type = LdInstType)."	| type |	code < 0 ifTrue: [^ code negated].	code < 256 ifFalse: [^ code // 256].	type _ CodeBases findFirst: [:one | code < one].	type = 0		ifTrue: [^ 5]		ifFalse: [^ type - 1]! !!VariableNode methodsFor: 'code generation' stamp: 'di 2/6/2000 10:52'!fieldOffset  "Return temp or instVar offset for this variable"	code < 256		ifTrue: 			[^ code \\ 16]		ifFalse: 			[^ code \\ 256]! !!VariableNode methodsFor: 'printing' stamp: 'sw 11/16/1999 16:36'!printOn: aStream indent: level 	aStream withAttributes: (Preferences syntaxAttributesFor: #variable)		do: [aStream nextPutAll: name].! !This morph simulates an old-fashioned vector display.In the mid-1970's, Danny Hillis and Marvin Minsky built a computer with a vector graphics display and used it to do Logo-style turtle graphics. An interesting additional feature they added was the ability to make the turtle's coordinate system rotate a varying speeds allowing animated drawings to be created very easily.To experiment with this morph, copy the following and paste it into a Workspace window, then select each group of lines and invoke "do it" from the menu or by typing alt-d (cmd-d on a Mac)."create the virtual vector scope display:"d _ VectorScopeMorph new openInWorld."stationary line:"d cs.d forward: 50."spinning line:"d cs.d spin: 2.d forward: 50."nested spins:"d cs.d spin: 5; forward: 50.d spin: -5; forward: 50.d spin: -10; forward: 50."ferris wheel:"d cs.d spin: 1.16 timesRepeat: [  4 timesRepeat: [d forward: 50; right: 90].  d right: 22.5]"snake:"d cs.10 timesRepeat: [d spin: 1; forward: 100]"snake made from flags:"d cs.5 timesRepeat: [	d spin: 5; forward: 50.	4 timesRepeat: [d forward: 50; right: 90]]"first two terms of the Fourier series for a square wave:"d cs.d spin: 1; forward: 100; spin: -2; forward: 100; spin: 1.d spin: 3; forward: -100 / 3 ; spin:  -6; forward: -100 / 3; spin: 3.d startGraph.  "graphs the y component of the final turtle position""first five terms of the Fourier series for a square wave:"d cs.d spin: 1; forward: 100; spin: -2; forward: 100; spin: 1.d spin: 3; forward: -100 / 3 ; spin:  -6; forward: -100 / 3; spin: 3.d spin: 5; forward:  100 / 5 ; spin: -10; forward:  100 / 5; spin: 5.d spin: 7; forward: -100 / 7 ; spin: -14; forward: -100 / 7; spin: 7.d spin: 9; forward:  100 / 9 ; spin: -18; forward:  100 / 9; spin: 9.d startGraph. "misc. graphing controls"d clearGraphd startGraph.d stopGraph.!!VectorScopeMorph methodsFor: 'initialization' stamp: 'jm 6/16/2003 18:44'!initialize	super initialize.	self position: 10@150.	self form: (Form extent: 400@400 depth: Display depth).	displayList _ OrderedCollection new.	graphPen _ nil.	tickNum _ 0.	self cs.! !!VectorScopeMorph methodsFor: 'accessing' stamp: 'jm 6/15/2003 09:37'!form: aForm	"Create a pen on my new Form."	super form: aForm.	pen _ Pen newOnForm: form.	pen color: Color white.! !!VectorScopeMorph methodsFor: 'commands' stamp: 'jm 6/15/2003 09:50'!clearGraph	"Clear the graph and place the graph pen on the left edge of the screen."	Display restore.	graphPen ifNotNil: [graphPen place: 0@0].! !!VectorScopeMorph methodsFor: 'commands' stamp: 'jm 6/15/2003 09:37'!cs	"Clear the screen and the the display list."	displayList _ displayList species new.	graphPen ifNotNil: [graphPen place: 0@0].	tickNum _ 0.! !!VectorScopeMorph methodsFor: 'commands' stamp: 'jm 6/15/2003 09:42'!forward: n	"Add a forward command to my display list."	displayList add: {#doForward:. n}.! !!VectorScopeMorph methodsFor: 'commands' stamp: 'jm 6/15/2003 09:42'!right: n	"Add a right turn command to my display list. The argument is in degrees. Negative arguments turn left."	displayList add: {#doRight:. n}.! !!VectorScopeMorph methodsFor: 'commands' stamp: 'jm 6/15/2003 09:45'!spin: n	"Make the coordinate system for subsequent drawing operations rotate by the given number of degrees per update cycle. Spin commands are additive: a spin of 2 followed by a spin of 5 results in a cummulative spin of 5. It follows that a negative spin can cancel out a positive spin of the same amount."	displayList add: {#doSpin:. n}.! !!VectorScopeMorph methodsFor: 'commands' stamp: 'jm 6/15/2003 10:07'!startGraph	"Start graphing the final y-coordinate of the drawing pen. Can be used to show, for example, how the y-component of a spinning line results in a sine wave."	Display restore.	graphPen _ Pen new place: 0@0.	graphPen color: Color blue.! !!VectorScopeMorph methodsFor: 'commands' stamp: 'jm 6/15/2003 09:51'!stopGraph	"Stop graphing."	graphPen _ nil.	Display restore.! !!VectorScopeMorph methodsFor: 'stepping' stamp: 'jm 6/15/2003 09:53'!step	"Clear the screen, perform all actions on the display list, and increment the tick number. If graphPen is not nil, plot the y-coordinate of the scope's drawing pen."	pen home; north.	form fillBlack.	displayList do: [:a | self perform: a first withArguments: a allButFirst].	graphPen ifNotNil: [		graphPen goto: (graphPen location x + 1) @ (pen location y // 3)].	tickNum _ (tickNum + 1) \\ 360.	self changed.! !!VectorScopeMorph methodsFor: 'stepping' stamp: 'jm 6/12/2003 12:59'!stepTime	^ 50! !!VectorScopeMorph methodsFor: 'private' stamp: 'jm 6/15/2003 09:38'!doForward: n	"Do a display list 'forward' command."	pen go: n.! !!VectorScopeMorph methodsFor: 'private' stamp: 'jm 6/15/2003 09:39'!doRight: n	"Do a display list 'right' command."	pen turn: n.! !!VectorScopeMorph methodsFor: 'private' stamp: 'jm 6/15/2003 09:39'!doSpin: n	"Do a display list 'spin' command."	pen turn: n * tickNum.! !!VectorScopeMorph class methodsFor: 'instance creation' stamp: 'jm 6/16/2003 18:47'!includeInNewMorphMenu	^ true! !!VersionsBrowser methodsFor: 'init & update' stamp: 'sw 5/6/2000 01:16'!changeListButtonSpecs	^#(		('compare to current'		compareToCurrentVersion		'opens a separate window which shows the text differences between the selected version and the current version')		('revert'		fileInSelections		'reverts the method to the version selected')		('remove from changes'		removeMethodFromChanges		'remove this method from the current change set')		('help'		offerVersionsHelp		'further explanation about use of Versions browsers')		)! !!VersionsBrowser methodsFor: 'init & update' stamp: 'sbw 12/30/1999 14:43'!optionalButtonsView	| view bHeight vWidth offset triples buttonCount previousView wid button |	view _ View new model: self.	bHeight _ self optionalButtonHeight.	vWidth _ 180.	view window: (0@0 extent: vWidth@bHeight).	offset _ 0.	triples _ self versionListButtonTriples.	buttonCount _ triples size + 1.	previousView _ nil.	wid _ vWidth // buttonCount.	triples do: [:triplet |		button _ PluggableButtonView on: self getState: nil action: triplet second.		button			label: triplet first asParagraph;			insideColor: Color lightBlue;			borderWidthLeft: 0 right: 1 top: 0 bottom: 0;			window: (offset@0 extent: wid@bHeight).		offset _ offset + wid.		triplet last = triples first last			ifTrue: [view addSubView: button]			ifFalse: [view addSubView: button toRightOf: previousView].		previousView _ button].	button _ PluggableButtonView on: self getState: #showDiffs action: #toggleDiff.	button		label: 'toggle diff' asParagraph;		insideColor: Color lightBlue;		window: (offset@0 extent: (vWidth - offset)@bHeight).	view addSubView: button toRightOf: previousView.	^ view! !!VersionsBrowser methodsFor: 'init & update' stamp: 'sw 11/28/1999 22:50'!reformulateList	| aMethod |	"Some uncertainty about how to deal with lost methods here"	aMethod _ classOfMethod compiledMethodAt: selectorOfMethod ifAbsent: [^ self].		self scanVersionsOf: aMethod class: classOfMethod theNonMetaClass meta: classOfMethod isMeta category: (classOfMethod whichCategoryIncludesSelector: selectorOfMethod) selector: selectorOfMethod.	self changed: #list. "for benefit of mvc"	listIndex _ 1.	self changed: #listIndex.	self contentsChanged! !!VersionsBrowser methodsFor: 'init & update' stamp: 'ar 5/17/2000 18:30'!scanVersionsOf: method class: class meta: meta category: category selector: selector	| position prevPos prevFileIndex preamble tokens sourceFilesCopy stamp |	selectorOfMethod _ selector.	currentCompiledMethod _ method.	classOfMethod _ meta ifTrue: [class class] ifFalse: [class].	changeList _ OrderedCollection new.	list _ OrderedCollection new.	listIndex _ 0.	position _ method filePosition.	sourceFilesCopy _ SourceFiles collect:		[:x | x isNil ifTrue: [ nil ]				ifFalse: [x readOnlyCopy]].	method fileIndex == 0 ifTrue: [^ nil].	file _ sourceFilesCopy at: method fileIndex.	[position notNil & file notNil]		whileTrue:		[file position: (0 max: position-150).  "Skip back to before the preamble"		[file position < (position-1)]  "then pick it up from the front"			whileTrue: [preamble _ file nextChunk].		"Preamble is likely a linked method preamble, if we're in			a changes file (not the sources file).  Try to parse it			for prior source position and file index"		prevPos _ nil.		stamp _ ''.		(preamble findString: 'methodsFor:' startingAt: 1) > 0			ifTrue: [tokens _ Scanner new scanTokens: preamble]			ifFalse: [tokens _ Array new  "ie cant be back ref"].		((tokens size between: 7 and: 8)			and: [(tokens at: tokens size-5) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-3) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size-2.						prevPos _ tokens last.						prevFileIndex _ sourceFilesCopy fileIndexFromSourcePointer: prevPos.						prevPos _ sourceFilesCopy filePositionFromSourcePointer: prevPos]				ifFalse: ["Old format gives no stamp; prior pointer in two parts"						prevPos _ tokens at: tokens size-2.						prevFileIndex _ tokens last].				(prevPos = 0 or: [prevFileIndex = 0]) ifTrue: [prevPos _ nil]].		((tokens size between: 5 and: 6)			and: [(tokens at: tokens size-3) = #methodsFor:])			ifTrue:				[(tokens at: tokens size-1) = #stamp:				ifTrue: ["New format gives change stamp and unified prior pointer"						stamp _ tokens at: tokens size]]. 		self addItem:				(ChangeRecord new file: file position: position type: #method						class: class name category: category meta: meta stamp: stamp)			text: stamp , ' ' , class name , (meta ifTrue: [' class '] ifFalse: [' ']) , selector.		position _ prevPos.		prevPos notNil ifTrue:			[file _ sourceFilesCopy at: prevFileIndex]].	sourceFilesCopy do: [:x | x notNil ifTrue: [x close]].	listSelections _ Array new: list size withAll: false! !!VersionsBrowser methodsFor: 'init & update' stamp: 'sw 10/19/1999 14:11'!updateListsAndCodeIn: aWindow	| aMethod |	aMethod _ classOfMethod compiledMethodAt: selectorOfMethod ifAbsent: [^ false].	aMethod == currentCompiledMethod		ifFalse:			[self reformulateList].	^ true! !!VersionsBrowser methodsFor: 'init & update' stamp: 'sbw 12/30/1999 14:34'!versionListButtonTriples	^#(		('compare to current'		compareToCurrentVersion		'opens a separate window which shows the text differences between the selected version and the current version')		('revert'		fileInSelections		'reverts the method to the version selected')		('remove from changes'		removeMethodFromChanges		'remove this method from the current change set')		('help'		offerVersionsHelp		'further explanation about use of Versions browsers')		)! !!VersionsBrowser methodsFor: 'menu' stamp: 'sw 10/12/1999 17:51'!fileInSelections 	super fileInSelections.	self reformulateList! !!VersionsBrowser methodsFor: 'menu' stamp: 'sw 10/12/1999 22:49'!offerVersionsHelp	(StringHolder new contents: self versionsHelpString)		openLabel: 'Versions Browsers'! !!VersionsBrowser methodsFor: 'menu' stamp: 'sw 10/12/1999 22:36'!removeMethodFromChanges	Smalltalk changes removeSelectorChanges: selectorOfMethod			class: classOfMethod! !!VersionsBrowser methodsFor: 'menu' stamp: 'sw 10/12/1999 23:09'!versionsHelpString	^ 'Each entry in the list pane represents a version of the source code for the same method; the topmost entry is the current version, the next entry is the next most recent, etc.To revert to an earlier version, select it (in the list pane) and then do any of the following:  *  Choose "revert to this version" from the list pane menu.  *  Hit the "revert" button,  *  Type ENTER in the code pane  *  Type cmd-s (alt-s) in the code pane.The code pane shows the source for the selected version.  If "diffing" is in effect, then differences betwen the selected version and the version before it are pointed out in the pane.  Turn diffing on and off by choosing "toggle diffing" from the list pane menu, or hitting the "diffs" button.To get a comparison between the selected version and the current version, choose "compare to current" from the list pane menu or hit the "compare to current" button.  (This is meaningless if the current version is selected, and is unnecessary if you''re interested in diffs from between the current version and the next-most-recent version, since the standard in-pane "diff" feature will give you that.)If further versions of the method in question have been submitted elsewhere since you launched a particular Versions Browser, it will still stay nicely up-to-date if you''re in Morphic and have asked that lazy updating be maintained; if you''re in mvc, you can use the "update list" command to make certain the versions list is up to date.Hit the "remove from changes" button, or choose the corresponding command in the list pane menu, to have the method in question deleted from the current change set.  This is useful if you''ve put debugging code into a method, and now want to strip it out and cleanse your current change set of all memory of the excursion.'! !!VersionsBrowser methodsFor: 'menu' stamp: 'sw 10/12/1999 22:32'!versionsMenu: aMenu	^ aMenu labels:'compare to currentrevert to this versionremove from changestoggle diffingupdate listhelp...'	lines: #()	selections: #(compareToCurrentVersion fileInSelections removeMethodFromChanges toggleDiffing reformulateList offerVersionsHelp)! !!VersionsBrowser methodsFor: 'misc' stamp: 'sw 10/19/1999 15:04'!showsVersions	^ true! !!VersionsBrowser class methodsFor: 'as yet unclassified' stamp: 'di 1/11/2000 12:45'!browseVersionsOf: method class: class meta: meta category: msgCategory selector: selector 	^ self browseVersionsOf: method class: class meta: meta category: msgCategory selector: selector lostMethodPointer: nil! !!VersionsBrowser class methodsFor: 'as yet unclassified' stamp: 'di 1/11/2000 12:44'!browseVersionsOf: method class: class meta: meta category: msgCategory selector: selector lostMethodPointer: sourcePointer 	| changeList |	Cursor read showWhile:		[changeList _ self new			scanVersionsOf: method class: class meta: meta			category: msgCategory selector: selector].	changeList ifNil: [^ self inform: 'No versions available'].	sourcePointer ifNotNil:		[changeList setLostMethodPointer: sourcePointer].	self open: changeList name: 'Recent versions of ' ,selector multiSelect: false! !!VersionsBrowser class methodsFor: 'as yet unclassified' stamp: 'sw 10/21/1999 17:21'!timeStampFor: aSelector class: aClass reverseOrdinal: anInteger	"Answer the time stamp corresponding to some version of the given method, nil if none.  The reverseOrdinal parameter is interpreted as:  1 = current version; 2 = last-but-one version, etc."		| method aChangeList |	method _ aClass compiledMethodAt: aSelector ifAbsent: [^ nil].	aChangeList _ self new			scanVersionsOf: method class: aClass meta: aClass isMeta			category: nil selector: aSelector.	^ aChangeList ifNil: [nil] ifNotNil:		[aChangeList list size >= anInteger			ifTrue:				[(aChangeList changeList at: anInteger) stamp]			ifFalse:				[nil]]! !!VersionsBrowser class methodsFor: 'as yet unclassified' stamp: 'sw 10/19/1999 15:01'!versionCountForSelector: aSelector class: aClass	"Answer the number of versions known to the system for the given class and method, including the current version.  A result of greater than one means that there is at least one superseded version.  Answer zero if no logged version can be obtained."		| method aChangeList |	method _ aClass compiledMethodAt: aSelector ifAbsent: [^ 0].	aChangeList _ self new			scanVersionsOf: method class: aClass meta: aClass isMeta			category: nil selector: aSelector.	^ aChangeList ifNil: [0] ifNotNil: [aChangeList list size]! !My instances are intended to be components in a structured picture. Each View in the structured picture can contain other Views as sub-components. These sub-components are called subViews. A View can be a subView of only one View. This View is called its superView. The set of Views in a structured picture forms a hierarchy. The one View in the hierarchy that has no superView is called the topView of the structured picture. A View in a structured picture with no subViews is called a bottom View. A View and all of its subViews, and all of their subViews and so on, are treated as a unit in many operations on the View. For example, if a View is displayed, all of its subViews are displayed as well. There are several categories of operations that can be performed on a View. Among these are the following:		1.	Adding subViews to a View.	2.	Positioning subViews within a View.	3.	Deleting subViews from a View.	4.	Transforming a View.	5.	Displaying a View.	Each View has its own coordinate system. In order to change from one coordinate system to another, each View has two transformations associated with it. The local transformation is a WindowingTransformation that maps objects in the coordinate system of the View to objects in the coordinate system of the superView of the View. The displayTransformation is a WindowingTransformation that maps objects in the coordinate system of the View to objects in the display screen coordinate system.	The part of the space that is to be made visible is represented by the window of the View. The window of a View is a Rectangle expressed in the coordinate system of the View. The area occupied by a View in the coordinate system of its superView is called its viewport. The viewport of a View is its window transformed by its local transformation. The region of the display screen occupied by a View is called its displayBox. The display box of a View can include a border. The width of the border expressed in display screen coordinates is called the border width of the View. The color of the border is called the border color. The region of the display box of a View excluding the border is called the inset display box. The color of the inset display box is called the inside color of the View.!!View methodsFor: 'display box access' stamp: 'jm 6/15/2003 18:25'!boundingBox	"Answer my bounding box, which in this default case is the rectangle surrounding the bounding boxes of all my subViews."	^ boundingBox ~~ nil		ifTrue: [boundingBox]		ifFalse: [self computeBoundingBox]! !!View methodsFor: 'display box access' stamp: 'acg 2/23/2000 00:08'!insetDisplayBox	"Answer the receiver's inset display box. The inset display box is the 	intersection of the receiver's window, tranformed to display coordinates, 	and the inset display box of the superView, inset by the border width. 	The inset display box represents the region of the display screen in 	which the inside of the receiver (all except the border) is displayed. If 	the receiver is totally clipped by the display screen and its superView, 	the resulting Rectangle will be invalid."	insetDisplayBox ifNil: [insetDisplayBox _ self computeInsetDisplayBox].	^insetDisplayBox! !!View methodsFor: 'bordering' stamp: 'sw 11/2/1998 15:34'!backgroundColor	Display depth <= 2 ifTrue: [^ Color white].	insideColor ifNotNil: [^ Color colorFrom: insideColor].	^ superView == nil		ifFalse: [superView backgroundColor]		ifTrue:	[Color white]! !!View methodsFor: 'bordering' stamp: 'sw 11/2/1998 15:35'!foregroundColor	borderColor ifNotNil: [^ Color colorFrom: borderColor].	^ superView == nil		ifFalse: [superView foregroundColor]		ifTrue:	[Color black]! !!View methodsFor: 'morphic compatibility' stamp: 'mdr 1/24/2000 17:27'!setBalloonText: aString	"Unfortunately we just ignore this help text because we are not morphic"! !I am a server for a simple voice messaging system. The first byte of the request message determines the response:	1 -- sendMsg		format: <1><from><toList><sampleRate><GSMData>		response: <empty>	2 -- nextMsg		format: <2><user>		response: <empty> | <2><from><toList><sampleRate><GSMData>	3 -- deleteMsg		format: <3><user>		response: <empty>	4 -- availableUsers		format: <4><user>		response: <4><userList>	5 -- allUsers		format: <5><user>		response: <5><userList>The client sends a voice message using sendMsg and polls for incoming messages by sending nextMsg requests. When it gets a non-empty reply, it removes that message from its message mailbox by sending deleteMsg, typically as part of the same transaction. A client can also get a list of all users (allUsers) or can find out which other users are currently online (availableUsers). The reply is a list of users that have performed a nextMsg request to the server recently.!!VoiceMsgServer methodsFor: 'initialization' stamp: 'jm 9/5/2001 07:48'!initialize	super initialize.	lastPollTime _ Dictionary new.	msgBox _ Dictionary new.! !!VoiceMsgServer methodsFor: 'request handling' stamp: 'jm 9/5/2001 12:01'!handleAllUsers: aByteArray	"Handle a allUsers request. The answer is a list of alll users who are registered with the server."	| s user allUsers out |	s _ ReadStream on: aByteArray.	s skip: 1.  "op"	user _ s string.	self ensureUserRegistered: user.	allUsers _ lastPollTime keys asArray sort.	out _ WriteStream on: (ByteArray new: 1000).	out nextPut: 5.	out uint16: allUsers size.	allUsers do: [:u | out string: u].	^ out contents! !!VoiceMsgServer methodsFor: 'request handling' stamp: 'jm 9/5/2001 11:44'!handleDeleteMsg: aByteArray	"Handle a deleteMsg request. Delete the first message in the requestor's message box, if any."	| s user box |	s _ ReadStream on: aByteArray.	s skip: 1.  "op"	user _ s string.	self ensureUserRegistered: user.	box _ msgBox at: user.	box isEmpty ifFalse: [box removeFirst].! !!VoiceMsgServer methodsFor: 'request handling' stamp: 'jm 9/5/2001 11:42'!handleMsgSend: aByteArray	"Handle a send request. The full message is in the proper format to be answered to a nextMsg request, which saves copying."	| s from toCount to |	s _ ReadStream on: aByteArray.	s skip: 1.  "op"	from _ s string.	self ensureUserRegistered: from.	toCount _ s uint16.	toCount timesRepeat: [		to _ s string.		self ensureUserRegistered: to.		(msgBox at: to) addLast: aByteArray].  "append the message"! !!VoiceMsgServer methodsFor: 'request handling' stamp: 'jm 9/5/2001 11:48'!handleNextMsg: aByteArray	"Process a nextMsg request. If the requesting user has no messages, answer the empty message. Otherwise, answer the first message in that user's message box."	| s user box |	s _ ReadStream on: aByteArray.	s skip: 1.  "op"	user _ s string.	self ensureUserRegistered: user.	box _ msgBox at: user.	box isEmpty ifTrue: [^ ByteArray new].  "no messages; respond with empty message"	^ box first  "answer the first message"! !!VoiceMsgServer methodsFor: 'request handling' stamp: 'jm 9/5/2001 11:46'!handleUsersAvailable: aByteArray	"Handle a usersAvailable request. The answer is a list of users who have interacted with the server in the past several minutes."	| s user cutoffTime availableUsers out |	s _ ReadStream on: aByteArray.	s skip: 1.  "op"	user _ s string.	self ensureUserRegistered: user.	cutoffTime _ Time totalSeconds - 120.	availableUsers _ lastPollTime keys asArray sort		select: [:u | (lastPollTime at: u) > cutoffTime].	out _ WriteStream on: (ByteArray new: 1000).	out nextPut: 4.	out uint16: availableUsers size.	availableUsers do: [:u | out string: u].	^ out contents! !!VoiceMsgServer methodsFor: 'request handling' stamp: 'jm 9/5/2001 11:58'!processMessage: aByteArray	"This server implements five commands. Zero-length messages are echoed. The first byte of the message defines the other commands:"	| op |	aByteArray size = 0 ifTrue: [^ ''].  "ping: an empty message generates an empty respose"	op _ aByteArray first.	op = 1 ifTrue: [^ self handleMsgSend: aByteArray].	op = 2 ifTrue: [^ self handleNextMsg: aByteArray].	op = 3 ifTrue: [^ self handleDeleteMsg: aByteArray].	op = 4 ifTrue: [^ self handleUsersAvailable: aByteArray].	op = 5 ifTrue: [^ self handleAllUsers: aByteArray].	^ ByteArray new  "null reply"! !!VoiceMsgServer methodsFor: 'private' stamp: 'jm 9/4/2001 15:13'!ensureUserRegistered: aString	"Make sure the given user has a message box and update the lastPollTime for that user."	(msgBox includesKey: aString) ifFalse: [		msgBox at: aString put: OrderedCollection new].	lastPollTime at: aString put: Time totalSeconds.! !!VoiceMsgServer class methodsFor: 'port number' stamp: 'jm 9/18/2001 11:56'!portNumber	^ 54324! !!VolumeEnvelope methodsFor: 'other' stamp: 'jm 8/17/1998 17:29'!computeSlopeAtMSecs: mSecs	"Private!! Find the next inflection point of this envelope and compute its target volume and the number of milliseconds until the inflection point is reached."	| t i |	((loopEndMSecs ~~ nil) and: [mSecs >= loopEndMSecs]) ifTrue: [  "decay phase"		t _ (points at: loopEndIndex) x + (mSecs - loopEndMSecs).		i _ self indexOfPointAfterMSecs: t startingAt: loopEndIndex.		i == nil ifTrue: [  "past end"			targetVol _ points last y * decayScale.			mSecsForChange _ 0.			nextRecomputeTime _ mSecs + 1000000.			^ self].		targetVol _ (points at: i) y * decayScale.		mSecsForChange _ (((points at: i) x - t) min: (endMSecs - mSecs)) max: 4.		nextRecomputeTime _ mSecs + mSecsForChange.		^ self].	mSecs < loopStartMSecs ifTrue: [  "attack phase"		i _ self indexOfPointAfterMSecs: mSecs startingAt: 1.		targetVol _ (points at: i) y.		mSecsForChange _ ((points at: i) x - mSecs) max: 4.		nextRecomputeTime _ mSecs + mSecsForChange.		((loopEndMSecs ~~ nil) and: [nextRecomputeTime > loopEndMSecs])			ifTrue: [nextRecomputeTime _ loopEndMSecs].		^ self].	"sustain and loop phase"	noChangesDuringLoop ifTrue: [		targetVol _ (points at: loopEndIndex) y.		mSecsForChange _ 10.		loopEndMSecs == nil			ifTrue: [nextRecomputeTime _ mSecs + 10]  "unknown end time"			ifFalse: [nextRecomputeTime _ loopEndMSecs].		^ self].	loopMSecs = 0 ifTrue: [^ (points at: loopEndIndex) y].  "looping on a single point"	t _ loopStartMSecs + ((mSecs - loopStartMSecs) \\ loopMSecs).	i _ self indexOfPointAfterMSecs: t startingAt: loopStartIndex.	targetVol _ (points at: i) y.	mSecsForChange _ ((points at: i) x - t) max: 4.	nextRecomputeTime _ (mSecs + mSecsForChange) min: loopEndMSecs.! !!VolumeEnvelope methodsFor: 'other' stamp: 'jm 9/10/1998 07:04'!updateTargetAt: mSecs	"Update the volume envelope slope and limit for my target. Answer false."	mSecs < nextRecomputeTime ifTrue: [^ false].	self computeSlopeAtMSecs: mSecs.	mSecsForChange < 5 ifTrue: [mSecsForChange _ 5].  "don't change instantly to avoid clicks"	target adjustVolumeTo: targetVol * scale overMSecs: mSecsForChange.	^ false! !!VolumeEnvelope methodsFor: 'other' stamp: 'jm 8/17/1998 08:00'!volume: aNumber	"Set the maximum volume of a volume-controlling envelope."	scale _ aNumber asFloat.! !WarpBlt is a little warp-drive added on to BitBlt.  It takes a quadrilateral as its source specification, while its destination is traversed and combined just like any other call to copyBits.The source quadrilateral is specified as an array of points starting with the corner that wants to end up in the topLeft, and proceding to the successive points that want to follow CCW around the destination rectangle.  Note that in specifying a plain old rectangle source, its non topLeft points must be actual pixels, not outside by 1, as with rectangle bottmRight, eg.  See the method Rectangle asQuad.WarpBlt does a fast job of rotation, reflection and scaling, and it can even produce a semblance of perspective.  Depth parameters are included for future improvements in this direction. but the primitve does not support this yet.!!WarpBlt methodsFor: 'setup' stamp: 'jm 4/11/1999 12:00'!cellSize: s	cellSize _ s.	cellSize = 1 ifTrue: [^ self].	colorMap _ Color colorMapIfNeededFrom: 32 to: destForm depth.! !!WarpBlt methodsFor: 'primitives' stamp: 'LY 6/17/2003 15:33'!copyQuad: pts toRect: destRect	cellSize ifNil: [^ self error: 'cellSize must not be nil!!'].	self sourceQuad: pts destRect: destRect.	self warpBits.! !!WarpBlt methodsFor: 'primitives' stamp: 'jm 5/2/1999 07:09'!sourceForm: srcForm destRect: dstRectangle	"Set up a WarpBlt from the entire source Form to the given destination rectangle."	| w h |	sourceForm _ srcForm.	sourceX _ sourceY _ 0.	destX _ dstRectangle left.	destY _ dstRectangle top.	width _ dstRectangle width.	height _ dstRectangle height.	w _ 16384 * (srcForm width - 1).	h _ 16384 * (srcForm height - 1).	p1x _ 0.	p2x _ 0.	p3x _ w.	p4x _ w.	p1y _ 0.	p2y _ h.	p3y _ h.	p4y _ 0.	p1z _ p2z _ p3z _ p4z _ 16384.  "z-warp ignored for now"! !!WarpBlt methodsFor: 'primitives' stamp: 'jm 4/11/1999 13:45'!warpBits	"Move those pixels!!"	self warpBitsSmoothing: cellSize		sourceMap: (sourceForm colormapIfNeededForDepth: 32).! !!WarpBlt methodsFor: 'primitives' stamp: 'jm 5/29/2003 18:07'!warpBitsSmoothing: n sourceMap: sourceMap	| deltaP12 deltaP43 pA pB deltaPAB sp fixedPtOne picker poker pix nSteps |	<primitive: 147>	"Check for compressed source, destination or halftone forms"	((sourceForm isKindOf: Form) and: [sourceForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	((destForm isKindOf: Form) and: [destForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	((halftoneForm isKindOf: Form) and: [halftoneForm unhibernate])		ifTrue: [^ self warpBitsSmoothing: n sourceMap: sourceMap].	(width < 1) | (height < 1) ifTrue: [^ self].	fixedPtOne _ 16384.  "1.0 in fixed-pt representation"	n > 1 ifTrue:		[(destForm depth < 16 and: [colorMap == nil])			ifTrue: ["color map is required to smooth non-RGB dest"					^ self primitiveFail].		pix _ Array new: n*n].	nSteps _ height-1 max: 1.	deltaP12 _ (self deltaFrom: p1x to: p2x nSteps: nSteps)			@ (self deltaFrom: p1y to: p2y nSteps: nSteps).	pA _ (self startFrom: p1x to: p2x offset: nSteps*deltaP12 x)		@ (self startFrom: p1y to: p2y offset: nSteps*deltaP12 y).	deltaP43 _ (self deltaFrom: p4x to: p3x nSteps: nSteps)			@ (self deltaFrom: p4y to: p3y nSteps: nSteps).	pB _ (self startFrom: p4x to: p3x offset: nSteps*deltaP43 x)		@ (self startFrom: p4y to: p3y offset: nSteps*deltaP43 y).	picker _ BitBlt bitPeekerFromForm: sourceForm.	poker _ BitBlt bitPokerToForm: destForm.	poker clipRect: self clipRect.	nSteps _ width-1 max: 1.	destY to: destY+height-1 do:		[:y |		deltaPAB _ (self deltaFrom: pA x to: pB x nSteps: nSteps)				@ (self deltaFrom: pA y to: pB y nSteps: nSteps).		sp _ (self startFrom: pA x to: pB x offset: nSteps*deltaPAB x)			@ (self startFrom: pA y to: pB y offset: nSteps*deltaPAB x).		destX to: destX+width-1 do:			[:x | 			n = 1			ifTrue:				[Transcript cr; print: sp // fixedPtOne asPoint.				poker pixelAt: x@y						put: (picker pixelAt: sp // fixedPtOne asPoint)]			ifFalse:				[0 to: n-1 do:					[:dx | 0 to: n-1 do:						[:dy |						pix at: dx*n+dy+1 put:								(picker pixelAt: sp									+ (deltaPAB*dx//n)									+ (deltaP12*dy//n)										// fixedPtOne asPoint)]].				poker pixelAt: x@y put: (self mixPix: pix										sourceMap: sourceMap										destMap: colorMap)].			sp _ sp + deltaPAB].		pA _ pA + deltaP12.		pB _ pB + deltaP43]! !!WarpBlt class methodsFor: 'examples' stamp: 'jm 7/17/2003 22:53'!test1   "Display restoreAfter: [WarpBlt test1]"	"Demonstrates variable scale and rotate"	| warp pts r1 p0 p ext |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) truncated.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext)]! !!WarpBlt class methodsFor: 'examples' stamp: 'jm 7/17/2003 22:53'!test12   "Display restoreAfter: [WarpBlt test12]"	"Just like test1, but comparing smooth to non-smooth warps"	| warp pts r1 p0 p ext warp2 |	Utilities informUser: 'Choose a rectangle with interesting stuff'		during: [r1 _ Rectangle originFromUser: 50@50.				Sensor waitNoButton].	Utilities informUser: 'Now click down and upand move the mouse around the dot'		during: [p0 _ Sensor waitClickButton.				(Form dotOfSize: 8) displayAt: p0].	warp _ (self toForm: Display)		cellSize: 2;  "installs a colormap"		clipRect: (0@0 extent: r1 extent*5);		sourceForm: Display;		combinationRule: Form over.	warp2 _ (self toForm: Display)		clipRect: ((0@0 extent: r1 extent*5) translateBy: 250@0);		sourceForm: Display;		combinationRule: Form over.	[Sensor anyButtonPressed] whileFalse:		[p _ Sensor cursorPoint.		pts _ {r1 topLeft. r1 bottomLeft. r1 bottomRight. r1 topRight}			collect: [:pt | pt rotateBy: (p-p0) theta about: r1 center].		ext _ (r1 extent*((p-p0) r / 20.0 max: 0.1)) truncated.		warp copyQuad: pts toRect: (r1 extent*5-ext//2 extent: ext).		warp2 copyQuad: pts toRect: ((r1 extent*5-ext//2 extent: ext) translateBy: 250@0).		]! !I am a Morphic clock or watch. My font can be changed and I can draw the clock face in either decimal or Roman numerals and I use an appropriate font for my current size.WatchMorph new openInWorld(WatchMorph fontName: 'ComicPlain') openInWorld  " transparent "(WatchMorph fontName: 'ComicBold' bgColor: Color white centerColor: Color black) openInWorldStructure:	fontName		String -- the labels' font name	cColor			Color -- center color	handsColor		Color	romanNumerals	Boolean!!WatchMorph methodsFor: 'initialization' stamp: 'jm 6/1/2003 05:32'!extent: newExtent	super extent: newExtent.	self createLabels.! !!WatchMorph methodsFor: 'initialization' stamp: 'jm 6/1/2003 05:39'!initialize	super initialize.	self color: Color green.	self centerColor: Color gray.	self handsColor: Color red.	fontName _ 'NewYork'.	romanNumerals _ false.	self extent: 130@130.! !!WatchMorph methodsFor: 'accessing' stamp: 'jm 6/1/2003 05:44'!centerColor: aColor	cColor _ aColor.	self changed.! !!WatchMorph methodsFor: 'accessing' stamp: 'jm 6/1/2003 05:51'!fontName: aString	fontName _ aString.	self createLabels.! !!WatchMorph methodsFor: 'accessing' stamp: 'jm 6/1/2003 05:52'!handsColor: aColor	handsColor _ aColor.	self changed.! !!WatchMorph methodsFor: 'drawing' stamp: 'jm 6/1/2003 05:47'!drawOn: aCanvas	| pHour pMin pSec time |	time _ Time now.	pHour _ self radius: 0.6 hourAngle: time hours + (time minutes / 60.0).	pMin _ self radius: 0.72 hourAngle: (time minutes / 5.0).	pSec _ self radius: 0.8 hourAngle: (time seconds / 5.0).	time hours < 12		ifTrue: [self centerColor: Color veryLightGray]		ifFalse: [self centerColor: Color darkGray].	super drawOn: aCanvas.	aCanvas		fillOval: (bounds insetBy: self extent*0.35) color: cColor;		line: self center to: pHour width: 3 color: handsColor;		line: self center to: pMin width: 2 color: handsColor;		line: self center to: pSec width: 1 color: handsColor.! !!WatchMorph methodsFor: 'menus' stamp: 'jm 6/1/2003 05:47'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand."	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'change font...' action: #changeFont.	romanNumerals		ifTrue: [aCustomMenu add: 'use latin numerals' action: #toggleRoman]		ifFalse: [aCustomMenu add: 'use roman numerals' action: #toggleRoman].	aCustomMenu add: 'change hands color...' action: #changeHandsColor.! !!WatchMorph methodsFor: 'menus' stamp: 'jm 6/1/2003 05:50'!changeFont	"Let the user change the font."	| newFontName |	newFontName _		(SelectionMenu			labelList: StrikeFont familyNames			selections: StrikeFont familyNames) startUp.	newFontName ifNil: [^ self].	self fontName: newFontName.! !!WatchMorph methodsFor: 'menus' stamp: 'jm 6/1/2003 05:36'!changeHandsColor	"Let the user change the color of the hands of the watch."	ColorPickerMorph new		sourceHand: self activeHand;		target: self;		selector: #handsColor:;		originalColor: self color;		addToWorld: self world near: self fullBounds.! !!WatchMorph methodsFor: 'menus' stamp: 'jm 6/1/2003 05:36'!toggleRoman	romanNumerals _ romanNumerals not.	self createLabels.! !!WatchMorph methodsFor: 'private' stamp: 'jm 6/1/2003 05:53'!createLabels	"Add hour labels."	| numeral font h r |	self removeAllMorphs.	font _ StrikeFont familyName: fontName size: (h _ self height min: self width) // 8.	r _ 1.0 - (1.4 * font height / h).	1 to: 12 do: [:hour |		numeral _ romanNumerals			ifTrue: [hour romanString]			ifFalse: [hour asString].		self addMorphBack: ((StringMorph contents: numeral font: font emphasis: 1)			center: (self radius: r hourAngle: hour)) lock].! !!WatchMorph methodsFor: 'private' stamp: 'jm 6/1/2003 05:35'!radius: unitRadius hourAngle: hourAngle	"unitRadius goes from 0.0 at the center to 1.0 on the circumference. hourAngle runs from 0.0 clockwise around to 12.0 with wrapping."	^ self center + (self extent * (Point r: 0.5 * unitRadius									degrees: hourAngle * 30.0 - 90.0)).! !!WatchMorph methodsFor: 'stepping' stamp: 'jm 6/1/2003 05:35'!step	self changed.! !!WatchMorph class methodsFor: 'instance creation' stamp: 'jm 6/1/2003 05:55'!fontName: aString	^ self fontName: aString bgColor: nil centerColor: nil! !!WatchMorph class methodsFor: 'instance creation' stamp: 'jm 6/1/2003 05:54'!fontName: aString bgColor: aColor centerColor: otherColor	^ self new		fontName: aString;		color: aColor;		centerColor: otherColor! !!WatchMorph class methodsFor: 'instance creation' stamp: 'jm 6/1/2003 05:55'!includeInNewMorphMenu	^ true! !I am a Scratch variable readout/editor. I can view both writable or read-only variables, and both user variables and built-in Scratch object variables. The underlying mechanism is based on a pair of selectors to read and (optionally) change the value, so a watched 'variable' may be dynamically computed, rather than an actual instance variable.I am used in several different contexts:  o in Scratch viewers, to view the state of variables  o in the work area, to watch a variable even when that object's viewer is not showing  o in scripts, as command block argumentsI change my layout and appearance to fit the context. For example, when I am used as an argument, I don't display the variable's value.!!WatcherMorph methodsFor: 'initialization' stamp: 'jm 8/24/2003 23:34'!buildMorphs	"Build my component morphs."	titleMorph _ StringMorph contents: '???'.	readoutFrame _ AlignmentMorph new		orientation: #vertical;		centering: #bottomRight;		hResizing: #rigid;		vResizing: #rigid;		extent: 40@20; "was 100@20"		color: ReadoutColor;		borderWidth: 1;		borderColor: #inset.	readout _ UpdatingStringMorph new		floatPrecision: 0.01;		stepTime: 100.	readoutFrame addMorph: readout.! !!WatcherMorph methodsFor: 'initialization' stamp: 'jm 8/24/2003 23:34'!initialize	super initialize.	watcher _ AlignmentMorph new		color: BaseColor;		borderWidth: 1;		borderColor: BorderColor;		inset: 2;		orientation: #horizontal;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		centering: #center.	self 		color: Color transparent;		orientation: #vertical;		centering: #center;		buildMorphs;		inset: 0;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		addMorphBack: watcher.	scratchSlider _ nil.! !!WatcherMorph methodsFor: 'initialization' stamp: 'jm 3/17/2003 16:29'!target: anObject getSelector: getSel	"Create a read-only watcher for a builtin variable. This can be made into a read/write watcher using the putSelector: message."	self target: anObject getSelector: getSel varName: nil.! !!WatcherMorph methodsFor: 'initialization' stamp: 'jm 3/17/2003 16:32'!target: anObject getSelector: getSel varName: varName	"Create a read-only watcher. This can be made into a read/write watcher using the putSelector: message. If varName is not nil, then it is supplied as a parmeter to the Scratch getVar:/setVar:to: messages, which are used to access user-defined variables."	readout		target: anObject;		getSelector: getSel asSymbol;		parameter: varName.	self layoutForViewer.! !!WatcherMorph methodsFor: 'accessing' stamp: 'DaveF 7/14/2003 16:25'!evaluate	"Answer the value of my variable."	^ readout valueFromTargetOrNil! !!WatcherMorph methodsFor: 'accessing' stamp: 'jm 3/17/2003 15:48'!isReporter	^ true! !!WatcherMorph methodsFor: 'accessing' stamp: 'jm 3/17/2003 15:34'!putSelector: aSymbol	readout putSelector: aSymbol asSymbol.! !!WatcherMorph methodsFor: 'accessing' stamp: 'jm 12/12/2003 13:46'!target: anObject	readout target: anObject.! !!WatcherMorph methodsFor: 'dropping/grabbing' stamp: 'jm 8/24/2003 18:00'!aboutToBeGrabbedBy: aHandMorph	"If I'm being used as an argument, replace myself with an appropriate argument morph."	| m |	(owner isKindOf: CommandBlockMorph) ifTrue: [		"if I was being used as argument, replace myself with a generic argument morph"		m _ owner argMorphToReplace: self.		m ifNotNil: [owner replaceArgMorph: self by: m]].! !!WatcherMorph methodsFor: 'dropping/grabbing' stamp: 'jm 8/24/2003 23:47'!justDroppedInto: aMorph event: anEvent		super justDroppedInto: aMorph event: anEvent.	(owner isKindOf: BlockMorph) ifTrue: [		self hideSlider.		self layoutAsArgument].	(owner isKindOf: ScratchScriptsMorph) ifTrue: [		self hideSlider].	(owner isKindOf: ScratchWorkPaneMorph) ifTrue: [		self layoutForViewer.		(readout target minFor: self getVariable) isNumber ifTrue: [			self showSlider]].	self updateTargetName.! !!WatcherMorph methodsFor: 'dropping/grabbing' stamp: 'TIS 7/9/2003 10:47'!rootForGrabOf: aMorph	"Allow myself to be extracted."	(owner notNil and: [owner isPartsBin])		ifTrue: [^ super rootForGrabOf: aMorph]		ifFalse: [^ self].! !!WatcherMorph methodsFor: 'stepping' stamp: 'jm 8/24/2003 23:35'!step	self updateTargetName.! !!WatcherMorph methodsFor: 'stepping' stamp: 'jm 8/24/2003 23:34'!stepTime	^ 100! !!WatcherMorph methodsFor: 'right button menu'!handlesMouseDown: evt	^ evt yellowButtonPressed! !!WatcherMorph methodsFor: 'right button menu' stamp: 'jm 8/24/2003 23:09'!hideSlider	self position: watcher position.	scratchSlider ifNotNil: [scratchSlider delete].	scratchSlider _ nil.	self layoutForViewer.! !!WatcherMorph methodsFor: 'right button menu' stamp: 'jm 11/25/2003 12:36'!makeSetter	| varSetter |	varSetter _ SetterBlockMorph new		variable: self getVariable;		receiver: readout target;		position: self position.	self owner addMorphBack: varSetter.	varSetter world startSteppingSubmorphsOf: varSetter.	self delete.! !!WatcherMorph methodsFor: 'right button menu' stamp: 'jm 11/25/2003 13:58'!mouseDown: evt	| menu |	((owner isKindOf: CommandBlockMorph) or:	 [self suppressReceiver]) ifTrue: [^ self].	menu _ CustomMenu new. 	((readout target userVars includes: self getVariable) or: 	 [(readout target minFor: self getVariable) ~= #nil]) ifTrue: [		(self owner isKindOf: ScratchScriptsMorph)			ifTrue: [				menu add: 'make setter' action: #makeSetter]			ifFalse: [				scratchSlider					ifNil: [menu add: 'show slider' action: #showSlider]					ifNotNil: [menu add: 'hide slider' action: #hideSlider]].		menu addLine]. 	menu add: 'delete' action: #delete.	menu invokeOn: self.! !!WatcherMorph methodsFor: 'right button menu' stamp: 'TIS 9/28/2003 12:29'!showSlider	| object var p |	scratchSlider ifNotNil: [^ self].  "slider is already showing"	p _ watcher position.	object _ readout target.	var _ self getVariable.	scratchSlider _ (ScratchSliderMorph new			target: object;			variable: var).	(object builtinVars includes: var) ifTrue: [		scratchSlider slider minVal: (object minFor: var).		scratchSlider slider maxVal: (object maxFor: var)].	scratchSlider updateActionSelector.	self addMorphBack: scratchSlider.	scratchSlider world startSteppingSubmorphsOf: scratchSlider.	scratchSlider fullBounds.	self fullBounds.	self position: p - ((watcher left - scratchSlider left) @ 0).! !!WatcherMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:27'!fieldsVersion	^ 1! !!WatcherMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:34'!initFieldsFrom: anObjStream version: classVersion	super initFieldsFrom: anObjStream version: classVersion.	self initFieldsNamed: #(		titleMorph		readout		readoutFrame		scratchSlider		watcher	) from: anObjStream.! !!WatcherMorph methodsFor: 'object i/o' stamp: 'jm 9/24/2003 19:36'!storeFieldsOn: anObjStream	super storeFieldsOn: anObjStream.	self storeFieldsNamed: #(		titleMorph		readout		readoutFrame		scratchSlider		watcher	) on: anObjStream.! !!WatcherMorph methodsFor: 'private' stamp: 'tis 6/27/2003 10:47'!findHatBlock	"I return the script hat of my receiver, or nil if my receiver is not attached to a hat block."	(self isKindOf: HatBlockMorph)		ifTrue: [^ self]		ifFalse: [(self owner isKindOf: BlockMorph) 			ifTrue: [^ self owner findHatBlock]			ifFalse: [^ nil]]! !!WatcherMorph methodsFor: 'private' stamp: 'jm 11/5/2003 09:48'!findScratchEditor	"Answer the scratch editor of my receiver or nil if my receiver is not in a scratch editor."	| m |	m _ self.	[m isKindOf: ScratchScriptEditorMorph] whileFalse: [		m owner ifNil: [^ nil].		m _ m owner].	^ m! !!WatcherMorph methodsFor: 'private' stamp: 'TIS 7/11/2003 10:11'!getVariable	readout parameter notNil		ifTrue: [^ readout parameter]		ifFalse: [^ readout getSelector]! !!WatcherMorph methodsFor: 'private' stamp: 'jm 11/5/2003 10:13'!hasContext	"If I have context, I don't want my receiver displayed."	| e h |	self suppressReceiver ifTrue: [^ true].	(e _ self findScratchEditor) ifNotNil: [^ e thumbnail target == readout target].	(h _ self findHatBlock) ifNotNil: [^ h scriptOwner == readout target].	^ false! !!WatcherMorph methodsFor: 'private' stamp: 'jm 8/24/2003 23:23'!layoutAsArgument	watcher		removeAllMorphs;		addMorphBack: (Morph new color: color; extent: 4);		addMorphBack: titleMorph;		addMorphBack: (Morph new color: color; extent: 3).! !!WatcherMorph methodsFor: 'private' stamp: 'jm 8/24/2003 23:15'!layoutForViewer	watcher		removeAllMorphs;		addMorphBack: (Morph new color: color; extent: 4);		addMorphBack: titleMorph;		addMorphBack: (AlignmentMorph new color: color; width: 5; hResizing: #rigid);		addMorphBack: readoutFrame;		addMorphBack: (Morph new color: color; extent: 3).! !!WatcherMorph methodsFor: 'private' stamp: 'jm 11/5/2003 10:07'!suppressReceiver	"Answer true if the receiver of this watcher should be suppressed in the current viewer or editor."	| m |	m _ owner.	[m notNil] whileTrue: [		(m isKindOf: ScratchViewerMorph) ifTrue: [^ true].		((m isKindOf: ScratchScriptEditorMorph) and:		 [m suppressBlockReceivers])			ifTrue: [^ true].		m _ m owner].	^ false! !!WatcherMorph methodsFor: 'private' stamp: 'jm 8/24/2003 23:22'!updateTargetName	"Check if I should display my target's name."	| showTargetName targetName varName |	(self ownerThatIsA: HandMorph) ifNotNil: [^ self].  "do nothing when in a HandMorph"		showTargetName _ self hasContext not.	targetName _ readout target objName.	(targetNameShowing = showTargetName and: [lastTargetName = targetName])		ifTrue: [^ self].  "no change"	readout parameter		ifNil: [varName _ readout getSelector]		ifNotNil: [varName _ readout parameter].	showTargetName		ifTrue: [titleMorph contents: targetName, '''s ', varName]		ifFalse: [titleMorph contents: varName].	targetNameShowing _ showTargetName.	lastTargetName _ targetName.! !!WatcherMorph class methodsFor: 'class initialization' stamp: 'jm 1/8/2003 21:51'!initialize	BaseColor _ Color r: 0.4 g: 1.0 b: 0.4.	BorderColor _ Color r: 0 g: 0.65 b: 0.	ReadoutColor _ Color r: 0.7 g: 1.0 b: 0.7.! !This tool was created to aid in the preparation of LoopedSampledSound objects. It includes support for finding good loop points with a little help from the user.  Namely, the user must identify a good ending point for the loop (typically just before the decay phase begins) and identify one cycle of the waveform. After that, the  "choose loop point" menu command can be invoked to search backwards to find and rank all possible loop starting points. Some experimentation is usually required to find a loop that "breaths" in a natural way.This tool can also be used as a general viewer of numerical sequences of any kind, such as time-varying functions, FFT data, etc.!!WaveEditor methodsFor: 'initialization' stamp: 'jm 6/15/2003 20:32'!addControls	| slider b r m |	b _ SimpleButtonMorph new target: self; borderColor: Color black; useSquareCorners.	r _ AlignmentMorph newRow.	r color: b color; borderWidth: 0; inset: 0.	r hResizing: #shrinkWrap; vResizing: #shrinkWrap; extent: 5@5.	r centering: #topLeft.	r addMorphBack: (b fullCopy label: 'X';					actionSelector: #delete).	r addMorphBack: (b fullCopy label: 'Menu'; actWhen: #buttonDown;															actionSelector: #invokeMenu).	r addMorphBack: (b fullCopy label: 'Play';				actionSelector: #play).	r addMorphBack: (b fullCopy label: 'Play Before';		actionSelector: #playBeforeCursor).	r addMorphBack: (b fullCopy label: 'Play After';			actionSelector: #playAfterCursor).	r addMorphBack: (b fullCopy label: 'Play Loop';			actionSelector: #playLoop).	r addMorphBack: (b fullCopy label: 'Test';				actionSelector: #playTestNote).	r addMorphBack: (b fullCopy label: 'Save';				actionSelector: #saveInstrument).	r addMorphBack: (b fullCopy label: 'Set Loop End';		actionSelector: #setLoopEnd).	r addMorphBack: (b fullCopy label: 'One Cycle';			actionSelector: #setOneCycle).	r addMorphBack: (b fullCopy label: 'Set Loop Start';		actionSelector: #setLoopStart).	self addMorphBack: r.	r _ AlignmentMorph newRow.	r color: self color; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #rigid; extent: 5@20; centering: #center.	m _ StringMorph new contents: 'Index: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #cursor; putSelector: #cursor:;		growable: false; width: 71; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Value: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #valueAtCursor; putSelector: #valueAtCursor:;		growable: false; width: 50; step.	r addMorphBack: m.	slider _ SimpleSliderMorph new		color: color;		extent: 200@2;		target: self;		actionSelector: #scrollTime:.	r addMorphBack: slider.	m _ Morph new color: r color; extent: 10@5.  "spacer"	r addMorphBack: m.	m _ UpdatingStringMorph new		target: graph; getSelector: #startIndex; putSelector: #startIndex:;		width: 40; step.	r addMorphBack: m.	self addMorphBack: r.! !!WaveEditor methodsFor: 'initialization' stamp: 'jm 8/17/1998 20:31'!addLoopPointControls	| r m |	r _ AlignmentMorph newRow.	r color: self color; borderWidth: 0; inset: 0.	r hResizing: #spaceFill; vResizing: #rigid; extent: 5@20; centering: #center.	m _ StringMorph new contents: 'Loop end: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #loopEnd; putSelector: #loopEnd:;		growable: false; width: 50; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Loop length: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #loopLength; putSelector: #loopLength:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Loop cycles: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #loopCycles; putSelector: #loopCycles:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	m _ StringMorph new contents: 'Frequency: '.	r addMorphBack: m.	m _ UpdatingStringMorph new		target: self; getSelector: #perceivedFrequency; putSelector: #perceivedFrequency:;		floatPrecision: 0.001;		growable: false; width: 50; step.	r addMorphBack: m.	self addMorphBack: r.! !!WaveEditor methodsFor: 'initialization' stamp: 'jm 6/15/2003 20:08'!initialize	super initialize.	samplingRate _ SoundPlayer samplingRate.	loopEnd _ loopLength _ 0.	loopCycles _ 1.	perceivedFrequency _ 0.  "zero means unknown"	self extent: 5@5;		orientation: #vertical;		centering: #topLeft;		hResizing: #shrinkWrap;		vResizing: #shrinkWrap;		inset: 3;		color: Color lightGray;		borderWidth: 2.	graph _ GraphMorph new extent: 450@200.	graph cursor: 0.	graph cursorColorAtZeroCrossings: Color blue.	self addControls.	self addLoopPointControls.	self addMorphBack: graph.	self addMorphBack: (Morph newBounds: (0@0 extent: 0@3) color: Color transparent).	self addMorphBack: (keyboard _ PianoKeyboardMorph new).! !!WaveEditor methodsFor: 'menu' stamp: 'di 6/22/1999 08:46'!chooseLoopStart 	| bestLoops menu secs choice start |	possibleLoopStarts ifNil: [		Utilities			informUser: 'Finding possible loop points...'			during: [possibleLoopStarts _ self findPossibleLoopStartsFrom: graph cursor]].	bestLoops _ possibleLoopStarts copyFrom: 1 to: (100 min: possibleLoopStarts size).	menu _ CustomMenu new.	bestLoops do: [:entry |		secs _ ((loopEnd - entry first) asFloat / self samplingRate) roundTo: 0.01.		menu add: entry third printString, ' cycles; ', secs printString, ' secs' action: entry].	choice _ menu startUp.	choice ifNil: [^ self].	loopCycles _ choice at: 3.	start _ self fractionalLoopStartAt: choice first.	self loopLength: (loopEnd asFloat - start) + 1.0.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/15/2003 22:52'!deleteInstrument	| sampledSoundNames menu soundToDelete |	sampledSoundNames _ AbstractSound soundNames		select: [:n | (AbstractSound soundNamed: n) isKindOf: LoopedSampledSound].	menu _ CustomMenu new title: 'Sound to delete:'.	sampledSoundNames do: [:n | menu add: n action: n].	soundToDelete _ menu startUp.	soundToDelete ifNotNil: [AbstractSound sounds removeKey: soundToDelete].! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/15/2003 22:12'!invokeMenu	"Invoke a menu of additonal functions for this WaveEditor."	| aMenu |	aMenu _ CustomMenu new.	aMenu addList:	#(		('play all'					play)		('play before cursor'		playBeforeCursor)		('play after cursor'			playAfterCursor)		('play test note'				playTestNote)		('play loop'					playLoop)		-		('trim before cursor'		trimBeforeCursor)		('trim after cursor'			trimAfterCursor)		-		('choose loop start'			chooseLoopStart)		('jump to loop start'			jumpToLoopStart)		('jump to loop end'			jumpToLoopEnd)		-		('make unlooped'			setUnlooped)		('make unpitched'			setUnpitched)		-		('show envelope'			showEnvelope)		('show FFT'					showFFTAtCursor)		-		('add to instrument library'	saveInstrument)		('delete instrument'			deleteInstrument)		-		('save to file'				saveToFile)		('read from file'			readFromFile)).	aMenu invokeOn: self defaultSelection: nil.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/3/1998 12:42'!jumpToLoopEnd	graph cursor: loopEnd; centerCursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 10:09'!jumpToLoopStart	graph cursor: (loopEnd - loopLength) truncated; centerCursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/21/1999 22:11'!makeLoopedSampledSound	| data end snd basePitch |	data _ graph data.	((loopEnd = 0) or: [loopLength = 0])		ifTrue: [  "save as unlooped"			perceivedFrequency = 0				ifTrue: [basePitch _ 100.0]				ifFalse: [basePitch _ perceivedFrequency].			snd _ LoopedSampledSound new				unloopedSamples: data pitch: basePitch samplingRate: samplingRate]		ifFalse: [			end _ (loopEnd min: data size) max: 1.			basePitch _ (samplingRate * loopCycles) / loopLength.			snd _ LoopedSampledSound new				samples: data loopEnd: end loopLength: loopLength				pitch: basePitch samplingRate: samplingRate].	snd addReleaseEnvelope.	^ snd! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/9/1998 09:23'!play	graph data size < 2 ifTrue: [^ self].	(SampledSound samples: graph data samplingRate: samplingRate) play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:40'!playAfterCursor	self playFrom: graph cursor to: graph data size.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:39'!playBeforeCursor	self playFrom: 1 to: graph cursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:02'!playFrom: start to: end	| sz i1 i2 snd |	sz _ graph data size.	i1 _ ((start + 1) min: sz) max: 1.	i2 _ ((end + 1) min: sz) max: i1.	(i1 + 2) >= i2 ifTrue: [^ self].	snd _ SampledSound		samples: (graph data copyFrom: i1 to: i2)		samplingRate: samplingRate.	snd play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 11:39'!playLoop	| sz i1 i2 snd len |	sz _ graph data size.	i1 _ ((loopEnd - loopLength) truncated min: sz) max: 1.	i2 _ (loopEnd min: sz) max: i1.	len _ (i2 - i1) + 1.	len < 2 ifTrue: [^ self].	snd _ LoopedSampledSound new		samples: (graph data copyFrom: i1 to: i2)		loopEnd: len		loopLength: loopLength		pitch: 100.0		samplingRate: samplingRate.	"sustain for the longer of four loops or two seconds"	snd setPitch: 100.0		dur: (((4.0 * loopLength) / samplingRate) max: 2.0)		loudness: 0.5.	snd play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/17/1998 11:38'!playTestNote	| data end snd loopDur dur |	(loopEnd = 0 or: [loopLength = 0]) ifTrue: [^ self].	data _ graph data.	end _ (loopEnd min: data size) max: 1.	snd _ LoopedSampledSound new		samples: data loopEnd: end loopLength: loopLength		pitch: 100.0 samplingRate: samplingRate.	loopDur _ (4.0 * loopLength / samplingRate) max: 2.0.  "longer of 4 loops or 2 seconds"	dur _ (data size / samplingRate) + loopDur.	(snd		addReleaseEnvelope;		setPitch: 100.0 dur: dur loudness: 0.5) play.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 12/4/2003 20:19'!readFromFile	"Read my samples from an image file."	| result fullName snd |	result _ StandardFileMenu  oldFileExtensions: #(aif aiff au wav).	result ifNil: [^ self].	fullName _ result directory pathName, FileDirectory slash, result name.	snd _ SampledSound fromFileNamed: fullName.	samplingRate _ snd originalSamplingRate.	graph data: snd samples.	loopEnd _ loopLength _ 0.	loopCycles _ 1.	perceivedFrequency _ 0.  "zero means unknown"! !!WaveEditor methodsFor: 'menu' stamp: 'di 6/21/1999 17:58'!saveInstrument	| name |	name _ FillInTheBlank request: 'Instrument name?'.	name isEmpty ifTrue: [^ self].	AbstractSound soundNamed: name put: self makeLoopedSampledSound.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/23/2003 16:25'!saveToFile	"Read my samples from an image file."	| fileName samples f |	fileName _ FillInTheBlank request: 'File name?'.	fileName ifNil: [^ self].	(fileName asLowercase endsWith: '.aif') ifFalse: [fileName _ fileName, '.aif'].	(graph data isKindOf: SoundBuffer)		ifTrue: [samples _ graph data]		ifFalse: [samples _ SoundBuffer fromArray: graph data].	f _ (FileStream newFileNamed: fileName) binary.	(SampledSound samples: samples samplingRate: samplingRate) storeAIFFSamplesOn: f.	f close.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/31/1998 11:06'!setLoopEnd	graph cursor: (self zeroCrossingAfter: graph cursor) - 1.	self loopEnd: graph cursor.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 7/9/1998 08:21'!setLoopStart	"Assuming that the loop end and approximate frequency have been set, this method uses the current cursor position to determine the loop length and the number of cycles."	| start len |	start _ graph cursor.	((start >= loopEnd) or: [perceivedFrequency = 0]) ifTrue: [		^ self inform:'Please set the loop end and the approximate frequencyfirst, then position the cursor one or more cyclesbefore the loop end and try this again.'].	len _ (loopEnd - start) + 1.	loopCycles _ (len / (samplingRate / perceivedFrequency)) rounded.	self loopLength: len.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setOneCycle	"Set the approximate frequency based on a single cycle specified by the user. To use this, first set the loop end, then place the cursor one full cycle before the loop end and invoke this method."	| len |	len _ loopEnd - graph cursor.	len > 0 ifTrue: [		loopCycles _ 1.		self loopLength: len].! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setUnlooped	"Make this sound play straight through without looping."	loopLength _ 0.	loopCycles _ 1.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 8/1/1998 11:05'!setUnpitched	"Make this instrument be unpitched and unlooped. Suitable for percussive sounds that should not be pitch-shifted when played. By convention, such sounds are played at a pitch of 100.0 to obtain their original pitch."	loopLength _ 0.	loopCycles _ 0.	perceivedFrequency _ 100.0.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/15/2003 20:06'!showEnvelope	"Show an envelope wave constructed by collecting the maximum absolute value of the samples in fixed-size time windows of mSecsPerQuantum."	| data mSecsPerQuantum samplesPerQuantum result endOfQuantum maxThisQuantum s nSamples |	data _ graph data.	mSecsPerQuantum _ 8.	samplesPerQuantum _ (mSecsPerQuantum / 1000.0) * self samplingRate.	result _ WriteStream on: (Array new: data size // samplesPerQuantum).	endOfQuantum _ samplesPerQuantum.	maxThisQuantum _ 0.	nSamples _ (data isKindOf: SoundBuffer)		ifTrue: [data monoSampleCount]		ifFalse: [data size].	1 to: nSamples do: [:i |		i asFloat > endOfQuantum ifTrue: [			result nextPut: maxThisQuantum.			maxThisQuantum _ 0.			endOfQuantum _ endOfQuantum + samplesPerQuantum].		s _ data at: i.		s < 0 ifTrue: [s _ 0 - s].		s > maxThisQuantum ifTrue: [maxThisQuantum _ s]].	(SimpleWaveEditor openOn: result contents) hideKeyboard.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/15/2003 20:16'!showFFTAtCursor	| data start availableSamples nu n fft r |	data _ graph data.	start _ graph cursor max: 1.	availableSamples _ (data size - start) + 1.	nu _ 12.	nu > (availableSamples highBit - 1) ifTrue:		[^ self inform: 'Too few samples after the cursor to take an FFT.'].	n _ 2 raisedTo: nu.	fft _ FFT new nu: nu.	fft realData: ((start to: start + n - 1) collect: [:i | data at: i]).	fft transformForward: true.	r _ (1 to: n // 2) collect:		[:i | ((fft realData at: i) squared + (fft imagData at: i) squared) sqrt].	(SimpleWaveEditor openOn: r) hideKeyboard.! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:48'!trimAfterCursor	graph data: (graph data copyFrom: 1 to: graph cursor).! !!WaveEditor methodsFor: 'menu' stamp: 'jm 6/30/1998 17:52'!trimBeforeCursor	graph data: (graph data copyFrom: graph cursor to: graph data size).	graph cursor: 1.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/5/1998 12:43'!data: newData	graph data: newData.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/3/2004 18:16'!graph	^ graph! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/7/1998 09:48'!loopCycles	^ loopCycles! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/8/1998 20:21'!loopCycles: aNumber	loopCycles _ aNumber.	self loopLength: loopLength.  "updates frequency"! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 6/30/1998 17:20'!loopEnd	^ loopEnd! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/31/1998 14:01'!loopEnd: aNumber	loopEnd _ (aNumber asInteger max: 1) min: graph data size.	possibleLoopStarts _ nil.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/7/1998 08:38'!loopLength	^ loopLength! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/8/1998 21:03'!loopLength: aNumber	loopLength _ aNumber.	((loopCycles > 0) and: [loopLength > 0]) ifTrue: [		perceivedFrequency _ samplingRate asFloat * loopCycles / loopLength].! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 10:08'!loopStart	^ (loopEnd - loopLength) truncated + 1! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:46'!loopStart: index	| start len |	start _ self fractionalLoopStartAt: index.	len _ (loopEnd asFloat - start) + 1.0.	loopCycles _ (len / (samplingRate / perceivedFrequency)) rounded.	self loopLength: len.! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:31'!perceivedFrequency	^ perceivedFrequency! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 8/17/1998 20:32'!perceivedFrequency: aNumber	perceivedFrequency _ aNumber.	(loopCycles > 0) ifTrue: [		loopLength _ samplingRate asFloat * loopCycles / perceivedFrequency].! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/4/1998 10:44'!samplingRate	^ samplingRate! !!WaveEditor methodsFor: 'accessing' stamp: 'jm 7/4/1998 10:44'!samplingRate: samplesPerSecond	samplingRate _ samplesPerSecond.! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/30/1998 18:51'!autoCorrolationBetween: index1 and: index2 length: length	"Answer the cummulative error between the portions of my waveform starting at the given two indices and extending for the given length. The larger this error, the greater the difference between the two waveforms."	| data error i1 e |	data _ graph data.	error _ 0.	i1 _ index1.	index2 to: (index2 + length - 1) do: [:i2 |		e _ (data at: i1) - (data at: i2).		e < 0 ifTrue: [e _ 0 - e].		error _ error + e.		i1 _ i1 + 1].	^ error! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/28/1998 02:29'!errorBetween: sampleArray1 and: sampleArray2	"Answer the cummulative error between the two sample arrays, which are assumed to be the same size."	| error e |	error _ 0.	1 to: sampleArray1 size do: [:i |		e _ (sampleArray1 at: i) - (sampleArray2 at: i).		e < 0 ifTrue: [e _ 0 - e].		error _ error + e].	^ error! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/17/1998 11:25'!findPossibleLoopStartsFrom: index	"Assume loopEnd is one sample before a zero-crossing."	| r postLoopCycleStart i postLoopCycleLength cycleLength cycleCount err oldI |	r _ OrderedCollection new.	"Record the start and length of the first cycle after the loop endpoint."	postLoopCycleStart _ loopEnd + 1.  "Assumed to be a zero-crossing."	i _ self zeroCrossingAfter: postLoopCycleStart + (0.9 * samplingRate / perceivedFrequency) asInteger.	postLoopCycleLength _ i - loopEnd - 1.	"Step backwards one cycle at a time, using zero-crossings to find the	 beginning of each cycle, and record the auto-corrolation error between	 each cycle and the cycle following the loop endpoint. Assume pitch may shift gradually."	i _ self zeroCrossingAfter: postLoopCycleStart - (1.1 * postLoopCycleLength) asInteger.	cycleLength _ postLoopCycleStart - i.	cycleCount _ 1.	[cycleLength > 0] whileTrue: [		err _ self autoCorrolationBetween: i and: postLoopCycleStart length: postLoopCycleLength.		r add: (Array				with: i				with: err				with: cycleCount				with: (((loopEnd - i) asFloat / self samplingRate) roundTo: 0.01)).		oldI _ i.		i _ self zeroCrossingAfter: oldI - (1.1 * cycleLength) asInteger.		cycleLength _ oldI - i.  "will be zero when start of data is encountered"		cycleCount _ cycleCount + 1].	r _ r asSortedCollection: [:e1 :e2 | (e1 at: 2) < (e2 at: 2)].	^ r asArray! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/17/1998 11:27'!fractionalLoopStartAt: index	"Answer the fractional index starting point near the given integral index that results in the closest match with the cycle following the loop end."	"Note: could do this more efficiently by sliding downhill on the error curve to find lowest error."	| oneCycle w1 minErr w2 err bestIndex |	oneCycle _ (samplingRate / perceivedFrequency) rounded.	w1 _ self interpolatedWindowAt: loopEnd + 1 width: oneCycle.	minErr _ SmallInteger maxVal.	((index - 2) max: 1) to: ((index + 2) min: graph data size) by: 0.01 do: [:i |		w2 _ self interpolatedWindowAt: i width: oneCycle.		err _ self errorBetween: w1 and: w2.		err < minErr ifTrue: [			bestIndex _ i.			minErr _ err]].	^ bestIndex! !!WaveEditor methodsFor: 'other' stamp: 'jm 6/15/2003 20:06'!hideKeyboard	keyboard delete.! !!WaveEditor methodsFor: 'other' stamp: 'jm 7/31/1998 11:54'!interpolatedWindowAt: index width: nSamples	"Return an array of N samples starting at the given index in my data."	| scale data baseIndex scaledFrac scaledOneMinusFrac prevSample nextSample v |	scale _ 10000.	data _ graph data.	index isInteger		ifTrue: [^ (index to: index + nSamples - 1) collect: [:i | data at: i]].	baseIndex _ index truncated.	scaledFrac _ ((index asFloat - baseIndex) * scale) truncated.	scaledOneMinusFrac _ scale - scaledFrac.	prevSample _ data at: baseIndex.	^ (baseIndex + 1 to: baseIndex + nSamples) collect: [:i |		nextSample _ data at: i.		v _ ((nextSample * scaledFrac) + (prevSample * scaledOneMinusFrac)) // scale.		prevSample _ nextSample.		v].! !!WaveEditor methodsFor: 'other' stamp: 'jm 9/19/1998 15:03'!normalize: sampleArray	"Return a copy of the given sample array scaled to use the maximum 16-bit sample range. Remove any D.C. offset."	| max abs scale out |	max _ 0.	sampleArray do: [:s |		s > 0 ifTrue: [abs _ s] ifFalse: [abs _ 0 - s].		abs > max ifTrue: [max _ abs]].	scale _ ((1 << 15) - 1) asFloat / max.	out _ sampleArray species new: sampleArray size.	1 to: sampleArray size do: [:i |		out at: i put: (scale * (sampleArray at: i)) truncated].	^ out! !!WaveEditor methodsFor: 'other' stamp: 'jm 6/15/2003 20:15'!scrollTime: relativeValue	graph startIndex: relativeValue * (graph data size - (graph width // 2)).	graph changed.! !!WaveEditor methodsFor: 'other' stamp: 'di 6/21/1999 17:59'!step	keyboard soundPrototype: self makeLoopedSampledSound! !!WaveEditor methodsFor: 'other' stamp: 'jm 9/20/1998 09:13'!stretch: sampleArray by: stretchFactor	"Return an array consisting of the given samples \stretched in time by the given factor."	| out end incr i frac index |	out _ OrderedCollection new: (stretchFactor * sampleArray size) asInteger + 1.	end _ (sampleArray size - 1) asFloat.	incr _ 1.0 / stretchFactor.	i _ 1.0.	[i < end] whileTrue: [		frac _ i fractionPart.		index _ i truncated.		i _ i + incr.		out addLast:			(((1.0 - frac) * (sampleArray at: index)) + (frac * (sampleArray at: index + 1))) rounded].	^ out asArray! !!WaveEditor methodsFor: 'other' stamp: 'jm 8/10/1998 15:08'!zeroCrossingAfter: index	"Find the index of the next negative-to-non-negative transition at or after the current index. The result is the index, i, of a zero crossing such that the sample at i-1 is negative and the sample at i is zero or positive. Answer the index of the last sample if the end of the array is encountered before finding a zero crossing."	| data end i |	data _ graph data.	end _ data size.	index <= 1 ifTrue: [^ 1].	i _ index - 1.	[(i <= end) and: [(data at: i) >= 0]] whileTrue: [i _ i + 1].  "find next negative sample"	i >= end ifTrue: [^ end].	i _ i + 1.	[(i <= end) and: [(data at: i) < 0]] whileTrue: [i _ i + 1].  "find next non-negative sample"	^ i! !!WaveEditor class methodsFor: 'instance creation' stamp: 'jm 9/6/1999 11:21'!openOn: dataCollection	"Open a new WaveEditor on the given sequencable collection of data."	^ (self new data: dataCollection) openInWorld! !WeakArray is an array which holds only weakly on its elements. This means whenever an object is only referenced by instances of WeakArray it will be garbage collected.!!WeakArray class methodsFor: 'class initialization' stamp: 'ar 10/7/1998 16:45'!initialize	"WeakArray initialize"	"Do we need to initialize specialObjectsArray?"	Smalltalk specialObjectsArray size < 42 		ifTrue:[Smalltalk recreateSpecialObjectsArray].	"Check if Finalization is supported by this VM"	IsFinalizationSupported _ nil.	self isFinalizationSupported ifFalse:[^self].	FinalizationProcess notNil ifTrue:[FinalizationProcess terminate].	FinalizationSemaphore := Smalltalk specialObjectsArray at: 42.	FinalizationDependents isNil ifTrue:[		FinalizationDependents := WeakArray new: 10.	].	FinalizationLock := Semaphore forMutualExclusion.	FinalizationProcess := [self finalizationProcess] newProcess.	FinalizationProcess priority: Processor userInterruptPriority.	FinalizationProcess resume.! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 10/8/1998 11:17'!addWeakDependent: anObject	| finished index weakDependent |	self isFinalizationSupported ifFalse:[^self].	FinalizationLock critical:[		finished := false.		index := 0.		[index := index + 1.		finished not and:[index <= FinalizationDependents size]] whileTrue:[			weakDependent := FinalizationDependents at: index.			weakDependent isNil ifTrue:[				FinalizationDependents at: index put: anObject.				finished := true.			].		].		finished ifFalse:[			"Grow linearly"			FinalizationDependents := FinalizationDependents, (WeakArray new: 10).			FinalizationDependents at: index put: anObject.		].	] ifError:[:msg :rcvr| rcvr error: msg].! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 10/7/1998 15:30'!isFinalizationSupported	"Check if this VM supports the finalization mechanism"	| tempObject |	IsFinalizationSupported ifNotNil:[^IsFinalizationSupported].	tempObject _ WeakArray new: 1.	"Check if the class format 4 is correctly understood by the VM.	If the weak class support is not installed then the VM will report	any weak class as containing 32bit words - not pointers"	(tempObject at: 1) = nil 		ifFalse:[^IsFinalizationSupported _false].	"Check if objects are correctly freed"	self pvtCreateTemporaryObjectIn: tempObject.	Smalltalk garbageCollect.	^IsFinalizationSupported _ (tempObject at: 1) == nil! !!WeakArray class methodsFor: 'accessing' stamp: 'ar 10/8/1998 11:17'!removeWeakDependent: anObject	self isFinalizationSupported ifFalse:[^self].	FinalizationLock critical:[		1 to: FinalizationDependents size do:[:i|			((FinalizationDependents at: i) == anObject) ifTrue:[				FinalizationDependents at: i put: nil.			].		].	] ifError:[:msg :rcvr| rcvr error: msg].! !!WeakArray class methodsFor: 'private' stamp: 'ar 10/8/1998 11:19'!finalizationProcess	[true] whileTrue:[		FinalizationSemaphore wait.		FinalizationLock critical:[			FinalizationDependents do:[:weakDependent|				weakDependent isNil 					ifFalse:[weakDependent finalizeValues].			].		] ifError:[:msg :rcvr| rcvr error: msg].	].! !!WeakArray class methodsFor: 'private' stamp: 'ar 10/7/1998 15:24'!pvtCreateTemporaryObjectIn: tempObject	"We have to create the temporary object in a separate stack frame"	tempObject at: 1 put: Object new! !I am an association holding only weakly on my key.!!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:45'!< aLookupKey 	"Refer to the comment in Magnitude|<."	^self key < aLookupKey key! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!= aLookupKey	self species = aLookupKey species		ifTrue: [^self key = aLookupKey key]		ifFalse: [^false]! !!WeakKeyAssociation methodsFor: 'comparing' stamp: 'ar 3/21/98 15:46'!hash	"Hash is reimplemented because = is implemented."	^self key hash! !!WeakKeyAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:53'!printOn: aStream	self key printOn: aStream.	aStream nextPutAll: '->'.	self value printOn: aStream! !!WeakKeyAssociation methodsFor: 'printing' stamp: 'ar 3/21/98 15:53'!storeOn: aStream	aStream 		nextPut: $(;		nextPutAll: self class name;		nextPutAll:' key: '.	self key storeOn: aStream.	aStream nextPutAll: ' value: '.	self value storeOn: aStream.	aStream nextPut: $)! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:54'!key	^key isNil		ifTrue:[nil]		ifFalse:[key at: 1]! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:45'!key: aKey	key := WeakArray with: aKey! !!WeakKeyAssociation methodsFor: 'accessing' stamp: 'ar 3/21/98 15:44'!key: aKey value: anObject	key := WeakArray with: key.	value := anObject.! !I am a dictionary holding only weakly on my keys. This is a bit dangerous since at any time my keys can go away. Clients are responsible to register my instances by WeakArray such that the appropriate actions can be taken upon loss of any keys.See WeakRegistry for an example of use.!!WeakKeyDictionary methodsFor: 'finalization' stamp: 'ar 3/21/98 16:15'!finalizeValues	"default action is to re-hash the receiver and to remove nil-keys"	self rehash.	self removeKey: nil ifAbsent:[].! !!WeakKeyDictionary methodsFor: 'accessing' stamp: 'ar 3/21/98 16:02'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	key isNil ifTrue:[^anObject].	index _ self findElementOrNil: key.	element _ array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakKeyAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !!WeakKeyDictionary methodsFor: 'private' stamp: 'ar 3/22/98 00:21'!rehash	"Overriden to copy the size also - we may have lost any number of elements"	| newSelf |	newSelf := self species new: self size.	self associationsDo:[:each| newSelf noCheckAdd: each].	array := newSelf array.	tally := newSelf size.! !!WeakKeyDictionary methodsFor: 'adding' stamp: 'ar 3/21/98 16:00'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !I am a registry for objects needing finalization. When an object is added the object as well as its executor is stored. When the object is garbage collected, the executor can take the appropriate action for any resources associated with the object.See also:	Object executor	Object actAsExecutor	Object finalize!!WeakRegistry methodsFor: 'finalization' stamp: 'ar 3/22/98 00:19'!finalizeValues	"Some of our elements may have gone away. Look for those and activate the associated executors."	| finiObjects |	finiObjects := nil.	"First collect the objects."	self protected:[		valueDictionary associationsDo:[:assoc|			assoc key isNil ifTrue:[				finiObjects isNil 					ifTrue:[finiObjects := OrderedCollection with: assoc value]					ifFalse:[finiObjects add: assoc value]]		].		finiObjects isNil ifFalse:[valueDictionary finalizeValues].	].	"Then do the finalization"	finiObjects isNil ifTrue:[^self].	finiObjects do:[:each| each finalize].! !!WeakRegistry methodsFor: 'adding' stamp: 'ar 3/21/98 16:33'!add: anObject	"Add anObject to the receiver. Store the object as well as the associated executor."	| executor |	executor := anObject executor.	self protected:[		valueDictionary at: anObject put: executor.	].	^anObject! !!WeakRegistry methodsFor: 'accessing' stamp: 'sma 5/12/2000 11:40'!size	^ self protected: [valueDictionary size]! !!WeakRegistry methodsFor: 'accessing' stamp: 'ar 3/20/98 19:31'!species	^Set! !!WeakRegistry methodsFor: 'initialize' stamp: 'ar 3/21/98 16:08'!initialize: n	valueDictionary := WeakKeyDictionary new: n.	accessLock := Semaphore forMutualExclusion.! !!WeakRegistry methodsFor: 'private' stamp: 'ar 10/8/1998 11:18'!protected: aBlock	"Execute aBlock protected by the accessLock"	^accessLock isNil		ifTrue:[aBlock value]		ifFalse:[accessLock critical: aBlock ifError:[:msg :rcvr| rcvr error: msg]]! !!WeakRegistry methodsFor: 'enumerating' stamp: 'ar 3/21/98 18:36'!do: aBlock	^self protected:[		valueDictionary keysDo: aBlock.	].! !!WeakRegistry methodsFor: 'removing' stamp: 'ar 3/21/98 21:12'!remove: oldObject ifAbsent: exceptionBlock	"Remove oldObject as one of the receiver's elements."	| removedObject |	oldObject isNil ifTrue:[^oldObject].	self protected:[		removedObject := valueDictionary removeKey: oldObject ifAbsent:[nil].	].	^removedObject isNil		ifTrue:[exceptionBlock value]		ifFalse:[removedObject].! !!WeakRegistry class methodsFor: 'instance creation' stamp: 'ar 3/21/98 15:32'!new	^self new: 5! !!WeakRegistry class methodsFor: 'instance creation' stamp: 'ar 3/21/98 15:33'!new: n	| registry |	registry := super new initialize: n.	WeakArray addWeakDependent: registry.	^registry! !!WeakValueAssociation methodsFor: 'accessing' stamp: 'r++ 5/27/2000 18:11'!key: aKey value: anObject 	"Store the arguments as the variables of the receiver."	key _ aKey.	self value: anObject! !!WeakValueAssociation methodsFor: 'accessing' stamp: 'r++ 5/27/2000 18:08'!value	^self at: 1! !!WeakValueAssociation methodsFor: 'accessing' stamp: 'r++ 5/27/2000 18:08'!value: anObject 	"Store the argument, anObject, as the value of the receiver."	self at: 1 put: anObject! !!WeakValueAssociation class methodsFor: 'instance creation' stamp: 'r++ 5/27/2000 18:07'!key: anObject value: bObject	^ self new key: anObject value: bObject! !!WeakValueAssociation class methodsFor: 'as yet unclassified' stamp: 'r++ 5/27/2000 18:12'!new	^ self new: 1! !I am a dictionary holding only weakly on my values. Clients may expect to get a nil value for any object they request.!!WeakValueDictionary methodsFor: 'adding' stamp: 'ar 3/21/98 16:02'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !!WeakValueDictionary methodsFor: 'accessing' stamp: 'ar 3/21/98 16:01'!at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	index _ self findElementOrNil: key.	element _ array at: index.	element == nil		ifTrue: [self atNewIndex: index put: (WeakValueAssociation key: key value: anObject)]		ifFalse: [element value: anObject].	^ anObject! !!WeatherSound class methodsFor: 'as yet unclassified' stamp: 'di 7/23/2002 15:41'!chime1	"WeatherSound chime1 play"	| snd |	snd _ FMSound new.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.985).	^ snd setPitch: 2000 dur: 6.0 loudness: 0.5! !!WeatherSound class methodsFor: 'as yet unclassified' stamp: 'di 7/23/2002 17:24'!chime2	"WeatherSound chime1 play"	| snd |	snd _ FMSound new.	snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.98).	^ snd setPitch: 2000 dur: 4.0 loudness: 0.5! !!WeatherSound class methodsFor: 'as yet unclassified' stamp: 'di 7/23/2002 16:10'!chimeTest1	"WeatherSound chimeTest1"	| snd pitches rnd |	pitches _ (AbstractSound chromaticPitchesFrom: #d6) atAll: #(1 4 8 11 13 15).  "D F A C D E"	rnd _ Random new.	1 to: 30 do:		[:i |		snd _ FMSound new.		snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.97).		snd setPitch: pitches atRandom dur: 6.0 loudness: rnd next.		snd play.		(Delay forMilliseconds: (rnd next*1000.0) rounded+1) wait]! !!WeatherSound class methodsFor: 'as yet unclassified' stamp: 'di 7/23/2002 16:10'!chimeTest2	"WeatherSound chimeTest2"	| snd pitches rnd |	pitches _ (AbstractSound chromaticPitchesFrom: #d5) atAll: #(1 4 8 11 13 15).  "D F A C D E"	rnd _ Random new.	1 to: 30 do:		[:i |		snd _ FMSound new.		snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.98).		snd setPitch: pitches atRandom dur: 6.0 loudness: rnd next.		snd play.		(Delay forMilliseconds: (rnd next*1000.0) rounded+1) wait]! !!WeatherSound class methodsFor: 'as yet unclassified' stamp: 'jm 11/14/2003 09:31'!chimeTest2: nNotes delay: avgDelay duration: dur pitchBase: pitchBase pitches: chromaticNumbers loudness: avgLoudness	"Test some random note sequences with long exponential decays for suitability as wind chime simulations."	"C D F G A C"	"WeatherSound chimeTest2: 20 delay: 600.0 duration: 6.0		pitchBase: #c4 pitches: #(1 3 6 8 10 13) loudness: 0.2"	| snd rnd pitches decay |	pitches _ (AbstractSound chromaticPitchesFrom: pitchBase) atAll: chromaticNumbers.	decay _ VolumeEnvelope exponentialDecay: 1.0 - (0.08/dur).	rnd _ Random new.	1 to: nNotes do:		[:i |		snd _ WeatherSound new.		snd addEnvelope: decay copy.		snd setPitch: pitches atRandom dur: dur loudness: rnd next*avgLoudness*2.0.		snd modulation: 0.1 ratio: Float e.		snd play.		(Delay forMilliseconds: (rnd next*avgDelay*2.0) rounded+1) wait]! !!WeatherSound class methodsFor: 'as yet unclassified' stamp: 'di 7/27/2002 08:23'!chimeTest: nNotes delay: avgDelay duration: dur pitchBase: pitchBase pitches: chromaticNumbers loudness: avgLoudness	"Test some random note sequences with long exponential decays for	suitability as wind chime simulations."	"G A C D F G  Pentatonic"	"WeatherSound chimeTest: 30 delay: 600.0 duration: 6.0		pitchBase: #g4 pitches: #(1 3 6 8 11 13) loudness: 0.2"	"C D F G A C"	"WeatherSound chimeTest: 30 delay: 600.0 duration: 6.0		pitchBase: #c5 pitches: #(1 3 6 8 10 13) loudness: 0.2"       "A B D E G# A  Aquarian"	"WeatherSound chimeTest: 30 delay: 600.0 duration: 6.0		pitchBase: #a4 pitches: #(1 3 6 8 12 13) loudness: 0.2"	"D E G A B D  Quartal"	"WeatherSound chimeTest: 30 delay: 600.0 duration: 6.0		pitchBase: #c4 pitches: #(3 5 8 10 12 15) loudness: 0.2"	"D F A C D E"	"WeatherSound chimeTest: 30 delay: 300.0 duration: 4.0		pitchBase: #d6 pitches: #(1 4 8 11 13 15) loudness: 0.2"	"WeatherSound chimeTest: 20 delay: 700.0 duration: 6.0		pitchBase: #d3 pitches: #(1 4 8 11 13 15) loudness: 0.3"	"G A B D G G"	"WeatherSound chimeTest: 30 delay: 500.0 duration: 6.0		pitchBase: #g5 pitches: #(1 3 5 8 13 13) loudness: 0.2"	| snd rnd pitches decay |	pitches _ (AbstractSound chromaticPitchesFrom: pitchBase) atAll: chromaticNumbers.	decay _ VolumeEnvelope exponentialDecay: 1.0 - (0.08/dur).	rnd _ Random new.	1 to: nNotes do:		[:i |		snd _ WeatherSound new.		snd addEnvelope: decay copy.		snd setPitch: pitches atRandom dur: dur loudness: rnd next*avgLoudness*2.0.		"snd modulation: 1.4 ratio: 0.45."		snd play.		(Delay forMilliseconds: (rnd next*avgDelay*2.0) rounded+1) wait]! !!WeatherSound class methodsFor: 'as yet unclassified' stamp: 'di 7/23/2002 19:23'!chimeTest: pitch modulation: mod	"WeatherSound chimeTest: 500.0 modulation: 0.5"	| snd |	0.13 to: 3.0 by: 0.1 do:		[:ratio |		snd _ FMSound new.		snd addEnvelope: (VolumeEnvelope exponentialDecay: 0.98).		snd modulation: mod ratio: ratio.		snd setPitch: pitch dur: 2.0 loudness: 0.5.		snd play.		ratio printString , '  ' displayAt: 0@0.		(Delay forMilliseconds: 2000) wait]! !!WebPageColorPicker methodsFor: 'initialization' stamp: 'jm 9/29/2003 08:48'!initialize	super initialize.	selectedColor _ Color black.	target _ selector _ nil.	self extent: 20@20.! !!WebPageColorPicker methodsFor: 'accessing' stamp: 'jm 9/29/2003 08:36'!extent: newExtent	(newExtent = self extent) ifFalse: [		super extent: newExtent.		self createColorWheelWidth: newExtent x height: newExtent y].! !!WebPageColorPicker methodsFor: 'accessing' stamp: 'qvl 6/29/2003 16:48'!selectedColor	^ selectedColor! !!WebPageColorPicker methodsFor: 'accessing' stamp: 'qvl 6/29/2003 16:49'!selector	^ selector! !!WebPageColorPicker methodsFor: 'accessing' stamp: 'jm 9/29/2003 08:29'!selector: sel	(sel isNil or: [sel = 'nil' or: [sel isEmpty]])		ifTrue: [selector _ nil]		ifFalse: [selector _ sel asSymbol].! !!WebPageColorPicker methodsFor: 'accessing' stamp: 'qvl 6/29/2003 16:49'!target	^ target! !!WebPageColorPicker methodsFor: 'accessing' stamp: 'jm 9/29/2003 08:27'!target: anObject	target _ anObject.! !!WebPageColorPicker methodsFor: 'event handling' stamp: 'qvl 6/29/2003 16:50'!handlesMouseDown: evt	^ true! !!WebPageColorPicker methodsFor: 'event handling' stamp: 'jm 9/29/2003 08:26'!mouseDown: evt	self mouseMove: evt.! !!WebPageColorPicker methodsFor: 'event handling' stamp: 'jm 9/29/2003 08:42'!mouseMove: evt	selectedColor _ Display colorAt: evt cursorPoint.	(target notNil & selector notNil) ifTrue: [		target perform: selector with: selectedColor].! !!WebPageColorPicker methodsFor: 'private' stamp: 'jm 9/29/2003 08:31'!createColorWheelWidth: xSize height: ySize	| f h c |	f _ Form extent: xSize@ySize depth: 32.	0 to: (xSize - 15) do: [:x |		h _ x * 360 // (xSize - 15).		0 to: (ySize // 2) do: [:y |			c _ Color h: h s: (y / (ySize // 2)) v: 1.0.			f fill: (x@y extent: 1) fillColor: c].		((ySize // 2) + 1) to: ySize do: [:y |			c _ Color h: h s: 1.0 v: (ySize - y) / (ySize // 2).			f fill: (x@y extent: 1) fillColor: c]].	0 to: ySize do: [:y |		c _ Color gray: (ySize - y) / ySize.		f fill: (((xSize - 15)@y) extent: (15@1)) fillColor: c].	self form: f.! !!WebPageLayoutMorph methodsFor: 'initialization' stamp: 'jm 5/8/2003 17:43'!addButtonRow	| b spacer buttonRow |	b _ SimpleButtonMorph new target: self; color: (Color gray: 0.8).	spacer _ AlignmentMorph newSpacer: self color.	buttonRow _ AlignmentMorph newRow		borderWidth: 0;		inset: 3;		color: self color;		width: self innerBounds width;		hResizing: #spaceFill;		vResizing: #shrinkWrap.	buttonRow		addMorphBack: spacer fullCopy;		addMorphBack: (b fullCopy label: 'Save'; actionSelector: #savePage);		addMorphBack: spacer fullCopy;		addMorphBack: (b fullCopy label: 'New Para.'; actionSelector: #newParagraph);		addMorphBack: spacer fullCopy.	self addMorphBack: buttonRow.! !!WebPageLayoutMorph methodsFor: 'initialization' stamp: 'jm 8/3/2003 14:10'!initialize	| m |	super initialize.	self orientation: #vertical.	self borderWidth: 2.	self addButtonRow.	self addMorphBack: (m _ ScrollFrameMorph new).	contentsMorph _ WebPageScrollableMorph new.	m contents: contentsMorph.	self extent: 300@400.! !!WebPageLayoutMorph methodsFor: 'stepping' stamp: 'jm 5/8/2003 20:16'!step	| droppedFiles p f m |	droppedFiles _ FileStream droppedFiles.	droppedFiles size = 0 ifTrue: [^ self].	p _ droppedFiles first.	(droppedFiles copyFrom: 2 to: droppedFiles size) do: [:file |		f _ Form fromBinaryStream: file binary.		m _ SketchMorph withForm: f.		m position: p.		contentsMorph acceptDroppingMorph: m event: MorphicEvent new.		file close].! !!WebPageLayoutMorph methodsFor: 'stepping' stamp: 'jm 5/8/2003 20:12'!stepTime	^ 300! !!WebPageLayoutMorph methodsFor: 'other' stamp: 'jm 5/8/2003 20:32'!newParagraph	| m |	m _ TextMorph new		width: contentsMorph width - 30;		contentsWrapped: 'Your text here...'.	self activeHand attachMorph: m.! !!WebPageLayoutMorph methodsFor: 'other' stamp: 'jm 6/17/2003 12:08'!savePage	"Save all the elements of this page and the HTML for the page itself."	| dir html unique fName f |	dir _ FileDirectory default directoryNamed: 'MyPage'.	dir deleteFileNamed: 'index.html'.	html _ dir newFileNamed: 'index.html'.	html nextPutAll: '<title>Squeak Page</title>', String crlf, String crlf.	unique _ 0.	(contentsMorph submorphs sort: [:m1 :m2 | m1 top < m2 top]) do: [:m |		(m isKindOf: SketchMorph) ifTrue: [			fName _ 'image', (unique _ unique + 1) printString, '.jpg'.			dir deleteFileNamed: fName.			f _ (dir newFileNamed: fName) binary.			f nextPutAll: (FastJPEG compress: m rotatedForm quality: 80).			f close.			html nextPutAll: '<p><img src="', fName, '"><br>', String crlf].		(m isKindOf: TextMorph) ifTrue: [			html nextPutAll: '<p> '.			html nextPutAll: m contents asString.			html nextPutAll: '</p>', String crlf]].	html close.! !!WebPageLayoutMorph class methodsFor: 'instance creation' stamp: 'jm 5/31/2003 20:04'!includeInNewMorphMenu	^ true! !I am used by WebPageLayoutMorph.!!WebPageScrollableMorph methodsFor: 'initialization' stamp: 'jm 8/3/2003 14:02'!initialize	super initialize.	self color: (Color gray: 0.9).	self borderColor: (Color gray: 0.9).	self enableDragNDrop: true.! !!WebPageScrollableMorph methodsFor: 'dropping' stamp: 'jm 5/8/2003 20:14'!acceptDroppingMorph: aMorph event: evt	super acceptDroppingMorph: aMorph event: evt.	self updateContentLayout.! !!WebPageScrollableMorph methodsFor: 'private' stamp: 'jm 5/8/2003 20:36'!updateContentLayout	| didSomething p sortedMorphs paraWidth |	didSomething _ false.	p _ self topLeft + 15.	paraWidth _ self width - 25.	sortedMorphs _ submorphs copy sort: [:m1 :m2 | m1 center y < m2 center y].	sortedMorphs do: [:m |		m position = p ifFalse: [			m position: p.			didSomething _ true].		((m isKindOf: TextMorph) and: [m width ~= paraWidth]) ifTrue: [			m contents: m contents wrappedTo: paraWidth.			didSomething _ true].		p _ p + (0@(m height + 15))].	didSomething ifTrue: [self layoutChanged].! !Weeks begin in #Monday and end in #Sunday!!Week methodsFor: 'converting' stamp: 'LC 7/26/1998 23:13'!asDate	"Answer the first day of the week."	^ Date		newDay: self dayOfMonth		month: self monthName		year: self year! !!Week methodsFor: 'converting' stamp: 'LC 7/26/1998 23:14'!next	^ self class fromDate: (self firstDate addDays: 7)! !!Week methodsFor: 'converting' stamp: 'LC 7/26/1998 23:14'!previous	^ self class fromDate: (self firstDate subtractDays: 7)! !!Week methodsFor: 'inquiries' stamp: 'LC 7/26/1998 23:14'!duration	^ 7! !!Week methodsFor: 'inquiries' stamp: 'LC 7/26/1998 13:17'!firstDate	^ self asDate! !!Week methodsFor: 'inquiries' stamp: 'LC 7/26/1998 23:17'!index	^ self indexInMonth: self firstDate month! !!Week methodsFor: 'inquiries' stamp: 'LC 7/26/1998 23:16'!indexInMonth: aMonth	"1=first week, 2=second week, etc."	^ (Date dayOfWeek: aMonth weekday) + self dayOfMonth - 2  // 7 + 1! !!Week methodsFor: 'inquiries' stamp: 'LC 7/26/1998 23:17'!lastDate	^ self firstDate addDays: 6! !!Week methodsFor: 'enumerating' stamp: 'LC 7/27/1998 04:08'!do: aBlock	| date |	date _ self asDate.	7 timesRepeat:		[aBlock value: date.		date _ date addDays: 1]! !!Week methodsFor: 'printing' stamp: 'LC 7/28/1998 00:37'!printOn: aStream	aStream nextPutAll:		self month printString, ', ',		(#('1st week' '2nd week' '3rd week' '4th week' '5th week' '6th week') at: self index)! !!Week class methodsFor: 'instance creation' stamp: 'sge 5/19/2000 21:02'!fromDate: aDate	| startDay |	startDay _ aDate previous: (self startMonday 								ifTrue: [#Monday] ifFalse: [#Sunday]).	^ self		newDay: startDay dayOfMonth		month: startDay monthName		year: startDay year! !!Week class methodsFor: 'class variables' stamp: 'sge 5/18/2000 05:50'!startMonday	StartMonday ifNil: [StartMonday _ true].	^ StartMonday! !!Week class methodsFor: 'class variables' stamp: 'sge 5/18/2000 06:24'!toggleStartMonday	StartMonday _ self startMonday not! !This subclass of PasteUpMorph provides special support for viewing of a world in an inner window (WorldWindow).!!WiWPasteUpMorph methodsFor: 'initialization' stamp: 'RAA 11/22/1999 09:51'!hostWindow: x	hostWindow _ x.	self canvas: nil.	"safer to start from scratch"	self viewBox: hostWindow panelRect.! !!WiWPasteUpMorph methodsFor: 'initialization' stamp: 'RAA 11/20/1999 15:11'!initialize	super initialize.	parentWorld _ World.! !!WiWPasteUpMorph methodsFor: 'initialization' stamp: 'RAA 11/21/1999 23:08'!viewBox: newViewBox	| vb |	self damageRecorder reset.	"since we may have moved, old data no longer valid"	((vb _ self viewBox) == nil or: [vb ~= newViewBox])		ifTrue: [self canvas: nil].	worldState viewBox: newViewBox.	bounds _ newViewBox.	self assuredCanvas.	"Paragraph problem workaround; clear selections to avoid screen droppings:"	self handsDo: [:h | h newKeyboardFocus: nil].	self fullRepaintNeeded.! !!WiWPasteUpMorph methodsFor: 'activation' stamp: 'jm 10/5/2002 06:40'!becomeTheActiveWorldWith: evt	World == self ifTrue: [^ self].	self damageRecorder reset.	"since we may have moved, old data no longer valid"	hostWindow setStripeColorsFrom: Color green.	self canvas: nil.	"safer to start from scratch"	displayChangeSignatureOnEntry _ Display displayChangeSignature.	World _ self.	self viewBox: hostWindow panelRect.	self startSteppingSubmorphsOf: self.	self changed.	pendingEvent _ nil.	evt ifNotNil: [self primaryHand handleEvent: (evt setHand: self primaryHand)].! !!WiWPasteUpMorph methodsFor: 'activation' stamp: 'jm 10/5/2002 06:41'!revertToParentWorldWithEvent: evt	"RAA 27 Nov 99 - if the display changed while we were in charge, parent may need to redraw"	self damageRecorder reset.	"Terminate local display"	World _ parentWorld.	World assuredCanvas.	hostWindow setStripeColorsFrom: Color red.	(displayChangeSignatureOnEntry = Display displayChangeSignature)		ifFalse: [World fullRepaintNeeded; displayWorld].	evt ifNotNil: [World restartWorldCycleWithEvent: evt].! !!WiWPasteUpMorph methodsFor: 'update cycle' stamp: 'RAA 11/14/1999 11:56'!doDeferredUpdating	"If this platform supports deferred updates, then make my canvas be the Display (or a rectangular portion of it), set the Display to deferred update mode, and answer true. Otherwise, do nothing and answer false. One can set the class variable DisableDeferredUpdates to true to completely disable the deferred updating feature."	DisableDeferredUpdates ifNil: [DisableDeferredUpdates _ false].	DisableDeferredUpdates ifTrue: [^ false].	(Display deferUpdates: true) ifNil: [^ false].  "deferred updates not supported"	self resetViewBox.	^ true! !!WiWPasteUpMorph methodsFor: 'update cycle' stamp: 'RAA 11/23/1999 09:01'!doOneCycle	pendingEvent ifNotNil: [		self primaryHand handleEvent: (pendingEvent setHand: self primaryHand).		pendingEvent _ nil.	].	^super doOneCycle.! !!WiWPasteUpMorph methodsFor: 'update cycle' stamp: 'RAA 11/23/1999 09:06'!restartWorldCycleWithEvent: evt	"redispatch that click in outer world"	pendingEvent _ evt.	Project current spawnNewProcessAndTerminateOld: true! !!WiWPasteUpMorph methodsFor: 'update cycle' stamp: 'RAA 11/25/1999 10:11'!runStepMethods	"self == World ifFalse: [^ self]."		"not sure why this was here, but MVC doesn't like it"	super runStepMethods! !!WiWPasteUpMorph methodsFor: 'drawing' stamp: 'ar 3/14/2000 16:07'!invalidRect: damageRect	self == World		ifTrue: [self damageRecorder ifNotNil:					[self damageRecorder recordInvalidRect: damageRect]]		ifFalse: [super invalidRect: (damageRect intersect: bounds)]! !!WiWPasteUpMorph methodsFor: 'drawing' stamp: 'jm 10/14/2002 07:49'!restoreDisplay	"RAA 27 Nov 99 - we do not change our size just because the Display changed"	self == World ifTrue: [  "otherwise, we're a morphic window in MVC and the restoreDisplay was, unusually, issued from that world's menu rather than from the MVC screen menu"		DisplayScreen startUp].	self fullRepaintNeeded.! !!WiWPasteUpMorph methodsFor: 'geometry' stamp: 'RAA 11/14/1999 12:05'!extent: x	super extent: x.	self resetViewBox.! !!WiWPasteUpMorph methodsFor: 'geometry' stamp: 'RAA 11/23/1999 11:11'!resetViewBox	| c |	(c _ self canvas) == nil ifTrue: [^self resetViewBoxForReal].	c form == Display ifFalse: [^self resetViewBoxForReal].	c origin = (0@0) ifFalse: [^self resetViewBoxForReal].	c clipRect extent = (self viewBox intersect: parentWorld viewBox) extent ifFalse: [^self resetViewBoxForReal].			! !!WiWPasteUpMorph methodsFor: 'geometry' stamp: 'ar 5/25/2000 18:02'!resetViewBoxForReal	| newClip |	self viewBox ifNil: [^self].	newClip _ self viewBox intersect: parentWorld viewBox.	self canvas: (		(Display getCanvas)			copyOffset:  0@0			clipRect: newClip	)! !!WiWPasteUpMorph methodsFor: 'events' stamp: 'di 11/26/1999 08:14'!mouseDown: evt	(World == self or: [World isNil]) ifTrue: [^ super mouseDown: evt].	(self bounds containsPoint: evt cursorPoint) ifFalse: [^ self].	self becomeTheActiveWorldWith: evt.! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'RAA 11/27/1999 15:30'!displayWorld	"RAA 27 Nov 99 - if we are not active, then the parent should do the drawing"	World == self ifTrue: [^super displayWorld].	parentWorld ifNotNil: [^parentWorld displayWorld].	^super displayWorld		"in case MVC needs it"! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'di 11/27/1999 10:27'!goBack	PopUpMenu notify: 'Project changes are not yet allowedfrom inner worlds.'! !!WiWPasteUpMorph methodsFor: 'as yet unclassified' stamp: 'di 11/27/1999 10:27'!jumpToProject	PopUpMenu notify: 'Project changes are not yet allowedfrom inner worlds.'! !My instances are used to transform objects from a source coordinate system to a destination coordinate system. Each instance contains a scale and a translation which can be applied to objects that respond to scaleBy: and translateBy:. It can be created with a default identity scale and translation, or with a specified scale and translation, or with a scale and translation computed from a window (a Rectangle in the source coordinate system) and a viewport (a Rectangle in the destination coordinate system). In applying a WindowingTransformation to an object, the object is first scaled (around the origin of the source coordinate system) and then translated. WindowingTransformations can be composed to form a single compound transformation.!WordArrays store 32-bit unsigned Integer values.!!WordArray methodsFor: 'converting' stamp: 'ar 9/14/1998 23:46'!asWordArray	^self! !!WordArray methodsFor: 'accessing' stamp: 'sma 4/22/2000 17:47'!atAllPut: value	"Fill the receiver with the given value"	<primitive: 145>	super atAllPut: value! !!WordArray methodsFor: 'accessing' stamp: 'tk 3/13/2000 14:46'!bytesPerElement	"Number of bytes in each item.  This multiplied by (self size)*8 gives the number of bits stored."	^ 4! !!WordArray methodsFor: 'accessing' stamp: 'ar 11/2/1998 12:19'!defaultElement	"Return the default element of the receiver"	^0! !!WordArray methodsFor: 'private' stamp: 'ar 2/15/1999 00:51'!replaceFrom: start to: stop with: replacement startingAt: repStart 	<primitive: 105>	^super replaceFrom: start to: stop with: replacement startingAt: repStart ! !!WordArray methodsFor: 'fileIn/Out' stamp: 'tk 1/22/2000 12:04'!swapBytesFrom: start to: stop	"Perform a bigEndian/littleEndian byte reversal of my words"	| hack blt |	"The implementation is a hack, but fast for large ranges"	hack _ Form new hackBits: self.	blt _ (BitBlt toForm: hack) sourceForm: hack.	blt combinationRule: Form reverse.  "XOR"	blt sourceY: start-1; destY: start-1; height: stop-start+1; width: 1.	blt sourceX: 0; destX: 3; copyBits.  "Exchange bytes 0 and 3"	blt sourceX: 3; destX: 0; copyBits.	blt sourceX: 0; destX: 3; copyBits.	blt sourceX: 1; destX: 2; copyBits.  "Exchange bytes 1 and 2"	blt sourceX: 2; destX: 1; copyBits.	blt sourceX: 1; destX: 2; copyBits.! !!WordArray methodsFor: 'fileIn/Out' stamp: 'jm 1/1/2004 18:54'!writeOn: aStream 	"Store the array of bits onto the argument, aStream. A leading byte ~= 16r80 identifies this as raw bits (uncompressed). Always store in Big Endian (Mac) byte order. Do the writing at BitBlt speeds."	| convertToBytes |	convertToBytes _ aStream originalContents class isBytes.	(aStream isKindOf: FileStream) ifTrue: [convertToBytes _ false].  "knows how"	Smalltalk isBigEndian		ifTrue: [  "no change"			aStream int32: self size.			convertToBytes ifTrue: [				self do: [:vv | aStream int32: vv]]					"Later define (aStream nextPutWordsAll:) that uses BitBlt to 					 put words on a byteStream quickly" 				ifFalse: [aStream nextPutAll: self]]		ifFalse: [			self swapBytesFrom: 1 to: self size.			aStream int32: self size.  "reverse byte order"			convertToBytes				ifTrue: [self do: [:vv | aStream int32: vv]]				ifFalse: [aStream nextPutAll: self].			self swapBytesFrom: 1 to: self size].  "revert to the original byte order"! !!Workspace methodsFor: 'binding' stamp: 'jm 7/12/2003 15:25'!bindings	^ bindings! !!Workspace methodsFor: 'accessing' stamp: 'jsp 3/23/1999 12:19'!setBindings: aDictionary	"Sets the Workspace to use the specified dictionary as its namespace"	bindings _ aDictionary.! !!Workspace methodsFor: 'as yet unclassified' stamp: 'sw 10/6/1999 15:17'!addModelItemsToWindowMenu: aMenu	aMenu addLine.	aMenu add: 'save contents to file...' target: self action: #saveContentsInFile ! !!Workspace methodsFor: 'as yet unclassified' stamp: 'dew 3/9/2000 00:13'!saveContentsInFile	"A bit of a hack to pass along this message to the controller or morph.  (Possibly this Workspace menu item could be deleted, since it's now in the text menu.)"	| textMorph textView |	textMorph _ self dependents detect: [:dep | dep isKindOf: PluggableTextMorph] ifNone: [nil].	textMorph notNil ifTrue: [^ textMorph saveContentsInFile].	textView _ self dependents detect: [:dep | dep isKindOf: PluggableTextView] ifNone: [nil].	textView notNil ifTrue: [^ textView controller saveContentsInFile].! !I hold the state for a Morphic world.!!WorldState methodsFor: 'initialization' stamp: 'jm 10/4/2002 18:26'!initialize	hands _ #().	activeHand _ viewBox _ canvas _ nil.	damageRecorder _ DamageRecorder new.	stepList _ OrderedCollection new.	lastStepTime _ lastCycleTime _ 0.! !!WorldState methodsFor: 'update cycle' stamp: 'di 6/7/1999 17:47'!lastCycleTime	^ lastCycleTime! !!WorldState methodsFor: 'update cycle' stamp: 'di 6/7/1999 17:52'!lastCycleTime: x	lastCycleTime _ x! !!WorldState methodsFor: 'stepping' stamp: 'di 6/10/1999 23:06'!adjustWakeupTimes	"Fix the wakeup times in my step list. This is necessary when this world has been restarted after a pause, say because some other view had control, after a snapshot, or because the millisecond clock has wrapped around. (The latter is a rare occurence with a 32-bit clock!!)"	| earliestTime t now m oldWakeupTime |	"find earliest wakeup time"	earliestTime _ SmallInteger maxVal.	stepList do: [:entry |		t _ entry at: 2.		t < earliestTime ifTrue: [earliestTime _ t]].	"recompute all wakeup times, using earliestTime as the origin"	now _ Time millisecondClockValue.	stepList do: [:entry |		m _ entry at: 1.		oldWakeupTime _ entry at: 2.		entry at: 2 put: now + ((oldWakeupTime - earliestTime) min: m stepTime)].	lastStepTime _ now.! !!WorldState methodsFor: 'stepping' stamp: 'di 6/10/1999 23:06'!adjustWakeupTimesIfNecessary	"Fix the wakeup times in my step list if necessary. This is needed after a snapshot, after a long pause (say because some other view had control or because the user was selecting from an MVC-style menu) or when the millisecond clock wraps around (a very rare occurence with a 32-bit clock!!)."	| now |	now _ Time millisecondClockValue.	((now < lastStepTime) or: [(now - lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"! !!WorldState methodsFor: 'stepping' stamp: 'di 6/10/1999 22:14'!isStepping: aMorph	"Return true if the given morph is in the step list."	stepList do: [:entry | entry first == aMorph ifTrue: [^ true]].  "already stepping"	^ false! !!WorldState methodsFor: 'stepping' stamp: 'di 6/7/1999 17:47'!lastStepTime	^ lastStepTime! !!WorldState methodsFor: 'stepping' stamp: 'di 6/7/1999 17:52'!lastStepTime: x	lastStepTime _ x! !!WorldState methodsFor: 'stepping' stamp: 'sw 10/20/1999 14:50'!runStepMethodsIn: aWorld	"Run morph 'step' methods whose time has come. Purge any morphs that are no longer in this world.	ar 3/13/1999: Remove buggy morphs from the step list so that they don't raise repeated errors."	| now deletions wakeupTime morphToStep |	stepList size = 0 ifTrue: [^ self].	now _ Time millisecondClockValue.	((now < lastStepTime) or: [(now - lastStepTime) > 5000])		 ifTrue: [self adjustWakeupTimes].  "clock slipped"	deletions _ nil.	"Note: Put the following into an error handler to prevent errors happening on stepping"	[stepList do: [:entry |		wakeupTime _ entry at: 2.		morphToStep _ entry at: 1.		morphToStep world == aWorld			ifTrue:				[wakeupTime <= now					ifTrue:						[morphToStep stepAt: now.						entry at: 2 put: now + morphToStep stepTime]]			ifFalse:				[deletions ifNil: [deletions _ OrderedCollection new].				deletions addLast: morphToStep]]]	 ifError: [:err :rcvr |		self stopStepping: morphToStep. "Stop this guy right now"		morphToStep setProperty: #errorOnStep toValue: true. "Remember stepping"		Processor activeProcess errorHandler: nil. "So we don't handle this guy twice"		rcvr error: err. "And re-raise the error from here so the stack is still valid"].	deletions ifNotNil:		[deletions do: [:deletedM |			self stopStepping: deletedM.			deletedM stopStepping]].	lastStepTime _ now! !!WorldState methodsFor: 'stepping' stamp: 'di 6/10/1999 22:10'!startStepping: aMorph	"Add the given morph to the step list. Do nothing if it is already being stepped."	stepList do: [:entry | entry first = aMorph ifTrue: [^ self]].  "already stepping"	self adjustWakeupTimesIfNecessary.	stepList add:		(Array with: aMorph with: Time millisecondClockValue).! !!WorldState methodsFor: 'stepping' stamp: 'di 6/7/1999 17:47'!stepList	^ stepList! !!WorldState methodsFor: 'stepping' stamp: 'di 6/7/1999 17:52'!stepList: x	stepList _ x! !!WorldState methodsFor: 'stepping' stamp: 'di 6/10/1999 22:15'!stopStepping: aMorph	"Remove the given morph from the step list."	stepList copy do: [:entry |		entry first == aMorph ifTrue: [stepList remove: entry ifAbsent: []]].! !!WorldState methodsFor: 'canvas' stamp: 'jm 11/24/2002 19:04'!assuredCanvas	(canvas isNil or:	 [(canvas extent ~= viewBox extent) or:	 [canvas form depth ~= Display depth]]) ifTrue: [		"allocate a new offscreen canvas the size of the window"		self canvas: (FormCanvas extent: viewBox extent)].	^ self canvas! !!WorldState methodsFor: 'canvas' stamp: 'di 6/7/1999 17:44'!canvas	^ canvas! !!WorldState methodsFor: 'canvas' stamp: 'di 7/19/1999 16:45'!canvas: x	canvas _ x.	damageRecorder == nil		ifTrue: [damageRecorder _ DamageRecorder new]		ifFalse: [damageRecorder doFullRepaint]! !!WorldState methodsFor: 'canvas' stamp: 'di 6/7/1999 17:45'!damageRecorder	^ damageRecorder! !!WorldState methodsFor: 'canvas' stamp: 'di 6/7/1999 17:44'!viewBox	^ viewBox! !!WorldState methodsFor: 'canvas' stamp: 'di 6/7/1999 17:58'!viewBox: x	viewBox _ x! !!WorldState methodsFor: 'hands' stamp: 'di 6/7/1999 17:42'!activeHand	^ activeHand! !!WorldState methodsFor: 'hands' stamp: 'di 6/7/1999 17:50'!activeHand: x	activeHand _ x! !!WorldState methodsFor: 'hands' stamp: 'di 6/7/1999 17:40'!hands	^ hands! !!WorldState methodsFor: 'hands' stamp: 'di 6/7/1999 17:51'!hands: x	hands _ x! !!WorldState methodsFor: 'remote server' stamp: 'jm 11/24/2002 19:02'!remoteServer	^ remoteServer! !!WorldState methodsFor: 'remote server' stamp: 'jm 11/24/2002 19:02'!remoteServer: aNebraskaServerOrNil	remoteServer ifNotNil: [remoteServer destroy].	remoteServer _ aNebraskaServerOrNil.! !Serves as a model for a WorldView -- a morphic world viewed within an mvc project.!!WorldViewModel methodsFor: 'as yet unclassified' stamp: 'sw 9/21/1998 17:50'!fullScreenSize	"Answer the size to which a window displaying the receiver should be set"	^ (0@0 extent: DisplayScreen actualScreenSize) copy! !!WorldViewModel methodsFor: 'as yet unclassified' stamp: 'sw 9/21/1998 17:51'!initialExtent	initialExtent ifNotNil: [^ initialExtent].	^ super initialExtent! !!WorldViewModel methodsFor: 'as yet unclassified' stamp: 'sw 9/21/1998 17:51'!initialExtent: anExtent	initialExtent _ anExtent! !I represent an accessor for a sequence of objects that can only store objects in the sequence.!!WriteStream methodsFor: 'accessing' stamp: 'di 3/8/1999 09:02'!nextPut: anObject 	"Primitive. Insert the argument at the next position in the Stream	represented by the receiver. Fail if the collection of this stream is not an	Array or a String. Fail if the stream is positioned at its end, or if the	position is out of bounds in the collection. Fail if the argument is not	of the right type for the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 66>	position >= writeLimit		ifTrue: [^ self pastEndPut: anObject]		ifFalse: 			[position _ position + 1.			^collection at: position put: anObject]! !!WriteStream methodsFor: 'accessing' stamp: 'ls 8/20/1998 10:19'!nextPutAll: aCollection	| newEnd |	collection class == aCollection class ifFalse: [		^super nextPutAll: aCollection ].	newEnd _ position + aCollection size.	newEnd > writeLimit ifTrue: [		collection _ collection,			(collection species new: (newEnd - writeLimit + (collection size max: 20)) ).		writeLimit _ collection size ].	collection replaceFrom: position+1 to: newEnd  with: aCollection.	position _ newEnd.! !!WriteStream methodsFor: 'positioning' stamp: 'ar 11/12/1998 21:27'!resetToStart	readLimit _ position _ 0.! !!WriteStream methodsFor: 'character writing' stamp: 'sr 4/8/2000 01:49'!tab: anInteger 	"Append anInteger tab characters to the receiver."	anInteger timesRepeat: [self nextPut: Character tab]! !!WriteStream methodsFor: 'private' stamp: 'di 11/18/1999 22:55'!braceArray	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	^ collection! !!WriteStream methodsFor: 'private' stamp: 'di 11/18/1999 22:50'!braceArray: anArray	"This method is used in compilation of brace constructs.	It MUST NOT be deleted or altered."	collection _ anArray.	position _ 0.	readLimit _ 0.	writeLimit _ anArray size.! !!WriteStream methodsFor: 'private' stamp: 'djp 11/6/1999 23:15'!withAttributes: attributes do: strmBlock 	"No-op here is overriden in TextStream for font emphasis"	^ strmBlock value! !!ZLibReadStream methodsFor: 'initialize' stamp: 'ar 12/27/1999 15:38'!on: aCollection from: firstIndex to: lastIndex	"Check the header of the ZLib stream."	| method byte |	super on: aCollection from: firstIndex to: lastIndex.	method _ self nextBits: 8.	(method bitAnd: 15) = 8 ifFalse:[^self error:'Unknown compression method'].	(method bitShift: -4) + 8 > 15 ifTrue:[^self error:'Invalid window size'].	byte _ self nextBits: 8.	(method bitShift: 8) + byte \\ 31 = 0 ifFalse:[^self error:'Incorrect header'].	(byte anyMask: 32) ifTrue:[^self error:'Need preset dictionary'].! !!ZLibWriteStream methodsFor: 'initialize-release' stamp: 'ar 12/27/1999 15:48'!on: aCollection	super on: aCollection.	encoder nextBits: 8 put: 120. "deflate method with 15bit window size"	encoder nextBits: 8 put: 1. "check sum; no preset dictionary"! !!ZipEncoder methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 00:38'!close	self flush.	(encodedStream respondsTo: #close) ifTrue:[encodedStream close].! !!ZipEncoder methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 15:51'!commit	encodedStream next: position putAll: collection.	position _ readLimit _ 0.! !!ZipEncoder methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 15:51'!flush	self flushBits.	self commit.! !!ZipEncoder methodsFor: 'initialize-release' stamp: 'ar 1/2/2000 16:35'!flushBits	"Flush currently unsent bits"	[bitPosition > 0] whileTrue:[		self nextBytePut: (bitBuffer bitAnd: 255).		bitBuffer _ bitBuffer bitShift: -8.		bitPosition _ bitPosition - 8].	bitPosition _ 0.! !!ZipEncoder methodsFor: 'initialize-release' stamp: 'jm 6/6/2003 07:39'!on: aCollectionOrStream	(aCollectionOrStream isKindOf: Stream) 		ifTrue: [encodedStream _ aCollectionOrStream]		ifFalse: [encodedStream _ WriteStream on: aCollectionOrStream].	encodedStream isBinary		ifTrue: [super on: (ByteArray new: 4096)]		ifFalse: [super on: (String new: 4096)].	bitPosition _ bitBuffer _ 0.! !!ZipEncoder methodsFor: 'accessing' stamp: 'ar 12/30/1999 00:45'!bitPosition	^encodedStream position + position * 8 + bitPosition.! !!ZipEncoder methodsFor: 'accessing' stamp: 'ar 12/30/1999 00:37'!encodedStream	^encodedStream! !!ZipEncoder methodsFor: 'accessing' stamp: 'ar 1/2/2000 16:34'!nextBits: nBits put: value	"Store a value of nBits"	"self assert:[value >= 0 and:[(1 bitShift: nBits) > value]]."	bitBuffer _ bitBuffer bitOr: (value bitShift: bitPosition).	bitPosition _ bitPosition + nBits.	[bitPosition >= 8] whileTrue:[		self nextBytePut: (bitBuffer bitAnd: 255).		bitBuffer _ bitBuffer bitShift: -8.		bitPosition _ bitPosition - 8].! !!ZipEncoder methodsFor: 'accessing' stamp: 'ar 1/2/2000 16:34'!nextBytePut: anObject 	"Primitive. Insert the argument at the next position in the Stream	represented by the receiver. Fail if the collection of this stream is not an	Array or a String. Fail if the stream is positioned at its end, or if the	position is out of bounds in the collection. Fail if the argument is not	of the right type for the collection. Optional. See Object documentation	whatIsAPrimitive."	<primitive: 66>	position >= writeLimit		ifTrue: [^ self pastEndPut: anObject]		ifFalse: 			[position _ position + 1.			^collection byteAt: position put: anObject]! !!ZipEncoder methodsFor: 'block encoding' stamp: 'ar 12/30/1999 18:39'!sendBlock: literalStream with: distanceStream with: litTree with: distTree	"Send the current block using the encodings from the given literal/length and distance tree"	| result |	result _ 0.	[literalStream atEnd] whileFalse:[		result _ result + (self privateSendBlock: literalStream						with: distanceStream with: litTree with: distTree).		self commit.	].	self nextBits: (litTree bitLengthAt: EndBlock) put: (litTree codeAt: EndBlock).	^result! !!ZipEncoder methodsFor: 'private' stamp: 'ar 1/2/2000 16:38'!pastEndPut: anObject	"Flush the current buffer and store the new object at the beginning"	self commit.	^self nextBytePut: anObject asInteger! !!ZipEncoder methodsFor: 'private' stamp: 'ar 12/30/1999 18:38'!privateSendBlock: literalStream with: distanceStream with: litTree with: distTree	"Send the current block using the encodings from the given literal/length and distance tree"	| lit dist code extra sum |	<primitive:'primitiveZipSendBlock'>	sum _ 0.	[lit _ literalStream next.	dist _ distanceStream next.	lit == nil] whileFalse:[		dist = 0 ifTrue:["lit is a literal"			sum _ sum + 1.			self nextBits: (litTree bitLengthAt: lit)				put: (litTree codeAt: lit).		] ifFalse:["lit is match length"			sum _ sum + lit + MinMatch.			code _ (MatchLengthCodes at: lit + 1).			self nextBits: (litTree bitLengthAt: code)				put: (litTree codeAt: code).			extra _ ExtraLengthBits at: code-NumLiterals.			extra = 0 ifFalse:[				lit _ lit - (BaseLength at: code-NumLiterals).				self nextBits: extra put: lit.			].			dist _ dist - 1.			dist < 256				ifTrue:[code _ DistanceCodes at: dist + 1]				ifFalse:[code _ DistanceCodes at: 257 + (dist bitShift: -7)].			"self assert:[code < MaxDistCodes]."			self nextBits: (distTree bitLengthAt: code)				put: (distTree codeAt: code).			extra _ ExtraDistanceBits at: code+1.			extra = 0 ifFalse:[				dist _ dist - (BaseDistance at: code+1).				self nextBits: extra put: dist.			].		].	].	^sum! !ZipEncoderNode represents a node in a huffman tree for encoding ZipStreams.Instance variables:	value 		<Integer>	- Encoded value	frequency	<Integer>	- Number of occurences of the encoded value	height 		<Integer>	- Height of the node in the tree	bitLength 	<Integer>	- bit length of the code	code		<Integer>	- Assigned code for this node	parent		<ZipEncoderNode>		- Parent of this node	left			<ZipEncoderNode>		- First child of this node	right		<ZipEncoderNode>		- Second child of this node!!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/25/1999 19:41'!bitLength	^bitLength ifNil:[0]! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/30/1999 14:28'!code	^code ifNil:[0]! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/25/1999 21:51'!code: aCode	self assert:[aCode >= 0 and:[(1 bitShift: bitLength) > aCode]].	code _ aCode.! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:36'!frequency	^frequency! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/28/1999 00:56'!frequency: aNumber	frequency _ aNumber! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/26/1999 10:44'!height	^height! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:43'!left	^left! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/25/1999 20:06'!left: aNode	aNode parent: self.	left _ aNode.! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:43'!parent	^parent! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:43'!parent: aNode	parent _ aNode! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:43'!right	^right! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/25/1999 20:06'!right: aNode	aNode parent: self.	right _ aNode.! !!ZipEncoderNode methodsFor: 'accessing' stamp: 'ar 12/24/1999 23:43'!value	^value! !!ZipEncoderNode methodsFor: 'encoding' stamp: 'ar 12/26/1999 11:49'!encodeBitLength: blCounts from: aTree	| index |	"Note: If bitLength is not nil then the tree must be broken"	bitLength == nil ifFalse:[self error:'Huffman tree is broken'].	parent = nil 		ifTrue:[bitLength _ 0]		ifFalse:[bitLength _ parent bitLength + 1].	self isLeaf ifTrue:[		index _ bitLength + 1.		blCounts at: index put: (blCounts at: index) + 1.	] ifFalse:[		left encodeBitLength: blCounts from: aTree.		right encodeBitLength: blCounts from: aTree.	].! !!ZipEncoderNode methodsFor: 'encoding' stamp: 'ar 12/27/1999 14:27'!rotateToHeight: maxHeight	"Rotate the tree to achieve maxHeight depth"	| newParent |	height < 4 ifTrue:[^self].	self left: (left rotateToHeight: maxHeight-1).	self right: (right rotateToHeight: maxHeight-1).	height _ (left height max: right height) + 1.	height <= maxHeight ifTrue:[^self].	(left height - right height) abs <= 2 ifTrue:[^self].	left height < right height ifTrue:[		right right height >= right left height ifTrue:[			newParent _ right.			self right: newParent left.			newParent left: self.		] ifFalse:[			newParent _ right left.			right left: newParent right.			newParent right: right.			self right: newParent left.			newParent left: self.		].	] ifFalse:[		left left height >= left right height ifTrue:[			newParent _ left.			self left: newParent right.			newParent right: self.		] ifFalse:[			newParent _ left right.			left right: newParent left.			newParent left: left.			self left: newParent right.			newParent right: self.		].	].	parent computeHeight.	^parent! !!ZipEncoderNode methodsFor: 'testing' stamp: 'ar 12/24/1999 23:17'!isLeaf	^left == nil! !!ZipEncoderNode methodsFor: 'private' stamp: 'ar 12/26/1999 10:45'!computeHeight	^self isLeaf		ifTrue:[height _ 0]		ifFalse:[height _ (left computeHeight max: right computeHeight) + 1].! !!ZipEncoderNode methodsFor: 'private' stamp: 'ar 12/25/1999 18:14'!leafNodes	self isLeaf		ifTrue:[^Array with: self]		ifFalse:[^left leafNodes, right leafNodes]! !!ZipEncoderNode methodsFor: 'private' stamp: 'ar 12/26/1999 12:05'!setBitLengthTo: bl	bitLength _ bl! !!ZipEncoderNode methodsFor: 'private' stamp: 'ar 12/26/1999 10:46'!setValue: v frequency: f height: h	value _ v.	frequency _ f.	height _ h.! !!ZipEncoderNode methodsFor: 'printing' stamp: 'ar 12/26/1999 10:46'!printOn: aStream	super printOn: aStream.	aStream nextPut:$(;		nextPutAll:'value = '; print: value;		nextPutAll:', freq = '; print: frequency;		nextPutAll:', bitLength = '; print: bitLength;		nextPutAll:', code = '; print: code;		nextPutAll:', height = '; print: height; 	nextPut:$).! !!ZipEncoderNode class methodsFor: 'instance creation' stamp: 'ar 12/26/1999 10:47'!value: v frequency: f height: h	^self new setValue: v frequency: f height: h! !ZipEncoderTree represents a huffman tree for encoding ZipStreams.Instance variables:	bitLengths	<WordArray>	 - Bit lengths of each generated code	codes		<WordArray>	 - Codes for each value	maxCode		<Integer>	- Maximum value with non-zero frequency!!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/30/1999 01:43'!bitLengthAt: index	^bitLengths at: index+1! !!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/30/1999 01:32'!bitLengths	"Return an array of all bitLength values for valid codes"	^bitLengths! !!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/30/1999 01:04'!codeAt: index	^codes at: index+1! !!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/30/1999 01:24'!codes	"Return an array of all valid codes"	^codes! !!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/25/1999 17:15'!maxCode	^maxCode! !!ZipEncoderTree methodsFor: 'accessing' stamp: 'ar 12/25/1999 21:45'!maxCode: aNumber	maxCode _ aNumber.! !!ZipEncoderTree methodsFor: 'encoding' stamp: 'ar 12/30/1999 01:34'!buildCodes: nodeList counts: blCounts maxDepth: depth	"Build the codes for all nodes"	| nextCode code node length |	nextCode _ WordArray new: depth+1.	code _ 0.	1 to: depth do:[:bits|		code _ (code + (blCounts at: bits)) << 1.		nextCode at: bits+1 put: code].	self assert:[(code + (blCounts at: depth+1) - 1) = (1 << depth - 1)].	0 to: maxCode do:[:n|		node _ nodeList at: n+1.		length _ node bitLength.		length = 0 ifFalse:[			code _ nextCode at: length+1.			node code: (self reverseBits: code length: length).			nextCode at: length+1 put: code+1.		].	].! !!ZipEncoderTree methodsFor: 'encoding' stamp: 'ar 12/26/1999 10:42'!buildHierarchyFrom: aHeap	"Build the node hierarchy based on the leafs in aHeap"	| left right parent |	[aHeap size > 1] whileTrue:[		left _ aHeap removeFirst.		right _ aHeap removeFirst.		parent _ ZipEncoderNode value: -1 			frequency: (left frequency + right frequency)			height: (left height max: right height) + 1.		left parent: parent.		right parent: parent.		parent left: left.		parent right: right.		aHeap add: parent].	^aHeap removeFirst! !!ZipEncoderTree methodsFor: 'encoding' stamp: 'ar 12/30/1999 14:19'!buildTree: nodeList maxDepth: depth	"Build either the literal or the distance tree"	| heap rootNode blCounts |	heap _ Heap new: nodeList size // 3.	heap sortBlock: self nodeSortBlock.	"Find all nodes with non-zero frequency and add to heap"	maxCode _ 0.	nodeList do:[:dNode|		dNode frequency = 0 ifFalse:[			maxCode _ dNode value.			heap add: dNode]].	"The pkzip format requires that at least one distance code exists,	and that at least one bit should be sent even if there is only one	possible code. So to avoid special checks later on we force at least	two codes of non zero frequency."	heap size = 0 ifTrue:[		self assert:[maxCode = 0].		heap add: nodeList first.		heap add: nodeList second.		maxCode _ 1].	heap size = 1 ifTrue:[		nodeList first frequency = 0			ifTrue:[heap add: nodeList first]			ifFalse:[heap add: nodeList second].		maxCode _ maxCode max: 1].	rootNode _ self buildHierarchyFrom: heap.	rootNode height > depth ifTrue:[		rootNode _ rootNode rotateToHeight: depth.		rootNode height > depth ifTrue:[self error:'Cannot encode tree']].	blCounts _ WordArray new: depth+1.	rootNode encodeBitLength: blCounts from: self.	self buildCodes: nodeList counts: blCounts maxDepth: depth.	self setValuesFrom: nodeList.! !!ZipEncoderTree methodsFor: 'encoding' stamp: 'ar 12/30/1999 01:24'!buildTreeFrom: frequencies maxDepth: depth	"Build the receiver from the given frequency values"	| nodeList |	nodeList _ Array new: frequencies size.	1 to: frequencies size do:[:i|		nodeList at: i put: (ZipEncoderNode value: i-1 frequency: (frequencies at: i) height: 0)	].	self buildTree: nodeList maxDepth: depth.! !!ZipEncoderTree methodsFor: 'encoding' stamp: 'ar 12/26/1999 10:42'!nodeSortBlock	^[:n1 :n2|		n1 frequency = n2 frequency			ifTrue:[n1 height <= n2 height]			ifFalse:[n1 frequency <= n2 frequency]].! !!ZipEncoderTree methodsFor: 'private' stamp: 'ar 12/30/1999 14:26'!bitLengths: blArray codes: codeArray	bitLengths _ blArray as: WordArray.	codes _ codeArray as: WordArray.	self assert:[(self bitLengthAt: maxCode) > 0].! !!ZipEncoderTree methodsFor: 'private' stamp: 'ar 12/26/1999 11:02'!reverseBits: code length: length	"Bit reverse the given code"	| result bit bits |	result _ 0.	bits _ code.	1 to: length do:[:i|		bit _ bits bitAnd: 1.		result _ result << 1 bitOr: bit.		bits _ bits >> 1].	^result! !!ZipEncoderTree methodsFor: 'private' stamp: 'sma 6/1/2000 11:52'!setValuesFrom: nodeList	self bitLengths: (nodeList			collect: [:n | n bitLength]			from: 1			to: maxCode + 1)		codes: (nodeList				collect: [:n | n code]				from: 1				to: maxCode + 1)! !!ZipEncoderTree class methodsFor: 'instance creation' stamp: 'ar 12/30/1999 01:25'!buildTreeFrom: frequencies maxDepth: depth	^self new buildTreeFrom: frequencies maxDepth: depth! !!ZipWriteStream methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 00:38'!close	self deflateBlock.	self flushBlock: true.	encoder close.! !!ZipWriteStream methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 00:40'!initialize	super initialize.	literals _ ByteArray new: WindowSize.	distances _ WordArray new: WindowSize.	literalFreq _ WordArray new: MaxLiteralCodes.	distanceFreq _ WordArray new: MaxDistCodes.	self initializeNewBlock.! !!ZipWriteStream methodsFor: 'initialize-release' stamp: 'ar 12/29/1999 18:29'!initializeNewBlock	"Initialize the encoder for a new block of data"	literalFreq atAllPut: 0.	distanceFreq atAllPut: 0.	literalFreq at: EndBlock+1 put: 1.	litCount _ 0.	matchCount _ 0.! !!ZipWriteStream methodsFor: 'initialize-release' stamp: 'ar 1/2/2000 17:23'!on: aCollectionOrStream	encoder _ ZipEncoder on: aCollectionOrStream.	encoder isBinary		ifTrue:[super on: ByteArray new]		ifFalse:[super on: String new]! !!ZipWriteStream methodsFor: 'initialize-release' stamp: 'ar 12/30/1999 00:39'!release	"We're done with compression. Do some cleanup."	literals _ distances _ literalFreq _ distanceFreq _ nil.! !!ZipWriteStream methodsFor: 'accessing' stamp: 'ar 12/30/1999 00:37'!encodedStream	^encoder encodedStream! !!ZipWriteStream methodsFor: 'accessing' stamp: 'ar 12/29/1999 18:32'!forcedMethod	"Return a symbol describing an enforced method or nil if the method should	be chosen adaptively. Valid symbols are		#stored	- store blocks (do not compress)		#fixed	- use fixed huffman trees		#dynamic	- use dynamic huffman trees."	^nil! !!ZipWriteStream methodsFor: 'deflating' stamp: 'ar 12/30/1999 14:27'!deflateBlock: lastIndex chainLength: chainLength goodMatch: goodMatch	"^DeflatePlugin doPrimitive:#primitiveDeflateBlock"	<primitive:'primitiveDeflateBlock'>	^super deflateBlock: lastIndex chainLength: chainLength goodMatch: goodMatch! !!ZipWriteStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:05'!encodeLiteral: lit	"Encode the given literal"	litCount _ litCount + 1.	literals at: litCount put: lit.	distances at: litCount put: 0.	literalFreq at: lit+1 put: (literalFreq at: lit+1) + 1.	^self shouldFlush! !!ZipWriteStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:05'!encodeMatch: length distance: dist	"Encode the given match of length length starting at dist bytes ahead"	| literal distance |	dist > 0 		ifFalse:[^self error:'Distance must be positive'].	length < MinMatch 		ifTrue:[^self error:'Match length must be at least ', MinMatch printString].	litCount _ litCount + 1.	matchCount _ matchCount + 1.	literals at: litCount put: length - MinMatch.	distances at: litCount put: dist.	literal _ (MatchLengthCodes at: length - MinMatch + 1).	literalFreq at: literal+1 put: (literalFreq at: literal+1) + 1.	dist < 257		ifTrue:[distance _ DistanceCodes at: dist]		ifFalse:[distance _ DistanceCodes at: 257 + (dist - 1 bitShift: -7)].	distanceFreq at: distance+1 put: (distanceFreq at: distance+1) + 1.	^self shouldFlush! !!ZipWriteStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:08'!flushBlock	^self flushBlock: false! !!ZipWriteStream methodsFor: 'encoding' stamp: 'ar 12/30/1999 11:54'!flushBlock: lastBlock	"Send the current block"	| lastFlag bitsRequired method bitsSent	storedLength fixedLength dynamicLength 	blTree lTree dTree blBits blFreq |	lastFlag _ lastBlock ifTrue:[1] ifFalse:[0].	"Compute the literal/length and distance tree"	lTree _ ZipEncoderTree buildTreeFrom: literalFreq maxDepth: MaxBits.	dTree _ ZipEncoderTree buildTreeFrom: distanceFreq maxDepth: MaxBits.	"Compute the bit length tree"	blBits _ lTree bitLengths, dTree bitLengths.	blFreq _ WordArray new: MaxBitLengthCodes.	self scanBitLengths: blBits into: blFreq.	blTree _ ZipEncoderTree buildTreeFrom: blFreq maxDepth: MaxBitLengthBits.	"Compute the bit length for the current block.	Note: Most of this could be computed on the fly but it's getting	really ugly in this case so we do it afterwards."	storedLength _ self storedBlockSize.	fixedLength _ self fixedBlockSizeFor: lTree and: dTree.	dynamicLength _ self dynamicBlockSizeFor: lTree and: dTree 							using: blTree and: blFreq.	VerboseLevel > 1 ifTrue:[		Transcript cr; show:'Block sizes (S/F/D):';			space; print: storedLength // 8; 			nextPut:$/; print: fixedLength // 8; 			nextPut:$/; print: dynamicLength // 8; space; endEntry].	"Check which method to use"	method _ self forcedMethod.	method == nil ifTrue:[		method _ (storedLength < fixedLength and:[storedLength < dynamicLength]) 			ifTrue:[#stored]			ifFalse:[fixedLength < dynamicLength ifTrue:[#fixed] ifFalse:[#dynamic]]].	(method == #stored and:[blockStart < 0]) ifTrue:[		"Cannot use #stored if the block is not available"		method _ fixedLength < dynamicLength ifTrue:[#fixed] ifFalse:[#dynamic]].	bitsSent _ encoder bitPosition. "# of bits sent before this block"	bitsRequired _ nil.	(method == #stored) ifTrue:[		VerboseLevel > 0 ifTrue:[Transcript show:'S'].		bitsRequired _ storedLength.		encoder nextBits: 3 put: StoredBlock << 1 + lastFlag.		self sendStoredBlock].	(method == #fixed) ifTrue:[		VerboseLevel > 0 ifTrue:[Transcript show:'F'].		bitsRequired _ fixedLength.		encoder nextBits: 3 put: FixedBlock << 1 + lastFlag.		self sendFixedBlock].	(method == #dynamic) ifTrue:[		VerboseLevel > 0 ifTrue:[Transcript show:'D'].		bitsRequired _ dynamicLength.		encoder nextBits: 3 put: DynamicBlock << 1 + lastFlag.		self sendDynamicBlock: blTree 			literalTree: lTree 			distanceTree: dTree 			bitLengths: blBits].	bitsRequired = (encoder bitPosition - bitsSent)		ifFalse:[self error:'Bits size mismatch'].	lastBlock 		ifTrue:[self release]		ifFalse:[self initializeNewBlock].! !!ZipWriteStream methodsFor: 'encoding' stamp: 'ar 12/29/1999 18:08'!shouldFlush	"Check if we should flush the current block.	Flushing can be useful if the input characteristics change."	| nLits |	litCount = literals size ifTrue:[^true]. "We *must* flush"	(litCount bitAnd: 16rFFF) = 0 ifFalse:[^false]. "Only check every N kbytes"	matchCount * 10 <= litCount ifTrue:[		"This is basically random data. 		There is no need to flush early since the overhead		for encoding the trees will add to the overall size"		^false].	"Try to adapt to the input data.	We flush if the ratio between matches and literals	changes beyound a certain threshold"	nLits _ litCount - matchCount.	nLits <= matchCount ifTrue:[^false]. "whow!! so many matches"	^nLits * 4 <= matchCount! !!ZipWriteStream methodsFor: 'stored blocks' stamp: 'ar 1/2/2000 16:36'!sendStoredBlock	"Send an uncompressed block"	| inBytes |	inBytes _ blockPosition - blockStart.	encoder flushBits. "Skip to byte boundary"	encoder nextBits: 16 put: inBytes.	encoder nextBits: 16 put: (inBytes bitXor: 16rFFFF).	encoder flushBits.	1 to: inBytes do:[:i|		encoder nextBytePut: (collection byteAt: blockStart+i)].! !!ZipWriteStream methodsFor: 'stored blocks' stamp: 'ar 12/30/1999 00:42'!storedBlockSize	"Compute the length for the current block when stored as is"	^3 "block type bits" 		+ (8 - (encoder bitPosition + 3 bitAnd: 7) bitAnd: 7)"skipped bits to byte boundary"			+ 32 "byte length + chksum" 				+ (blockPosition - blockStart * 8) "actual data bits".! !!ZipWriteStream methodsFor: 'fixed blocks' stamp: 'ar 12/29/1999 18:18'!fixedBlockSizeFor: lTree and: dTree	"Compute the length for the current block using fixed huffman trees"	| bits extra |	bits _ 3 "block type".	"Compute the size of the compressed block"	0 to: NumLiterals do:[:i| "encoding of literals"		bits _ bits + ((literalFreq at: i+1) * (FixedLiteralTree bitLengthAt: i))].	NumLiterals+1 to: lTree maxCode+1 do:[:i| "Encoding of match lengths"		extra _ ExtraLengthBits at: i-NumLiterals.		bits _ bits + ((literalFreq at: i+1) * ((FixedLiteralTree bitLengthAt: i) + extra))].	0 to: dTree maxCode do:[:i| "encoding of distances"		extra _ ExtraDistanceBits at: i+1.		bits _ bits + ((distanceFreq at: i+1) * ((FixedDistanceTree bitLengthAt: i) + extra))].	^bits! !!ZipWriteStream methodsFor: 'fixed blocks' stamp: 'ar 12/29/1999 18:18'!sendFixedBlock	"Send a block using fixed huffman trees"	self sendCompressedBlock: FixedLiteralTree with: FixedDistanceTree.! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 01:55'!dynamicBlockSizeFor: lTree and: dTree using: blTree and: blFreq	"Compute the length for the current block using dynamic huffman trees"	| bits index extra treeBits freq |	bits _ 3 "block type" + 5 "literal codes length" + 5 "distance codes length".	"Compute the # of bits for sending the bit length tree"	treeBits _ 4. "Max index for bit length tree"	index _ MaxBitLengthCodes.	[index >= 4] whileTrue:[		(index = 4 or:[(blFreq at: (BitLengthOrder at: index)+1) > 0])			ifTrue:[treeBits _ treeBits + (index * 3).					index _ -1]			ifFalse:[index _ index - 1]].	"Compute the # of bits for sending the literal/distance tree.	Note: The frequency are already stored in the blTree"	0 to: 15 do:[:i| "First, the non-repeating values"		freq _ blFreq at: i+1.		freq > 0 ifTrue:[treeBits _ treeBits + (freq * (blTree bitLengthAt: i))]].	"Now the repeating values"	(Repeat3To6 to: Repeat11To138) with: #(2 3 7) do:[:i :addl|		freq _ blFreq at: i+1.		freq > 0 ifTrue:[			treeBits _ treeBits + (freq * ((blTree bitLengthAt: i) + addl "addl bits"))]].	VerboseLevel > 1 ifTrue:[		Transcript show:'['; print: treeBits; show:' bits for dynamic tree]'].	bits _ bits + treeBits.	"Compute the size of the compressed block"	0 to: NumLiterals do:[:i| "encoding of literals"		freq _ literalFreq at: i+1.		freq > 0 ifTrue:[bits _ bits + (freq * (lTree bitLengthAt: i))]].	NumLiterals+1 to: lTree maxCode do:[:i| "encoding of match lengths"		freq _ literalFreq at: i+1.		extra _ ExtraLengthBits at: i-NumLiterals.		freq > 0 ifTrue:[bits _ bits + (freq * ((lTree bitLengthAt: i) + extra))]].	0 to: dTree maxCode do:[:i| "encoding of distances"		freq _ distanceFreq at: i+1.		extra _ ExtraDistanceBits at: i+1.		freq > 0 ifTrue:[bits _ bits + (freq * ((dTree bitLengthAt: i) + extra))]].	^bits! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:55'!scanBitLength: bitLength repeatCount: repeatCount into: anArray	"Update the frequency for the aTree based on the given values"	| count |	count _ repeatCount.	bitLength = 0 ifTrue:[		[count >= 11] whileTrue:[			anArray at: Repeat11To138+1 put: (anArray at: Repeat11To138+1) + 1.			count _ (count - 138) max: 0].		[count >= 3] whileTrue:[			anArray at: Repeat3To10+1 put: (anArray at: Repeat3To10+1) + 1.			count _ (count - 10) max: 0].		count > 0 ifTrue:[anArray at: bitLength+1 put: (anArray at: bitLength+1) + count].	] ifFalse:[		anArray at: bitLength+1 put: (anArray at: bitLength+1) + 1.		count _ count - 1.		[count >= 3] whileTrue:[			anArray at: Repeat3To6+1 put: (anArray at: Repeat3To6+1) + 1.			count _ (count - 6) max: 0].		count > 0 ifTrue:[anArray at: bitLength+1 put: (anArray at: bitLength+1) + count].	].! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:55'!scanBitLengths: bits into: anArray	"Scan the trees and determine the frequency of the bit lengths.	For repeating codes, emit a repeat count."	| lastValue lastCount value |	bits size = 0 ifTrue:[^self].	lastValue _ bits at: 1.	lastCount _ 1.	2 to: bits size do:[:i|		value _ bits at: i.		value = lastValue 			ifTrue:[lastCount _ lastCount + 1]			ifFalse:[self scanBitLength: lastValue repeatCount: lastCount into: anArray.					lastValue _ value.					lastCount _ 1]].	self scanBitLength: lastValue repeatCount: lastCount into: anArray.! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:40'!sendBitLength: bitLength repeatCount: repeatCount tree: aTree	"Send the given bitLength, repeating repeatCount times"	| count |	count _ repeatCount.	bitLength = 0 ifTrue:[		[count >= 11] whileTrue:[			self sendBitLength: Repeat11To138 tree: aTree.			encoder nextBits: 7 put: (count min: 138) - 11.			count _ (count - 138) max: 0].		[count >= 3] whileTrue:[			self sendBitLength: Repeat3To10 tree: aTree.			encoder nextBits: 3 put: (count min: 10) - 3.			count _ (count - 10) max: 0].		count timesRepeat:[self sendBitLength: bitLength tree: aTree].	] ifFalse:[		self sendBitLength: bitLength tree: aTree.		count _ count - 1.		[count >= 3] whileTrue:[			self sendBitLength: Repeat3To6 tree: aTree.			encoder nextBits: 2 put: (count min: 6) - 3.			count _ (count - 6) max: 0].		count timesRepeat:[self sendBitLength: bitLength tree: aTree].	].! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:40'!sendBitLength: bitLength tree: aTree	"Send the given bitLength"	encoder nextBits: (aTree bitLengthAt: bitLength) 		put: (aTree codeAt: bitLength).! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:40'!sendBitLengthTree: blTree	"Send the bit length tree"	| blIndex bitLength |	MaxBitLengthCodes to: 4 by: -1 do:[:maxIndex|		blIndex _ BitLengthOrder at: maxIndex.		bitLength _ blIndex <= blTree maxCode 			ifTrue:[blTree bitLengthAt: blIndex] ifFalse:[0].		(maxIndex = 4 or:[bitLength > 0]) ifTrue:[			encoder nextBits: 4 put: maxIndex - 4.			1 to: maxIndex do:[:j|				blIndex _ BitLengthOrder at: j.				bitLength _ blIndex <= blTree maxCode 					ifTrue:[blTree bitLengthAt: blIndex] ifFalse:[0].				encoder nextBits: 3 put: bitLength].			^self]].! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 00:48'!sendCompressedBlock: litTree with: distTree	"Send the current block using the encodings from the given literal/length and distance tree"	| sum |	sum _ encoder			sendBlock: (ReadStream on: literals from: 1 to: litCount)			with: (ReadStream on: distances from: 1 to: litCount)			with: litTree			with: distTree.	sum = (blockPosition - blockStart) ifFalse:[self error:'Wrong number of bytes'].! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/29/1999 18:19'!sendDynamicBlock: blTree literalTree: lTree distanceTree: dTree bitLengths: bits	"Send a block using dynamic huffman trees"	self sendLiteralTree: lTree distanceTree: dTree using: blTree bitLengths: bits.	self sendCompressedBlock: lTree with: dTree.! !!ZipWriteStream methodsFor: 'dynamic blocks' stamp: 'ar 12/30/1999 11:40'!sendLiteralTree: lTree distanceTree: dTree using: blTree bitLengths: bits	"Send all the trees needed for dynamic huffman tree encoding"	| lastValue lastCount value |	encoder nextBits: 5 put: (lTree maxCode - 256).	encoder nextBits: 5 put: (dTree maxCode).	self sendBitLengthTree: blTree.	bits size = 0 ifTrue:[^self].	lastValue _ bits at: 1.	lastCount _ 1.	2 to: bits size do:[:i|		value _ bits at: i.		value = lastValue 			ifTrue:[lastCount _ lastCount + 1]			ifFalse:[self sendBitLength: lastValue repeatCount: lastCount tree: blTree.					lastValue _ value.					lastCount _ 1]].	self sendBitLength: lastValue repeatCount: lastCount tree: blTree.! !!ZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 12/30/1999 00:31'!initialize	"ZipWriteStream initialize"	#(		MaxBits MaxBitLengthBits EndBlock		StoredBlock FixedBlock DynamicBlock 		NumLiterals MaxLengthCodes MaxDistCodes MaxBitLengthCodes MaxLiteralCodes		Repeat3To6 Repeat3To10 Repeat11To138		ExtraLengthBits ExtraDistanceBits ExtraBitLengthBits BitLengthOrder		BaseLength MatchLengthCodes BaseDistance DistanceCodes 		FixedLiteralTree FixedDistanceTree	) do:[:sym|		ZipConstants declare: sym from: Undeclared.	].	VerboseLevel _ 0.	MaxBits _ 15.	MaxBitLengthBits _ 7.	EndBlock _ 256.	StoredBlock _ 0.	FixedBlock _ 1.	DynamicBlock _ 2.	NumLiterals _ 256.	MaxLengthCodes _ 29.	MaxDistCodes _ 30.	MaxBitLengthCodes _ 19.	MaxLiteralCodes _ NumLiterals + MaxLengthCodes + 1. "+ End of Block"	Repeat3To6 _ 16. "Repeat previous bit length 3-6 times (2 bits repeat count)"	Repeat3To10 _ 17. "Repeat previous bit length 3-10 times (3 bits repeat count)"	Repeat11To138 _ 18. "Repeat previous bit length 11-138 times (7 bits repeat count)"	self initializeExtraBits.	self initializeLengthCodes.	self initializeDistanceCodes.	self initializeFixedTrees.! !!ZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 12/29/1999 18:26'!initializeDistanceCodes	| dist |	BaseDistance _ WordArray new: MaxDistCodes.	DistanceCodes _ WordArray new: 512.	dist _ 0.	1 to: 16 do:[:code|		BaseDistance at: code put: dist.		1 to: (1 bitShift: (ExtraDistanceBits at: code)) do:[:n|			dist _ dist + 1.			DistanceCodes at: dist put: code-1]].	dist = 256 ifFalse:[self error:'Whoops?!!'].	dist _ dist >> 7.	17 to: MaxDistCodes do:[:code|		BaseDistance at: code put: dist << 7.		1 to: (1 bitShift: (ExtraDistanceBits at: code)-7) do:[:n|			dist _ dist + 1.			DistanceCodes at: 256 + dist put: code-1]].! !!ZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 12/29/1999 18:27'!initializeExtraBits	ExtraLengthBits _ 		WordArray withAll: #(0 0 0 0 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 0).	ExtraDistanceBits _ 		WordArray withAll: #(0 0 0 0 1 1 2 2 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10 10 11 11 12 12 13 13).	ExtraBitLengthBits _ 		WordArray withAll: #(0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 2 3 7).	BitLengthOrder _		WordArray withAll: #(16 17 18 0 8 7 9 6 10 5 11 4 12 3 13 2 14 1 15).! !!ZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 12/30/1999 14:25'!initializeFixedTrees	"ZipWriteStream initializeFixedTrees"	| counts nodes |	FixedLiteralTree _ ZipEncoderTree new.	FixedLiteralTree maxCode: 287.	counts _ WordArray new: MaxBits+1.	counts at: 7+1 put: 24.	counts at: 8+1 put: 144+8.	counts at: 9+1 put: 112.	nodes _ Array new: 288.	1 to: 288 do:[:i| nodes at: i put: (ZipEncoderNode value: i-1 frequency: 0 height: 0)].	0 to: 143 do:[:i| (nodes at: i+1) setBitLengthTo: 8].	144 to: 255 do:[:i| (nodes at: i+1) setBitLengthTo: 9].	256 to: 279 do:[:i| (nodes at: i+1) setBitLengthTo: 7].	280 to: 287 do:[:i| (nodes at: i+1) setBitLengthTo: 8].	FixedLiteralTree buildCodes: nodes counts: counts maxDepth: MaxBits.	FixedLiteralTree setValuesFrom: nodes.	FixedDistanceTree _ ZipEncoderTree new.	FixedDistanceTree maxCode: MaxDistCodes.	FixedDistanceTree		bitLengths: ((WordArray new: MaxDistCodes+1) atAllPut: 5)		codes: ((0 to: MaxDistCodes) collect:[:i| FixedDistanceTree reverseBits: i length: 5]).! !!ZipWriteStream class methodsFor: 'class initialization' stamp: 'ar 12/29/1999 18:26'!initializeLengthCodes	| length |	BaseLength _ WordArray new: MaxLengthCodes.	MatchLengthCodes _ WordArray new: MaxMatch - MinMatch + 1.	length _ 0.	1 to: MaxLengthCodes - 1 do:[:code|		BaseLength at: code put: length.		1 to: (1 bitShift: (ExtraLengthBits at: code)) do:[:n|			length _ length + 1.			MatchLengthCodes at: length put: NumLiterals + code]].! !!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/30/1999 15:55'!baseDistance	^BaseDistance! !!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/30/1999 15:55'!baseLength	^BaseLength! !!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:42'!distanceCodes	^DistanceCodes! !!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/30/1999 15:55'!extraDistanceBits	^ExtraDistanceBits! !!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/30/1999 15:55'!extraLengthBits	^ExtraLengthBits! !!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:42'!matchLengthCodes	^MatchLengthCodes! !!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:53'!maxDistanceCodes	^MaxDistCodes! !!ZipWriteStream class methodsFor: 'accessing' stamp: 'ar 12/29/1999 20:53'!maxLiteralCodes	^MaxLiteralCodes! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ar 12/29/1999 23:48'!compressAndDecompress: aFile using: tempName stats: stats	| fileSize tempFile result |	aFile == nil ifTrue:[^nil].	fileSize _ aFile size.	(fileSize < 1"00000" "or:[fileSize > 1000000]") ifTrue:[aFile close. ^nil].	Transcript cr; show:'Testing ', aFile name,' ... '.	tempFile _ StandardFileStream new open: tempName forWrite: true.	'Compressing ', aFile name,'...' displayProgressAt: Sensor cursorPoint		from: 1 to: aFile size during:[:bar|			result _ self regressionCompress: aFile into: tempFile notifiying: bar stats: stats].	result ifTrue:[		'Validating ', aFile name,'...' displayProgressAt: Sensor cursorPoint			from: 0 to: aFile size during:[:bar|				result _ self regressionDecompress: aFile from: tempFile notifying: bar stats: stats]].	aFile close.	tempFile close.	FileDirectory default deleteFileNamed: tempName ifAbsent:[].	result ~~ false ifTrue:[		Transcript show:' ok (', (result * 100 truncateTo: 0.01) printString,')'].	^result! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ar 12/29/1999 21:11'!logProblem: reason for: aFile	| errFile |	errFile _ FileStream fileNamed:'problems.log'.	errFile position: errFile size.	errFile cr; nextPutAll: aFile name;			cr; nextPutAll: reason.	errFile close.	Transcript show:' failed (', reason,')'.	aFile close.	^false! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ar 12/31/1999 17:48'!printRegressionStats: stats from: fd	| raw compressed numFiles |	raw _ stats at: #rawSize ifAbsent:[0].	raw = 0 ifTrue:[^self].	compressed _ stats at: #compressedSize ifAbsent:[0].	numFiles _ stats at: #numFiles ifAbsent:[0].	Transcript cr; nextPutAll: fd pathName.	Transcript crtab; nextPutAll:'Files compressed: ', numFiles asStringWithCommas.	Transcript crtab; nextPutAll:'Bytes compressed: ', raw asStringWithCommas.	Transcript crtab; nextPutAll:'Avg. compression ratio: ';		print: ((compressed / raw asFloat * 100.0) truncateTo: 0.01).	Transcript endEntry.! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ar 12/29/1999 23:44'!regressionCompress: aFile into: tempFile notifiying: progressBar stats: stats	"Compress aFile into tempFile"	| zip encoded buffer |	aFile binary.	aFile position: 0.	tempFile binary.	buffer _ ByteArray new: 4096.	zip _ self on: (ByteArray new: 10000).	encoded _ zip encodedStream.	[aFile atEnd] whileFalse:[		progressBar value: aFile position.		zip nextPutAll: (aFile nextInto: buffer).		encoded position > 0 ifTrue:[			tempFile nextPutAll: encoded contents.			encoded position: 0]].	zip close.	tempFile nextPutAll: encoded contents.	^true! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ar 12/29/1999 23:45'!regressionDecompress: aFile from: tempFile notifying: progressBar stats: stats	"Validate aFile as decompressed from tempFile"	| unzip rawSize compressedSize buffer1 buffer2 |	rawSize _ aFile size.	compressedSize _ tempFile size.	aFile ascii.	aFile position: 0.	tempFile ascii.	tempFile position: 0.	buffer1 _ String new: 4096.	buffer2 _ buffer1 copy.	unzip _ FastInflateStream on: tempFile.	[aFile atEnd] whileFalse:[		progressBar value: aFile position.		buffer1 _ aFile nextInto: buffer1.		buffer2 _ unzip nextInto: buffer2.		buffer1 = buffer2			ifFalse:[^self logProblem: 'contents ' for: aFile].	].	unzip next = nil ifFalse:[^self logProblem: 'EOF' for: aFile].	stats at: #rawSize put:		(stats at: #rawSize ifAbsent:[0]) + rawSize.	stats at: #compressedSize put:		(stats at: #compressedSize ifAbsent:[0]) + compressedSize.	^compressedSize asFloat / rawSize asFloat.! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ar 12/31/1999 17:48'!regressionTest "ZipWriteStream regressionTest"	"Compress and decompress everything we can 	find to validate that compression works as expected."	self regressionTestFrom: (FileDirectory default).! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ar 12/29/1999 23:46'!regressionTestFrom: fd	"ZipWriteStream regressionTestFrom: FileDirectory default"	"ZipWriteStream regressionTestFrom: (FileDirectory on:'')"	"ZipWriteStream regressionTestFrom: (FileDirectory on:'C:')"	| tempName stats |	Transcript clear.	stats _ Dictionary new.	tempName _ FileDirectory default fullNameFor: '$$sqcompress$$'.	FileDirectory default deleteFileNamed: tempName.	self regressionTestFrom: fd using: tempName stats: stats.! !!ZipWriteStream class methodsFor: 'regression test' stamp: 'ar 12/31/1999 17:47'!regressionTestFrom: fd using: tempName stats: stats	| files file fullName |	files _ fd fileNames asSortedCollection.	files do:[:fName|		file _ nil.		fullName _ fd fullNameFor: fName.		fullName = tempName ifFalse:[			file _ StandardFileStream new open: fullName forWrite: false].		self compressAndDecompress: file using: tempName stats: stats].	stats at: #numFiles put: (stats at: #numFiles ifAbsent:[0]) + files size.	files _ nil.	self printRegressionStats: stats from: fd.	fd directoryNames asSortedCollection do:[:dName|		self regressionTestFrom: (fd directoryNamed: dName) using: tempName stats: stats.	].! !----STARTUP----#(4 January 2004 11:02:43 am) as Sackbut:Desktop Folder:MIT Squeak:MITBase.image!Smalltalk condenseChanges!----QUIT----#(4 January 2004 11:04:26 am) priorSource: 3894888!----STARTUP----#(4 January 2004 11:04:35 am) as Sackbut:Desktop Folder:MIT Squeak:MITBase.image!Smalltalk obsoleteBehaviors inspect!DependentsFields!Smalltalk removeAllLineFeeds!Smalltalk testDecompiler!Smalltalk verifyChanges!----STARTUP----#(4 January 2004 4:10:51 pm) as Sackbut:Desktop Folder:MIT Squeak:MITBase.image!p _ SerialPort new baudRate: 19200.!p!SimpleMIDIPort inputPortNumFromUser!p openPort: 1!buf _ ByteArray new: 10.!count _ p readInto: buf startingAt: 1.!p readInto: buf startingAt: 1.!p nextPutAll: (ByteArray with: 255).!p readInto: buf startingAt: 1.!buf!p readInto: buf startingAt: 1.!p readInto: buf startingAt: 1.!p nextPutAll: (ByteArray with: 255).!p readInto: buf startingAt: 1.!buf !p readInto: buf startingAt: 1.!p readInto: buf startingAt: 1.!p nextPutAll: (ByteArray with: 255).!p readInto: buf startingAt: 1.!p readInto: buf startingAt: 1.!buf!p readInto: buf startingAt: 1.!p nextPutAll: (ByteArray with: 255).!p readInto: buf startingAt: 1.!p readInto: buf startingAt: 1.!buf!buf!p readInto: buf startingAt: 1.!buf!buf _ ByteArray new: 4.p nextPutAll: (ByteArray with: 255).p readInto: buf startingAt: 1.!p readInto: buf startingAt: 1.!buf!buf _ ByteArray new: 4.p nextPutAll: (ByteArray with: 255).(Delay forMilliseconds: 100) wait.p readInto: buf startingAt: 1.!buf!buf _ ByteArray new: 4.p nextPutAll: (ByteArray with: 255).(Delay forMilliseconds: 100) wait.p readInto: buf startingAt: 1.!buf!buf _ ByteArray new: 4.p nextPutAll: (ByteArray with: 255).(Delay forMilliseconds: 100) wait.p readInto: buf startingAt: 1.!buf!buf _ ByteArray new: 10.4 timesRepeat: [	p nextPutAll: (ByteArray with: 255).	(Delay forMilliseconds: 50) wait].(Delay forMilliseconds: 100) wait.p readInto: buf startingAt: 1.!buf!p!p readInto: buf startingAt: 1.!buf!p readInto: buf startingAt: 1.!buf _ ByteArray new: 10.4 timesRepeat: [	p nextPutAll: (ByteArray with: 255).	(Delay forMilliseconds: 50) wait].(Delay forMilliseconds: 100) wait.p readInto: buf startingAt: 1.!buf!buf _ ByteArray new: 10.4 timesRepeat: [	p nextPutAll: (ByteArray with: 255).	(Delay forMilliseconds: 50) wait].(Delay forMilliseconds: 100) wait.p readInto: buf startingAt: 1.!buf!buf _ ByteArray new: 10.4 timesRepeat: [	p nextPutAll: (ByteArray with: 255).	(Delay forMilliseconds: 50) wait].(Delay forMilliseconds: 100) wait.p readInto: buf startingAt: 1.!buf!p close!p _ SerialPort new baudRate: 9600.!p openPort: 1.!buf _ ByteArray new: 10.!	p nextPutAll: (ByteArray with: 255).!p readInto: buf startingAt: 1.!	p nextPutAll: (ByteArray with: 255).!p readInto: buf startingAt: 1.!p close!p close!p openPort: 1.!p close!p _ SerialPort new baudRate: 19200.!p openPort: 1.!buf _ ByteArray new: 10.4 timesRepeat: [	p nextPutAll: (ByteArray with: 255).	(Delay forMilliseconds: 50) wait].(Delay forMilliseconds: 100) wait.p readInto: buf startingAt: 1.!buf!p readInto: buf startingAt: 1.!buf!p readInto: buf startingAt: 1.!p readInto: buf startingAt: 1.!p readInto: buf startingAt: 1.!p readInto: buf startingAt: 1.!p close!p openPort: 1.!p readInto: buf startingAt: 1.!	p nextPutAll: (ByteArray with: 255).!p readInto: buf startingAt: 1.!buf!buf _ ByteArray new: 10.!buf _ ByteArray new: 10.4 timesRepeat: [	p nextPutAll: (ByteArray with: 255).	(Delay forMilliseconds: 50) wait].(Delay forMilliseconds: 100) wait.p readInto: buf startingAt: 1.!buf!p readInto: buf startingAt: 1.!buf _ ByteArray new: 10.4 timesRepeat: [	p nextPutAll: (ByteArray with: 255).	(Delay forMilliseconds: 50) wait].(Delay forMilliseconds: 100) wait.p readInto: buf startingAt: 1.!buf!buf _ ByteArray new: 10.4 timesRepeat: [	p nextPutAll: (ByteArray with: 255).	(Delay forMilliseconds: 50) wait].(Delay forMilliseconds: 100) wait.p readInto: buf startingAt: 1.!buf!buf _ ByteArray new: 10.10 timesRepeat: [	p nextPutAll: (ByteArray with: 255).	(Delay forMilliseconds: 50) wait].(Delay forMilliseconds: 100) wait.p readInto: buf startingAt: 1.!buf!p close!----QUIT----#(4 January 2004 4:31:16 pm) priorSource: 3895015!----STARTUP----#(4 January 2004 8:49:56 pm) as Sackbut:Desktop Folder:MIT Squeak:MITBase.image!ScratchFrameMorph open!!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'jm 1/4/2004 20:52' prior: 36499840!blockFromSpec: spec	"Create a block from the given block specification. Answer nil if I don't implement the block spec selector."	| blockLabelSpec blockType selector block |	blockLabelSpec _ spec at: 1.	blockType _ spec at: 2.	selector _ (spec at: 3) asSymbol."This needs work; was filtering out blocks such as 'not' and 'wait':	((blockType includes: $s) or:	 [selector isInfix or:	 [self blockReceiver respondsTo: selector]]) ifFalse: [^ nil]."	"basic block type: normal or C-shaped"	(blockType includes: $c)		ifTrue:	[block _ CBlockMorph new]		ifFalse:	[block _ CommandBlockMorph new].	block isReporter: (blockType includes: $r).	block isSpecialForm: (blockType includes: $s).	block isTimed: (blockType includes: $t).	(blockType includes: $u) ifFalse: [  "wants owner name"		block wantsName: true.		block isReporter ifTrue: [block wantsPossession: true]].	^ block		commandSpec: blockLabelSpec;		selector: selector;		receiver: self! !!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'jm 1/4/2004 20:55' prior: 37453959!blockFromSpec: spec	"Create a block from the given block specification. Answer nil if I don't implement the block spec selector."	| blockLabelSpec blockType selector block |	blockLabelSpec _ spec at: 1.	blockType _ spec at: 2.	selector _ (spec at: 3) asSymbol."This needs work; it was filtering out blocks such as 'not' and 'wait':	((blockType includes: $s) or:	 [selector isInfix or:	 [self blockReceiver respondsTo: selector]]) ifFalse: [^ nil]."	"basic block type: normal or C-shaped"	(blockType includes: $c)		ifTrue:	[block _ CBlockMorph new]		ifFalse:	[block _ CommandBlockMorph new].	block isReporter: (blockType includes: $r).	block isSpecialForm: (blockType includes: $s).	block isTimed: (blockType includes: $t).	(blockType includes: $u) ifFalse: [  "wants owner name"		block wantsName: true.		block isReporter ifTrue: [block wantsPossession: true]].	^ block		commandSpec: blockLabelSpec;		selector: selector;		receiver: self! !!ScriptableScratchMorph class methodsFor: 'scratch' stamp: 'jm 1/4/2004 20:56' prior: 36509911!genericBlockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector>).	Explanation of flags:		-	no flags		c	c-shaped block containing a sequence of commands		r	reporter		s	special form with own evaluation rule		t	timed command, like wait or glide		u	unnamed block (neither possessive ('s) nor ask ('name,') forms)"	^ #(		'control'			('if %b'				csu	doIf)			('forever'			csu	doForever)			('repeat %n'			csu	doRepeat)			('while %b'			csu	doWhile)			('wait until %b'		su	doWaitUntil)			('done'				su	doReturn)			('answer %n'		su	doReturn)			('wait %n secs'		tu	wait:elapsed:from:)"xxx  comment these out for now:			('monitor %n %n'	rsu	doMonitor)			('ask %m to'			csu	doAsk)xxx"		'math'			('%n + %n'			ru	+)			('%n - %n'			ru	-)			('%n * %n'			ru	*)			('%n / %n'			ru	/)			('abs %n'			ru	absoluteValue:)			('%n mod %n'		ru	\\)			('%n < %n'			ru	<)			('%n = %n'			ru	=)			('%n > %n'			ru	>)		'math2'			('%b and %b'		ru	&)			('%b or %b'			ru	|)			('not %b'			ru	not)			('random from %n to %n'	ru	randomFrom:to:)			('point x %n y %n'	ru	@)		'mouse/keyboard'			('mouse pressed?'	ru	mousePressed)			('mouse position'	ru	mousePosition)			('mouse x'			ru	mouseX)			('mouse y'			ru	mouseY)			('mouse touching'	ru	mouseTouching)			('key available?'	ru	isKeyAvailable)			('get key'			ru	getKey)		'other'			('timer'				ru	timer)			('timer reset'		u	timerReset)			('copy'				r	doCopy)			('load %s'			-	loadFile:)			('save %s'			-	saveFile:)	).! !ScratchFrameMorph open!!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'jm 1/4/2004 21:04' prior: 36501736!variablesPage	"Answer a morph containing my variables."	| bin y w setter setButton b |	bin _ PasteUpMorph new		color: (Color gray: 0.9);		borderWidth: 0;		isPartsBin: true;		enableDragNDrop: false.	setButton _ SimpleButtonMorph new		label: 'set';		actWhen: #buttonUp;		target: self blockReceiver;		actionSelector: #makeSetterFor:.	y _ 4.	"built in variables"	self builtinVars do: [:varName |		b _ setButton fullCopy			arguments: (Array with: varName);			position: 5@(y + 4).		w _ WatcherMorph new			layoutAsArgument;			target: self blockReceiver getSelector: varName.		setter _ (varName, ':') asSymbol.		(self blockReceiver respondsTo: setter) ifTrue: [			bin addMorphBack: b.			w putSelector: setter].		w position: 34@y.		bin addMorphBack: w.		y _ y + w height + 2].	"user variables"	self userVars do: [:varName |		b _ setButton fullCopy			arguments: (Array with: varName);			position: 5@(y + 4).		bin addMorphBack: b.		w _ WatcherMorph new			target: self blockReceiver getSelector: #getUserVar: varName: varName;			putSelector: #setUserVar:to:.		w position: 34@y.		bin addMorphBack: w.		y _ y + w height + 2].	^ bin! !!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'jm 1/4/2004 21:04' prior: 37457891!variablesPage	"Answer a morph containing my variables."	| bin y w setter setButton b |	bin _ PasteUpMorph new		color: (Color gray: 0.9);		borderWidth: 0;		isPartsBin: true;		enableDragNDrop: false.	setButton _ SimpleButtonMorph new		label: 'set';		actWhen: #buttonUp;		target: self blockReceiver;		actionSelector: #makeSetterFor:.	y _ 4.	"built in variables"	self builtinVars do: [:varName |		b _ setButton fullCopy			arguments: (Array with: varName);			position: 5@(y + 4).		w _ WatcherMorph new			layoutAsArgument;			target: self blockReceiver getSelector: varName.		setter _ (varName, ':') asSymbol.		(self blockReceiver respondsTo: setter) ifTrue: [			bin addMorphBack: b.			w putSelector: setter].		w position: 34@y.		bin addMorphBack: w.		y _ y + w height + 2].	"user variables"	self userVars do: [:varName |		b _ setButton fullCopy			arguments: (Array with: varName);			position: 5@(y + 4).		bin addMorphBack: b.		w _ WatcherMorph new			layoutAsArgument;			target: self blockReceiver getSelector: #getUserVar: varName: varName;			putSelector: #setUserVar:to:.		w position: 34@y.		bin addMorphBack: w.		y _ y + w height + 2].	^ bin! !!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'jm 1/4/2004 21:06' prior: 37459153!variablesPage	"Answer a morph containing my variables."	| bin y w setter setButton b |	bin _ PasteUpMorph new		color: (Color gray: 0.9);		borderWidth: 0;		isPartsBin: true;		enableDragNDrop: false.	setButton _ SimpleButtonMorph new		label: 'set';		actWhen: #buttonUp;		target: self blockReceiver;		actionSelector: #makeSetterFor:.	y _ 4.	"built in variables"	self builtinVars do: [:varName |		b _ setButton fullCopy			arguments: (Array with: varName);			position: 5@(y + 4).		w _ WatcherMorph new			target: self blockReceiver getSelector: varName;			layoutAsArgument.		setter _ (varName, ':') asSymbol.		(self blockReceiver respondsTo: setter) ifTrue: [			bin addMorphBack: b.			w putSelector: setter].		w position: 34@y.		bin addMorphBack: w.		y _ y + w height + 2].	"user variables"	self userVars do: [:varName |		b _ setButton fullCopy			arguments: (Array with: varName);			position: 5@(y + 4).		bin addMorphBack: b.		w _ WatcherMorph new			target: self blockReceiver getSelector: #getUserVar: varName: varName;			putSelector: #setUserVar:to:;			layoutAsArgument.		w position: 34@y.		bin addMorphBack: w.		y _ y + w height + 2].	^ bin! !!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'jm 1/4/2004 21:07' prior: 37460436!variablesPage	"Answer a morph containing my variables."	| bin y w setter setButton b |	bin _ PasteUpMorph new		color: (Color gray: 0.9);		borderWidth: 0;		isPartsBin: true;		enableDragNDrop: false.	setButton _ SimpleButtonMorph new		label: 'set';		actWhen: #buttonUp;		target: self blockReceiver;		actionSelector: #makeSetterFor:.	y _ 4.	"built in variables"	self builtinVars do: [:varName |		b _ setButton fullCopy			arguments: (Array with: varName);			position: 5@(y + 4).		w _ WatcherMorph new			target: self blockReceiver getSelector: varName;			layoutAsArgument.		setter _ (varName, ':') asSymbol.		(self blockReceiver respondsTo: setter) ifTrue: [			bin addMorphBack: b.			w putSelector: setter].		w position: 34@y.		bin addMorphBack: w.		y _ y + w height + 6].	"user variables"	self userVars do: [:varName |		b _ setButton fullCopy			arguments: (Array with: varName);			position: 5@(y + 4).		bin addMorphBack: b.		w _ WatcherMorph new			target: self blockReceiver getSelector: #getUserVar: varName: varName;			putSelector: #setUserVar:to:;			layoutAsArgument.		w position: 34@y.		bin addMorphBack: w.		y _ y + w height + 6].	^ bin! !!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'jm 1/4/2004 21:07' prior: 37461719!variablesPage	"Answer a morph containing my variables."	| bin y w setter setButton b |	bin _ PasteUpMorph new		color: (Color gray: 0.9);		borderWidth: 0;		isPartsBin: true;		enableDragNDrop: false.	setButton _ SimpleButtonMorph new		label: 'set';		actWhen: #buttonUp;		target: self blockReceiver;		actionSelector: #makeSetterFor:.	y _ 4.	"built in variables"	self builtinVars do: [:varName |		b _ setButton fullCopy			arguments: (Array with: varName);			position: 5@(y + 0).		w _ WatcherMorph new			target: self blockReceiver getSelector: varName;			layoutAsArgument.		setter _ (varName, ':') asSymbol.		(self blockReceiver respondsTo: setter) ifTrue: [			bin addMorphBack: b.			w putSelector: setter].		w position: 34@y.		bin addMorphBack: w.		y _ y + w height + 6].	"user variables"	self userVars do: [:varName |		b _ setButton fullCopy			arguments: (Array with: varName);			position: 5@(y + 0).		bin addMorphBack: b.		w _ WatcherMorph new			target: self blockReceiver getSelector: #getUserVar: varName: varName;			putSelector: #setUserVar:to:;			layoutAsArgument.		w position: 34@y.		bin addMorphBack: w.		y _ y + w height + 6].	^ bin! !!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'jm 1/4/2004 21:08' prior: 37463002!variablesPage	"Answer a morph containing my variables."	| bin y w setter setButton b |	bin _ PasteUpMorph new		color: (Color gray: 0.9);		borderWidth: 0;		isPartsBin: true;		enableDragNDrop: false.	setButton _ SimpleButtonMorph new		label: 'set';		actWhen: #buttonUp;		target: self blockReceiver;		actionSelector: #makeSetterFor:.	y _ 4.	"built in variables"	self builtinVars do: [:varName |		b _ setButton fullCopy			arguments: (Array with: varName);			position: 5@(y - 1).		w _ WatcherMorph new			target: self blockReceiver getSelector: varName;			layoutAsArgument.		setter _ (varName, ':') asSymbol.		(self blockReceiver respondsTo: setter) ifTrue: [			bin addMorphBack: b.			w putSelector: setter].		w position: 34@y.		bin addMorphBack: w.		y _ y + w height + 6].	"user variables"	self userVars do: [:varName |		b _ setButton fullCopy			arguments: (Array with: varName);			position: 5@(y - 1).		bin addMorphBack: b.		w _ WatcherMorph new			target: self blockReceiver getSelector: #getUserVar: varName: varName;			putSelector: #setUserVar:to:;			layoutAsArgument.		w position: 34@y.		bin addMorphBack: w.		y _ y + w height + 6].	^ bin! !!ScriptableScratchMorph methodsFor: 'blocks' stamp: 'jm 1/4/2004 21:09' prior: 37464285!variablesPage	"Answer a morph containing my variables."	| bin y w setter setButton b |	bin _ PasteUpMorph new		color: (Color gray: 0.9);		borderWidth: 0;		isPartsBin: true;		enableDragNDrop: false.	setButton _ SimpleButtonMorph new		label: 'set';		actWhen: #buttonUp;		target: self blockReceiver;		actionSelector: #makeSetterFor:.	y _ 4.	"built in variables"	self builtinVars do: [:varName |		b _ setButton fullCopy			arguments: (Array with: varName);			position: 5@(y - 1).		w _ WatcherMorph new			target: self blockReceiver getSelector: varName;			layoutAsArgument.		setter _ (varName, ':') asSymbol.		(self blockReceiver respondsTo: setter) ifTrue: [			bin addMorphBack: b.			w putSelector: setter].		w position: 34@y.		bin addMorphBack: w.		y _ y + w height + 4].	"user variables"	self userVars do: [:varName |		b _ setButton fullCopy			arguments: (Array with: varName);			position: 5@(y - 1).		bin addMorphBack: b.		w _ WatcherMorph new			target: self blockReceiver getSelector: #getUserVar: varName: varName;			putSelector: #setUserVar:to:;			layoutAsArgument.		w position: 34@y.		bin addMorphBack: w.		y _ y + w height + 4].	^ bin! !!ScriptableScratchMorph class methodsFor: 'scratch' stamp: 'jm 1/4/2004 21:13' prior: 37456079!genericBlockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector>).	Explanation of flags:		-	no flags		c	c-shaped block containing a sequence of commands		r	reporter		s	special form with own evaluation rule		t	timed command, like wait or glide		u	unnamed block (neither possessive ('s) nor ask ('name,') forms)"	^ #(		'control'			('if %b'				csu	doIf)			('forever'			csu	doForever)			('repeat %n'			csu	doRepeat)			('while %b'			csu	doWhile)			('wait until %b'		su	doWaitUntil)			('done'				su	doReturn)			('answer %n'		su	doReturn)			('wait %n secs'		tu	wait:elapsed:from:)"xxx  comment these out for now:			('monitor %n %n'	rsu	doMonitor)			('ask %m to'			csu	doAsk)xxx"		'math'			('%n + %n'			ru	+)			('%n - %n'			ru	-)			('%n * %n'			ru	*)			('%n / %n'			ru	/)			('abs %n'			ru	absoluteValue:)			('%n mod %n'		ru	\\)			('%n < %n'			ru	<)			('%n = %n'			ru	=)			('%n > %n'			ru	>)			('%b and %b'		ru	&)			('%b or %b'			ru	|)			('not %b'			ru	not)			('random %n to %n'	ru	randomFrom:to:)			('point x %n y %n'	ru	@)		'mouse/keyboard'			('mouse pressed?'	ru	mousePressed)			('mouse position'	ru	mousePosition)			('mouse x'			ru	mouseX)			('mouse y'			ru	mouseY)			('mouse touching'	ru	mouseTouching)			('key available?'	ru	isKeyAvailable)			('get key'			ru	getKey)		'other'			('timer'				ru	timer)			('timer reset'		u	timerReset)			('copy'				r	doCopy)			('load %s'			-	loadFile:)			('save %s'			-	saveFile:)	).! !!ImageBoxMorph class methodsFor: 'scratch' stamp: 'jm 1/4/2004 21:16' prior: 35020692!varSpecs	^ #((x 0 1000)		(y 0 1000)		(layer 1 100)		(width 0 500)		(height 0 500)		(transparency 0 1)		(borderWidth 0 100)		(panX -200 200)		(panY -200 200)		(zoom 0.1 10)		(fade 0 1)		(currentSeconds 0 100)		(currentFrame	0 1000)		(volume 0 1)		(balance 0 1))! !!ScriptableScratchMorph class methodsFor: 'scratch' stamp: 'jm 1/4/2004 21:23' prior: 37466858!genericBlockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector>).	Explanation of flags:		-	no flags		c	c-shaped block containing a sequence of commands		r	reporter		s	special form with own evaluation rule		t	timed command, like wait or glide		u	unnamed block (neither possessive ('s) nor ask ('name,') forms)"	^ #(		'control'			('if %b'				csu	doIf)			('forever'			csu	doForever)			('repeat %n'			csu	doRepeat)			('while %b'			csu	doWhile)			('wait until %b'		su	doWaitUntil)			('done'				su	doReturn)			('answer %n'		su	doReturn)			('wait %n secs'		tu	wait:elapsed:from:)"xxx  comment these out for now:			('monitor %n %n'	rsu	doMonitor)			('ask %m to'			csu	doAsk)xxx"		'math'			('%n + %n'			ru	+)			('%n - %n'			ru	-)			('%n * %n'			ru	*)			('%n / %n'			ru	/)			('abs %n'			ru	absoluteValue:)			('%n mod %n'		ru	\\)			('%n < %n'			ru	<)			('%n = %n'			ru	=)			('%n > %n'			ru	>)			('%b and %b'		ru	&)			('%b or %b'			ru	|)			('not %b'			ru	not)			('random %n to %n'	ru	randomFrom:to:)			('point x %n y %n'	ru	@)		'mouse/keyboard'			('mouse down?'	ru	mousePressed)			('mouse position'	ru	mousePosition)			('mouse x'			ru	mouseX)			('mouse y'			ru	mouseY)			('mouse touch?'		ru	mouseTouching)			('key available?'	ru	isKeyAvailable)			('get key'			ru	getKey)		'other'			('timer'				ru	timer)			('timer reset'		u	timerReset)			('copy'				r	doCopy)	).! !!ScriptableScratchMorph class methodsFor: 'scratch' stamp: 'jm 1/4/2004 21:25' prior: 37469005!genericBlockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector>).	Explanation of flags:		-	no flags		c	c-shaped block containing a sequence of commands		r	reporter		s	special form with own evaluation rule		t	timed command, like wait or glide		u	unnamed block (neither possessive ('s) nor ask ('name,') forms)"	^ #(		'control'			('if %b'				csu	doIf)			('forever'			csu	doForever)			('repeat %n'			csu	doRepeat)			('while %b'			csu	doWhile)			('wait until %b'		su	doWaitUntil)			('done'				su	doReturn)			('answer %n'		su	doReturn)			('wait %n secs'		tu	wait:elapsed:from:)"xxx  comment these out for now:			('monitor %n %n'	rsu	doMonitor)			('ask %m to'			csu	doAsk)xxx"		'math'			('%n + %n'			ru	+)			('%n - %n'			ru	-)			('%n * %n'			ru	*)			('%n / %n'			ru	/)			('abs %n'			ru	absoluteValue:)			('%n mod %n'		ru	\\)			('%n < %n'			ru	<)			('%n = %n'			ru	=)			('%n > %n'			ru	>)			('%b and %b'		ru	&)			('%b or %b'			ru	|)			('not %b'			ru	not)			('random %n to %n'	ru	randomFrom:to:)			('point x %n y %n'	ru	@)		'mouse/keyboard'			('mouse down?'		ru	mousePressed)			('mouse position'	ru	mousePosition)			('mouse x'			ru	mouseX)			('mouse y'			ru	mouseY)			('mouse touch?'		ru	mouseTouching)			('key available?'	ru	isKeyAvailable)			('get key'			ru	getKey)		'other'			('timer'				ru	timer)			('timer reset'		u	timerReset)			('copy'				r	doCopy)	).! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 1/4/2004 21:31'!gotoX: endX y: endY duration: duration elapsed: elapsed from: startPoint	"Interpolate my position from startPoint to endPoint over the given duration. If startPoint is nil, just answer my current position; this sets the starting point for the interpolation."	| fraction endPoint |	startPoint ifNil: [^ self referencePosition].	endPoint _ endX@endY.	fraction _ elapsed asFloat / (1000.0 * duration).	fraction > 1.0 ifTrue: [fraction _ 1].	fraction < 0.0 ifTrue: [fraction _ 0].	self referencePosition: startPoint + (fraction * (endPoint - startPoint)) truncated.! !!SpriteMorph class methodsFor: 'scratch' stamp: 'jm 1/4/2004 21:33' prior: 36823331!classBlockSpecs	^ #(		'motion'			('forward %n'				-	forward:)			('turn %n'					-	turn:)			('goto %p'					-	referencePosition:)			('goto %p secs %n'			t	goto:duration:elapsed:from:)			('goto x %d y %d secs %n'	t	gotoX:y:duration:elapsed:from:)			('w %n h %n secs %n'		t	width:height:duration:elapsed:from:)			('look like %m'				-	lookLike:)			('pen up'					-	putPenUp)			('pen down'					-	putPenDown)			('pen color %c'				-	penColor:)		'sensing'			('color %c is over %c'		r	color:sees:)			('touching %m' 				r	spriteOverlapping:)			('dist to %p'					r	distanceTo:) 			('dist to %m'					r	distanceTo:)			('heading to %p' 			r	headingTo:)			('heading to %m'			r	headingTo:)	).! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 1/4/2004 21:35'!gotoX: x y: y	self referencePosition: x@y.! !!SpriteMorph class methodsFor: 'scratch' stamp: 'jm 1/4/2004 21:37' prior: 37473082!classBlockSpecs	^ #(		'motion'			('forward %n'				-	forward:)			('turn %n'					-	turn:)			('goto %p'					-	referencePosition:)			('goto %p secs %n'			t	goto:duration:elapsed:from:)			('goto %d %d'				-	gotoX:y:)			('goto %d %d secs %n'		t	gotoX:y:duration:elapsed:from:)			('resize %n %n secs %n'		t	width:height:duration:elapsed:from:)			('look like %m'				-	lookLike:)			('pen up'					-	putPenUp)			('pen down'					-	putPenDown)			('pen color %c'				-	penColor:)		'sensing'			('color %c is over %c'		r	color:sees:)			('touching %m' 				r	spriteOverlapping:)			('dist to %p'					r	distanceTo:) 			('dist to %m'					r	distanceTo:)			('heading to %p' 			r	headingTo:)			('heading to %m'			r	headingTo:)	).! !ScratchFrameMorph open!!SpriteMorph class methodsFor: 'scratch' stamp: 'jm 1/4/2004 21:38' prior: 37473993!classBlockSpecs	^ #(		'motion'			('forward %n'				-	forward:)			('turn %n'					-	turn:)			('goto %p'					-	referencePosition:)			('goto %p secs %n'			t	goto:duration:elapsed:from:)			('goto %n %n'				-	gotoX:y:)			('goto %n %n secs %n'		t	gotoX:y:duration:elapsed:from:)			('resize %n %n secs %n'		t	width:height:duration:elapsed:from:)			('look like %m'				-	lookLike:)			('pen up'					-	putPenUp)			('pen down'					-	putPenDown)			('pen color %c'				-	penColor:)		'sensing'			('color %c is over %c'		r	color:sees:)			('touching %m' 				r	spriteOverlapping:)			('dist to %p'					r	distanceTo:) 			('dist to %m'					r	distanceTo:)			('heading to %p' 			r	headingTo:)			('heading to %m'			r	headingTo:)	).! !!SpriteMorph class methodsFor: 'scratch' stamp: 'jm 1/4/2004 21:42' prior: 37474834!classBlockSpecs	^ #(		'motion'			('forward %n'				-	forward:)			('turn %n'					-	turn:)			('goto %n %n'				-	gotoX:y:)			('goto %n %n secs %n'		t	gotoX:y:duration:elapsed:from:)			('resize %n %n secs %n'		t	width:height:duration:elapsed:from:)			('look like %m'				-	lookLike:)			('pen up'					-	putPenUp)			('pen down'					-	putPenDown)			('pen color %c'				-	penColor:)		'sensing'			('color %c is over %c'		r	color:sees:)			('touching %m' 				r	spriteOverlapping:)			('dist to %p'					r	distanceTo:) 			('dist to %m'					r	distanceTo:)			('heading to %p' 			r	headingTo:)			('heading to %m'			r	headingTo:)	).! !!SpriteMorph methodsFor: 'scratch ops' stamp: 'jm 1/4/2004 21:46'!headingToX: x y: y	"Answer the heading from my reference position to the given point."	^ (self referencePosition bearingToPoint: x@y) - 90! !!SpriteMorph class methodsFor: 'scratch' stamp: 'jm 1/4/2004 21:48' prior: 37475650!classBlockSpecs	^ #(		'motion'			('forward %n'				-	forward:)			('turn %n'					-	turn:)			('goto %n %n'				-	gotoX:y:)			('goto %n %n secs %n'		t	gotoX:y:duration:elapsed:from:)			('resize %n %n secs %n'		t	width:height:duration:elapsed:from:)			('look like %m'				-	lookLike:)			('pen up'					-	putPenUp)			('pen down'					-	putPenDown)			('pen color %c'				-	penColor:)		'sensing'			('color %c is over %c'		r	color:sees:)			('touching %m' 				r	spriteOverlapping:)			('dist to %n %n'				r	distanceToX:y:) 			('dist to %m'					r	distanceTo:)			('heading to %n %n' 		r	headingToX:y:)	)! !!SpriteMorph methodsFor: 'scratch ops' stamp: 'jm 1/4/2004 21:49'!distanceToX: x y: y	"Answer the distance from my reference position to the given point."	^ self referencePosition dist: x@y! !!SpriteMorph class methodsFor: 'scratch' stamp: 'jm 1/4/2004 21:51' prior: 37476584!classBlockSpecs	^ #(		'motion'			('forward %n'				-	forward:)			('turn %n'					-	turn:)			('goto %n %n'				-	gotoX:y:)			('goto %n %n secs %n'		t	gotoX:y:duration:elapsed:from:)			('resize %n %n secs %n'		t	width:height:duration:elapsed:from:)			('look like %m'				-	lookLike:)			('point to %n %n'			r	pointToX:y:) 			('pen up'					-	putPenUp)			('pen down'					-	putPenDown)			('pen color %c'				-	penColor:)		'sensing'			('color %c is over %c'		r	color:sees:)			('touching %m' 				r	spriteOverlapping:)			('dist to %n %n'				r	distanceToX:y:) 			('heading to %n %n' 		r	headingToX:y:)	)! !!SpriteMorph class methodsFor: 'scratch' stamp: 'jm 1/4/2004 21:57' prior: 37477476!classBlockSpecs	^ #(		'motion'			('forward %n'				-	forward:)			('turn %n'					-	turn:)			('goto %n %n'				-	gotoX:y:)			('goto %n %n secs %n'		t	gotoX:y:duration:elapsed:from:)			('resize %n %n secs %n'		t	width:height:duration:elapsed:from:)			('look like %m'				-	lookLike:)			('point to %n %n'			-	pointToX:y:) 			('pen up'					-	putPenUp)			('pen down'					-	putPenDown)			('pen color %c'				-	penColor:)		'sensing'			('color %c is over %c'		r	color:sees:)			('touching %m' 				r	spriteOverlapping:)			('dist to %n %n'				r	distanceToX:y:) 			('heading to %n %n' 		r	headingToX:y:)	)! !!SpriteMorph methodsFor: 'scratch ops' stamp: 'jm 1/4/2004 21:59'!pointToX: x y: y	"Set my heading to point to the given point."	self heading: (self headingTo: x@y).! !Origin!self position!self referencePosition!Display fill: (self referencePosition extent: 3) fillColor: Color red!!SpriteMorph methodsFor: 'accessing' stamp: 'jm 1/4/2004 22:08' prior: 36806407!referencePosition	^ ((bounds origin - offsetWhenRotated) + rotationCenter) + Origin! !Display fill: (self referencePosition extent: 3) fillColor: Color red!!SpriteMorph methodsFor: 'accessing' stamp: 'jm 11/13/2003 12:31' prior: 37479162!referencePosition	^ ((bounds origin - offsetWhenRotated) + rotationCenter) - Origin! !Display fill: (self referencePosition + owner topLeft extent: 3) fillColor: Color red!!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 1/4/2004 22:10' prior: 36505474!mouseX	^ self mousePosition x - Origin x! !!ScriptableScratchMorph methodsFor: 'scratch ops' stamp: 'jm 1/4/2004 22:12' prior: 36505591!mouseY	^ self mousePosition y - Origin y! !!SpriteMorph class methodsFor: 'scratch' stamp: 'jm 1/4/2004 23:57' prior: 37478173!classBlockSpecs	^ #(		'motion'			('forward %n'				-	forward:)			('turn %n'					-	turn:)			('point to %n %n'			-	pointToX:y:) 			('goto %n %n'				-	gotoX:y:)			('goto %n %n secs %n'		t	gotoX:y:duration:elapsed:from:)			('resize %n %n secs %n'		t	width:height:duration:elapsed:from:)			('look like %m'				-	lookLike:)			('pen up'					-	putPenUp)			('pen down'					-	putPenDown)			('pen color %c'				-	penColor:)		'sensing'			('color %c is over %c'		r	color:sees:)			('touching %m' 				r	spriteOverlapping:)			('dist to %n %n'				r	distanceToX:y:) 			('heading to %n %n' 		r	headingToX:y:)	)! !!SoundMorph class methodsFor: 'scratch' stamp: 'jm 1/4/2004 23:59' prior: 36762830!classBlockSpecs	^ #(		'playing'			('play'							-	playFromStart)			('resume'						-	resumePlaying)			('pause'							-	pausePlaying)					('play from %n to %n secs'		-	playFrom:to:)			('total secs'						r	totalSeconds)	)! !!SoundMorph class methodsFor: 'scratch' stamp: 'jm 1/4/2004 23:59' prior: 37480648!classBlockSpecs	^ #(		'playing'			('play'							-	playFromStart)			('resume'						-	resumePlaying)			('pause'							-	pausePlaying)					('play from %n to %n secs'		-	playFrom:to:)			('total secs'						r	totalSeconds)	)! !!SoundMorph class methodsFor: 'scratch' stamp: 'jm 1/5/2004 00:00' prior: 37480965!classBlockSpecs	^ #(		'playing'			('play'					-	playFromStart)			('resume'				-	resumePlaying)			('pause'					-	pausePlaying)					('play %n to %n secs'	-	playFrom:to:)			('total secs'				r	totalSeconds)	)! !!ImageBoxMorph class methodsFor: 'scratch' stamp: 'jm 1/5/2004 00:03' prior: 35020242!classBlockSpecs	^ #(		'movie'			('play'						-	startPlaying)			('pause'						-	stopPlaying)			('jump to %n secs'			-	jumpToSeconds:)			('forward %n frames'		-	forwardFrames:)			('frameCount'				r	frameCount)			('total secs'					r	totalSeconds)			('reset frame rate'			-	syncToSound)			('border color %c'			-	borderColor:)			('fade color %c'				-	fadeColor:)	).! !!ScriptableScratchMorph class methodsFor: 'scratch' stamp: 'jm 1/5/2004 00:16' prior: 37470722!genericBlockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector>).	Explanation of flags:		-	no flags		c	c-shaped block containing a sequence of commands		r	reporter		s	special form with own evaluation rule		t	timed command, like wait or glide		u	unnamed block (neither possessive ('s) nor ask ('name,') forms)"	^ #(		'control'			('if %b'				csu	doIf)			('forever'			csu	doForever)			('repeat %n'			csu	doRepeat)			('while %b'			csu	doWhile)			('wait until %b'		su	doWaitUntil)			('done'				su	doReturn)			('answer %n'		su	doReturn)			('wait %n secs'		tu	wait:elapsed:from:)"xxx  comment these out for now:			('monitor %n %n'	rsu	doMonitor)			('ask %m to'			csu	doAsk)xxx"		'math'			('%n + %n'			ru	+)			('%n - %n'			ru	-)			('%n * %n'			ru	*)			('%n / %n'			ru	/)			('abs %n'			ru	absoluteValue:)			('%n mod %n'		ru	\\)			('%n < %n'			ru	<)			('%n = %n'			ru	=)			('%n > %n'			ru	>)			('%b and %b'		ru	&)			('%b or %b'			ru	|)			('not %b'			ru	not)			('random %n to %n'	ru	randomFrom:to:)			('point x %n y %n'	ru	@)		'mouse/keyboard'			('mouse down?'		ru	mousePressed)			('mouse x'			ru	mouseX)			('mouse y'			ru	mouseY)			('mouse touch?'		ru	mouseTouching)			('key available?'	ru	isKeyAvailable)			('get key'			ru	getKey)		'other'			('timer'				ru	timer)			('timer reset'		u	timerReset)			('copy'				r	doCopy)	).! !!ScriptableScratchMorph class methodsFor: 'scratch' stamp: 'jm 1/5/2004 00:18' prior: 37482060!genericBlockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector>).	Explanation of flags:		-	no flags		c	c-shaped block containing a sequence of commands		r	reporter		s	special form with own evaluation rule		t	timed command, like wait or glide		u	unnamed block (neither possessive ('s) nor ask ('name,') forms)"	^ #(		'control'			('if %b'				csu	doIf)			('forever'			csu	doForever)			('repeat %n'			csu	doRepeat)			('while %b'			csu	doWhile)			('wait until %b'		su	doWaitUntil)			('done'				su	doReturn)			('answer %n'		su	doReturn)			('wait %n secs'		tu	wait:elapsed:from:)"xxx  comment these out for now:			('monitor %n %n'	rsu	doMonitor)			('ask %m to'			csu	doAsk)xxx"		'math'			('%n + %n'			ru	+)			('%n - %n'			ru	-)			('%n * %n'			ru	*)			('%n / %n'			ru	/)			('abs %n'			ru	absoluteValue:)			('%n mod %n'		ru	\\)			('%n < %n'			ru	<)			('%n = %n'			ru	=)			('%n > %n'			ru	>)			('%b and %b'		ru	&)			('%b or %b'			ru	|)			('not %b'			ru	not)			('random %n to %n'	ru	randomFrom:to:)		'mouse/keyboard'			('mouse down?'		ru	mousePressed)			('mouse x'			ru	mouseX)			('mouse y'			ru	mouseY)			('mouse touch?'		ru	mouseTouching)			('key available?'	ru	isKeyAvailable)			('get key'			ru	getKey)		'other'			('timer'				ru	timer)			('timer reset'		u	timerReset)			('copy'				r	doCopy)	).! !!ScriptableScratchMorph class methodsFor: 'scratch' stamp: 'jm 1/5/2004 00:20' prior: 37483739!genericBlockSpecs	"Answer a collection of block specifications for the blocks that are common to all objects. Block specificatons (Arrays) are interspersed with category names (Strings). A block specification is an Array of the form: (<block spec string> <block type> <selector>).	Explanation of flags:		-	no flags		c	c-shaped block containing a sequence of commands		r	reporter		s	special form with own evaluation rule		t	timed command, like wait or glide		u	unnamed block (neither possessive ('s) nor ask ('name,') forms)"	^ #(		'control'			('if %b'				csu	doIf)			('forever'			csu	doForever)			('repeat %n'			csu	doRepeat)			('while %b'			csu	doWhile)			('wait until %b'		su	doWaitUntil)			('done'				su	doReturn)			('answer %n'		su	doReturn)			('wait %n secs'		tu	wait:elapsed:from:)"xxx  comment these out for now:			('monitor %n %n'	rsu	doMonitor)			('ask %m to'			csu	doAsk)xxx"		'math'			('%n + %n'			ru	+)			('%n - %n'			ru	-)			('%n * %n'			ru	*)			('%n / %n'			ru	/)			('%n mod %n'		ru	\\)			('%n < %n'			ru	<)			('%n = %n'			ru	=)			('%n > %n'			ru	>)			('%b and %b'		ru	&)			('%b or %b'			ru	|)			('not %b'			ru	not)			('random %n to %n'	ru	randomFrom:to:)		'mouse/keyboard'			('mouse down?'		ru	mousePressed)			('mouse x'			ru	mouseX)			('mouse y'			ru	mouseY)			('mouse touch?'		ru	mouseTouching)			('key available?'	ru	isKeyAvailable)			('get key'			ru	getKey)		'other'			('timer'				ru	timer)			('timer reset'		u	timerReset)			('copy'				r	doCopy)	).! !----QUIT----#(5 January 2004 12:22:22 am) priorSource: 3899250!----SNAPSHOT----#(5 January 2004 12:22:49 am) priorSource: 3932478!Smalltalk garbageCollect.Smalltalk obsoleteClasses size!Smalltalk removeClassNamed: #GravisWavePlayer!Smalltalk removeClassNamed: #GravisWave!Smalltalk removeClassNamed: #GravisPatchReader!Smalltalk removeClassNamed: #TI430Assembler!Smalltalk removeClassNamed: #NTagPuppetMaster!Smalltalk removeClassNamed: #NTagLogoCompiler!Smalltalk removeClassNamed: #NTagDumpAnalyzer!Smalltalk removeClassNamed: #LogoSimulatorClient!Smalltalk removeClassNamed: #WebPageScrollableMorph!Smalltalk removeClassNamed: #WebPageLayoutMorph!Smalltalk removeClassNamed: #WeatherSound!Smalltalk removeClassNamed: #VectorScopeMorph!Smalltalk removeClassNamed: #TowerTester!Smalltalk removeClassNamed: #StripChartMorph!Smalltalk removeClassNamed: #SoundFilePlayer!Smalltalk removeClassNamed: #ScratchViewerButtonsMorph!Smalltalk removeClassNamed: #PresenceServer!Smalltalk removeClassNamed: #PlotterMorph!Smalltalk removeClassNamed: #NewSerialPortPrimsTest!Smalltalk removeClassNamed: #MinuteMinderMorph!Smalltalk removeClassNamed: #MemeExchange!Smalltalk removeClassNamed: #JohnsCKLightsMorph!Smalltalk removeClassNamed: #GraphWithBookmarksMorph!Smalltalk removeClassNamed: #FontExtractor!Smalltalk removeClassNamed: #CoupledOscSim!Smalltalk removeClassNamed: #BusCommanderMessage!Smalltalk removeClassNamed: #BookReader!Smalltalk removeClassNamed: #BeatBox!Smalltalk removeClassNamed: #AnimationTestMorph!Smalltalk garbageCollect.Smalltalk obsoleteClasses size!allBindings _ nil.!allBindings _ OrderedCollection new.Workspace allInstances do: [:w |	w bindings ifNotNil: [w bindings associationsDo: [:assoc | allBindings add: assoc]]]!allBindings!allBindings _ nil.!Smalltalk cleanOutUndeclared!Undeclared!Smalltalk unimplemented!TranscriptStream allInstances do: [:t | t on: (String new: 1000)]!Utilities clearAuthorInfo!ScriptableScratchMorph resetInstanceCounts!Smalltalk version!SystemWindow clearTopWindow.HandMorph clearPasteBuffer.Smalltalk reclaimDependents.Smalltalk forgetDoIts.Smalltalk removeEmptyMessageCategories.Symbol rehash.Smalltalk garbageCollect.Array with: Metaclass instanceCount with: CompiledMethod instanceCount with: Smalltalk obsoleteClasses size!----QUIT----#(5 January 2004 12:29:45 am) priorSource: 3932543!